/* * ************************************************************************ * Copyright (C) 2015 MennÄ“ Software Solutions, LLC * * This code is released as open source under the Apache 2.0 License:<br/> * <a href="http://www.apache.org/licenses/LICENSE-2.0"> * http://www.apache.org/licenses/LICENSE-2.0</a><br /> * ************************************************************************ */package com.moneydance.modules.features.ratios;import com.infinitekind.moneydance.model.ParentTxn;import com.infinitekind.moneydance.model.Txn;import com.infinitekind.moneydance.model.TxnSearch;import java.util.ArrayList;import java.util.List;/** * This is a special filter just for the Ratios extension. It looks at both sides of a transaction to see if the tags match. Ratios is * different from other calculations because it depends on the flow direction of each transaction. However, the user intent of filtering * on tags is that the tags match on either side of each split, irrespective of the flow direction. */public class TxnTagsFilter  implements TxnSearch {  private final List<String> _includedTags;  private final TagLogic _combineLogic;  TxnTagsFilter(final List<String> included, final TagLogic combine) {    _includedTags = new ArrayList<String>(included);    _combineLogic = combine;  }  public boolean matches(Txn txn) {    // only splits have value, and ratio calculations only need the transactions with value    if (txn instanceof ParentTxn) return false;    // check the first side for a tag match    if (txnSideMatches(txn)) return true;    // check the other side    return txnSideMatches(txn.getOtherTxn(0));  }  private boolean txnSideMatches(Txn txn) {    boolean isMatch;    if (TagLogic.EXACT.equals(_combineLogic)) {      isMatch = isExactMatch(txn);    } else if (TagLogic.AND.equals(_combineLogic)) {      isMatch = isAllMatch(txn);    } else {      isMatch = isAnyMatch(txn); // OR logic    }    return isMatch;  }  public boolean matchesAll() {    return !TagLogic.EXACT.equals(_combineLogic) && _includedTags.isEmpty();  }  ///////////////////////////////////////////////////////////////////////////////////////////////  // Private Methods  ///////////////////////////////////////////////////////////////////////////////////////////////  private boolean isAllMatch(final Txn txn) {    // if the included tags are blank, that effectively disables the inclusion criteria and all transactions should match    if (_includedTags.isEmpty()) return true;    // the transaction can have a different number of tags, but must have all of the tags the user has included    List<String> splitTags = txn.getKeywords();    return splitTags.containsAll(_includedTags);  }  private boolean isAnyMatch(final Txn txn) {    // if the included tags are blank, that effectively disables the inclusion criteria and all transactions should match    if (_includedTags.isEmpty()) return true;    // the transaction must have at least one of the tags the user has chosen in order to match    List<String> splitTags = txn.getKeywords();    for (final String includedTag : _includedTags) {      if (splitTags.contains(includedTag)) {        return true;      }    }    return false;  }  private boolean isExactMatch(final Txn txn) {    // All tags defined in the split must be in the included tags, and the two lists must be the same size    final List<String> txnTags = txn.getKeywords();    if (txnTags.size() != _includedTags.size()) {      // can't be an exact match, included tags are defined and the split doesn't have any      return false;    }    return _includedTags.isEmpty() || txnTags.containsAll(_includedTags);  }}