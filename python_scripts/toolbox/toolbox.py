#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# ######################################################################################################################
# The Infinite Kind (Moneydance) - Co-authored by Stuart Beesley in collaboration with Moneydance as a support tool
#
# Moneydance Support Tool
# ######################################################################################################################

# toolbox.py build: 1045 - November 2020 thru Oct 2021+ - Stuart Beesley StuWareSoftSystems (>1000 coding hours)
# Thanks and credit to Derek Kent(23) for his extensive testing and suggestions....
# Further thanks to Kevin(N), Dan T Davis, and dwg for their testing, input and OFX Bank help/input.....
# Credit of course to Moneydance and they retain all copyright over Moneydance internal code
# Designed to show user a number of settings / fixes / updates they may find useful (some normally hidden)
# The Basic / Geek Out Mode(s) are very safe and do not change any data or settings
# If you switch to Advanced / Hacker mode(s) then you have the ability to perform fixes, change data, change config etc
# NOTE: Any change that impacts config.dict, custom_theme.properties, LocalStorage() ./safe/settings...
#       will always backup that single config/settings file (in the directory where it's located).
#       This is not the same as backing up your Dataset that contains your financial data.

# NOTE: You will see some usage of globals... I wrote this when I was learning Python and Java... Know I know a lot more,
# I would do this differently, but leaving this as-is for now... (I'll upgrade elements as I make future changes)

# DISCLAIMER >> PLEASE ALWAYS BACKUP YOUR DATA BEFORE MAKING CHANGES (Menu>Export Backup will achieve this).

# Includes previous / standalone scripts (which I have now decommissioned):
# FIX-reset_window_location_data.py 0.2beta
# DIAG-can_i_delete_security.py v2
# DIAG-list_security_currency_decimal_places.py v1
# DIAG-diagnose_currencies.py v2a
# fix_macos_tabbing_mode.py v1b

# Also includes these MD scripts (enhanced)
# reset_relative_currencies.py                          (from Moneydance support)
# remove_ofx_account_bindings.py                        (from Moneydance support)
# convert_secondary_to_primary_data_set.py              (from Moneydance support)
# remove_one_service.py                                 (from Moneydance support)
# delete_invalid_txns.py                                (from Moneydance support)
# price_history_thinner.py                              (from Moneydance support)
# fix_dropbox_one_way_syncing.py                        (from Moneydance support)
# reset_sync_and_dropbox_settings.py                    (from Moneydance support)
# force_change_account_currency.py                      (from Moneydance support)
# fix_restored_accounts.py (check only)                 (from Moneydance support)
# export_all_attachments.py                             (from Moneydance support)
# fix_account_parent.py                                 (from Moneydance support)
# (... and old check_root_structure.py)                 (from Moneydance support)
# fix_non-hierarchical_security_account_txns.py         (from Moneydance support)
# (... and fix_investment_txns_to_wrong_security.py)    (from Moneydance support)
# remove_ofx_security_bindings.py                       (from Moneydance support)
# show_object_type_quantities.py                        (from Moneydance support)
# delete_intermediate_downloaded_transaction_caches.py  (from Moneydance support)
# delete_orphaned_downloaded_txn_lists.py               (from Moneydance support)
# set_account_type.py                                   (from Moneydance support)
# force_change_all_currencies.py                        (from Moneydance support)
# fix_invalid_currency_rates.py                         (from Moneydance support)
# reverse_txn_amounts.py                                (from Moneydance support)
# reverse_txn_exchange_rates_by_account_and_date.py     (from Moneydance support)
# show_open_tax_lots.py                                 (author unknown)
# MakeFifoCost.py                                       (author unknown)
# change-security-cusip.py                              (from Finite Mobius, LLC / Jason R. Miller)
# https://github.com/finitemobius/moneydance-py

###############################################################################
# MIT License
#
# Copyright (c) 2021 Stuart Beesley - StuWareSoftSystems & Infinite Kind (Moneydance)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
###############################################################################

# Build: 999 PREVIEW RELEASE
# Build: 999a Added some instructions on how to properly edit Moneydance.vmoptions file; added to help file(s)
# Build: 999a Now finds the application directory for MacOS too....
# Build: 1000 INITIAL PUBLIC RELEASE
# Build: 1001 Enhanced MyPrint to catch unicode utf-8 encode/decode errors
# Build: 1002 - fixed raise(Exception) clauses ;->
# Build: 1002 - Now leveraging the Default font set in Moneydance; added change Fonts Button
# Build: 1003 - Updated common codeset
# Build: 1004 - Removed TxnSortOrder from common code, and catch error on import for earlier versions of MD
# Build: 1004 - Fix for Jython 2.7.1 where csv.writer expects a 1-byte string delimiter, not unicode....
# Build: 1005 - Tweaked for 2021 build 3032 (fonts/preferences)
# Build: 1006 - Detect when the .moneydancesync folder is missing and add button to fix this
# Build: 1006 - Detect current Toolbox version from github.. added downloadStuWareSoftSystemsExtensions()
# Build: 1007 - Renamed REPO, Moneydance and ID to lowercase ready for signing (Sean request)...
# Build: 1008 - Cosmetic changes to searching window; update available windows...
# Build: 1008 - new button; search for ios sync data for sync key recovery....
# Build: 1008 - New hacker buttons; Moneydance internal DEBUG ON/OFF; Moneydance ofx connection console debug ON/OFF check; set check days
# Build: 1009 - Changed JFrame() to leverage internal moneydance's main frame size/dimensions etc.... (IK request)
# Build: 1010 - Tweaks to popup boxes to fit text for certain fonts and common imports
# Build: 1011 - Added "code_font" setting (which got sneaked into MD).... (and the print font setting too while I was at it); also corrected where font set to 'null' in config.dict
# Build: 1012 - Tweak to code_font display message
# Build: 1013 - Added Diagnose Attachments button(also detects Orphans)
# Build: 1014 - Added size and date to search for dataset outputs
# Build: 1014 - Enhanced main Frame to resize components on resize....; also the QuickJFrame; Small fix to Geek out mode error....:->
# Build: 1015 - Added more scripts as buttons: price_history_thinner.py
# Build: 1016 - Added Hacker button; save trunk file (false)
# Build: 1016 - Added Advanced Mode Button - fix one way syncing
# Build: 1017 - Added script: change-security-cusip.py; print message when checking dataset name vs root name; enhancements to price_history_thinner
# Build: 1018 - Override and reduce font point-size down to 18 max
# Build: 1018 - Tweaks to reset_relative_currencies - fix known error conditions / bugs in MD
# Build: 1019 - Added database objects count t  o main diagnostic screen.....
# Build: 1019 - Added support script: force_change_account_currency.py as a new button
# Build: 1019 - Added Hacker mode button to suppress the your file is stored in Dropbox warning (with disclaimer etc)
# Build: 1019 - Move the triple confirmation, backup, disclaimer messages to one common function
# Build: 1019 - Moved all OFX Function to a new Online Bank (OFX) Menu
# Build: 1019 - Changed the GeekOut mode to sort some objects first before selection....; major update to fix relative currencies
# Build: 1020 - Added button to analise dataset objects, files and sizes...; enhanced debug mode (same as console); use mono font in common code MyPopUpDialogBox()
# Build: 1020 - Massive update to OFX management, new button, menu, updated outputs with extensive data...; updates to Hacker mode
# Build: 1020 - Allow escape in common QuickJFrames and Popup dialogs.... (triggers cancel)
# Build: 1020 - Detect missing or invalid ROOT account based on fix_restored_accounts.py (but no fix as I don't think it's needed any more)...
# Build: 1020 - Extract Attachments button
# Build: 1020 - added fix_account_parent.py script as a button
# Build: 1020 - added show_open_tax_lots.py script as a button
# Build: 1020 - added MakeFifoCost.py script as a button
# Build: 1020 - added Linux instructions to view .vmoptions for screen scaling
# Build: 1020 - change to use common function for backup confirm disclaimer etc....
# Build: 1020 - Geekout and searches for OFX bank data significantly improved
# Build: 1020 - Bug fix finding location of backup dir
# Build: 1020 - Enabled auto-pruning of internal backups of config.dict, settings, custom_themes
# Build: 1020 - Added Hacker buttons to clean up the external file/open list and also delete these datasets, and also internal datasets
# Build: 1020 - added .dispose and del of FileDialog objects after usage as otherwise it remembers the last directory selected.....
# Build: 1020 - Removed OFX console debug window; not needed. The debug in console is good enough/better already
# Build: 1020 - Forces all Moneydance Debugs ON - same as console window - at launch (rather than launching console window)
# Build: 1020 - New Hacker button for extra debug options
# Build: 1020 - Listen to MD Events.. Close Toolbox down when switching datasets.... (called when MD flags new file has been opened)
# Build: 1020 - save parameters everytime the menu option changes (in case program is killed or MD exits)
# Build: 1020 - script now checks for version information online and updates it's own defaults....
# Build: 1020 - Added button / script fix_non-hierarchical_security_account_txns.py (and fix_investment_txns_to_wrong_security.py)
# Build: 1020 - script now dials home to check for updated version information etc.... (any error/not found, it just ignores and carries on)
# Build: 1020 - RELEASE 2.0: New Diag and Fix buttons (incl. Thin Price History and more); New OFX Bank Management Menu; many updates to Hacker mode
# Build: 1021 - Tweak to delete int/ext files workflow; changed open file to JFileChooser() when I don't want remembered directories (Java 'feature')
# Build: 1021 - Tweak to find my dataset, don't report .moneydance folder as a dataset in the counts.. fixed display of archives found count..
# Build: 1021 - Applied same cosmetic tweaks to Find iOS Dataset too....
# Build: 1021 - Added please wait message when extracting attachments....
# Build: 1021 - Somehow lost the Hack menu DEBUG toggle button... Put back....
# Build: 1022 - Cosmetic tweak to curr/sec dpc to show something when blank name...
# Build: 1022 - Added the older Import QIF file button; added service.clearAuthenticationCache() to remove_one_service.py script
# Build: 1022 - Added delete_intermediate_downloaded_transaction_caches.py script to OFX banking menu
# Build: 1022 - Re-badged as InfiniteKind - co-authored by Stuart Beesley
# Build: 1022 - Added size of database objects to analyse objects button
# Build: 1023 - Added option after search for datasets to add missing files to config.dict and file open menu; also excluded /System from search on Macs
# Build: 1023 - Added Force change Account type button to advanced menu (set_account_type.py)
# Build: 1023 - Added Force change all Accounts' currencies to advanced menu (force_change_all_currencies.py)
# Build: 1023 - Started the journey (due to learning) to ensure unicode used everywhere (rather than byte strings) (yes; I learnt coding back in the 80s!)
# Build: 1023 - Error trapped diagnostic display - crashed on non utf8 characters - and also when decimal local grouping character was nbsp (chr(160)) - fixed....
# Build: 1023 - added button fix invalid currency rates to advanced menu (fix_invalid_currency_rates.py)
# Build: 1023 - Updated search datasets and search ios backups to skip symbolic links.... also skip some system dirs on some platforms
# Build: 1024 - Updated search so that it asks again after 10 mins, but then also carries on if no response after 10 seconds
# Build: 1024 - Moved some buttons to the toolbar...
# Build: 1024 - Fix for when System Property "HomeDir" is None on Mac (thanks Sean!). Comma in wrong place....!
# Build: 1025 - New hacker button - Import a file into Local storage....
# Build: 1025 - Allow " " and "'" in key data values when editing in Hacker mode..; Added option to demote Primary to Secondary Sync Node
# Build: 1025 - Added script reverse_txn_amounts.py to Transaction Menu - advanced mode
# Build: 1025 - Added script reverse_txn_exchange_rates_by_account_and_date.py to Transaction Menu - advanced mode
# Build: 1025 - Revamped button/menu system. As many buttons as poss on sub-menus...
# Build: 1025 - small fix for is_moneydance_loaded_properly() when using MD build 2012
# Build: 1026 - Enhancements to detect when extension is already running....
# Build: 1026 - Detect when .moneydance and or .moneydancesync folder(s) are readonly/hidden - alert only
# Build: 1027 - CMD-F Search popup on all displays feature added; tweak to block old MD versions....; Added back view whole console (searchable)
# Build: 1027 - enhanced launch code...; added information banner when toolbox connects to the internet...
# Build: 1028 - Common code update (default the parameter filename); update tested versions; Allow \&/ in keys/data
# build: 1029 - Put suitable objects into editing mode by calling .setEditingMode() whilst editing until .syncItem() called
# build: 1029 - Switch to SwingUtilities.invokeLater() rather than Thread(); other small internal tweaks; fix toolbar location on older versions
# build: 1029 - Build 3051 of Moneydance... fix references to moneydance_* variables; Remove OFX_SETUP_MATCH_MD_BUILD;
# build: 1029 - Build 3051 fix >> getOutdatedExtensionIDs() replaced with getUnloadableExtensionIDs()...
# build: 1029 - Build 3051 leverage moneydance_extension_loader class loader to get help file from the mxt container
# build: 1030 - Build 3056 'deal' with the Python loader changes..
# build: 1031 - Build 3056 Utilise .unload() method...
# build: 1032 - Add HomePageViews (widgets) to extension list; add getTIKServiceID() to delete_one_service popup display
# build: 1032 - Add 'View all your OFX last download txn dates (for all accounts)'to menu
# build: 1033 - Common code tweaks
# build: 1034 - Disabled the 'tabbing mode' check from build 3065 onwards
# build: 1035 - Build 3067 of MD renamed com.moneydance.apps.md.view.gui.theme.Theme to com.moneydance.apps.md.view.gui.theme.ThemeInfo
# build: 1036 - Added the 'Can I delete Currency' menu option
# build: 1037 - Updated for MD2021.1 stable release build 3069
# build: 1038 - Change to popup warning about running on a secondary node; as suggested by IK (Sean); Popup warning about improper opening of backup files...
# build: 1039 - Built in error trap for .getSyncFolder() as it crashes if there is a Dropbox issue on the machine...
# build: 1040 - Changes requested by IK to change / remove version updates from non IK source(s) - so as to load into manage extensions list
# build: 1041 - Feature to convert TimeStamps to readable dates; Geekout, Diagnosis and manual edit mode for Currency/Security price_date parameter...
# build: 1041 - Detect cached downloaded bank transactions (OnlineTxnList) at startup...
# build: 1041 - Enhanced OFX Search data and service profile lists with linkage account key data et al...
# build: 1041 - Fixed several JFileChooser file dialogs - since the VAqua LaF upgrade (2021.1) on Macs broke it...
# build: 1041 - Fixed pickle.dump/load common code to work properly cross-platform (e.g. Windows to Mac) by (stripping \r when needed)
# build: 1041 - Enhanced / tweaked Fix relative currencies function (quite a lot ;-> )
# build: 1041 - New feature - Move/Merge Investment Txns from one account into another >> 550+ lines of code for this neat little function!
# build: 1041 - New feature - FIX - Detect and fix Investment Security records not properly linked to Security Master records
# build: 1041 - New feature - FIX - Delete invalid price history records where rate <= (1.0/9999999999) or >= 9999999999.
# build: 1041 - New feature - FIX - Merge 'duplicate' securities (and related Investment txns) together into one master security record.
# build: 1041 - New feature - FIX - Edit a Security's (hidden) Decimal Place setting (adjusts related Investment txns & Security balances accordingly).
# build: 1041 - Fixed hacker mode on SplitTxns to properly 'manage' parent record; fixed Geekout lookup for splits by UUID; Added 5 newest/oldest Snapshots data to geekout
# build: 1041 - Switch back to Home Screen before some functions... Stops Lot control box appearing; Good practice to get out of all accounts first...
# build: 1041 - Renamed feature to: - FIX - Fix currencies / securities (including relative currencies) (fixes your currency & security's key settings) (reset_relative_currencies.py)
# build: 1041 - Updated 'Diagnose Currency / Security (hidden) Decimal Places' report
# build: 1041 - Added options to report and set the shouldBeIncludedInNetWorth() settings to Accounts Tools Menu
# build: 1041 - Added feature - View your Security's hidden CUSIP settings to Online Banking (OFX) Tools Menu
# build: 1041 - Tweaks to cope with MD2021.2(3088)+ (iCloud Sync, env var 'md_passphrase', currency rrate fixes)
# build: 1041 - Currency rrate checking / fix features now detect version 2021.2 build 3089 of Moneydance where the code 'issue' was resolved...
# build: 1041 - Amended fix relative currencies accordingly with MD2021.2(3088) rate / rrate knowledge. I now only touch 'rrate' (not 'rate)...
# build: 1041 - Added save output button to QuickJFrame() popup that displays output text, along with top and bottom buttons.....
# build: 1041 - Fetch iCloud details if used, and added open sync location to open md folders button; also now copy tha path to clipboard too.
# build: 1041 - Added print function to QuickJFrame(); also save and print to main diagnostics display
# build: 1041 - Added feature - HACK: Peek at an encrypted file located in your Sync Folder...
# build: 1041 - Added feature - Diagnose Attachments - DELETE Orphan attachments.
# build: 1041 - Detect User's Locale (vs MD User Preferences for Locale).
# build: 1041 - Added feature - HACK: Shrink Dataset feature...
# build: 1041 - Added feature - HACK: Force a refresh/PUSH to Sync option
# build: 1041 - Updated Common code to use FileDialog/JFileChooser wrapper...
# build: 1041 - Added feature - HACK: Force disable/turn Sync OFF...
# build: 1041 - Converted all statusLabel usage over to GlobalVars and method call... 1000s of changes....
# build: 1042 - Enabling MD2022 (with Moneydance+)
# build: 1042 - Updated for new 2022 license keys
# build: 1042 - OFX forget banking link disabled for build 4040 onwards as new mapping table and user managed
# build: 1042 - New features: ZAP, Export, Import your Moneydance+ license key/object. Updated Geekout mode for license object, and mappings enabled too
# build: 1042 - Code updated with MD2022 Online Banking features / requirements...
# build: 1042 - New features: Cleanup missing banking links (MD2022 too)
# build: 1042 - Main menus enhanced to be scrollable... Toolbox now quits MD where needed..... after fix.....
# build: 1042 - New feature: Force reset Sync settings...; changed edit lasttxndownloaddate for MD+ to reset which forces new MD popup prompt...
# build: 1042 - Disable edit last txn download date if MD+ enabled build .....
# build: 1043 - Bug fixes on colors...; Common code fix lAlertLevel= on Mac/Dark Mode; added Dark detection and color fixes...
# build: 1043 - Enhanced cleanup missing banking links to detect/delete orphaned md+ connections; tweak to GeekOut on OFX Data (Accounts)
# build: 1043 - New feature: 'Restore an archive file, and RETAIN Sync settings ' (avoids wiping out Sync settings on restore)
# build: 1043 - New feature: Fix iCloud Sync Crash (same as Fix Dropbox One-Way Crash)
# build: 1043 - Tweaked OFX Authentication menu... Added change OFX Password feature
# build: 1044 - Enhanced OFX Authentication Menu. Added option to prime USAA UserID/ClientUID...; tweaked open md folder, for open system locations to work
# build: 1044 - Added execution of ofx_populate_multiple_userids.py script...
# build: 1044 - Added execution of ofx_create_new_usaa_bank_custom_profile.py script...
# build: 1044 - Tweaks for new Dark Flat theme in build 4059
# build: 1044 - Fix 'FIX - Non Hierarchical Security Account Txns' for None Account issue... (this is where User force removed a Security from Investment Account)
# build: 1045 - Enhanced search option (CMD-F) so that text field gets focus....
# build: 1045 - Enhanced 'Prime' USAA ClientUID function to allow deletion of old USAA profile(s)
# build: 1045 - Enhanced decrypt file from local storage... Catch BadPadding Exception and continue....
# build: 1045 - Fix to editStoredOFXPasswords() was pre-pending the key prefix when it was already there.....
# build: 1045 - Common code tweak - destroyOldFrames() - add a "_" for cloned instances; re-enable
# build: 1045 - Changed JFrame and JPanel layouts so that JScrollPane resize just works etc... Removed ReSize Listener (watching out for increased memory consumption)
# build: 1045 - Fix JMenu()s - remove <html> tags (affects colors on older Macs)
# build: 1045 - changed all to use .isMasterSyncNode() and .isMasterSyncNode() and also set primary on force reset all sync settings too (to match 4063)
# build: 1045 - Newer MyJFrame.dispose(); enhanced analise datasets and objects to detect permission problems with folders...

# todo - purge old in/out/ .txn files (possibly corrupt), not in processed.dct (should get added to processed.dct build 4061 onwards)
# todo - check/fix QuickJFrame() alert colours since VAqua....!?
# todo - add SwingWorker Threads as appropriate (on heavy duty methods)

# NOTE: Toolbox will connect to the internet to gather some data. IT WILL NOT SEND ANY OF YOUR DATA OUT FROM YOUR SYSTEM. This is why:
# 1. At launch it connects to the Author's code site to get information about the latest version of Toolbox and version requirements
# 2. At various times it may connect to the Infinite Kind server to gather information about extensions and versions
# 3. Within the OFX banking menu, it can connect to the Infinite Kind server to get the latest bank connection profiles for viewing

# NOTE - I Use IntelliJ IDE - you may see # noinspection Pyxxxx or # noqa comments
# These tell the IDE to ignore certain irrelevant/erroneous warnings being reporting:
# Further options at: https://www.jetbrains.com/help/pycharm/disabling-and-enabling-inspections.html#comments-ref

# CUSTOMIZE AND COPY THIS ##############################################################################################
# CUSTOMIZE AND COPY THIS ##############################################################################################
# CUSTOMIZE AND COPY THIS ##############################################################################################

# SET THESE LINES
myModuleID = u"toolbox"
version_build = "1045"
MIN_BUILD_REQD = 1904                                               # Check for builds less than 1904 / version < 2019.4
_I_CAN_RUN_AS_MONEYBOT_SCRIPT = True

if u"debug" in globals():
    global debug
else:
    debug = False
global toolbox_frame_
# SET LINES ABOVE ^^^^

# COPY >> START
global moneydance, moneydance_ui, moneydance_extension_loader, moneydance_extension_parameter
MD_REF = moneydance             # Make my own copy of reference as MD removes it once main thread ends.. Don't use/hold on to _data variable
MD_REF_UI = moneydance_ui       # Necessary as calls to .getUI() will try to load UI if None - we don't want this....
if MD_REF is None: raise Exception("CRITICAL ERROR - moneydance object/variable is None?")
if u"moneydance_extension_loader" in globals():
    MD_EXTENSION_LOADER = moneydance_extension_loader
else:
    MD_EXTENSION_LOADER = None

from java.lang import System, Runnable
from javax.swing import JFrame, SwingUtilities, SwingWorker
from java.awt.event import WindowEvent

class MyJFrame(JFrame):

    def __init__(self, frameTitle=None):
        super(JFrame, self).__init__(frameTitle)
        self.disposing = False
        self.myJFrameVersion = 3
        self.isActiveInMoneydance = False
        self.isRunTimeExtension = False
        self.MoneydanceAppListener = None
        self.HomePageViewObj = None

    def dispose(self):
        # This removes all content as VAqua retains the JFrame reference in memory...
        if self.disposing: return
        try:
            self.disposing = True
            self.removeAll()
            if self.getJMenuBar() is not None: self.setJMenuBar(None)
            super(self.__class__, self).dispose()
        except:
            _msg = "%s: ERROR DISPOSING OF FRAME: %s\n" %(myModuleID, self)
            print(_msg); System.err.write(_msg)
        finally:
            self.disposing = False

class GenericWindowClosingRunnable(Runnable):

    def __init__(self, theFrame):
        self.theFrame = theFrame

    def run(self):
        self.theFrame.setVisible(False)
        self.theFrame.dispatchEvent(WindowEvent(self.theFrame, WindowEvent.WINDOW_CLOSING))

class GenericDisposeRunnable(Runnable):
    def __init__(self, theFrame):
        self.theFrame = theFrame

    def run(self):
        self.theFrame.setVisible(False)
        self.theFrame.dispose()

class GenericVisibleRunnable(Runnable):
    def __init__(self, theFrame, lVisible=True, lToFront=False):
        self.theFrame = theFrame
        self.lVisible = lVisible
        self.lToFront = lToFront

    def run(self):
        self.theFrame.setVisible(self.lVisible)
        if self.lVisible and self.lToFront:
            if self.theFrame.getExtendedState() == JFrame.ICONIFIED:
                self.theFrame.setExtendedState(JFrame.NORMAL)
            self.theFrame.toFront()

def getMyJFrame( moduleName ):
    try:
        frames = JFrame.getFrames()
        for fr in frames:
            if (fr.getName().lower().startswith(u"%s_main" %moduleName)
                    and type(fr).__name__ == MyJFrame.__name__                         # isinstance() won't work across namespaces
                    and fr.isActiveInMoneydance):
                _msg = "%s: Found live frame: %s (MyJFrame() version: %s)\n" %(myModuleID,fr.getName(),fr.myJFrameVersion)
                print(_msg); System.err.write(_msg)
                if fr.isRunTimeExtension:
                    _msg = "%s: ... and this is a run-time self-installed extension too...\n" %(myModuleID)
                    print(_msg); System.err.write(_msg)
                return fr
    except:
        _msg = "%s: Critical error in getMyJFrame(); caught and ignoring...!\n" %(myModuleID)
        print(_msg); System.err.write(_msg)
    return None


frameToResurrect = None
try:
    # So we check own namespace first for same frame variable...
    if (u"%s_frame_"%myModuleID in globals()
            and isinstance(toolbox_frame_, MyJFrame)        # EDIT THIS
            and toolbox_frame_.isActiveInMoneydance):       # EDIT THIS
        frameToResurrect = toolbox_frame_                   # EDIT THIS
    else:
        # Now check all frames in the JVM...
        getFr = getMyJFrame( myModuleID )
        if getFr is not None:
            frameToResurrect = getFr
        del getFr
except:
    msg = "%s: Critical error checking frameToResurrect(1); caught and ignoring...!\n" %(myModuleID)
    print(msg); System.err.write(msg)

# ############################
# Trap startup conditions here.... The 'if's pass through to oblivion (and thus a clean exit)... The final 'else' actually runs the script
if int(MD_REF.getBuild()) < MIN_BUILD_REQD:     # Check for builds less than 1904 (version 2019.4) or build 3056 accordingly
    msg = "SORRY YOUR MONEYDANCE VERSION IS TOO OLD FOR THIS SCRIPT/EXTENSION (min build %s required)" %(MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try:    MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif frameToResurrect and frameToResurrect.isRunTimeExtension:
    msg = "%s: Sorry - runtime extension already running. Please uninstall/reinstall properly. Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif not _I_CAN_RUN_AS_MONEYBOT_SCRIPT and u"__file__" in globals():
    msg = "%s: Sorry - this script cannot be run in Moneybot console. Please install mxt and run extension properly. Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif not _I_CAN_RUN_AS_MONEYBOT_SCRIPT and u"moneydance_extension_loader" not in globals():
    msg = "%s: Error - moneydance_extension_loader seems to be missing? Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif frameToResurrect:  # and it's active too...
    try:
        msg = "%s: Detected that %s is already running..... Attempting to resurrect..\n" %(myModuleID, myModuleID)
        print(msg); System.err.write(msg)
        SwingUtilities.invokeLater(GenericVisibleRunnable(frameToResurrect, True, True))
    except:
        msg  = "%s: Failed to resurrect main Frame.. This duplicate Script/extension is now terminating.....\n" %(myModuleID)
        print(msg); System.err.write(msg)
        raise Exception(msg)

else:
    del frameToResurrect
    msg = "%s: Startup conditions passed (and no other instances of this program detected). Now executing....\n" %(myModuleID)
    print(msg); System.err.write(msg)

    # COMMON IMPORTS #######################################################################################################
    # COMMON IMPORTS #######################################################################################################
    # COMMON IMPORTS #######################################################################################################

    # NOTE: As of MD2022(4040) python.getSystemState().setdefaultencoding("utf8") is called on the python interpreter at launch...
    import sys
    reload(sys)  # Dirty hack to eliminate UTF-8 coding errors
    sys.setdefaultencoding('utf8')  # Dirty hack to eliminate UTF-8 coding errors. Without this str() fails on unicode strings...

    import os
    import os.path
    import codecs
    import inspect
    import pickle
    import platform
    import csv
    import datetime
    import traceback
    import subprocess

    from org.python.core.util import FileUtil

    from java.lang import Thread
    from java.lang import IllegalArgumentException

    from com.moneydance.util import Platform
    from com.moneydance.awt import JTextPanel, GridC, JDateField
    from com.moneydance.apps.md.view.gui import MDImages

    from com.infinitekind.util import DateUtil, CustomDateFormat
    from com.infinitekind.moneydance.model import *
    from com.infinitekind.moneydance.model import AccountUtil, AcctFilter, CurrencyType, CurrencyUtil
    from com.infinitekind.moneydance.model import Account, Reminder, ParentTxn, SplitTxn, TxnSearch, InvestUtil, TxnUtil

    from javax.swing import JButton, JScrollPane, WindowConstants, JLabel, JPanel, JComponent, KeyStroke, JDialog, JComboBox
    from javax.swing import JOptionPane, JTextArea, JMenuBar, JMenu, JMenuItem, AbstractAction, JCheckBoxMenuItem, JFileChooser
    from javax.swing import JTextField, JPasswordField, Box, UIManager, JTable, JCheckBox, JRadioButton, ButtonGroup
    from javax.swing.text import PlainDocument
    from javax.swing.border import EmptyBorder
    from javax.swing.filechooser import FileFilter

    exec("from javax.print import attribute")       # IntelliJ doesnt like the use of 'print' (as it's a keyword). Messy, but hey!
    exec("from java.awt.print import PrinterJob")   # IntelliJ doesnt like the use of 'print' (as it's a keyword). Messy, but hey!
    global attribute, PrinterJob

    from java.awt.datatransfer import StringSelection
    from javax.swing.text import DefaultHighlighter
    from javax.swing.event import AncestorListener

    from java.awt import Color, Dimension, FileDialog, FlowLayout, Toolkit, Font, GridBagLayout, GridLayout
    from java.awt import BorderLayout, Dialog, Insets
    from java.awt.event import KeyEvent, WindowAdapter, InputEvent
    from java.util import Date

    from java.text import DecimalFormat, SimpleDateFormat, MessageFormat
    from java.util import Calendar, ArrayList
    from java.lang import Double, Math, Character
    from java.io import FileNotFoundException, FilenameFilter, File, FileInputStream, FileOutputStream, IOException, StringReader
    from java.io import BufferedReader, InputStreamReader
    from java.nio.charset import Charset
    if isinstance(None, (JDateField,CurrencyUtil,Reminder,ParentTxn,SplitTxn,TxnSearch, JComboBox, JCheckBox,
                         JTextArea, JMenuBar, JMenu, JMenuItem, JCheckBoxMenuItem, JFileChooser, JDialog,
                         JButton, FlowLayout, InputEvent, ArrayList, File, IOException, StringReader, BufferedReader,
                         InputStreamReader, Dialog, JTable, BorderLayout, Double, InvestUtil, JRadioButton, ButtonGroup,
                         AccountUtil, AcctFilter, CurrencyType, Account, TxnUtil, JScrollPane, WindowConstants, JFrame,
                         JComponent, KeyStroke, AbstractAction, UIManager, Color, Dimension, Toolkit, KeyEvent,
                         WindowAdapter, CustomDateFormat, SimpleDateFormat, Insets, FileDialog, Thread, SwingWorker)): pass
    if codecs.BOM_UTF8 is not None: pass
    if csv.QUOTE_ALL is not None: pass
    if datetime.MINYEAR is not None: pass
    if Math.max(1,1): pass
    # END COMMON IMPORTS ###################################################################################################

    # COMMON GLOBALS #######################################################################################################
    global myParameters, myScriptName, _resetParameters, i_am_an_extension_so_run_headless, moneydanceIcon
    global lPickle_version_warning, decimalCharSep, groupingCharSep, lIamAMac, lGlobalErrorDetected
    global MYPYTHON_DOWNLOAD_URL
    # END COMMON GLOBALS ###################################################################################################
    # COPY >> END

    # SET THESE VARIABLES FOR ALL SCRIPTS ##################################################################################
    myScriptName = u"%s.py(Extension)" %myModuleID                                                                      # noqa
    myParameters = {}                                                                                                   # noqa
    _resetParameters = False                                                                                            # noqa
    lPickle_version_warning = False                                                                                     # noqa
    lIamAMac = False                                                                                                    # noqa
    lGlobalErrorDetected = False																						# noqa
    MYPYTHON_DOWNLOAD_URL = "https://yogi1967.github.io/MoneydancePythonScripts/"                                       # noqa

    class GlobalVars:        # Started using this method for storing global variables from August 2021
        CONTEXT = MD_REF
        defaultPrintService = None
        defaultPrinterAttributes = None
        defaultPrintFontSize = None
        defaultPrintLandscape = None
        defaultDPI = 72     # NOTE: 72dpi is Java2D default for everything; just go with it. No easy way to change
        STATUS_LABEL = None
        DARK_GREEN = Color(0, 192, 0)
        def __init__(self): pass    # Leave empty

    # END SET THESE VARIABLES FOR ALL SCRIPTS ##############################################################################

    # >>> THIS SCRIPT'S IMPORTS ############################################################################################
    import re
    import fnmatch
    import time
    import shutil
    import threading
    from collections import OrderedDict

    from org.python.core import PySystemState
    from java.util import Timer, TimerTask, Locale, Map, HashMap
    from java.util.zip import ZipInputStream, ZipEntry

    # renamed in MD build 3067
    if int(MD_REF.getBuild()) >= 3067:
        from com.moneydance.apps.md.view.gui.theme import ThemeInfo                                                     # noqa
    else:
        from com.moneydance.apps.md.view.gui.theme import Theme as ThemeInfo                                            # noqa

    try:
        if Platform.isOSX() and int(MD_REF.getBuild()) >= 3088:
            from com.moneydance.apps.md.view.gui.sync import ICloudSyncConfigurer
            from com.moneydance.apps.md.controller.sync import ICloudContainer
    except:
        pass

    from java.io import ByteArrayInputStream, OutputStream, InputStream
    from java.nio.charset import StandardCharsets

    from java.security import MessageDigest, KeyFactory
    from java.security.spec import PKCS8EncodedKeySpec, X509EncodedKeySpec, MGF1ParameterSpec

    from javax.crypto import Cipher, BadPaddingException
    from javax.crypto.spec import SecretKeySpec, OAEPParameterSpec, PSource

    from com.google.gson import Gson

    from com.moneydance.apps.md.controller import AccountBookWrapper, MDException, Util, AppEventListener

    from com.moneydance.apps.md.view.gui.sync import SyncFolderUtil
    from com.moneydance.apps.md.controller.sync import MDSyncCipher
    from com.moneydance.apps.md.controller import ModuleLoader, ModuleMetaData, LocalStorageCipher, Common, BalanceType
    from com.moneydance.apps.md.controller.io import FileUtils, AccountBookUtil
    from java.awt import GraphicsEnvironment, Desktop, Event

    from com.infinitekind.util import StreamTable, StreamVector, IOUtils, StringUtils, CustomDateFormat
    from com.infinitekind.moneydance.model import ReportSpec, AddressBookEntry, OnlineService, MoneydanceSyncableItem
    from com.infinitekind.moneydance.model import OnlinePayeeList, OnlinePaymentList, InvestFields, AccountBook
    from com.infinitekind.moneydance.model import CurrencySnapshot, CurrencySplit, OnlineTxnList, CurrencyTable
    from com.infinitekind.tiksync import SyncRecord
    from com.infinitekind.tiksync import SyncableItem

    from com.moneydance.apps.md.view.gui.txnreg import DownloadedTxnsView
    from com.moneydance.apps.md.view.gui import OnlineUpdateTxnsWindow

    from com.moneydance.apps.md.view.gui import ConsoleWindow
    from com.infinitekind.tiksync import Syncer
    from com.moneydance.apps.md.controller.olb.ofx import OFXConnection
    from com.moneydance.apps.md.controller.olb import MoneybotURLStreamHandlerFactory
    from com.infinitekind.moneydance.online import OnlineTxnMerger, OFXAuthInfo
    from com.moneydance.apps.md.view.gui import MDAccountProxy
    from java.lang import Integer, String
    from javax.swing import BorderFactory, JSeparator

    from java.net import URL, URLEncoder, URLDecoder                                                                    # noqa

    from java.awt.event import ComponentAdapter

    from java.util import UUID

    try:
        from com.infinitekind.moneydance.model import TxnSortOrder
        lImportOK = True
    except:
        lImportOK = False
    # >>> END THIS SCRIPT'S IMPORTS ########################################################################################

    # >>> THIS SCRIPT'S GLOBALS ############################################################################################
    global __TOOLBOX
    global toolbox_frame_, fixRCurrencyCheck, lCopyAllToClipBoard_TB, _COLWIDTHS, lGeekOutModeEnabled_TB
    global lHackerMode, lAdvancedMode, lIgnoreOutdatedExtensions_TB, lMustRestartAfterSnapChanges, lAutoPruneInternalBackups_TB
    global globalSaveFI_data, globalSave_DEBUG_FI_data
    global TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_BUILD
    global MD_OFX_BANK_SETTINGS_DIR, MD_OFX_DEFAULT_SETTINGS_FILE, MD_OFX_DEBUG_SETTINGS_FILE, MD_EXTENSIONS_DIRECTORY_FILE
    global TOOLBOX_VERSION_VALIDATION_URL, TOOLBOX_STOP_NOW
    global MD_RRATE_ISSUE_FIXED_BUILD, MD_ICLOUD_ENABLED, MD_MDPLUS_BUILD

    GlobalVars.TOOLBOX_UNLOCK = False
    GlobalVars.SCRIPT_RUNNING_LOCK = threading.Lock()

    lCopyAllToClipBoard_TB = False                                                                                      # noqa
    lGeekOutModeEnabled_TB = False                                                                                      # noqa
    lIgnoreOutdatedExtensions_TB = False                                                                                # noqa
    lAutoPruneInternalBackups_TB = False                                                                                # noqa
    lHackerMode = False                                                                                                 # noqa
    lAdvancedMode = False                                                                                               # noqa
    _COLWIDTHS = ["bank", "cc", "invest", "security", "loan", "misc", "split","rec_credits","rec_debits","secdetail"]   # noqa
    lMustRestartAfterSnapChanges = False                                                                                # noqa
    globalSaveFI_data = None                                                                                            # noqa
    globalSave_DEBUG_FI_data = None                                                                                     # noqa
    TOOLBOX_STOP_NOW = False                                                                                            # noqa

    MD_ICLOUD_ENABLED = 3088                                                                                            # noqa
    MD_RRATE_ISSUE_FIXED_BUILD = 3089                                                                                   # noqa
    MD_MDPLUS_BUILD = 4040                                                                                              # noqa
    TOOLBOX_MINIMUM_TESTED_MD_VERSION = 2020.0                                                                          # noqa
    TOOLBOX_MAXIMUM_TESTED_MD_VERSION = 2022.3                                                                          # noqa
    TOOLBOX_MAXIMUM_TESTED_MD_BUILD =   4063                                                                            # noqa
    MD_OFX_BANK_SETTINGS_DIR = "https://infinitekind.com/app/md/fis/"                                                   # noqa
    MD_OFX_DEFAULT_SETTINGS_FILE = "https://infinitekind.com/app/md/fi2004.dict"                                        # noqa
    MD_OFX_DEBUG_SETTINGS_FILE = "https://infinitekind.com/app/md.debug/fi2004.dict"                                    # noqa
    MD_EXTENSIONS_DIRECTORY_FILE = "https://infinitekind.com/app/md/extensions.dct"                                     # noqa
    TOOLBOX_VERSION_VALIDATION_URL = "https://raw.githubusercontent.com/yogi1967/MoneydancePythonScripts/master/source/toolbox/toolbox_version_requirements.dict" # noqa
    # Alternatively perhaps use....: "https://raw.githubusercontent.com/TheInfiniteKind/moneydance_open/main/python_scripts/toolbox/toolbox_version_requirements.dict"
    # >>> END THIS SCRIPT'S GLOBALS ############################################################################################

    # COPY >> START
    # COMMON CODE ######################################################################################################
    # COMMON CODE ################# VERSION 106 ########################################################################
    # COMMON CODE ######################################################################################################
    i_am_an_extension_so_run_headless = False                                                                           # noqa
    try:
        myScriptName = os.path.basename(__file__)
    except:
        i_am_an_extension_so_run_headless = True                                                                        # noqa

    scriptExit = """
----------------------------------------------------------------------------------------------------------------------
Thank you for using %s!
The author has other useful Extensions / Moneybot Python scripts available...:

Extension (.mxt) format only:
Toolbox:                                View Moneydance settings, diagnostics, fix issues, change settings and much more
Custom Balances (net_account_balances): Summary Page (HomePage) widget. Display the total of selected Account Balances
Total selected transactions:            One-click. Shows a popup total of the register txn amounts selected on screen

Extension (.mxt) and Script (.py) Versions available:
Extract Data:                           Extract various data to screen and/or csv.. Consolidation of:
- stockglance2020                       View summary of Securities/Stocks on screen, total by Security, export to csv 
- extract_reminders_csv                 View reminders on screen, edit if required, extract all to csv
- extract_currency_history_csv          Extract currency history to csv
- extract_investment_transactions_csv   Extract investment transactions to csv
- extract_account_registers_csv         Extract Account Register(s) to csv along with any attachments

List Future Reminders:                  View future reminders on screen. Allows you to set the days to look forward

A collection of useful ad-hoc scripts (zip file)
useful_scripts:                         Just unzip and select the script you want for the task at hand...

Visit: %s (Author's site)
----------------------------------------------------------------------------------------------------------------------
""" %(myScriptName, MYPYTHON_DOWNLOAD_URL)

    def cleanup_references():
        global MD_REF, MD_REF_UI, MD_EXTENSION_LOADER
        myPrint("DB","About to delete reference to MD_REF, MD_REF_UI and MD_EXTENSION_LOADER....!")
        del MD_REF, MD_REF_UI, MD_EXTENSION_LOADER

    def load_text_from_stream_file(theStream):
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

        cs = Charset.forName("UTF-8")

        istream = theStream

        if not istream:
            myPrint("B","... Error - the input stream is None")
            return "<NONE>"

        fileContents = ""
        istr = bufr = None
        try:
            istr = InputStreamReader(istream, cs)
            bufr = BufferedReader(istr)
            while True:
                line = bufr.readLine()
                if line is not None:
                    line += "\n"                   # not very efficient - should convert this to "\n".join() to contents
                    fileContents+=line
                    continue
                break
            fileContents+="\n<END>"
        except:
            myPrint("B", "ERROR reading from input stream... ")
            dump_sys_error_to_md_console_and_errorlog()

        try: bufr.close()
        except: pass

        try: istr.close()
        except: pass

        try: istream.close()
        except: pass

        myPrint("DB", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return fileContents

    # P=Display on Python Console, J=Display on MD (Java) Console Error Log, B=Both, D=If Debug Only print, DB=print both
    def myPrint(where, *args):
        global myScriptName, debug, i_am_an_extension_so_run_headless

        if where[0] == "D" and not debug: return

        try:
            printString = ""
            for what in args:
                printString += "%s " %what
            printString = printString.strip()

            if where == "P" or where == "B" or where[0] == "D":
                if not i_am_an_extension_so_run_headless:
                    try:
                        print(printString)
                    except:
                        print("Error writing to screen...")
                        dump_sys_error_to_md_console_and_errorlog()

            if where == "J" or where == "B" or where == "DB":
                dt = datetime.datetime.now().strftime("%Y/%m/%d-%H:%M:%S")
                try:
                    System.err.write(myScriptName + ":" + dt + ": ")
                    System.err.write(printString)
                    System.err.write("\n")
                except:
                    System.err.write(myScriptName + ":" + dt + ": "+"Error writing to console")
                    dump_sys_error_to_md_console_and_errorlog()

        except IllegalArgumentException:
            myPrint("B","ERROR - Probably on a multi-byte character..... Will ignore as code should just continue (PLEASE REPORT TO DEVELOPER).....")
            dump_sys_error_to_md_console_and_errorlog()

        return

    def dump_sys_error_to_md_console_and_errorlog(lReturnText=False):

        tb = traceback.format_exc()
        trace = traceback.format_stack()
        theText =  ".\n" \
                   "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n" \
                   "@@@@@ Unexpected error caught!\n".upper()
        theText += tb
        for trace_line in trace: theText += trace_line
        theText += "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"
        myPrint("B", theText)
        if lReturnText: return theText
        return

    def safeStr(_theText): return ("%s" %(_theText))

    def pad(theText, theLength):
        if not (isinstance(theText, unicode) or isinstance(theText, str)): theText = safeStr(theText)
        theText = theText[:theLength].ljust(theLength, u" ")
        return theText

    def rpad(theText, theLength):
        if not (isinstance(theText, unicode) or isinstance(theText, str)): theText = safeStr(theText)
        theText = theText[:theLength].rjust(theLength, u" ")
        return theText

    def cpad(theText, theLength):
        if not (isinstance(theText, unicode) or isinstance(theText, str)): theText = safeStr(theText)
        if len(theText)>=theLength: return theText[:theLength]
        padLength = int((theLength - len(theText)) / 2)
        theText = theText[:theLength]
        theText = ((" "*padLength)+theText+(" "*padLength))[:theLength]

        return theText

    myPrint("B", myScriptName, ": Python Script Initialising.......", "Build:", version_build)

    def getMonoFont():
        global debug

        try:
            theFont = MD_REF.getUI().getFonts().code
            # if debug: myPrint("B","Success setting Font set to Moneydance code: %s" %theFont)
        except:
            theFont = Font("monospaced", Font.PLAIN, 15)
            if debug: myPrint("B","Failed to Font set to Moneydance code - So using: %s" %theFont)

        return theFont

    def get_home_dir():
        homeDir = None

        # noinspection PyBroadException
        try:
            if Platform.isOSX():
                homeDir = System.getProperty(u"UserHome")  # On a Mac in a Java VM, the homedir is hidden
            else:
                # homeDir = System.getProperty("user.home")
                homeDir = os.path.expanduser(u"~")  # Should work on Unix and Windows
                if homeDir is None or homeDir == u"":
                    homeDir = System.getProperty(u"user.home")
                if homeDir is None or homeDir == u"":
                    homeDir = os.environ.get(u"HOMEPATH")
        except:
            pass

        if not homeDir: homeDir = u"?"
        return homeDir

    def getDecimalPoint(lGetPoint=False, lGetGrouping=False):
        global debug

        decimalFormat = DecimalFormat.getInstance()
        # noinspection PyUnresolvedReferences
        decimalSymbols = decimalFormat.getDecimalFormatSymbols()

        if not lGetGrouping: lGetPoint = True
        if lGetGrouping and lGetPoint: return u"error"

        try:
            if lGetPoint:
                _decimalCharSep = decimalSymbols.getDecimalSeparator()
                myPrint(u"D",u"Decimal Point Character: %s" %(_decimalCharSep))
                return _decimalCharSep

            if lGetGrouping:
                _groupingCharSep = decimalSymbols.getGroupingSeparator()
                if _groupingCharSep is None or _groupingCharSep == u"":
                    myPrint(u"B", u"Caught empty Grouping Separator")
                    return u""
                if ord(_groupingCharSep) >= 128:    # Probably a nbsp (160) = e.g. South Africa for example..!
                    myPrint(u"B", u"Caught special character in Grouping Separator. Ord(%s)" %(ord(_groupingCharSep)))
                    if ord(_groupingCharSep) == 160:
                        return u" (non breaking space character)"
                    return u" (non printable character)"
                myPrint(u"D",u"Grouping Separator Character:", _groupingCharSep)
                return _groupingCharSep
        except:
            myPrint(u"B",u"Error in getDecimalPoint() routine....?")
            dump_sys_error_to_md_console_and_errorlog()

        return u"error"


    decimalCharSep = getDecimalPoint(lGetPoint=True)
    groupingCharSep = getDecimalPoint(lGetGrouping=True)

    def isMacDarkModeDetected():
        darkResponse = "LIGHT"
        if Platform.isOSX():
            try:
                darkResponse = subprocess.check_output("defaults read -g AppleInterfaceStyle", shell=True)
                darkResponse = darkResponse.strip().lower()
            except: pass
        return ("dark" in darkResponse)

    def isMDThemeDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            try:
                if currentTheme.isSystemDark(): return True     # NOTE: Only VAQua has isSystemDark()
            except: pass
            if "dark" in currentTheme.getThemeID().lower(): return True
            if isMDThemeFlatDark(): return True
            if isMDThemeDarcula(): return True
        except: pass
        return False

    def isMDThemeDarcula():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if isMDThemeFlatDark(): return False                    # Flat Dark pretends to be Darcula!
            if "darcula" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeFlatDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "flat dark" in currentTheme.toString().lower(): return True
        except: pass
        return False

    def isMDThemeVAQua():
        if Platform.isOSX():
            try:
                currentTheme = MD_REF.getUI().getCurrentTheme()
                if ".vaqua" in safeStr(currentTheme.getClass()).lower(): return True
            except: pass
        return False

    # JOptionPane.DEFAULT_OPTION, JOptionPane.YES_NO_OPTION, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.OK_CANCEL_OPTION
    # JOptionPane.ERROR_MESSAGE, JOptionPane.INFORMATION_MESSAGE, JOptionPane.WARNING_MESSAGE, JOptionPane.QUESTION_MESSAGE, JOptionPane.PLAIN_MESSAGE

    # Copies MD_REF.getUI().showInfoMessage
    def myPopupInformationBox(theParent=None, theMessage="What no message?!", theTitle="Info", theMessageType=JOptionPane.INFORMATION_MESSAGE):

        if theParent is None:
            if theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE:
                icon_to_use=MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png")
                JOptionPane.showMessageDialog(theParent, JTextPanel(theMessage), theTitle, theMessageType, icon_to_use)
                return
        JOptionPane.showMessageDialog(theParent, JTextPanel(theMessage), theTitle, theMessageType)
        return

    def wrapLines(message, numChars=40):
        charCount = 0
        result=""
        for ch in message:
            if ch == '\n' or ch == '\r':
                charCount = 0
            elif charCount > numChars and not Character.isWhitespace(ch):
                result+="\n"
                charCount = 0
            else:
                charCount+=1
            result+=ch
        return result

    def myPopupAskBackup(theParent=None, theMessage="What no message?!", lReturnTheTruth=False):

        _options=["STOP", "PROCEED WITHOUT BACKUP", "DO BACKUP NOW"]
        response = JOptionPane.showOptionDialog(theParent,
                                                theMessage,
                                                "PERFORM BACKUP BEFORE UPDATE?",
                                                0,
                                                JOptionPane.WARNING_MESSAGE,
                                                None,
                                                _options,
                                                _options[0])

        if response == 2:
            myPrint("B", "User requested to perform Export Backup before update/fix - calling moneydance export backup routine...")
            MD_REF.getUI().setStatus("%s performing an Export Backup...." %(myScriptName),-1.0)
            MD_REF.getUI().saveToBackup(None)
            MD_REF.getUI().setStatus("%s Export Backup completed...." %(myScriptName),0)
            return True

        elif response == 1:
            myPrint("B", "User DECLINED to perform Export Backup before update/fix...!")
            if not lReturnTheTruth:
                return True

        return False

    # Copied MD_REF.getUI().askQuestion
    def myPopupAskQuestion(theParent=None,
                           theTitle="Question",
                           theQuestion="What?",
                           theOptionType=JOptionPane.YES_NO_OPTION,
                           theMessageType=JOptionPane.QUESTION_MESSAGE):

        icon_to_use = None
        if theParent is None:
            if theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE:
                icon_to_use=MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png")

        # question = wrapLines(theQuestion)
        question = theQuestion
        result = JOptionPane.showConfirmDialog(theParent,
                                               question,
                                               theTitle,
                                               theOptionType,
                                               theMessageType,
                                               icon_to_use)  # getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"))

        return result == 0

    # Copies Moneydance .askForQuestion
    def myPopupAskForInput(theParent,
                           theTitle,
                           theFieldLabel,
                           theFieldDescription="",
                           defaultValue=None,
                           isPassword=False,
                           theMessageType=JOptionPane.INFORMATION_MESSAGE):

        icon_to_use = None
        if theParent is None:
            if theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE:
                icon_to_use=MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png")

        p = JPanel(GridBagLayout())
        defaultText = None
        if defaultValue: defaultText = defaultValue
        if isPassword:
            field = JPasswordField(defaultText)
        else:
            field = JTextField(defaultText)
        field.addAncestorListener(RequestFocusListener())

        _x = 0
        if theFieldLabel:
            p.add(JLabel(theFieldLabel), GridC.getc(_x, 0).east())
            _x+=1

        p.add(field, GridC.getc(_x, 0).field())
        p.add(Box.createHorizontalStrut(244), GridC.getc(_x, 0))
        if theFieldDescription:
            p.add(JTextPanel(theFieldDescription), GridC.getc(_x, 1).field().colspan(_x + 1))
        if (JOptionPane.showConfirmDialog(theParent,
                                          p,
                                          theTitle,
                                          JOptionPane.OK_CANCEL_OPTION,
                                          theMessageType,
                                          icon_to_use) == 0):
            return field.getText()
        return None

    # APPLICATION_MODAL, DOCUMENT_MODAL, MODELESS, TOOLKIT_MODAL
    class MyPopUpDialogBox():

        def __init__(self, theParent=None, theStatus="", theMessage="", theWidth=200, theTitle="Info", lModal=True, lCancelButton=False, OKButtonText="OK", lAlertLevel=0):
            self.theParent = theParent
            self.theStatus = theStatus
            self.theMessage = theMessage
            self.theWidth = max(80,theWidth)
            self.theTitle = theTitle
            self.lModal = lModal
            self.lCancelButton = lCancelButton
            self.OKButtonText = OKButtonText
            self.lAlertLevel = lAlertLevel
            self.fakeJFrame = None
            self._popup_d = None
            self.lResult = [None]
            if not self.theMessage.endswith("\n"): self.theMessage+="\n"
            if self.OKButtonText == "": self.OKButtonText="OK"
            if Platform.isOSX() and int(float(MD_REF.getBuild())) >= 3039: self.lAlertLevel = 0    # Colors don't work on Mac since VAQua
            if isMDThemeDark() or isMacDarkModeDetected(): self.lAlertLevel = 0

        class WindowListener(WindowAdapter):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def windowClosing(self, WindowEvent):                                                                       # noqa
                global debug
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                myPrint("DB", "JDialog Frame shutting down....")

                self.lResult[0] = False

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class OKButtonAction(AbstractAction):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def actionPerformed(self, event):
                global debug
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                self.lResult[0] = True

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class CancelButtonAction(AbstractAction):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def actionPerformed(self, event):
                global debug
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                self.lResult[0] = False

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        def kill(self):

            global debug
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(GenericVisibleRunnable(self._popup_d, False))
                if self.fakeJFrame is not None:
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self._popup_d))
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self.fakeJFrame))
                else:
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self._popup_d))
            else:
                self._popup_d.setVisible(False)
                if self.fakeJFrame is not None:
                    self._popup_d.dispose()
                    self.fakeJFrame.dispose()
                else:
                    self._popup_d.dispose()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

        def result(self):
            global debug
            return self.lResult[0]

        def go(self):
            global debug

            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            class MyPopUpDialogBoxRunnable(Runnable):
                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                                      # noqa

                    myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
                    myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                    # Create a fake JFrame so we can set the Icons...
                    if self.callingClass.theParent is None:
                        self.callingClass.fakeJFrame = MyJFrame()
                        self.callingClass.fakeJFrame.setName(u"%s_fake_dialog" %(myModuleID))
                        self.callingClass.fakeJFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)
                        self.callingClass.fakeJFrame.setUndecorated(True)
                        self.callingClass.fakeJFrame.setVisible( False )
                        if not Platform.isOSX():
                            self.callingClass.fakeJFrame.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    if self.callingClass.lModal:
                        # noinspection PyUnresolvedReferences
                        self.callingClass._popup_d = JDialog(self.callingClass.theParent, self.callingClass.theTitle, Dialog.ModalityType.APPLICATION_MODAL)
                    else:
                        # noinspection PyUnresolvedReferences
                        self.callingClass._popup_d = JDialog(self.callingClass.theParent, self.callingClass.theTitle, Dialog.ModalityType.MODELESS)

                    self.callingClass._popup_d.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()

                    # Add standard CMD-W keystrokes etc to close window
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")
                    self.callingClass._popup_d.getRootPane().getActionMap().put("close-window", self.callingClass.CancelButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult))
                    self.callingClass._popup_d.addWindowListener(self.callingClass.WindowListener(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult))

                    if (not Platform.isMac()):
                        # MD_REF.getUI().getImages()
                        self.callingClass._popup_d.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    displayJText = JTextArea(self.callingClass.theMessage)
                    displayJText.setFont( getMonoFont() )
                    displayJText.setEditable(False)
                    displayJText.setLineWrap(False)
                    displayJText.setWrapStyleWord(False)

                    _popupPanel=JPanel()

                    # maxHeight = 500
                    _popupPanel.setLayout(GridLayout(0,1))
                    _popupPanel.setBorder(EmptyBorder(8, 8, 8, 8))

                    if self.callingClass.theStatus:
                        _label1 = JLabel(pad(self.callingClass.theStatus,self.callingClass.theWidth-20))
                        _label1.setForeground(getColorBlue())
                        _popupPanel.add(_label1)

                    myScrollPane = JScrollPane(displayJText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
                    if displayJText.getLineCount()>5:
                        myScrollPane.setWheelScrollingEnabled(True)
                        _popupPanel.add(myScrollPane)
                    else:
                        _popupPanel.add(displayJText)

                    buttonPanel = JPanel()
                    if self.callingClass.lModal or self.callingClass.lCancelButton:
                        buttonPanel.setLayout(FlowLayout(FlowLayout.CENTER))

                        if self.callingClass.lCancelButton:
                            cancel_button = JButton("CANCEL")
                            cancel_button.setPreferredSize(Dimension(100,40))
                            cancel_button.setBackground(Color.LIGHT_GRAY)
                            cancel_button.setBorderPainted(False)
                            cancel_button.setOpaque(True)
                            cancel_button.addActionListener( self.callingClass.CancelButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult) )
                            buttonPanel.add(cancel_button)

                        if self.callingClass.lModal:
                            ok_button = JButton(self.callingClass.OKButtonText)
                            if len(self.callingClass.OKButtonText) <= 2:
                                ok_button.setPreferredSize(Dimension(100,40))
                            else:
                                ok_button.setPreferredSize(Dimension(200,40))

                            ok_button.setBackground(Color.LIGHT_GRAY)
                            ok_button.setBorderPainted(False)
                            ok_button.setOpaque(True)
                            ok_button.addActionListener( self.callingClass.OKButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame, self.callingClass.lResult) )
                            buttonPanel.add(ok_button)

                        _popupPanel.add(buttonPanel)

                    if self.callingClass.lAlertLevel>=2:
                        # internalScrollPane.setBackground(Color.RED)
                        # theJText.setBackground(Color.RED)
                        # theJText.setForeground(Color.BLACK)
                        displayJText.setBackground(Color.RED)
                        displayJText.setForeground(Color.BLACK)
                        _popupPanel.setBackground(Color.RED)
                        _popupPanel.setForeground(Color.BLACK)
                        buttonPanel.setBackground(Color.RED)
                        myScrollPane.setBackground(Color.RED)

                    elif self.callingClass.lAlertLevel>=1:
                        # internalScrollPane.setBackground(Color.YELLOW)
                        # theJText.setBackground(Color.YELLOW)
                        # theJText.setForeground(Color.BLACK)
                        displayJText.setBackground(Color.YELLOW)
                        displayJText.setForeground(Color.BLACK)
                        _popupPanel.setBackground(Color.YELLOW)
                        _popupPanel.setForeground(Color.BLACK)
                        buttonPanel.setBackground(Color.YELLOW)
                        myScrollPane.setBackground(Color.RED)

                    self.callingClass._popup_d.add(_popupPanel)
                    self.callingClass._popup_d.pack()
                    self.callingClass._popup_d.setLocationRelativeTo(None)
                    self.callingClass._popup_d.setVisible(True)  # Keeping this modal....

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyPopUpDialogBoxRunnable()...")
                SwingUtilities.invokeAndWait(MyPopUpDialogBoxRunnable(self))
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                MyPopUpDialogBoxRunnable(self).run()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

            return self.lResult[0]

    def play_the_money_sound():

        # Seems to cause a crash on Virtual Machine with no Audio - so just in case....
        try:
            MD_REF.getUI().getSounds().playSound("cash_register.wav")
        except:
            pass

        return

    def get_filename_addition():

        cal = Calendar.getInstance()
        hhmm = str(10000 + cal.get(11) * 100 + cal.get(12))[1:]
        nameAddition = "-" + str(DateUtil.getStrippedDateInt()) + "-"+hhmm

        return nameAddition

    def check_file_writable(fnm):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )
        myPrint("DB","Checking path: ", fnm)

        if os.path.exists(fnm):
            myPrint("DB", "path exists..")
            # path exists
            if os.path.isfile(fnm):  # is it a file or a dir?
                myPrint("DB","path is a file..")
                # also works when file is a link and the target is writable
                return os.access(fnm, os.W_OK)
            else:
                myPrint("DB", "path is not a file..")
                return False  # path is a dir, so cannot write as a file
        # target does not exist, check perms on parent dir
        myPrint("DB","path does not exist...")
        pdir = os.path.dirname(fnm)
        if not pdir: pdir = '.'
        # target is creatable if parent dir is writable
        return os.access(pdir, os.W_OK)

    class ExtFilenameFilter(FilenameFilter):
        """File extension filter for FileDialog"""
        def __init__(self, ext): self.ext = "." + ext.upper()                                                           # noqa

        def accept(self, thedir, filename):                                                                             # noqa
            if filename is not None and filename.upper().endswith(self.ext): return True
            return False

    class ExtFileFilterJFC(FileFilter):
        """File extension filter for JFileChooser"""
        def __init__(self, ext): self.ext = "." + ext.upper()

        def getDescription(self): return "*"+self.ext                                                                   # noqa

        def accept(self, _theFile):                                                                                     # noqa
            if _theFile is None: return False
            return _theFile.getName().upper().endswith(self.ext)

    try:
        moneydanceIcon = MDImages.getImage(MD_REF.getSourceInformation().getIconResource())
    except:
        moneydanceIcon = None

    def MDDiag():
        global debug
        myPrint("D", "Moneydance Build:", MD_REF.getVersion(), "Build:", MD_REF.getBuild())


    MDDiag()

    myPrint("DB","System file encoding is:", sys.getfilesystemencoding() )   # Not used, but interesting. Perhaps useful when switching between Windows/Macs and writing files...

    def checkVersions():
        global debug

        lError = False
        plat_j = platform.system()
        plat_p = platform.python_implementation()
        python_maj = sys.version_info.major
        python_min = sys.version_info.minor

        myPrint("DB","Platform:", plat_p, plat_j, python_maj, ".", python_min)
        myPrint("DB", sys.version)

        if plat_p != "Jython":
            lError = True
            myPrint("DB", "Error: Script requires Jython")
        if plat_j != "Java":
            lError = True
            myPrint("DB", "Error: Script requires Java  base")
        if (python_maj != 2 or python_min != 7):
            lError = True
            myPrint("DB", "\n\nError: Script was  designed on version 2.7. By all means bypass this test and see what happens.....")

        if lError:
            myPrint("J", "Platform version issue - will terminate script!")
            myPrint("P", "\n@@@ TERMINATING PROGRAM @@@\n")
            raise(Exception("Platform version issue - will terminate script!"))

        return not lError


    checkVersions()

    def setDefaultFonts():

        myFont = MD_REF.getUI().getFonts().defaultText

        if myFont.getSize()>18:
            try:
                myFont = myFont.deriveFont(16.0)
                myPrint("B", "I have reduced the font size down to point-size 16 - Default Fonts are now set to: %s" %(myFont))
            except:
                myPrint("B","ERROR - failed to override font point size down to 16.... will ignore and continue. Font set to: %s" %(myFont))
        else:
            myPrint("DB", "Attempting to set default font to %s" %myFont)

        try:
            UIManager.getLookAndFeelDefaults().put("defaultFont", myFont )

            # https://thebadprogrammer.com/swing-uimanager-keys/
            UIManager.put("CheckBoxMenuItem.acceleratorFont", myFont)
            UIManager.put("Button.font", myFont)
            UIManager.put("ToggleButton.font", myFont)
            UIManager.put("RadioButton.font", myFont)
            UIManager.put("CheckBox.font", myFont)
            UIManager.put("ColorChooser.font", myFont)
            UIManager.put("ComboBox.font", myFont)
            UIManager.put("Label.font", myFont)
            UIManager.put("List.font", myFont)
            UIManager.put("MenuBar.font", myFont)
            UIManager.put("Menu.acceleratorFont", myFont)
            UIManager.put("RadioButtonMenuItem.acceleratorFont", myFont)
            UIManager.put("MenuItem.acceleratorFont", myFont)
            UIManager.put("MenuItem.font", myFont)
            UIManager.put("RadioButtonMenuItem.font", myFont)
            UIManager.put("CheckBoxMenuItem.font", myFont)
            UIManager.put("OptionPane.buttonFont", myFont)
            UIManager.put("OptionPane.messageFont", myFont)
            UIManager.put("Menu.font", myFont)
            UIManager.put("PopupMenu.font", myFont)
            UIManager.put("OptionPane.font", myFont)
            UIManager.put("Panel.font", myFont)
            UIManager.put("ProgressBar.font", myFont)
            UIManager.put("ScrollPane.font", myFont)
            UIManager.put("Viewport.font", myFont)
            UIManager.put("TabbedPane.font", myFont)
            UIManager.put("Slider.font", myFont)
            UIManager.put("Table.font", myFont)
            UIManager.put("TableHeader.font", myFont)
            UIManager.put("TextField.font", myFont)
            UIManager.put("Spinner.font", myFont)
            UIManager.put("PasswordField.font", myFont)
            UIManager.put("TextArea.font", myFont)
            UIManager.put("TextPane.font", myFont)
            UIManager.put("EditorPane.font", myFont)
            UIManager.put("TabbedPane.smallFont", myFont)
            UIManager.put("TitledBorder.font", myFont)
            UIManager.put("ToolBar.font", myFont)
            UIManager.put("ToolTip.font", myFont)
            UIManager.put("Tree.font", myFont)
            UIManager.put("FormattedTextField.font", myFont)
            UIManager.put("IconButton.font", myFont)
            UIManager.put("InternalFrame.optionDialogTitleFont", myFont)
            UIManager.put("InternalFrame.paletteTitleFont", myFont)
            UIManager.put("InternalFrame.titleFont", myFont)
        except:
            myPrint("B","Failed to set Swing default fonts to use Moneydance defaults... sorry")

        myPrint("DB",".setDefaultFonts() successfully executed...")
        return

    if MD_REF_UI is not None:
        setDefaultFonts()

    def who_am_i():
        try:
            username = System.getProperty("user.name")
        except:
            username = "???"

        return username

    def getHomeDir():
        # Yup - this can be all over the place...
        myPrint("D", 'System.getProperty("user.dir")', System.getProperty("user.dir"))
        myPrint("D", 'System.getProperty("UserHome")', System.getProperty("UserHome"))
        myPrint("D", 'System.getProperty("user.home")', System.getProperty("user.home"))
        myPrint("D", 'os.path.expanduser("~")', os.path.expanduser("~"))
        myPrint("D", 'os.environ.get("HOMEPATH")', os.environ.get("HOMEPATH"))
        return

    def amIaMac():
        return Platform.isOSX()

    myPrint("D", "I am user:", who_am_i())
    if debug: getHomeDir()
    lIamAMac = amIaMac()

    def myDir():
        global lIamAMac
        homeDir = None

        try:
            if lIamAMac:
                homeDir = System.getProperty("UserHome")  # On a Mac in a Java VM, the homedir is hidden
            else:
                # homeDir = System.getProperty("user.home")
                homeDir = os.path.expanduser("~")  # Should work on Unix and Windows
                if homeDir is None or homeDir == "":
                    homeDir = System.getProperty("user.home")
                if homeDir is None or homeDir == "":
                    homeDir = os.environ.get("HOMEPATH")
        except:
            pass

        if homeDir is None or homeDir == "":
            homeDir = MD_REF.getCurrentAccountBook().getRootFolder().getParent()  # Better than nothing!

        myPrint("DB", "Home Directory selected...:", homeDir)
        if homeDir is None: return ""
        return homeDir

    # noinspection PyArgumentList
    class JTextFieldLimitYN(PlainDocument):

        limit = 10  # Default
        toUpper = False
        what = ""

        def __init__(self, limit, toUpper, what):

            super(PlainDocument, self).__init__()
            self.limit = limit
            self.toUpper = toUpper
            self.what = what

        def insertString(self, myOffset, myString, myAttr):

            if (myString is None): return
            if self.toUpper: myString = myString.upper()
            if (self.what == "YN" and (myString in "YN")) \
                    or (self.what == "DELIM" and (myString in ";|,")) \
                    or (self.what == "1234" and (myString in "1234")) \
                    or (self.what == "CURR"):
                if ((self.getLength() + len(myString)) <= self.limit):
                    super(JTextFieldLimitYN, self).insertString(myOffset, myString, myAttr)                             # noqa

    def fix_delimiter( theDelimiter ):

        try:
            if sys.version_info.major >= 3: return theDelimiter
            if sys.version_info.major <  2: return str(theDelimiter)

            if sys.version_info.minor >  7: return theDelimiter
            if sys.version_info.minor <  7: return str(theDelimiter)

            if sys.version_info.micro >= 2: return theDelimiter
        except:
            pass

        return str( theDelimiter )

    def get_StuWareSoftSystems_parameters_from_file(myFile="StuWareSoftSystems.dict"):
        global debug, myParameters, lPickle_version_warning, version_build, _resetParameters                            # noqa

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if _resetParameters:
            myPrint("B", "User has specified to reset parameters... keeping defaults and skipping pickle()")
            myParameters = {}
            return

        old_dict_filename = os.path.join("..", myFile)

        # Pickle was originally encrypted, no need, migrating to unencrypted
        migratedFilename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(),myFile)

        myPrint("DB", "Now checking for parameter file:", migratedFilename)

        if os.path.exists( migratedFilename ):

            myPrint("DB", "loading parameters from non-encrypted Pickle file:", migratedFilename)
            myPrint("DB", "Parameter file", migratedFilename, "exists..")
            # Open the file
            try:
                # Really we should open() the file in binary mode and read/write as binary, then we wouldn't get platform differences!
                istr = FileInputStream(migratedFilename)
                load_file = FileUtil.wrap(istr)
                if not Platform.isWindows():
                    load_string = load_file.read().replace('\r', '')    # This allows for files migrated from windows (strip the extra CR)
                else:
                    load_string = load_file.read()

                myParameters = pickle.loads(load_string)
                load_file.close()
            except FileNotFoundException:
                myPrint("B", "Error: failed to find parameter file...")
                myParameters = None
            except EOFError:
                myPrint("B", "Error: reached EOF on parameter file....")
                myParameters = None
            except:
                myPrint("B","Error opening Pickle File (will try encrypted version) - Unexpected error ", sys.exc_info()[0])
                myPrint("B","Error opening Pickle File (will try encrypted version) - Unexpected error ", sys.exc_info()[1])
                myPrint("B","Error opening Pickle File (will try encrypted version) - Line Number: ", sys.exc_info()[2].tb_lineno)

                # OK, so perhaps from older version - encrypted, try to read
                try:
                    local_storage = MD_REF.getCurrentAccountBook().getLocalStorage()
                    istr = local_storage.openFileForReading(old_dict_filename)
                    load_file = FileUtil.wrap(istr)
                    # noinspection PyTypeChecker
                    myParameters = pickle.load(load_file)
                    load_file.close()
                    myPrint("B","Success loading Encrypted Pickle file - will migrate to non encrypted")
                    lPickle_version_warning = True
                except:
                    myPrint("B","Opening Encrypted Pickle File - Unexpected error ", sys.exc_info()[0])
                    myPrint("B","Opening Encrypted Pickle File - Unexpected error ", sys.exc_info()[1])
                    myPrint("B","Error opening Pickle File - Line Number: ", sys.exc_info()[2].tb_lineno)
                    myPrint("B", "Error: Pickle.load() failed.... Is this a restored dataset? Will ignore saved parameters, and create a new file...")
                    myParameters = None

            if myParameters is None:
                myParameters = {}
                myPrint("DB","Parameters did not load, will keep defaults..")
            else:
                myPrint("DB","Parameters successfully loaded from file...")
        else:
            myPrint("J", "Parameter Pickle file does not exist - will use default and create new file..")
            myPrint("D", "Parameter Pickle file does not exist - will use default and create new file..")
            myParameters = {}

        if not myParameters: return

        myPrint("DB","myParameters read from file contains...:")
        for key in sorted(myParameters.keys()):
            myPrint("DB","...variable:", key, myParameters[key])

        if myParameters.get("debug") is not None: debug = myParameters.get("debug")
        if myParameters.get("lUseMacFileChooser") is not None:
            myPrint("B", "Detected old lUseMacFileChooser parameter/variable... Will delete it...")
            myParameters.pop("lUseMacFileChooser", None)  # Old variable - not used - delete from parameter file

        myPrint("DB","Parameter file loaded if present and myParameters{} dictionary set.....")

        # Now load into memory!
        load_StuWareSoftSystems_parameters_into_memory()

        return

    def save_StuWareSoftSystems_parameters_to_file(myFile="StuWareSoftSystems.dict"):
        global debug, myParameters, lPickle_version_warning, version_build

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if myParameters is None: myParameters = {}

        # Don't forget, any parameters loaded earlier will be preserved; just add changed variables....
        myParameters["__Author"] = "Stuart Beesley - (c) StuWareSoftSystems"
        myParameters["debug"] = debug

        dump_StuWareSoftSystems_parameters_from_memory()

        # Pickle was originally encrypted, no need, migrating to unencrypted
        migratedFilename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(),myFile)

        myPrint("DB","Will try to save parameter file:", migratedFilename)

        ostr = FileOutputStream(migratedFilename)

        myPrint("DB", "about to Pickle.dump and save parameters to unencrypted file:", migratedFilename)

        try:
            save_file = FileUtil.wrap(ostr)
            pickle.dump(myParameters, save_file, protocol=0)
            save_file.close()

            myPrint("DB","myParameters now contains...:")
            for key in sorted(myParameters.keys()):
                myPrint("DB","...variable:", key, myParameters[key])

        except:
            myPrint("B", "Error - failed to create/write parameter file.. Ignoring and continuing.....")
            dump_sys_error_to_md_console_and_errorlog()

            return

        myPrint("DB","Parameter file written and parameters saved to disk.....")

        return

    def get_time_stamp_as_nice_text( timeStamp ):

        prettyDate = ""
        try:
            c = Calendar.getInstance()
            c.setTime(Date(timeStamp))
            dateFormatter = SimpleDateFormat("yyyy/MM/dd HH:mm:ss(.SSS) Z z zzzz")
            prettyDate = dateFormatter.format(c.getTime())
        except:
            pass

        return prettyDate

    def currentDateTimeMarker():
        c = Calendar.getInstance()
        dateformat = SimpleDateFormat("_yyyyMMdd_HHmmss")
        _datetime = dateformat.format(c.getTime())
        return _datetime

    def destroyOldFrames(moduleName):
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))
        frames = JFrame.getFrames()
        for fr in frames:
            if fr.getName().lower().startswith(moduleName+"_"):
                myPrint("DB","Found old frame %s and active status is: %s" %(fr.getName(),fr.isActiveInMoneydance))
                try:
                    fr.isActiveInMoneydance = False
                    if not SwingUtilities.isEventDispatchThread():
                        SwingUtilities.invokeLater(GenericVisibleRunnable(fr, False, False))
                        SwingUtilities.invokeLater(GenericDisposeRunnable(fr))  # This should call windowClosed() which should remove MD listeners.....
                    else:
                        fr.setVisible(False)
                        fr.dispose()            # This should call windowClosed() which should remove MD listeners.....
                    myPrint("DB","disposed of old frame: %s" %(fr.getName()))
                except:
                    myPrint("B","Failed to dispose old frame: %s" %(fr.getName()))
                    dump_sys_error_to_md_console_and_errorlog()

    def classPrinter(className, theObject):
        try:
            text = "Class: %s %s@{:x}".format(System.identityHashCode(theObject)) %(className, theObject.__class__)
        except:
            text = "Error in classPrinter(): %s: %s" %(className, theObject)
        return text

    def getColorBlue():
        if not isMDThemeDark() and not isMacDarkModeDetected(): return(Color.BLUE)
        return (MD_REF.getUI().getColors().defaultTextForeground)

    def getColorRed(): return (MD_REF.getUI().getColors().errorMessageForeground)

    def getColorDarkGreen(): return (MD_REF.getUI().getColors().budgetHealthyColor)

    def setDisplayStatus(_theStatus, _theColor=None):
        """Sets the Display / Status label on the main diagnostic display: G=Green, B=Blue, R=Red, DG=Dark Green"""

        if GlobalVars.STATUS_LABEL is None or not isinstance(GlobalVars.STATUS_LABEL, JLabel): return

        GlobalVars.STATUS_LABEL.setText((_theStatus).ljust(800, " "))

        if _theColor is None or _theColor == "": _theColor = "X"
        _theColor = _theColor.upper()
        if _theColor == "R":    GlobalVars.STATUS_LABEL.setForeground(getColorRed())
        elif _theColor == "B":  GlobalVars.STATUS_LABEL.setForeground(getColorBlue())
        elif _theColor == "DG": GlobalVars.STATUS_LABEL.setForeground(getColorDarkGreen())
        else:                   GlobalVars.STATUS_LABEL.setForeground(MD_REF.getUI().getColors().defaultTextForeground)
        return

    def setJFileChooserParameters(_jf, lReportOnly=False, lDefaults=False, lPackagesT=None, lApplicationsT=None, lOptionsButton=None, lNewFolderButton=None):
        """sets up Client Properties for JFileChooser() to behave as required >> Mac only"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not Platform.isOSX(): return
        if not isinstance(_jf, JFileChooser): return

        _PKG = "JFileChooser.packageIsTraversable"
        _APP = "JFileChooser.appBundleIsTraversable"
        _OPTIONS = "JFileChooser.optionsPanelEnabled"
        _NEWFOLDER = "JFileChooser.canCreateDirectories"

        # JFileChooser defaults: https://violetlib.org/vaqua/filechooser.html
        # "JFileChooser.packageIsTraversable"   default False   >> set "true" to allow Packages to be traversed
        # "JFileChooser.appBundleIsTraversable" default False   >> set "true" to allow App Bundles to be traversed
        # "JFileChooser.optionsPanelEnabled"    default False   >> set "true" to allow Options button
        # "JFileChooser.canCreateDirectories"   default False   >> set "true" to allow New Folder button

        if debug or lReportOnly:
            myPrint("B", "Parameters set: ReportOnly: %s, Defaults:%s, PackagesT: %s, ApplicationsT:%s, OptionButton:%s, NewFolderButton: %s" %(lReportOnly, lDefaults, lPackagesT, lApplicationsT, lOptionsButton, lNewFolderButton))
            txt = ("Before setting" if not lReportOnly else "Reporting only")
            for setting in [_PKG, _APP, _OPTIONS, _NEWFOLDER]: myPrint("DB", "%s: '%s': '%s'" %(pad(txt,14), pad(setting,50), _jf.getClientProperty(setting)))
            if lReportOnly: return

        if lDefaults:
            _jf.putClientProperty(_PKG, None)
            _jf.putClientProperty(_APP, None)
            _jf.putClientProperty(_OPTIONS, None)
            _jf.putClientProperty(_NEWFOLDER, None)
        else:
            if lPackagesT       is not None: _jf.putClientProperty(_PKG, lPackagesT)
            if lApplicationsT   is not None: _jf.putClientProperty(_APP, lApplicationsT)
            if lOptionsButton   is not None: _jf.putClientProperty(_OPTIONS, lOptionsButton)
            if lNewFolderButton is not None: _jf.putClientProperty(_NEWFOLDER, lNewFolderButton)

        for setting in [_PKG, _APP, _OPTIONS, _NEWFOLDER]: myPrint("DB", "%s: '%s': '%s'" %(pad("After setting",14), pad(setting,50), _jf.getClientProperty(setting)))

        return

    def setFileDialogParameters(lReportOnly=False, lDefaults=False, lSelectDirectories=None, lPackagesT=None):
        """sets up System Properties for FileDialog() to behave as required >> Mac only"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not Platform.isOSX(): return

        _TRUE = "true"
        _FALSE = "false"

        _DIRS_FD = "apple.awt.fileDialogForDirectories"        # Changes Behaviour. When True you can select a Folder (rather than a file)
        _PKGS_FD = "com.apple.macos.use-file-dialog-packages"

        # FileDialog defaults
        # "apple.awt.fileDialogForDirectories"       default "false" >> set "true"  to allow Directories to be selected
        # "com.apple.macos.use-file-dialog-packages" default "true"  >> set "false" to allow access to Mac 'packages'

        if debug or lReportOnly:
            myPrint("B", "Parameters set: ReportOnly: %s, Defaults:%s, SelectDirectories:%s, PackagesT:%s" % (lReportOnly, lDefaults, lSelectDirectories, lPackagesT))
            txt = ("Before setting" if not lReportOnly else "Reporting only")
            for setting in [_DIRS_FD, _PKGS_FD]: myPrint("DB", "%s: '%s': '%s'" %(pad(txt,14), pad(setting,50), System.getProperty(setting)))
            if lReportOnly: return

        if lDefaults:
            System.setProperty(_DIRS_FD,_FALSE)
            System.setProperty(_PKGS_FD,_TRUE)
        else:
            if lSelectDirectories is not None: System.setProperty(_DIRS_FD, (_TRUE if lSelectDirectories   else _FALSE))
            if lPackagesT         is not None: System.setProperty(_PKGS_FD, (_TRUE if lPackagesT           else _FALSE))

        for setting in [_DIRS_FD, _PKGS_FD]: myPrint("DB", "After setting:  '%s': '%s'" %(pad(setting,50), System.getProperty(setting)))

        return

    def getFileFromFileChooser(fileChooser_parent,                  # The Parent Frame, or None
                               fileChooser_starting_dir,            # The Starting Dir
                               fileChooser_filename,                # Default filename (or None)
                               fileChooser_title,                   # The Title (with FileDialog, only works on SAVE)
                               fileChooser_multiMode,               # Normally False (True has not been coded!)
                               fileChooser_open,                    # True for Open/Load, False for Save
                               fileChooser_selectFiles,             # True for files, False for Directories
                               fileChooser_OK_text,                 # Normally None, unless set - use text
                               fileChooser_fileFilterText=None,     # E.g. "txt" or "qif"
                               lForceJFC=False,
                               lForceFD=False,
                               lAllowTraversePackages=None,
                               lAllowTraverseApplications=None,     # JFileChooser only..
                               lAllowNewFolderButton=True,          # JFileChooser only..
                               lAllowOptionsButton=None):           # JFileChooser only..
        """Launches FileDialog on Mac, or JFileChooser on other platforms... NOTE: Do not use Filter on Macs!"""

        _THIS_METHOD_NAME = "Dynamic File Chooser"

        if fileChooser_multiMode:
            myPrint("B","@@ SORRY Multi File Selection Mode has not been coded! Exiting...")
            return None

        if fileChooser_starting_dir is None or fileChooser_starting_dir == "" or not os.path.exists(fileChooser_starting_dir):
            fileChooser_starting_dir = MD_REF.getPreferences().getSetting("gen.data_dir", None)

        if fileChooser_starting_dir is None or not os.path.exists(fileChooser_starting_dir):
            fileChooser_starting_dir = None
            myPrint("B","ERROR: Starting Path does not exist - will start with no starting path set..")

        else:
            myPrint("DB", "Preparing the Dynamic File Chooser with path: %s" %(fileChooser_starting_dir))
            if Platform.isOSX() and "/Library/Containers/" in fileChooser_starting_dir:
                myPrint("DB", "WARNING: Folder will be restricted by MacOSx...")
                if not lForceJFC:
                    txt = ("FileDialog: MacOSx restricts Java Access to 'special' locations like 'Library\n"
                          "Folder: %s\n"
                          "Please navigate to this location manually in the next popup. This grants permission"
                          %(fileChooser_starting_dir))
                else:
                    txt = ("JFileChooser: MacOSx restricts Java Access to 'special' locations like 'Library\n"
                          "Folder: %s\n"
                          "Your files will probably be hidden.. If so, switch to FileDialog()...(contact author)"
                          %(fileChooser_starting_dir))
                MyPopUpDialogBox(fileChooser_parent,
                                 "NOTE: Mac Security Restriction",
                                 txt,
                                 theTitle=_THIS_METHOD_NAME,
                                 lAlertLevel=1).go()

        if (Platform.isOSX() and not lForceJFC) or lForceFD:

            setFileDialogParameters(lPackagesT=lAllowTraversePackages, lSelectDirectories=(not fileChooser_selectFiles))

            myPrint("DB", "Preparing FileDialog() with path: %s" %(fileChooser_starting_dir))
            if fileChooser_filename is not None: myPrint("DB", "... and filename:                 %s" %(fileChooser_filename))

            fileDialog = FileDialog(fileChooser_parent, fileChooser_title)

            fileDialog.setTitle(fileChooser_title)

            if fileChooser_starting_dir is not None:    fileDialog.setDirectory(fileChooser_starting_dir)
            if fileChooser_filename is not None:        fileDialog.setFile(fileChooser_filename)

            fileDialog.setMultipleMode(fileChooser_multiMode)

            if fileChooser_open:
                fileDialog.setMode(FileDialog.LOAD)
            else:
                fileDialog.setMode(FileDialog.SAVE)

            if fileChooser_fileFilterText is not None and (not Platform.isOSX() or not Platform.isOSXVersionAtLeast("10.13")):
                myPrint("DB",".. Adding file filter for: %s" %(fileChooser_fileFilterText))
                fileDialog.setFilenameFilter(ExtFilenameFilter(fileChooser_fileFilterText))

            fileDialog.setVisible(True)

            setFileDialogParameters(lDefaults=True)

            myPrint("DB", "FileDialog returned File:      %s" %(fileDialog.getFile()))
            myPrint("DB", "FileDialog returned Directory: %s" %(fileDialog.getDirectory()))

            if fileDialog.getFile() is None or fileDialog.getFile() == "": return None

            _theFile = os.path.join(fileDialog.getDirectory(), fileDialog.getFile())

        else:

            myPrint("DB", "Preparing JFileChooser() with path: %s" %(fileChooser_starting_dir))
            if fileChooser_filename is not None: myPrint("DB", "... and filename:                   %s" %(fileChooser_filename))

            if fileChooser_starting_dir is not None:
                jfc = JFileChooser(fileChooser_starting_dir)
            else:
                jfc = JFileChooser()

            if fileChooser_filename is not None: jfc.setSelectedFile(File(fileChooser_filename))
            setJFileChooserParameters(jfc,
                                      lPackagesT=lAllowTraversePackages,
                                      lApplicationsT=lAllowTraverseApplications,
                                      lNewFolderButton=lAllowNewFolderButton,
                                      lOptionsButton=lAllowOptionsButton)

            jfc.setDialogTitle(fileChooser_title)
            jfc.setMultiSelectionEnabled(fileChooser_multiMode)

            if fileChooser_selectFiles:
                jfc.setFileSelectionMode(JFileChooser.FILES_ONLY)         # FILES_ONLY, DIRECTORIES_ONLY, FILES_AND_DIRECTORIES
            else:
                jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)   # FILES_ONLY, DIRECTORIES_ONLY, FILES_AND_DIRECTORIES

            if fileChooser_fileFilterText is not None and (not Platform.isOSX() or not Platform.isOSXVersionAtLeast("10.13")):
                myPrint("DB",".. Adding file filter for: %s" %(fileChooser_fileFilterText))
                jfc.setFileFilter(ExtFileFilterJFC(fileChooser_fileFilterText))

            if fileChooser_OK_text is not None:
                returnValue = jfc.showDialog(fileChooser_parent, fileChooser_OK_text)
            else:
                if fileChooser_open:
                    returnValue = jfc.showOpenDialog(fileChooser_parent)
                else:
                    returnValue = jfc.showSaveDialog(fileChooser_parent)

            if returnValue == JFileChooser.CANCEL_OPTION \
                    or (jfc.getSelectedFile() is None or jfc.getSelectedFile().getName()==""):
                myPrint("DB","JFileChooser was cancelled by user, or no file was selected...")
                return None

            _theFile = jfc.getSelectedFile().getAbsolutePath()
            myPrint("DB","JFileChooser returned File/path..: %s" %(_theFile))

        myPrint("DB","...File/path exists..: %s" %(os.path.exists(_theFile)))
        return _theFile

    class RequestFocusListener(AncestorListener):
        """Add this Listener to a JTextField by using .addAncestorListener(RequestFocusListener()) before calling JOptionPane.showOptionDialog()"""

        def __init__(self, removeListener=True):
            self.removeListener = removeListener

        def ancestorAdded(self, e):
            component = e.getComponent()
            component.requestFocusInWindow()
            component.selectAll()
            if (self.removeListener): component.removeAncestorListener(self)

        def ancestorMoved(self, e): pass
        def ancestorRemoved(self, e): pass

    class SearchAction(AbstractAction):

        def __init__(self, theFrame, searchJText):
            self.theFrame = theFrame
            self.searchJText = searchJText
            self.lastSearch = ""
            self.lastPosn = -1
            self.previousEndPosn = -1
            self.lastDirection = 0

        def actionPerformed(self, event):
            myPrint("D","in SearchAction(), Event: ", event)

            p = JPanel(FlowLayout())
            lbl = JLabel("Enter the search text:")
            tf = JTextField(self.lastSearch,20)
            p.add(lbl)
            p.add(tf)

            tf.addAncestorListener(RequestFocusListener())

            _search_options = [ "Next", "Previous", "Cancel" ]

            defaultDirection = _search_options[self.lastDirection]

            response = JOptionPane.showOptionDialog(self.theFrame,
                                                    p,
                                                    "Search for text",
                                                    JOptionPane.OK_CANCEL_OPTION,
                                                    JOptionPane.QUESTION_MESSAGE,
                                                    None,
                                                    _search_options,
                                                    defaultDirection)

            lSwitch = False
            if (response == 0 or response == 1):
                if response != self.lastDirection: lSwitch = True
                self.lastDirection = response
                searchWhat = tf.getText()
            else:
                searchWhat = None

            del p, lbl, tf, _search_options

            if not searchWhat or searchWhat == "": return

            theText = self.searchJText.getText().lower()
            highlighter = self.searchJText.getHighlighter()
            highlighter.removeAllHighlights()

            startPos = 0

            if response == 0:
                direction = "[forwards]"
                if searchWhat == self.lastSearch:
                    startPos = self.lastPosn
                    if lSwitch: startPos=startPos+len(searchWhat)+1
                self.lastSearch = searchWhat

                # if startPos+len(searchWhat) >= len(theText):
                #     startPos = 0
                #
                pos = theText.find(searchWhat.lower(),startPos)     # noqa
                myPrint("DB", "Search %s Pos: %s, searchWhat: '%s', startPos: %s, endPos: %s" %(direction, pos, searchWhat,startPos, -1))

            else:
                direction = "[backwards]"
                endPos = len(theText)-1

                if searchWhat == self.lastSearch:
                    if self.previousEndPosn < 0: self.previousEndPosn = len(theText)-1
                    endPos = max(0,self.previousEndPosn)
                    if lSwitch: endPos = max(0,self.lastPosn-1)

                self.lastSearch = searchWhat

                pos = theText.rfind(searchWhat.lower(),startPos,endPos)     # noqa
                myPrint("DB", "Search %s Pos: %s, searchWhat: '%s', startPos: %s, endPos: %s" %(direction, pos, searchWhat,startPos,endPos))

            if pos >= 0:
                self.searchJText.setCaretPosition(pos)
                try:
                    highlighter.addHighlight(pos,min(pos+len(searchWhat),len(theText)),DefaultHighlighter.DefaultPainter)
                except: pass
                if response == 0:
                    self.lastPosn = pos+len(searchWhat)
                    self.previousEndPosn = len(theText)-1
                else:
                    self.lastPosn = pos-len(searchWhat)
                    self.previousEndPosn = pos-1
            else:
                self.lastPosn = 0
                self.previousEndPosn = len(theText)-1
                myPopupInformationBox(self.theFrame,"Searching %s text not found" %direction)

            return

    def saveOutputFile(_theFrame, _theTitle, _fileName, _theText):

        theTitle = "Select location to save the current displayed output... (CANCEL=ABORT)"
        copyToFile = getFileFromFileChooser(_theFrame,          # Parent frame or None
                                            get_home_dir(),     # Starting path
                                            _fileName,          # Default Filename
                                            theTitle,           # Title
                                            False,              # Multi-file selection mode
                                            False,              # True for Open/Load, False for Save
                                            True,               # True = Files, else Dirs
                                            None,               # Load/Save button text, None for defaults
                                            "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if copyToFile is None or copyToFile == "":
            return
        elif not safeStr(copyToFile).endswith(".txt"):
            myPopupInformationBox(_theFrame, "Sorry - please use a .txt file extension when saving output txt")
            return
        elif ".moneydance" in os.path.dirname(copyToFile):
            myPopupInformationBox(_theFrame, "Sorry, please choose a location outside of the Moneydance location")
            return

        if not check_file_writable(copyToFile):
            myPopupInformationBox(_theFrame, "Sorry, that file/location does not appear allowed by the operating system!?")

        toFile = copyToFile
        try:
            with open(toFile, 'w') as f: f.write(_theText)
            myPrint("B", "%s: text output copied to: %s" %(_theTitle, toFile))

            if os.path.exists(toFile):
                play_the_money_sound()
                txt = "%s: Output text saved as requested to: %s" %(_theTitle, toFile)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(_theFrame, txt)
            else:
                txt = "ERROR - failed to write output text to file: %s" %(toFile)
                myPrint("B", txt)
                myPopupInformationBox(_theFrame, txt)
        except:
            txt = "ERROR - failed to write output text to file: %s" %(toFile)
            dump_sys_error_to_md_console_and_errorlog()
            myPopupInformationBox(_theFrame, txt)

        return

    try: GlobalVars.defaultPrintFontSize = eval("MD_REF.getUI().getFonts().print.getSize()")   # Do this here as MD_REF disappears after script ends...
    except: GlobalVars.defaultPrintFontSize = 12

    ####################################################################################################################
    # PRINTING UTILITIES...: Points to MM, to Inches, to Resolution: Conversion routines etc
    _IN2MM = 25.4; _IN2CM = 2.54; _IN2PT = 72
    def pt2dpi(_pt,_resolution):    return _pt * _resolution / _IN2PT
    def mm2pt(_mm):                 return _mm * _IN2PT / _IN2MM
    def mm2mpt(_mm):                return _mm * 1000 * _IN2PT / _IN2MM
    def pt2mm(_pt):                 return round(_pt * _IN2MM / _IN2PT, 1)
    def mm2in(_mm):                 return _mm / _IN2MM
    def in2mm(_in):                 return _in * _IN2MM
    def in2mpt(_in):                return _in * _IN2PT * 1000
    def in2pt(_in):                 return _in * _IN2PT
    def mpt2in(_mpt):               return _mpt / _IN2PT / 1000
    def mm2px(_mm, _resolution):    return mm2in(_mm) * _resolution
    def mpt2px(_mpt, _resolution):  return mpt2in(_mpt) * _resolution

    def printDeducePrintableWidth(_thePageFormat, _pAttrs):

        _BUFFER_PCT = 0.95

        myPrint("DB", "PageFormat after user dialog: Portrait=%s Landscape=%s W: %sMM(%spts) H: %sMM(%spts) Paper: %s Paper W: %sMM(%spts) H: %sMM(%spts)"
                %(_thePageFormat.getOrientation()==_thePageFormat.PORTRAIT, _thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE,
                  pt2mm(_thePageFormat.getWidth()),_thePageFormat.getWidth(), pt2mm(_thePageFormat.getHeight()),_thePageFormat.getHeight(),
                  _thePageFormat.getPaper(),
                  pt2mm(_thePageFormat.getPaper().getWidth()), _thePageFormat.getPaper().getWidth(), pt2mm(_thePageFormat.getPaper().getHeight()), _thePageFormat.getPaper().getHeight()))

        if _pAttrs.get(attribute.standard.MediaSizeName):
            myPrint("DB", "Requested Media: %s" %(_pAttrs.get(attribute.standard.MediaSizeName)))

        if not _pAttrs.get(attribute.standard.MediaPrintableArea):
            raise Exception("ERROR: MediaPrintableArea not present in pAttrs!?")

        mediaPA = _pAttrs.get(attribute.standard.MediaPrintableArea)
        myPrint("DB", "MediaPrintableArea settings from Printer Attributes..: w%sMM h%sMM MediaPrintableArea: %s, getPrintableArea: %s "
                % (mediaPA.getWidth(attribute.standard.MediaPrintableArea.MM),
                   mediaPA.getHeight(attribute.standard.MediaPrintableArea.MM),
                   mediaPA, mediaPA.getPrintableArea(attribute.standard.MediaPrintableArea.MM)))

        if (_thePageFormat.getOrientation()==_thePageFormat.PORTRAIT):
            deducedWidthMM = mediaPA.getWidth(attribute.standard.MediaPrintableArea.MM)
        elif (_thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE):
            deducedWidthMM = mediaPA.getHeight(attribute.standard.MediaPrintableArea.MM)
        else:
            raise Exception("ERROR: thePageFormat.getOrientation() was not PORTRAIT or LANDSCAPE!?")

        myPrint("DB","Paper Orientation: %s" %("LANDSCAPE" if _thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE else "PORTRAIT"))

        _maxPaperWidthPTS = mm2px(deducedWidthMM, GlobalVars.defaultDPI)
        _maxPaperWidthPTS_buff = _maxPaperWidthPTS * _BUFFER_PCT

        myPrint("DB", "MediaPrintableArea: deduced printable width: %sMM(%sPTS) (using factor of *%s = %sPTS)" %(round(deducedWidthMM,1), round(_maxPaperWidthPTS,1), _BUFFER_PCT, _maxPaperWidthPTS_buff))
        return deducedWidthMM, _maxPaperWidthPTS, _maxPaperWidthPTS_buff

    def loadDefaultPrinterAttributes(_pAttrs=None):

        if _pAttrs is None:
            _pAttrs = attribute.HashPrintRequestAttributeSet()
        else:
            _pAttrs.clear()

        # Refer: https://docs.oracle.com/javase/7/docs/api/javax/print/attribute/standard/package-summary.html
        _pAttrs.add(attribute.standard.DialogTypeSelection.NATIVE)
        if GlobalVars.defaultPrintLandscape:
            _pAttrs.add(attribute.standard.OrientationRequested.LANDSCAPE)
        else:
            _pAttrs.add(attribute.standard.OrientationRequested.PORTRAIT)
        _pAttrs.add(attribute.standard.Chromaticity.MONOCHROME)
        _pAttrs.add(attribute.standard.JobSheets.NONE)
        _pAttrs.add(attribute.standard.Copies(1))
        _pAttrs.add(attribute.standard.PrintQuality.NORMAL)

        return _pAttrs

    def printOutputFile(_callingClass=None, _theTitle=None, _theJText=None, _theString=None):

        # Possible future modification, leverage MDPrinter, and it's classes / methods to save/load preferences and create printers
        try:
            if _theJText is None and _theString is None: return
            if _theJText is not None and len(_theJText.getText()) < 1: return
            if _theString is not None and len(_theString) < 1: return

            # Make a new one for printing
            if _theJText is not None:
                printJTextArea = JTextArea(_theJText.getText())
            else:
                printJTextArea = JTextArea(_theString)

            printJTextArea.setEditable(False)
            printJTextArea.setLineWrap(True)    # As we are reducing the font size so that the width fits the page width, this forces any remainder to wrap
            # if _callingClass is not None: printJTextArea.setLineWrap(_callingClass.lWrapText)  # Mirror the word wrap set by user
            printJTextArea.setWrapStyleWord(False)
            printJTextArea.setOpaque(False); printJTextArea.setBackground(Color(0,0,0,0)); printJTextArea.setForeground(Color.BLACK)
            printJTextArea.setBorder(EmptyBorder(0, 0, 0, 0))

            # IntelliJ doesnt like the use of 'print' (as it's a keyword)
            try:
                if "MD_REF" in globals():
                    usePrintFontSize = eval("MD_REF.getUI().getFonts().print.getSize()")
                elif "moneydance" in globals():
                    usePrintFontSize = eval("moneydance.getUI().getFonts().print.getSize()")
                else:
                    usePrintFontSize = GlobalVars.defaultPrintFontSize  # Just in case cleanup_references() has tidied up once script ended
            except:
                usePrintFontSize = 12   # Font print did not exist before build 3036

            theFontToUse = getMonoFont()       # Need Monospaced font, but with the font set in MD preferences for print
            theFontToUse = theFontToUse.deriveFont(float(usePrintFontSize))
            printJTextArea.setFont(theFontToUse)

            def computeFontSize(_theComponent, _maxPaperWidth, _dpi):

                # Auto shrink font so that text fits on one line when printing
                # Note: Java seems to operate it's maths at 72DPI (so must factor that into the maths)
                try:
                    _DEFAULT_MIN_WIDTH = mm2px(100, _dpi)   # 100MM
                    _minFontSize = 5                        # Below 5 too small
                    theString = _theComponent.getText()
                    _startingComponentFont = _theComponent.getFont()

                    if not theString or len(theString) < 1: return -1

                    fm = _theComponent.getFontMetrics(_startingComponentFont)
                    _maxFontSize = curFontSize = _startingComponentFont.getSize()   # Max out at the MD default for print font size saved in preferences
                    myPrint("DB","Print - starting font:", _startingComponentFont)
                    myPrint("DB","... calculating.... The starting/max font size is:", curFontSize)

                    maxLineWidthInFile = _DEFAULT_MIN_WIDTH
                    longestLine = ""
                    for line in theString.split("\n"):              # Look for the widest line adjusted for font style
                        _w = pt2dpi(fm.stringWidth(line), _dpi)
                        # myPrint("DB", "Found line (len: %s):" %(len(line)), line)
                        # myPrint("DB", "...calculated length metrics: %s/%sPTS (%sMM)" %(fm.stringWidth(line), _w, pt2mm(_w)))
                        if _w > maxLineWidthInFile:
                            longestLine = line
                            maxLineWidthInFile = _w
                    myPrint("DB","longest line width %s chars; maxLineWidthInFile now: %sPTS (%sMM)" %(len(longestLine),maxLineWidthInFile, pt2mm(maxLineWidthInFile)))

                    # Now shrink the font size to fit.....
                    while (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi) > _maxPaperWidth):
                        myPrint("DB","At font size: %s; (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi):" %(curFontSize), (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), pt2mm(pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), "MM", " >> max width:", _maxPaperWidth)
                        curFontSize -= 1
                        fm = _theComponent.getFontMetrics(Font(_startingComponentFont.getName(), _startingComponentFont.getStyle(), curFontSize))
                        myPrint("DB","... next will be: at font size: %s; (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi):" %(curFontSize), (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), pt2mm(pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), "MM")

                        myPrint("DB","... calculating.... length of line still too long... reducing font size to:", curFontSize)
                        if curFontSize < _minFontSize:
                            myPrint("DB","... calculating... Next font size is too small... exiting the reduction loop...")
                            break

                    if not Platform.isMac():
                        curFontSize -= 1   # For some reason, sometimes on Linux/Windows still too big....
                        myPrint("DB","..knocking 1 off font size for good luck...! Now: %s" %(curFontSize))

                    # Code to increase width....
                    # while (pt2dpi(fm.stringWidth(theString) + 5,_dpi) < _maxPaperWidth):
                    #     curSize += 1
                    #     fm = _theComponent.getFontMetrics(Font(_startingComponentFont.getName(), _startingComponentFont.getStyle(), curSize))

                    curFontSize = max(_minFontSize, curFontSize); curFontSize = min(_maxFontSize, curFontSize)
                    myPrint("DB","... calculating.... Adjusted final font size to:", curFontSize)

                except:
                    myPrint("B", "ERROR: computeFontSize() crashed?"); dump_sys_error_to_md_console_and_errorlog()
                    return -1
                return curFontSize

            myPrint("DB", "Creating new PrinterJob...")
            printer_job = PrinterJob.getPrinterJob()

            if GlobalVars.defaultPrintService is not None:
                printer_job.setPrintService(GlobalVars.defaultPrintService)
                myPrint("DB","Assigned remembered PrintService...: %s" %(printer_job.getPrintService()))

            if GlobalVars.defaultPrinterAttributes is not None:
                pAttrs = attribute.HashPrintRequestAttributeSet(GlobalVars.defaultPrinterAttributes)
            else:
                pAttrs = loadDefaultPrinterAttributes(None)

            pAttrs.remove(attribute.standard.JobName)
            pAttrs.add(attribute.standard.JobName("%s: %s" %(myModuleID.capitalize(), _theTitle), None))

            if GlobalVars.defaultDPI != 72:
                pAttrs.remove(attribute.standard.PrinterResolution)
                pAttrs.add(attribute.standard.PrinterResolution(GlobalVars.defaultDPI, GlobalVars.defaultDPI, attribute.standard.PrinterResolution.DPI))

            for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes before user dialog: %s:%s" %(atr.getName(), atr))

            if not printer_job.printDialog(pAttrs):
                myPrint("DB","User aborted the Print Dialog setup screen, so exiting...")
                return

            selectedPrintService = printer_job.getPrintService()
            myPrint("DB", "User selected print service:", selectedPrintService)

            thePageFormat = printer_job.getPageFormat(pAttrs)

            # .setPrintable() seems to modify pAttrs & adds MediaPrintableArea. Do this before printDeducePrintableWidth()
            header = MessageFormat(_theTitle)
            footer = MessageFormat("- page {0} -")
            printer_job.setPrintable(printJTextArea.getPrintable(header, footer), thePageFormat)    # Yes - we do this twice

            for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes **AFTER** user dialog (and setPrintable): %s:%s" %(atr.getName(), atr))

            deducedWidthMM, maxPaperWidthPTS, maxPaperWidthPTS_buff = printDeducePrintableWidth(thePageFormat, pAttrs)

            if _callingClass is None or not _callingClass.lWrapText:

                newFontSize = computeFontSize(printJTextArea, int(maxPaperWidthPTS), GlobalVars.defaultDPI)

                if newFontSize > 0:
                    theFontToUse = theFontToUse.deriveFont(float(newFontSize))
                    printJTextArea.setFont(theFontToUse)

            # avoiding Intellij errors
            # eval("printJTextArea.print(header, footer, False, selectedPrintService, pAttrs, True)")  # If you do this, then native features like print to PDF will get ignored - so print via PrinterJob

            # Yup - calling .setPrintable() twice - before and after .computeFontSize()
            printer_job.setPrintable(printJTextArea.getPrintable(header, footer), thePageFormat)
            eval("printer_job.print(pAttrs)")

            del printJTextArea

            myPrint("DB", "Saving current print service:", printer_job.getPrintService())
            GlobalVars.defaultPrinterAttributes = attribute.HashPrintRequestAttributeSet(pAttrs)
            GlobalVars.defaultPrintService = printer_job.getPrintService()

        except:
            myPrint("B", "ERROR in printing routines.....:"); dump_sys_error_to_md_console_and_errorlog()
        return

    def pageSetup():

        myPrint("DB","Printer Page setup routines..:")

        myPrint("DB", 'NOTE: A4        210mm x 297mm	8.3" x 11.7"	Points: w595 x h842')
        myPrint("DB", 'NOTE: Letter    216mm x 279mm	8.5" x 11.0"	Points: w612 x h791')

        pj = PrinterJob.getPrinterJob()

        # Note: PrintService is not used/remembered/set by .pageDialog

        if GlobalVars.defaultPrinterAttributes is not None:
            pAttrs = attribute.HashPrintRequestAttributeSet(GlobalVars.defaultPrinterAttributes)
        else:
            pAttrs = loadDefaultPrinterAttributes(None)

        for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes before Page Setup: %s:%s" %(atr.getName(), atr))

        if not pj.pageDialog(pAttrs):
            myPrint("DB", "User cancelled Page Setup - exiting...")
            return

        for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes **AFTER** Page Setup: %s:%s" %(atr.getName(), atr))

        if debug: printDeducePrintableWidth(pj.getPageFormat(pAttrs), pAttrs)

        myPrint("DB", "Printer selected: %s" %(pj.getPrintService()))

        GlobalVars.defaultPrinterAttributes = attribute.HashPrintRequestAttributeSet(pAttrs)
        myPrint("DB", "Printer Attributes saved....")

        return

    class SetupMDColors:

        OPAQUE = None
        FOREGROUND = None
        FOREGROUND_REVERSED = None
        BACKGROUND = None
        BACKGROUND_REVERSED = None

        def __init__(self): raise Exception("ERROR - Should not create instance of this class!")

        @staticmethod
        def updateUI():
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

            SetupMDColors.OPAQUE = False

            SetupMDColors.FOREGROUND = GlobalVars.CONTEXT.getUI().getColors().defaultTextForeground
            SetupMDColors.FOREGROUND_REVERSED = SetupMDColors.FOREGROUND

            SetupMDColors.BACKGROUND = GlobalVars.CONTEXT.getUI().getColors().defaultBackground
            SetupMDColors.BACKGROUND_REVERSED = SetupMDColors.BACKGROUND

            if ((not isMDThemeVAQua() and not isMDThemeDark() and isMacDarkModeDetected())
                    or (not isMacDarkModeDetected() and isMDThemeDarcula())):
                SetupMDColors.FOREGROUND_REVERSED = GlobalVars.CONTEXT.getUI().colors.defaultBackground
                SetupMDColors.BACKGROUND_REVERSED = GlobalVars.CONTEXT.getUI().colors.defaultTextForeground

    class QuickJFrame():

        def __init__(self, title, output, lAlertLevel=0, copyToClipboard=False, lJumpToEnd=False, lWrapText=True, lQuitMDAfterClose=False):
            self.title = title
            self.output = output
            self.lAlertLevel = lAlertLevel
            self.returnFrame = None
            self.copyToClipboard = copyToClipboard
            self.lJumpToEnd = lJumpToEnd
            self.lWrapText = lWrapText
            self.lQuitMDAfterClose = lQuitMDAfterClose
            if Platform.isOSX() and int(float(MD_REF.getBuild())) >= 3039: self.lAlertLevel = 0    # Colors don't work on Mac since VAQua
            if isMDThemeDark() or isMacDarkModeDetected(): self.lAlertLevel = 0

        class QJFWindowListener(WindowAdapter):

            def __init__(self, theFrame, lQuitMDAfterClose=False):
                self.theFrame = theFrame
                self.lQuitMDAfterClose = lQuitMDAfterClose
                self.saveMD_REF = MD_REF

            def windowClosing(self, WindowEvent):                                                                       # noqa
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                myPrint("DB", "QuickJFrame() Frame shutting down.... Calling .dispose()")
                self.theFrame.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

            def windowClosed(self, WindowEvent):                                                                       # noqa
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))

                if self.lQuitMDAfterClose:
                    myPrint("B", "Quit MD after Close triggered... Now quitting MD")
                    self.saveMD_REF.getUI().exit()   # NOTE: This method should already detect whether MD is already shutting down.... (also, MD Shut down just kills extensions dead)
                else:
                    myPrint("DB", "FYI No Quit MD after Close triggered... So doing nothing")

        class CloseAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):
                myPrint("D","in CloseAction(), Event: ", event)
                myPrint("DB", "QuickJFrame() Frame shutting down....")

                try:
                    if not SwingUtilities.isEventDispatchThread():
                        SwingUtilities.invokeLater(GenericDisposeRunnable(self.theFrame))
                    else:
                        self.theFrame.dispose()
                except:
                    myPrint("B","Error. QuickJFrame dispose failed....?")
                    dump_sys_error_to_md_console_and_errorlog()


        class ToggleWrap(AbstractAction):

            def __init__(self, theCallingClass, theJText):
                self.theCallingClass = theCallingClass
                self.theJText = theJText

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                self.theCallingClass.lWrapText = not self.theCallingClass.lWrapText
                self.theJText.setLineWrap(self.theCallingClass.lWrapText)

        class QuickJFrameNavigate(AbstractAction):

            def __init__(self, theJText, lTop=False, lBottom=False):
                self.theJText = theJText
                self.lTop = lTop
                self.lBottom = lBottom

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if self.lBottom: self.theJText.setCaretPosition(self.theJText.getDocument().getLength())
                if self.lTop:    self.theJText.setCaretPosition(0)

        class QuickJFramePrint(AbstractAction):

            def __init__(self, theCallingClass, theJText, theTitle=""):
                self.theCallingClass = theCallingClass
                self.theJText = theJText
                self.theTitle = theTitle

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                printOutputFile(_callingClass=self.theCallingClass, _theTitle=self.theTitle, _theJText=self.theJText)

        class QuickJFramePageSetup(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                pageSetup()

        class QuickJFrameSaveTextToFile(AbstractAction):

            def __init__(self, theText, callingFrame):
                self.theText = theText
                self.callingFrame = callingFrame

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                saveOutputFile(self.callingFrame, "QUICKJFRAME", "%s_output.txt" %(myModuleID), self.theText)

        def show_the_frame(self):

            class MyQuickJFrameRunnable(Runnable):

                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                                      # noqa
                    screenSize = Toolkit.getDefaultToolkit().getScreenSize()
                    frame_width = min(screenSize.width-20, max(1024,int(round(MD_REF.getUI().firstMainFrame.getSize().width *.9,0))))
                    frame_height = min(screenSize.height-20, max(768, int(round(MD_REF.getUI().firstMainFrame.getSize().height *.9,0))))

                    # JFrame.setDefaultLookAndFeelDecorated(True)   # Note: Darcula Theme doesn't like this and seems to be OK without this statement...
                    jInternalFrame = MyJFrame(self.callingClass.title + " (%s+F to find/search for text)%s"
                                              %( MD_REF.getUI().ACCELERATOR_MASK_STR,
                                                ("" if not self.callingClass.lQuitMDAfterClose else  " >> MD WILL QUIT AFTER VIEWING THIS <<")))

                    jInternalFrame.setName(u"%s_quickjframe" %myModuleID)

                    if not Platform.isOSX(): jInternalFrame.setIconImage(MDImages.getImage(MD_REF.getUI().getMain().getSourceInformation().getIconResource()))

                    jInternalFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)
                    jInternalFrame.setResizable(True)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W,  shortcut), "close-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F,  shortcut), "search-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, shortcut),  "print-me")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")

                    theJText = JTextArea(self.callingClass.output)
                    theJText.setEditable(False)
                    theJText.setLineWrap(self.callingClass.lWrapText)
                    theJText.setWrapStyleWord(False)
                    theJText.setFont( getMonoFont() )

                    jInternalFrame.getRootPane().getActionMap().put("close-window", self.callingClass.CloseAction(jInternalFrame))
                    jInternalFrame.getRootPane().getActionMap().put("search-window", SearchAction(jInternalFrame,theJText))
                    jInternalFrame.getRootPane().getActionMap().put("print-me", self.callingClass.QuickJFramePrint(self.callingClass, theJText, self.callingClass.title))
                    jInternalFrame.addWindowListener(self.callingClass.QJFWindowListener(jInternalFrame, self.callingClass.lQuitMDAfterClose))

                    internalScrollPane = JScrollPane(theJText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)

                    if self.callingClass.lAlertLevel>=2:
                        internalScrollPane.setBackground(Color.RED)
                        theJText.setBackground(Color.RED)
                        theJText.setForeground(Color.BLACK)
                    elif self.callingClass.lAlertLevel>=1:
                        internalScrollPane.setBackground(Color.YELLOW)
                        theJText.setBackground(Color.YELLOW)
                        theJText.setForeground(Color.BLACK)

                    jInternalFrame.setPreferredSize(Dimension(frame_width, frame_height))

                    SetupMDColors.updateUI()

                    printButton = JButton("Print")
                    printButton.setToolTipText("Prints the output displayed in this window to your printer")
                    printButton.setOpaque(SetupMDColors.OPAQUE)
                    printButton.setBackground(SetupMDColors.BACKGROUND); printButton.setForeground(SetupMDColors.FOREGROUND)
                    printButton.addActionListener(self.callingClass.QuickJFramePrint(self.callingClass, theJText, self.callingClass.title))

                    if GlobalVars.defaultPrinterAttributes is None:
                        printPageSetup = JButton("Page Setup")
                        printPageSetup.setToolTipText("Printer Page Setup")
                        printPageSetup.setOpaque(SetupMDColors.OPAQUE)
                        printPageSetup.setBackground(SetupMDColors.BACKGROUND); printPageSetup.setForeground(SetupMDColors.FOREGROUND)
                        printPageSetup.addActionListener(self.callingClass.QuickJFramePageSetup())

                    saveButton = JButton("Save to file")
                    saveButton.setToolTipText("Saves the output displayed in this window to a file")
                    saveButton.setOpaque(SetupMDColors.OPAQUE)
                    saveButton.setBackground(SetupMDColors.BACKGROUND); saveButton.setForeground(SetupMDColors.FOREGROUND)
                    saveButton.addActionListener(self.callingClass.QuickJFrameSaveTextToFile(self.callingClass.output, jInternalFrame))

                    wrapOption = JCheckBox("Wrap Contents (Screen & Print)", self.callingClass.lWrapText)
                    wrapOption.addActionListener(self.callingClass.ToggleWrap(self.callingClass, theJText))
                    wrapOption.setForeground(SetupMDColors.FOREGROUND_REVERSED); wrapOption.setBackground(SetupMDColors.BACKGROUND_REVERSED)

                    topButton = JButton("Top")
                    topButton.setOpaque(SetupMDColors.OPAQUE)
                    topButton.setBackground(SetupMDColors.BACKGROUND); topButton.setForeground(SetupMDColors.FOREGROUND)
                    topButton.addActionListener(self.callingClass.QuickJFrameNavigate(theJText, lTop=True))

                    botButton = JButton("Bottom")
                    botButton.setOpaque(SetupMDColors.OPAQUE)
                    botButton.setBackground(SetupMDColors.BACKGROUND); botButton.setForeground(SetupMDColors.FOREGROUND)
                    botButton.addActionListener(self.callingClass.QuickJFrameNavigate(theJText, lBottom=True))

                    closeButton = JButton("Close")
                    closeButton.setOpaque(SetupMDColors.OPAQUE)
                    closeButton.setBackground(SetupMDColors.BACKGROUND); closeButton.setForeground(SetupMDColors.FOREGROUND)
                    closeButton.addActionListener(self.callingClass.CloseAction(jInternalFrame))

                    if Platform.isOSX():
                        save_useScreenMenuBar= System.getProperty("apple.laf.useScreenMenuBar")
                        if save_useScreenMenuBar is None or save_useScreenMenuBar == "":
                            save_useScreenMenuBar= System.getProperty("com.apple.macos.useScreenMenuBar")
                        System.setProperty("apple.laf.useScreenMenuBar", "false")
                        System.setProperty("com.apple.macos.useScreenMenuBar", "false")
                    else:
                        save_useScreenMenuBar = "true"

                    mb = JMenuBar()
                    mb.setBorder(EmptyBorder(0, 0, 0, 0))
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(topButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(botButton)
                    mb.add(Box.createHorizontalGlue())
                    mb.add(wrapOption)

                    if GlobalVars.defaultPrinterAttributes is None:
                        mb.add(Box.createRigidArea(Dimension(10, 0)))
                        mb.add(printPageSetup)                                                                          # noqa

                    mb.add(Box.createHorizontalGlue())
                    mb.add(printButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(saveButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(closeButton)
                    mb.add(Box.createRigidArea(Dimension(30, 0)))

                    jInternalFrame.setJMenuBar(mb)

                    jInternalFrame.add(internalScrollPane)

                    jInternalFrame.pack()
                    jInternalFrame.setLocationRelativeTo(None)
                    jInternalFrame.setVisible(True)

                    if Platform.isOSX():
                        System.setProperty("apple.laf.useScreenMenuBar", save_useScreenMenuBar)
                        System.setProperty("com.apple.macos.useScreenMenuBar", save_useScreenMenuBar)

                    if "errlog.txt" in self.callingClass.title or self.callingClass.lJumpToEnd:
                        theJText.setCaretPosition(theJText.getDocument().getLength())

                    try:
                        if self.callingClass.copyToClipboard:
                            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(self.callingClass.output), None)
                    except:
                        myPrint("J","Error copying contents to Clipboard")
                        dump_sys_error_to_md_console_and_errorlog()

                    self.callingClass.returnFrame = jInternalFrame

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyQuickJFrameRunnable()...")
                SwingUtilities.invokeAndWait(MyQuickJFrameRunnable(self))
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                MyQuickJFrameRunnable(self).run()

            return (self.returnFrame)

    class AboutThisScript():

        class CloseAboutAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):
                global debug
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event:", event)

                # Listener is already on the Swing EDT...
                self.theFrame.dispose()

        def __init__(self, theFrame):
            global debug, scriptExit
            self.theFrame = theFrame

        def go(self):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

            class MyAboutRunnable(Runnable):
                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                                      # noqa

                    myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
                    myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                    # noinspection PyUnresolvedReferences
                    about_d = JDialog(self.callingClass.theFrame, "About", Dialog.ModalityType.MODELESS)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
                    about_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
                    about_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    about_d.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")

                    about_d.getRootPane().getActionMap().put("close-window", self.callingClass.CloseAboutAction(about_d))

                    about_d.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)  # The CloseAction() and WindowListener() will handle dispose() - else change back to DISPOSE_ON_CLOSE

                    if (not Platform.isMac()):
                        # MD_REF.getUI().getImages()
                        about_d.setIconImage(MDImages.getImage(MD_REF.getUI().getMain().getSourceInformation().getIconResource()))

                    aboutPanel=JPanel()
                    aboutPanel.setLayout(FlowLayout(FlowLayout.LEFT))
                    aboutPanel.setPreferredSize(Dimension(1120, 525))

                    _label1 = JLabel(pad("Author: Stuart Beesley", 800))
                    _label1.setForeground(getColorBlue())
                    aboutPanel.add(_label1)

                    _label2 = JLabel(pad("StuWareSoftSystems (2020-2021)", 800))
                    _label2.setForeground(getColorBlue())
                    aboutPanel.add(_label2)

                    _label3 = JLabel(pad("Script/Extension: %s (build: %s)" %(myScriptName, version_build), 800))
                    _label3.setForeground(getColorBlue())
                    aboutPanel.add(_label3)

                    displayString=scriptExit
                    displayJText = JTextArea(displayString)
                    displayJText.setFont( getMonoFont() )
                    displayJText.setEditable(False)
                    displayJText.setLineWrap(False)
                    displayJText.setWrapStyleWord(False)
                    displayJText.setMargin(Insets(8, 8, 8, 8))

                    aboutPanel.add(displayJText)

                    about_d.add(aboutPanel)

                    about_d.pack()
                    about_d.setLocationRelativeTo(None)
                    about_d.setVisible(True)

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyAboutRunnable()...")
                SwingUtilities.invokeAndWait(MyAboutRunnable(self))
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                MyAboutRunnable(self).run()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def isGoodRate(theRate):

        if Double.isNaN(theRate) or Double.isInfinite(theRate) or theRate == 0:
            return False
        return True

    def safeInvertRate(theRate):

        if not isGoodRate(theRate):
            return theRate
        return (1.0 / theRate)

    def convertBytesMBs(_size): return round((_size/(1000.0*1000.0)),1)

    def convertBytesKBs(_size): return round((_size/(1000.0)),1)

    def getHumanReadableDateTimeFromTimeStamp(_theTimeStamp):
        return datetime.datetime.fromtimestamp(_theTimeStamp).strftime('%Y-%m-%d %H:%M:%S')

    def getHumanReadableModifiedDateTimeFromFile(_theFile):
        return getHumanReadableDateTimeFromTimeStamp(os.path.getmtime(_theFile))

    def convertStrippedIntDateFormattedText(strippedDateInt, _format=None):

        if _format is None: _format = "yyyy/MM/dd"

        convertedDate = ""
        try:
            c = Calendar.getInstance()
            dateFromInt = DateUtil.convertIntDateToLong(strippedDateInt)
            c.setTime(dateFromInt)
            dateFormatter = SimpleDateFormat(_format)
            convertedDate = dateFormatter.format(c.getTime())
        except:
            pass

        return convertedDate

    def selectHomeScreen():

        try:
            currentViewAccount = MD_REF.getUI().firstMainFrame.getSelectedAccount()
            if currentViewAccount != MD_REF.getRootAccount():
                myPrint("DB","Switched to Home Page Summary Page (from: %s)" %(currentViewAccount))
                MD_REF.getUI().firstMainFrame.selectAccount(MD_REF.getRootAccount())
        except:
            myPrint("B","@@ Error switching to Summary Page (Home Page)")

    def fireMDPreferencesUpdated():
        """This triggers MD to firePreferencesUpdated().... Hopefully refreshing Home Screen Views too"""
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        class FPSRunnable(Runnable):
            def __init__(self): pass

            def run(self):
                myPrint("DB",".. Inside FPSRunnable() - calling firePreferencesUpdated()...")
                myPrint("B","Triggering an update to the Summary/Home Page View")
                MD_REF.getPreferences().firePreferencesUpdated()

        if not SwingUtilities.isEventDispatchThread():
            myPrint("DB",".. Not running within the EDT so calling via FPSRunnable()...")
            SwingUtilities.invokeLater(FPSRunnable())
        else:
            myPrint("DB",".. Already running within the EDT so calling FPSRunnable() naked...")
            FPSRunnable().run()
        return

    # END COMMON DEFINITIONS ###############################################################################################
    # END COMMON DEFINITIONS ###############################################################################################
    # END COMMON DEFINITIONS ###############################################################################################
    # COPY >> END

    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    def load_StuWareSoftSystems_parameters_into_memory():
        global debug, myParameters, lPickle_version_warning, version_build

        # >>> THESE ARE THIS SCRIPT's PARAMETERS TO LOAD
        global __TOOLBOX, lCopyAllToClipBoard_TB, lGeekOutModeEnabled_TB, lIgnoreOutdatedExtensions_TB, lAutoPruneInternalBackups_TB

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )
        myPrint("DB", "Loading variables into memory...")

        if myParameters is None: myParameters = {}

        if myParameters.get("__TOOLBOX") is not None: __TOOLBOX = myParameters.get("__TOOLBOX")
        if myParameters.get("lCopyAllToClipBoard_TB") is not None: lCopyAllToClipBoard_TB = myParameters.get("lCopyAllToClipBoard_TB")
        if myParameters.get("lGeekOutModeEnabled_TB") is not None: lGeekOutModeEnabled_TB = myParameters.get("lGeekOutModeEnabled_TB")
        if myParameters.get("lIgnoreOutdatedExtensions_TB") is not None: lIgnoreOutdatedExtensions_TB = myParameters.get("lIgnoreOutdatedExtensions_TB")
        if myParameters.get("lAutoPruneInternalBackups_TB") is not None: lAutoPruneInternalBackups_TB = myParameters.get("lAutoPruneInternalBackups_TB")

        myPrint("DB","myParameters{} set into memory (as variables).....")

        return

    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    def dump_StuWareSoftSystems_parameters_from_memory():
        global debug, myParameters, lPickle_version_warning, version_build

        # >>> THESE ARE THIS SCRIPT's PARAMETERS TO SAVE
        global __TOOLBOX, lCopyAllToClipBoard_TB, lGeekOutModeEnabled_TB, lIgnoreOutdatedExtensions_TB, lAutoPruneInternalBackups_TB

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        # NOTE: Parameters were loaded earlier on... Preserve existing, and update any used ones...
        # (i.e. other StuWareSoftSystems programs might be sharing the same file)

        if myParameters is None: myParameters = {}

        myParameters["__TOOLBOX"] = version_build
        myParameters["lCopyAllToClipBoard_TB"] = lCopyAllToClipBoard_TB
        myParameters["lGeekOutModeEnabled_TB"] = lGeekOutModeEnabled_TB
        myParameters["lIgnoreOutdatedExtensions_TB"] = lIgnoreOutdatedExtensions_TB
        myParameters["lAutoPruneInternalBackups_TB"] = lAutoPruneInternalBackups_TB

        myPrint("DB","variables dumped from memory back into myParameters{}.....")

        return

    get_StuWareSoftSystems_parameters_from_file()

    # clear up any old left-overs....
    destroyOldFrames(myModuleID)

    myPrint("DB", "DEBUG IS ON..")

    if SwingUtilities.isEventDispatchThread():
        myPrint("DB", "FYI - This script/extension is currently running within the Swing Event Dispatch Thread (EDT)")
    else:
        myPrint("DB", "FYI - This script/extension is NOT currently running within the Swing Event Dispatch Thread (EDT)")

    def cleanup_actions(theFrame=None):
        myPrint("DB", "In", inspect.currentframe().f_code.co_name, "()")
        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

        if theFrame is not None and not theFrame.isActiveInMoneydance:
            destroyOldFrames(myModuleID)

        try:
            MD_REF.getUI().setStatus(">> Infinite Kind (co-authored by Stuart Beesley: StuWareSoftSystems) - Thanks for using Toolbox.......",0)
        except:
            pass  # If this fails, then MD is probably shutting down.......

        if not i_am_an_extension_so_run_headless: print(scriptExit)

        cleanup_references()

    GlobalVars.defaultPrintLandscape = True
    # END ALL CODE COPY HERE ###############################################################################################
    # END ALL CODE COPY HERE ###############################################################################################
    # END ALL CODE COPY HERE ###############################################################################################

    # Prevent usage later on... We use MD_REF
    del moneydance

    class MyJScrollPaneForJOptionPane(JScrollPane):               # Allows a scrollable menu in JOptionPane
        def __init__(self, _component, _max_w=800, _max_h=600):
            super(JScrollPane, self).__init__(_component)
            self.maxWidth = _max_w
            self.maxHeight = _max_h
            self.borders = 90
            self.screenSize = Toolkit.getDefaultToolkit().getScreenSize()

        def getPreferredSize(self):
            frame_width = int(round((toolbox_frame_.getSize().width - self.borders) *.9,0))
            frame_height = int(round((toolbox_frame_.getSize().height - self.borders) *.9,0))
            return Dimension(min(self.maxWidth, frame_width), min(self.maxHeight, frame_height))

    def getTheSetting(what, _padLength=0):
        _x = MD_REF.getPreferences().getSetting(what, None)
        if not _x or _x == u"": return None
        if _padLength < 1: return u"%s: %s" %(what, _x)
        return u"%s%s" %(pad("%s:" %(what),_padLength), _x)

    def isPreviewBuild():
        if MD_EXTENSION_LOADER is not None:
            try:
                stream = MD_EXTENSION_LOADER.getResourceAsStream("/_PREVIEW_BUILD_")
                if stream is not None:
                    myPrint("B", "@@ PREVIEW BUILD (%s) DETECTED @@" %(version_build))
                    stream.close()
                    return True
            except: pass
        return False

    def isToolboxUnlocked(): return GlobalVars.TOOLBOX_UNLOCK

    def isMDPlusEnabledBuild(): return (float(MD_REF.getBuild()) >= MD_MDPLUS_BUILD)

    if isMDPlusEnabledBuild():
        # from com.moneydance.apps.md.controller import MDPlus
        # from com.moneydance.apps.md.controller.olb.plaid import PlaidConnection
        from com.infinitekind.moneydance.model import OnlineServiceLink

    def  getMDPlusLicenseInfoForBook():
        _licenseObject = MD_REF.getCurrentAccountBook().getItemForID("tik.mdplus-license")	    # type: MoneydanceSyncableItem
        return _licenseObject

    def isMDPlusLicenseActivated():
        if isMDPlusEnabledBuild():
            _licenseObject = getMDPlusLicenseInfoForBook()
            if _licenseObject is not None:
                mdplus_email = _licenseObject.getParameter("mdplus.account_email", None)
                mdplus_signup_status = _licenseObject.getParameter("signup_status", None)

                # noinspection PyUnresolvedReferences
                if (mdplus_email and len(mdplus_email) > 0
                        and mdplus_signup_status and mdplus_signup_status.lower() == "activated"):
                    return True
        return False

    def calculateMoneydanceDatasetSize(_lReturnMBs=False):
        """Calculates and returns the size of the Moneydance dataset in bytes (or MBs when _lReturnMBs=True), and file count"""

        total_size_MBs = 0.0
        count_files = total_size = 0

        try:
            startDir = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

            for path, dirs, files in os.walk(startDir):
                for f in files:
                    fp = os.path.join(path, f)
                    count_files += 1
                    total_size += os.path.getsize(fp)

            if total_size > 0: total_size_MBs = convertBytesMBs(total_size)

        except:
            myPrint("B", "ERROR: Crashed whilst calculating dataset size?!")
            dump_sys_error_to_md_console_and_errorlog()
            return (0.0,0)

        myPrint("DB", "Calculated dataset size as %s bytes, %sMBs (containing: %s files)" %(total_size, total_size_MBs, count_files))

        if _lReturnMBs: return (total_size_MBs, count_files)
        return (total_size, count_files)

    def removeEmptyDirs(_pathToSearch):
        """Given a valid path, this method searches for and then removes all empty sub-directories"""

        # Failsafe checks....
        if not isinstance(_pathToSearch, (unicode, str)):   return False
        if _pathToSearch is None:                           return False
        if not os.path.exists(_pathToSearch):               return False
        if not os.path.isdir(_pathToSearch):                return False
        if len(_pathToSearch) < len(".moneydance"):         return False

        lOK = True
        countDeleted = 0
        storeEmptyDirs = []
        try:
            for root, dirs, files in os.walk(_pathToSearch, topdown=False):
                for name in dirs:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp): continue
                    if not os.path.isdir(fp): continue
                    if len(os.listdir(fp)) < 1: storeEmptyDirs.append(fp)

            myPrint("DB", "removeEmptyDirs(%s) Found %s empty directories" %(_pathToSearch, len(storeEmptyDirs)))
            for f in storeEmptyDirs:
                try:
                    os.removedirs(f)    # This actually deletes up the tree until a non empty dir is found..... (I hope..)
                    myPrint("DB", ".. removed structure for: %s" %(f))
                    countDeleted += 1
                except:
                    lOK = False
                    myPrint("B", ".. ERROR removing structure for: %s" %(f))
        except:
            lOK = False
            myPrint("B","ERROR: removeEmptyDirs(%s) crashed" %(_pathToSearch))
            dump_sys_error_to_md_console_and_errorlog()

        if not lOK: myPrint("B","ERROR: 1 or more directory structures could not be removed...")
        myPrint("B","%s: %s directory structures sucessfully deleted" %(_pathToSearch, countDeleted))
        return lOK

    def is_file_older_than_x_days(_file, _days=1):
        file_time = os.path.getmtime(_file) 	# Check against 24 hours
        if ((time.time() - file_time) / 3600) > (24 * _days):
            return True
        return False

    # noinspection PyBroadException
    def downloadStuWareSoftSystemsExtensions( what ):
        global i_am_an_extension_so_run_headless, debug

        myPrint("B","#########################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to the master Toolbox code repository to check if an updated version is available - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","#########################################################################################################################################################")

        dictInfo = StreamTable()

        inx = None
        theDict = "https://raw.githubusercontent.com/yogi1967/MoneydancePythonScripts/master/source/%s/meta_info.dict" %what

        try:
            myPrint("DB","About to open url: %s" %theDict)
            urlDict = URL(theDict)
            inx = BufferedReader(InputStreamReader(urlDict.openStream(), "UTF8"))
            dictInfo.readFrom(inx)
        except:
            myPrint("J","")
            myPrint("B", "ERROR downloading meta-info.dict from GitHub... ")
            if debug: dump_sys_error_to_md_console_and_errorlog()
            return False

        finally:
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing URL stream (%s)" %theDict)
                    dump_sys_error_to_md_console_and_errorlog()

        return dictInfo

    class DetectAndChangeMacTabbingMode(AbstractAction):

        def __init__(self, lQuickCheckOnly):
            self.lQuickCheckOnly = lQuickCheckOnly

        def actionPerformed(self, event):
            global toolbox_frame_, debug

            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            if not Platform.isOSX():
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - This can only be run on a Mac!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not Platform.isOSXVersionAtLeast("10.16"):
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - You are not running Big Sur - no changes made!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if (float(MD_REF.getBuild()) > 1929 and float(MD_REF.getBuild()) < 2008):                                         # noqa
                txt = "You are running 2021.build %s - This version has problems with DUAL MONITORS - Upgrade to at least 2021. build 2012: https://infinitekind.com/preview" %(MD_REF.getBuild())
                setDisplayStatus(txt, "R")
                txt = "Change Mac Tabbing Mode - You are running 2021.build %s - This version has problems with DUAL MONITORS\nPlease upgrade to at least 2021. build 2012:\nhttps://infinitekind.com/preview" %(MD_REF.getBuild())
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            prefFile = os.path.join(System.getProperty("UserHome", "Library/Preferences/.GlobalPreferences.plist"))
            if not os.path.exists(prefFile):
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - Sorry - For some reason I could not find: %s - no changes made!" %(prefFile)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            try:
                tabbingMode = subprocess.check_output("defaults read -g AppleWindowTabbingMode", shell=True)
            except:
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - Sorry - error getting your Tabbing mode! - no changes made!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                dump_sys_error_to_md_console_and_errorlog()
                return

            tabbingMode=tabbingMode.strip().lower()
            if not (tabbingMode == "fullscreen" or tabbingMode == "manual" or tabbingMode == "always"):
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - Sorry - I don't understand your tabbing mode: %s - no changes made!" %(tabbingMode)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if tabbingMode == "fullscreen" or tabbingMode == "manual":
                if self.lQuickCheckOnly:
                    myPrint("J","Quick check of MacOS tabbing showed it's OK and set to: %s" %tabbingMode)
                    return True
                txt = "Change Mac Tabbing Mode - NO PROBLEM FOUND - Your tabbing mode is: %s - no changes made!" %(tabbingMode)
                setDisplayStatus(txt, "B")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt)
                return

            if self.lQuickCheckOnly:
                myPrint("J","Quick check of MacOS tabbing showed it's NEEDS CHANGING >> It's set to: %s" %tabbingMode)
                return False

            myPrint("B","More information here: https://support.apple.com/en-gb/guide/mac-help/mchla4695cce/mac")

            myPrint("B", "@@@ PROBLEM - Your Tabbing Mode is set to: %s - NEEDS CHANGING" %tabbingMode)
            myPopupInformationBox(toolbox_frame_,"@@@ PROBLEM - Your Tabbing Mode is set to: %s\nTHIS NEEDS CHANGING!" %tabbingMode,theMessageType=JOptionPane.ERROR_MESSAGE)
            myPopupInformationBox(toolbox_frame_,"Info:\n<https://support.apple.com/en-gb/guide/mac-help/mchla4695cce/mac>\nPress OK to select new mode...",theMessageType=JOptionPane.ERROR_MESSAGE)

            mode_options = ["fullscreen", "manual"]
            selectedMode = JOptionPane.showInputDialog(toolbox_frame_,
                                                        "TABBING MODE", "Select the new Tabbing Mode?",
                                                        JOptionPane.WARNING_MESSAGE,
                                                        MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                        mode_options,
                                                        None)
            if selectedMode is None:
                txt = "Change Mac Tabbing Mode - No new Tabbing Mode was selected - aborting.."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt)
                return

            disclaimer = myPopupAskForInput(toolbox_frame_,
                                            "TABBING MODE",
                                            "DISCLAIMER:",
                                            "Are you really sure you want to change MacOS system setting>>Tabbing Mode? Type 'IAGREE' to continue..",
                                            "NO",
                                            False,
                                            JOptionPane.ERROR_MESSAGE)

            if not disclaimer == 'IAGREE':
                txt = "Change Mac Tabbing Mode - User declined the disclaimer - no changes made...."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            try:
                tabbingModeChanged = subprocess.check_output('defaults write -g AppleWindowTabbingMode -string "%s"' %selectedMode, shell=True)
                if tabbingModeChanged.strip() != "":
                    myPrint("B", "Tabbing mode change output>>>>")
                    myPrint("B", tabbingModeChanged)
                myPrint("B","!!! Your tabbing mode has been changed to %s - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD" %selectedMode)
            except:
                txt = "Change Mac Tabbing Mode - Sorry - error setting your Tabbing mode! - no changes made!"
                myPrint("B", txt)
                dump_sys_error_to_md_console_and_errorlog()
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if tabbingModeChanged.strip() != "":
                myPopupInformationBox(toolbox_frame_,"Change Mac Tabbing Mode: Response: %s" %tabbingModeChanged, JOptionPane.WARNING_MESSAGE)

            txt = "MacOS Tabbing Mode: OK I Made the Change to your Mac Tabbing Mode: MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            MD_REF.getUI().exit()

    def find_other_datasets():
        output = ""
        output+=("\nQUICK SEARCH FOR OTHER DATASETS:\n"
                 "---------------------------------\n")

        try:
            md_extn = ".moneydance"
            md_archive = ".moneydancearchive"

            saveFiles = {}
            saveArchiveFiles = {}

            myDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

            errorDirs = []

            internalDir = Common.getDocumentsDirectory().getCanonicalPath()
            try:
                dirList =  os.listdir(internalDir)
                for fileName in dirList:
                    fullPath = os.path.join(internalDir,fileName)
                    if fileName.endswith(md_extn):
                        saveFiles[fullPath] = True
                    elif fileName.endswith(md_archive):
                        saveArchiveFiles[fullPath] = True
                del dirList
            except OSError:
                myPrint("B","@@ Error accessing internalDir: '%s' - skipping...." %(internalDir))
                errorDirs.append(internalDir)

            parentofDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getParent()
            if os.path.exists(parentofDataset):
                try:
                    dirList =  os.listdir(parentofDataset)
                    for fileName in dirList:
                        fullPath = os.path.join(parentofDataset,fileName)
                        if fileName.endswith(md_extn):
                            saveFiles[fullPath] = True
                        elif fileName.endswith(md_archive):
                            saveArchiveFiles[fullPath] = True
                    del dirList
                except OSError:
                    myPrint("B","@@ Error accessing dataset's folder: '%s' - skipping...." %(parentofDataset))
                    errorDirs.append(parentofDataset)
            del parentofDataset

            externalFiles = AccountBookUtil.getExternalAccountBooks()
            for wrapper in externalFiles:
                saveFiles[wrapper.getBook().getRootFolder().getCanonicalPath()] = True
                externalDir = wrapper.getBook().getRootFolder().getParent()
                if os.path.exists(externalDir):
                    try:
                        dirList =  os.listdir(externalDir)
                        for fileName in dirList:
                            fullPath = os.path.join(externalDir,fileName)
                            if fileName.endswith(md_extn):
                                saveFiles[fullPath] = True
                            elif fileName.endswith(md_archive):
                                saveArchiveFiles[fullPath] = True
                        del dirList
                    except OSError:
                        myPrint("B","@@ Error accessing externalDir: '%s' - skipping...." %(externalDir))
                        errorDirs.append(externalDir)

            del externalFiles

            for backupLocation in [ FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath(),
                                    MD_REF.getUI().getPreferences().getSetting("backup.location",""),
                                    MD_REF.getUI().getPreferences().getSetting("backup.last_saved",""),
                                    MD_REF.getUI().getPreferences().getSetting("backup.last_browsed","")]:
                if backupLocation is not None and backupLocation != "" and os.path.exists(backupLocation):
                    try:
                        dirList =  os.listdir(backupLocation)
                        for fileName in dirList:
                            fullPath = os.path.join(backupLocation,fileName)
                            if fileName.endswith(md_extn):
                                if saveFiles.get(fileName) is not None:
                                    saveFiles[fullPath] = True
                            elif fileName.endswith(md_archive):
                                saveArchiveFiles[fullPath] = True
                        del dirList
                    except OSError:
                        myPrint("B","@@ Error accessing backupLocationDir: '%s' - skipping...." %(backupLocation))
                        errorDirs.append(backupLocation)
            del backupLocation

            saveFiles[myDataset] = None

            listTheFiles=sorted(saveFiles.keys())
            listTheArchiveFiles=sorted(saveArchiveFiles.keys())

            for _f in listTheFiles:
                if saveFiles[_f] is not None:
                    output+=("Dataset: Mod: %s %s\n"
                             % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(_f)).strftime('%Y-%m-%d %H:%M:%S'), 11), _f))
            del listTheFiles

            output+=("\nBACKUP FILES\n"
                     "-------------\n")

            for _f in listTheArchiveFiles:
                if saveArchiveFiles[_f] is not None:
                    output+=("Archive: Mod: %s %s\n"
                             % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(_f)).strftime('%Y-%m-%d %H:%M:%S'), 11), _f))
            del listTheArchiveFiles

            output+=("\nSYNC FOLDERS FOUND:\n"
                     "---------------------\n")

            saveSyncFolder=None
            try:
                # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
                # Also, MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
                syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
                syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

                if syncMethod is not None and syncMethod.getSyncFolder() is not None:
                    # noinspection PyUnresolvedReferences
                    syncBaseFolder = syncMethod.getSyncFolder().getSyncBaseFolder()

                    saveSyncFolder = syncBaseFolder.getCanonicalPath()
                    dirList =  os.listdir(saveSyncFolder)

                    for fileName in dirList:
                        fullPath = os.path.join(saveSyncFolder,fileName)
                        if len(fileName)>32:
                            output+=("Sync Folder: %s %s\n"
                                     % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(fullPath)).strftime('%Y-%m-%d %H:%M:%S'), 11), fullPath))
                else:
                    output+=("<NONE FOUND>\n")

                del syncMethod, syncMethods
            except:
                pass

            dropboxPath = tell_me_if_dropbox_folder_exists()
            if dropboxPath and dropboxPath is not None and dropboxPath != saveSyncFolder:

                output+=("\nDROPBOX FOLDERS FOUND:\n"
                         "-----------------------\n")
                dirList =  os.listdir(dropboxPath)

                for fileName in dirList:
                    fullPath = os.path.join(dropboxPath,fileName)
                    if len(fileName)>32:
                        output+=("Dropbox Sync Folder: %s %s\n"
                                 % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(fullPath)).strftime('%Y-%m-%d %H:%M:%S'), 11), fullPath))
            del dropboxPath

            if len(errorDirs) > 0:
                output += ("\nERROR ACCESSING DIRECTORY:\n"
                           "---------------------------\n")
                for errorDir in errorDirs: output += (" @@ %s\n" %(errorDir))

            output+="\n\n(for a more extensive search please use Toolbox - Find my Datasets and Backups button\n\n"

        except:
            myPrint("B","@@ ERROR: Failed in find_other_datasets()?")
            output += dump_sys_error_to_md_console_and_errorlog(lReturnText=True)

        return output

    def count_database_objects():
        output = ""
        output+=("\nDATABASE OBJECT COUNT        (count) (est.size KBs):\n"
                 "-----------------------------------------------------\n")
        foundStrange=0
        types={}

        onlineTxns=0
        onlineTxnsCharacters=0
        onlinePayees=0
        onlinePayments=0

        for mdItem in MD_REF.getCurrentAccount().getBook().getSyncer().getSyncedDocument().allItems():
            if isinstance(mdItem, MoneydanceSyncableItem):

                if isinstance(mdItem, OnlineTxnList):
                    onlineTxns      +=mdItem.getTxnCount()
                    for olKey in mdItem.getParameterKeys():
                        onlineTxnsCharacters += len(olKey)
                        onlineTxnsCharacters += len(mdItem.getParameter(olKey))

                if isinstance(mdItem, OnlinePayeeList):     onlinePayees    +=mdItem.getPayeeCount()
                if isinstance(mdItem, OnlinePaymentList):   onlinePayments  +=mdItem.getPaymentCount()

                getTheSavedData = types.get(mdItem.getParameter("obj_type", "UNKNOWN"))
                if getTheSavedData is not None:
                    x,theLength = getTheSavedData
                else:
                    x = 0
                    theLength = 0

                theSyncInfo = mdItem.getSyncInfo()
                theDescription = theSyncInfo.toMultilineHumanReadableString()  # format is "key: data\n" but file is '&key=data'
                theLength += len( ("mod.%s:" %(mdItem.getParameter("obj_type",""))) )
                theLength += len(theDescription)
                theLength -= len(mdItem.getParameterKeys())  # remove the number of "\n"s

                types[mdItem.getParameter("obj_type", "UNKNOWN")] = [x+1, theLength]
            else:
                foundStrange+=1
        i=0
        charCount=0
        for x in types.keys():
            i+=types[x][0]
            charCount+=types[x][1]
            extraText = ""
            if x == "oltxns":
                if onlineTxns:
                    extraText = "(containing %s Online Txns consuming %s KBs)" %(onlineTxns, round(onlineTxnsCharacters/1000.0,1))
            elif x == "olpayees":
                if onlinePayees:
                    extraText = "(containing %s Online Payees)" %(onlinePayees)
            elif x == "olpmts":
                if onlinePayments:
                    extraText = "(containing %s Online Payments)" %(onlinePayments)

            output+=("Object: %s %s   %s %s\n" %(pad(x,15),rpad(types[x][0],12),rpad(round(types[x][1] / (1000.0),1),12), extraText))

        if foundStrange:
            output+=("\n@@ I also found %s non Moneydance Syncable Items?! Why? @@\n" %(foundStrange))
        output+=(" ==========\n TOTAL:                 %s   %s\n\n" %(rpad(i,12),rpad(round(charCount/(1000.0),1),12)))
        del types
        del foundStrange
        return output

    def buildDiagText():

        textArray = []                                                                                                  # noqa

        if isPreviewBuild(): textArray.append(u"*** PREVIEW BUILD (%s) DETECTED ***\n" %(version_build))

        x = getMonoFont()
        textArray.append(u"FONT USED FOR TOOLBOX OUTPUT/DISPLAY(can be changed): %s(%s)" %(x.getFontName(), x.getSize()))
        try:
            loc = MD_REF.getUI().getPreferences().getLocale()
            if loc is not None and \
                    (loc.getLanguage() in (loc.CHINESE.getLanguage(), loc.JAPANESE.getLanguage(), loc.KOREAN.getLanguage(), loc.SIMPLIFIED_CHINESE.getLanguage(), loc.TRADITIONAL_CHINESE.getLanguage())
                     or loc.getCountry() in (loc.CHINA.getCountry(), loc.JAPAN.getCountry(), loc.KOREA.getCountry(), loc.TAIWAN.getCountry()) ):
                textArray.append(u"** if Toolbox display/outputs do not show your language's double-byte characters properly, then change to a Monospaced Font that supports your character set **")
                textArray.append(u"** (Advanced Mode) General Tools, Set MD Fonts: Change 'code' Font (please only use Monospaced fonts for text alignment!) **")
        except:
            myPrint("B",u"@@ ERROR: Failed to detect MD Locale..?")
            dump_sys_error_to_md_console_and_errorlog()

        textArray.append(u"")

        textArray.append(u"Moneydance Version / Build:          %s" %(MD_REF.getVersion()) + u"  Build: %s" %(MD_REF.getBuild()))
        textArray.append(u"Moneydance Config file reports:      %s" %MD_REF.getUI().getPreferences().getSetting(u"current_version", u""))
        textArray.append(u"Moneydance updater version to track: %s" %MD_REF.getUI().getPreferences().getSetting(u"updater.version_to_track",u""))
        textArray.append(u"")

        currLicense = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2022",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2021",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2019",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2017",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2015",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2014",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2011",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2010",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2008",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2004",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key",u"?")))))))))))

        license2022 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2022", None)                               # noqa
        license2021 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2021", None)                               # noqa
        license2019 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2019", None)
        license2017 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2017", None)
        license2015 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2015", None)
        license2014 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2014", None)
        license2011 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2011", None)
        license2010 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2010", None)
        license2008 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2008", None)
        license2004 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2004", None)

        if not isMDPlusEnabledBuild():      # The start of MD+ and new licensing....
            if MD_REF.getUI().getMain().isRegistered():
                textArray.append(u"LICENSED: %s" %(currLicense))
            else:
                textArray.append(u"UNLICENSED!")

        else:
            licenseInfo = MD_REF.getLicenseInfo()
            x = pad((u"UNLICENSED:" if (not licenseInfo.isRegistered()) else u"LICENSED:"),12)
            textArray.append(u"%s%s (key version: %s, key status: %s, isUpgradeable: %s)"
                             %(x, licenseInfo.getLicenseKey(), licenseInfo.getKeyVersion(), licenseInfo.getStatus(), licenseInfo.isUpgradeable()))

            licenseInfo = getMDPlusLicenseInfoForBook()     # type: MoneydanceSyncableItem

            if licenseInfo is None:
                textArray.append(u"Moneydance+ License: NOT FOUND...")
            else:
                mdplus_email = licenseInfo.getParameter(u"mdplus.account_email", None)
                mdplus_pend_email = licenseInfo.getParameter(u"mdplus.pending_email", None)
                mdplus_signup_status = licenseInfo.getParameter(u"signup_status", None)
                mdplus_keyRegenDate = licenseInfo.getLongParameter(u"mdplus.date", 0L)
                mdplus_refreshDate = licenseInfo.getLongParameter(u"mdplus.refresh_date", 0L)
                mdplus_keypairCreated = licenseInfo.getLongParameter(u"mdplus.keypair_created", 0L)
                mdplus_privKeyHex = licenseInfo.getParameter(u"mdplus.priv", None)
                mdplus_pubKeyHex = licenseInfo.getParameter(u"mdplus.pub", None)

                if mdplus_email or mdplus_pend_email or mdplus_signup_status or mdplus_keyRegenDate or mdplus_refreshDate or mdplus_keypairCreated or mdplus_privKeyHex or mdplus_pubKeyHex:
                    textArray.append(u"")
                    textArray.append(u"Moneydance+ License information:")
                    if mdplus_email:            textArray.append(u"Email:            %s" %(mdplus_email))
                    if mdplus_email is None or mdplus_email == u"":
                        if mdplus_pend_email:       textArray.append(u"Email pending:    %s" %(mdplus_pend_email))
                    if mdplus_signup_status:    textArray.append(u"Signup status:    %s" %(mdplus_signup_status))
                    if mdplus_keyRegenDate:     textArray.append(u"MD+ date:         %s" %(get_time_stamp_as_nice_text(mdplus_keyRegenDate)))
                    if mdplus_refreshDate:      textArray.append(u"MD+ refresh date: %s" %(get_time_stamp_as_nice_text(mdplus_refreshDate)))
                    if mdplus_keypairCreated:   textArray.append(u"MD+ keypair date: %s" %(get_time_stamp_as_nice_text(mdplus_keypairCreated)))
                    if mdplus_privKeyHex:       textArray.append(u"MD+ Private Key:  %s (length: %s)" %(u"****** hidden ******", len(mdplus_privKeyHex)))
                    if mdplus_pubKeyHex:        textArray.append(u"MD+ Public Key:   %s (length: %s)" %(u"****** hidden ******", len(mdplus_pubKeyHex)))
                    textArray.append(u"")
                else:
                    textArray.append(u"Moneydance+ License: NOT FOUND...")

                del licenseInfo

        if license2021:      textArray.append(u" >old licenses (2021): " + license2021)
        if license2019:      textArray.append(u" >old licenses (2019): " + license2019)
        if license2017:      textArray.append(u" >old licenses (2017): " + license2017)
        if license2015:      textArray.append(u" >old licenses (2015): " + license2015)
        if license2014:      textArray.append(u" >old licenses (2014): " + license2014)
        if license2011:      textArray.append(u" >old licenses (2011): " + license2011)
        if license2010:      textArray.append(u" >old licenses (2010): " + license2010)
        if license2008:      textArray.append(u" >old licenses (2008): " + license2008)
        if license2004:      textArray.append(u" >old licenses (2004): " + license2004)

        if not MD_REF.getCurrentAccount().getBook(): textArray.append(u"Moneydance datafile is empty")
        x = MD_REF.getUI().getPreferences().getSetting(u"current_accountbook", None)
        y = MD_REF.getUI().getPreferences().getSetting(u"current_account_file", None)

        theExtn = os.path.splitext((MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()))

        if x:
            textArray.append(u"\n"
                             u"Current Dataset:               %s" %(x))
        if y:
            textArray.append(u"\n"
                             u"Current Dataset:               %s" %(y))

        textArray.append(u"Full location of this Dataset: %s" %(MD_REF.getCurrentAccount().getBook().getRootFolder()))

        x = find_the_program_install_dir()
        if x and Platform.isOSX() and System.getProperty(u"install4j.exeDir","") != "":     # Special 'not normal' check.... will normally never trigger
            textArray.append(u"Application Install Directory (Mac running manual launch script): %s" %(x))
        elif x:
            textArray.append(u"Application Install Directory: %s" %(x))
        else:
            textArray.append(u"UNABLE TO DETERMINE Application's Install Directory! (are you running Moneydance by manually executing the .jar file?)")


        lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
        if lDropbox:
            textArray.append(u"\n@@ WARNING: You have your dataset installed in Dropbox - This can damage your data!")
            if lSuppressed:
                textArray.append(u"@@ WARNING: You have also SUPPRESSED the warning messages - THIS IS AT YOUR OWN RISK!")
            textArray.append(u"@@ The recommendation is to move your Dataset to your local drive (out of Dropbox) and a) use MD's internal Sync feature, or b) set Dropbox as the location for MD Backups\n")

        # MD2021.2(3088) adds this capability.....
        grabEnvPassphrases = findEnvironmentPassphrases()
        if grabEnvPassphrases:
            textArray.append(u"\nENVIRONMENT PASSPHRASE(S) STORED TO BYPASS POPUP ENCRYPTION PROMPTS")
            for k, v in grabEnvPassphrases:
                textArray.append(u"Environment key: %s <Stored Passphrase: ******>"  %(k))
        del grabEnvPassphrases

        textArray.append(u"")
        x, y = calculateMoneydanceDatasetSize(True)
        textArray.append(u"Dataset size: %sMBs (%s files)\n" %(x,y))

        textArray.append(count_database_objects())

        textArray.append(u"Master Node (dataset): %s" %(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))

        textArray.append(u"\nENCRYPTION")
        x = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
        if x is None or x == u"":
            x = u"Encryption not set! - This means an internal Moneydance passphrase is being used to encrypt your dataset!".upper()
        else:
            x = u"***************"
        textArray.append(u"'Master' / Encryption Passphrase: %s" %x)

        x = u"Encryption Store Online Banking (OFX) Passwords in File: %s" %(isCachingPasswords())
        if isCachingPasswords():
            textArray.append(x+u" (This means you are able to save your online banking passwords)")
        else:
            textArray.append(x+u"\n>>You cannot save online banking passwords until you set a 'Master' (encryption) password **AND** select 'Store Online Passwords in File'\n")

        x = MD_REF.getUI().getCurrentAccounts().getEncryptionHint()
        if x is None or x == u"":
            x = u"Encryption passphrase hint not set!".upper()
        else:
            x = u"***************"
        textArray.append(u"Encryption passphrase hint: %s" %x)

        if MD_REF.getCurrentAccount().getBook().getLocalStorage().getString("md.crypto_level", None):
            x = u"Encryption level - Moneydance reports 'md.crypto_level' set as: %s" %(MD_REF.getCurrentAccount().getBook().getLocalStorage().getString("md.crypto_level", None))
            textArray.append(x)

        x = u"Toolbox's actual 'test' of your Encryption key/passphrase reports: %s\n" %(getMDEncryptionKey())

        x += u"I understand the dataset encryption is: AES 128-bit. Passphrase encrypted using PBKDF2WithHmacSHA512 " \
             u"(fixed internal salt, high iteration) and then your (secure/random) key is encrypted and used to encrypt " \
             u"data to disk using AES/CBC/PKCS5Padding with a fixed internal IV"
        textArray.append(x)

        textArray.append(u"\nSYNC DETAILS")
        # SYNC details
        x = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()
        if x is None or x == u"":
            x = u"Sync passphrase not set!"
        else:
            x = u"***************"
        textArray.append(u"Sync Password:                 %s" %x)

        try:
            # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
            # MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            noSyncOption = SyncFolderUtil.configurerForIDFromList(u"none", syncMethods)
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)
            if syncMethod is None:
                syncMethod = noSyncOption
            else:
                syncMethod = syncMethod
            textArray.append(u"Sync Method:                   %s" %(syncMethod.getSyncFolder()))
            x = get_sync_folder()
            if x: textArray.append(u"Sync local disk base location: %s" %(x))

        except:
            textArray.append(u"Sync Method: *** YOU HAVE A PROBLEM WITH YOUR DROPBOX CONFIGURATION! ***")
            myPrint("B",u"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            myPrint("B",u"!! WARNING - You have a Dropbox configuration issue which is crashing .getSyncFolder() !!")
            myPrint("B",u"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            MyPopUpDialogBox(toolbox_frame_,
                             u"WARNING - DROPBOX ERROR",
                             u"You seem to have a Dropbox configuration issue!?\n"
                             u"(or you have launched from command line, not the code-signed app bundle)\n"
                             u"Toolbox cannot fix this for you - please review your console logs\n"
                             u"and contact the online support forum for help....\n"
                             u"(if you find a fix, please inform the Toolbox author)",
                             150,
                             u"DROPBOX ERROR",
                             lModal=False,
                             lAlertLevel=2).go()

        if not check_for_dropbox_folder():
            textArray.append(u"Sync WARNING: Dropbox sync will not work until you add the missing .moneydancesync folder - use advanced mode to fix!")

        textArray.append(u"\nTHEMES")

        try:  x = u"'%s' : %s" %(MD_REF.getUI().getCurrentTheme(),UIManager.getLookAndFeel())
        except:  x = u"failed to get Theme details"

        y = u"(DARK THEME)" if (isMDThemeDark()) else u""
        z = u"(Mac Dark Mode detected)" if (Platform.isOSX() and isMacDarkModeDetected()) else u""

        textArray.append(u"Your selected Theme: %s (%s) %s %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID), x, y, z))

        # noinspection PyUnresolvedReferences
        x = ThemeInfo.customThemeFile.getCanonicalPath()
        if not os.path.exists(x):
            x = u"custom_theme.properties file DOES NOT EXIST!"
        textArray.append(u"Custom Theme File:   %s" %(x))
        # noinspection PyUnresolvedReferences
        textArray.append(u"Available themes:    %s" %(ThemeInfo.getAllThemes()))

        textArray.append(u"\nRUNTIME ENVIRONMENT")

        textArray.append(u"Java version:                        %s"  %(System.getProperty(u"java.version")))
        textArray.append(u"Java vendor:                         %s"  %(System.getProperty(u"java.vendor")))

        textArray.append(u"Platform:                            %s %s %s.%s" %(platform.python_implementation(), platform.system(), sys.version_info.major, sys.version_info.minor))

        textArray.append(u"SandBoxed:                           %s" %(MD_REF.getPlatformHelper().isSandboxed()))
        textArray.append(u"Restricted:                          %s" %(MD_REF.getPlatformHelper().isConstrainedToSandbox()))

        if MD_REF.getExecutionMode() == MD_REF.EXEC_MODE_APP:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()) + u" = APP (Normal App)")
        elif MD_REF.getExecutionMode() == MD_REF.EXEC_MODE_APPLET:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()) + u" = APPLET (probably from an AppStore?")
        else:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()))

        textArray.append(u"MD Debug Mode:                       %s" %(MD_REF.DEBUG))
        textArray.append(u"Beta Features:                       %s" %(MD_REF.BETA_FEATURES))
        textArray.append(u"Architecture:                        %s" %(System.getProperty(u"os.arch")))

        if theExtn and theExtn[1].strip() != u"":
            textArray.append(u"File Extension:                      %s" %theExtn[1])
        else:
            textArray.append(u"File Extension:                      %s" %(MD_REF.FILE_EXTENSION))

        # NOTE: As of MD2022(4040) python.getSystemState().setdefaultencoding("utf8") is called on the python interpreter at launch...
        textArray.append(u"Operating System file encoding:      %s" %(Charset.defaultCharset()))
        textArray.append(u"File system default encoding:        %s, Python default encoding: %s (overridden from ASCII)"
                         %(sys.getfilesystemencoding(), PySystemState().getdefaultencoding()))

        try:
            # New for MD2020.2012
            x = MD_REF.getUI().getFonts().code
        except:
            myPrint("B",u"Failed to get Moneydance code font (must be older version), loading older mono")
            x = MD_REF.getUI().getFonts().mono

        textArray.append(u"Python default display font:         %s(%s)" %(x.getFontName(), x.getSize()))


        textArray.append(u"\nENVIRONMENT")

        try:
            username = System.getProperty(u"user.name")
        except:
            username = u"???"
        textArray.append(u"Username:                            %s" %username)

        textArray.append(u"OS Platform:                         %s" %System.getProperty(u"os.name") + u"OS Version: %s" %(System.getProperty(u"os.version")))

        textArray.append(u"Home Directory:                      %s" %(get_home_dir()))
        if System.getProperty(u"user.dir"): textArray.append(u"  user.dir:                          %s" %System.getProperty(u"user.dir"))
        if System.getProperty(u"UserHome"): textArray.append(u"  UserHome:                          %s" %System.getProperty(u"UserHome"))
        if os.path.expanduser(u"~"):        textArray.append(u"  ~:                                 %s" %os.path.expanduser(u"~"))
        if os.environ.get(u"HOMEPATH"):     textArray.append(u"  HOMEPATH:                          %s" %os.environ.get(u"HOMEPATH"))

        textArray.append(u"Moneydance decimal point:            %s" %MD_REF.getUI().getPreferences().getSetting(u"decimal_character", u"."))
        textArray.append(u"System Locale Decimal Point:         %s" %(getDecimalPoint(lGetPoint=True)) + u" Grouping Char: %s" %(getDecimalPoint(lGetGrouping=True)))
        if MD_REF.getUI().getPreferences().getSetting(u"decimal_character", u".") != getDecimalPoint(lGetPoint=True):
            textArray.append(u"NOTE - MD Decimal point is DIFFERENT to the Locale decimal point!!!")
        textArray.append(u"MD User set Locale Country:          %s" %(MD_REF.getUI().getPreferences().getSetting(u"locale.country", u"")))
        textArray.append(u"MD User set Locale Language:         %s" %(MD_REF.getUI().getPreferences().getSetting(u"locale.language", u"")))

        loc = Locale.getDefault(); loc_c = loc.getCountry(); loc_l = loc.getLanguage()
        # noinspection PyUnresolvedReferences
        if (loc_c.lower() != MD_REF.getUI().getPreferences().getSetting(u"locale.country", u"_unknown_").lower()) \
                or (loc_l.lower() != MD_REF.getUI().getPreferences().getSetting(u"locale.language", u"_unknown_").lower()):
            textArray.append(u"NOTE - MD User set Locale details are different to System Locale details!!!")
            textArray.append(u"(System Locale Country:              %s)" %(loc_c))
            textArray.append(u"(System Locale Language:             %s)" %(loc_l))
        del loc, loc_c, loc_l

        textArray.append(u"\nFOLDER / FILE LOCATIONS")

        textArray.append(u"MD Dataset internal top level (root) Directory: %s" %(MD_REF.getCurrentAccount().getBook().getRootFolder().getParent()))
        textArray.append(u"Auto Backup Folder:                             %s " %(FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath() ) )
        textArray.append(u"(Last backup location:                          %s)" %(MD_REF.getUI().getPreferences().getSetting(u"backup.last_saved", u"")))

        internalFiles = AccountBookUtil.getInternalAccountBooks()
        externalFiles = AccountBookUtil.getExternalAccountBooks()

        if internalFiles.size() + externalFiles.size() > 1:
            textArray.append(u"\nOther MD Datasets I am aware of...:")

        for wrapper in internalFiles:
            if MD_REF.getUI().getCurrentAccounts() is not None and MD_REF.getUI().getCurrentAccounts().getBook() == wrapper.getBook():
                pass
            else:
                textArray.append(u"Internal file:           %s" %(wrapper.getBook().getRootFolder().getCanonicalPath()))

        for wrapper in externalFiles:
            if (MD_REF.getUI().getCurrentAccounts() is not None and MD_REF.getUI().getCurrentAccounts().getBook() == wrapper.getBook()):
                pass
            else:
                textArray.append(u"External file:           %s" %(wrapper.getBook().getRootFolder().getCanonicalPath()))

        if internalFiles.size() + externalFiles.size() > 1:
            textArray.append(u"\n")

        textArray.append(u"MD System Root Directory:    %s" %(Common.getRootDirectory().getCanonicalPath()))

        textArray.append(u"MD Log file:                 %s" %(MD_REF.getLogFile().getCanonicalPath()))
        textArray.append(u"Preferences File:            %s" %(Common.getPreferencesFile().getCanonicalPath()))

        if os.path.exists((Common.getArchiveDirectory().getCanonicalPath())):
            textArray.append(u"Archive Directory:           %s" %(Common.getArchiveDirectory().getCanonicalPath()))
        if os.path.exists((Common.getFeatureModulesDirectory().getCanonicalPath())):
            textArray.append(u"Extensions Directory:        %s" %(Common.getFeatureModulesDirectory().getCanonicalPath()))
        if os.path.exists((Common.getCertificateDirectory().getCanonicalPath())):
            textArray.append(u"Certificates Directory:      %s" %(Common.getCertificateDirectory().getCanonicalPath()))
        if os.path.exists((Common.getDocumentsDirectory().getCanonicalPath())):
            textArray.append(u"Documents Directory:         %s" %(Common.getDocumentsDirectory().getCanonicalPath()))

        if getTheSetting(u"gen.report_dir"):
            textArray.append(getTheSetting(u"gen.report_dir", 29))
        if getTheSetting(u"gen.data_dir"):
            textArray.append(getTheSetting(u"gen.data_dir", 29))
        if getTheSetting(u"gen.import_dir"):
            textArray.append(getTheSetting(u"gen.import_dir", 29))

        textArray.append(u"\n")
        if os.path.exists((Common.getPythonDirectory().getCanonicalPath())):
            textArray.append(u"Python Directory:                %s" %(Common.getPythonDirectory().getCanonicalPath()))
        if getTheSetting(u"gen.last_ext_file_dir"):
            textArray.append(getTheSetting(u"gen.last_ext_file_dir", 33))
        if getTheSetting(u"gen.python_default_file"):
            textArray.append(getTheSetting(u"gen.python_default_file", 33))
        if getTheSetting(u"gen.python_dir"):
            textArray.append(getTheSetting(u"gen.python_dir", 33))
        if getTheSetting(u"gen.graph_dir"):
            textArray.append(getTheSetting(u"gen.graph_dir", 33))
        if getTheSetting(u"gen.recent_files"):
            textArray.append(getTheSetting(u"gen.recent_files", 33))

        textArray.append(u"System 'python.path':            %s" %System.getProperty(u"python.path"))
        textArray.append(u"System 'python.cachedir':        %s" %System.getProperty(u"python.cachedir"))
        textArray.append(u"System 'python.cachedir.skip':   %s" %System.getProperty(u"python.cachedir.skip"))

        try:
            textArray.append(u"\nEXTENSIONS / EDITORS / VIEWS")

            textArray.append(u"Extensions enabled:                          %s" %MD_REF.getUI().getMain().getSourceInformation().getExtensionsEnabled())

            x = MD_REF.getExternalAccountEditors()
            for y in x:
                textArray.append(u"External Account Editor:                     %s" %(y))
            x = MD_REF.getExternalViews()
            for y in x:
                textArray.append(u"External View(HomePage widget):              %s" %(y))
            x = MD_REF.getLoadedModules()
            for y in x:
                textArray.append(u"Extension Loaded:                            %s" %(y.getDisplayName()))
            x = MD_REF.getSuppressedExtensionIDs()
            for y in x:
                textArray.append(u"Internal/suppressed/secret/unloadable extns: %s" %(y))
            if float(MD_REF.getBuild()) < 3051:
                # .getOutdatedExtensionIDs() name changed prior to 3051
                x = MD_REF.getOutdatedExtensionIDs()                                                                    # noqa
            else:
                x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
            for y in x:
                textArray.append(u"Outdated extensions (not loaded):            %s" %(y))

            try:
                theUpdateList = get_extension_update_info()

                for key in theUpdateList.keys():
                    updateInfo = theUpdateList[key]
                    textArray.append(u"** UPDATABLE EXTENSION: %s to version: %s" %(pad(key,20),(updateInfo[0].getBuild())) )
            except:
                textArray.append(u"ERROR: Failed to retrieve / download Extension update list....")
                dump_sys_error_to_md_console_and_errorlog()

        except:
            pass

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            textArray.append(u"\nCONGRATULATIONS - NO ORPHAN EXTENSIONS DETECTED!!\n")
        else:
            textArray.append(u"\nWARNING: Orphan Extensions detected (%s in config.dict) & (%s in .MXT files)\n" %(len(orphan_prefs)+len(orphan_confirmed_extn_keys),len(orphan_files)))
            myPrint(u"B", u"WARNING: Orphan Extensions detected (%s in config.dict) & (%s in .MXT files)\n" %(len(orphan_prefs)+len(orphan_confirmed_extn_keys),len(orphan_files)))


        textArray.append(u"\n ======================================================================================")
        textArray.append(u"USER PREFERENCES")
        textArray.append(u"-----------------")
        textArray.append(u">> GENERAL")
        textArray.append(u"Show Full Account Paths:             %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"show_full_account_path", True)))
        textArray.append(u"Register Follows Recorded Txns:      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.register_follows_txns", True)))
        textArray.append(u"Use VAT/GST:                         %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.use_vat", False)))
        textArray.append(u"Case Sensitive Auto-Complete:        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.case_sensitive_ac", False)))
        textArray.append(u"Auto Insert Decimal Points:          %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.quickdecimal", False)))
        textArray.append(u"Auto Create New Transactions:        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.new_txn_on_record", True)))
        textArray.append(u"Separate Tax Date for Transactions:  %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.separate_tax_date", False)))
        textArray.append(u"Show All Accounts in Popup:          %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.show_all_accts_in_popup", False)))
        textArray.append(u"Beep when Transactions Change:       %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"beep_on_transaction_change", True)))
        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"Theme: %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID)))
        textArray.append(u"Show Selection Details:              %s" %(MD_REF.getUI().getPreferences().getSetting(u"details_view_mode", u"inwindow")))
        textArray.append(u"Side Bar Balance Type:               %s" %(MD_REF.getUI().getPreferences().getSideBarBalanceType()))
        textArray.append(u"Date Format:                         %s" %(MD_REF.getUI().getPreferences().getSetting(u"date_format", None)))
        # this.prefs.getShortDateFormat());
        textArray.append(u"Decimal Character:                   %s" %(MD_REF.getUI().getPreferences().getSetting(u"decimal_character", ".")))
        # this.prefs.getDecimalChar()));
        textArray.append(u"Locale:                              %s" %(MD_REF.getUI().getPreferences().getLocale()))

        i = MD_REF.getUI().getPreferences().getIntSetting(u"gen.fiscal_year_start_mmdd", 101)
        if i == 101: i = u"January 1"
        elif i == 201: i = u"February 1"
        elif i == 301: i = u"March 1"
        elif i == 401: i = u"April 1"
        elif i == 406: i = u"April 6 (UK Tax Year Start Date)"
        elif i == 501: i = u"May 1"
        elif i == 601: i = u"June 1"
        elif i == 701: i = u"July 1"
        elif i == 801: i = u"August 1"
        elif i == 901: i = u"September 1"
        elif i == 1001: i = u"October 1"
        elif i == 1101: i = u"November 1"
        elif i == 1201: i = u"December 1"
        else: i = i
        textArray.append(u"Fiscal Year Start:                   %s" %(i))

        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"Font Size:                           +%s" %(MD_REF.getUI().getPreferences().getIntSetting(u"gui.font_increment", 0)))

        if float(MD_REF.getBuild()) >= 3032:
            textArray.append(u"\n>> APPEARANCE")
            textArray.append(u"Theme:                               %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID)))
            if (MD_REF.getUI().getPreferences().getSetting(u"main_font")) != u"null":
                textArray.append(u"Font:                                %s" %(MD_REF.getUI().getPreferences().getSetting(u"main_font")))
            else:
                textArray.append(u"Font:                                (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"mono_font")) != u"null":
                textArray.append(u"Numeric Font:                        %s" %(MD_REF.getUI().getPreferences().getSetting(u"mono_font")))
            else:
                textArray.append(u"Numeric Font:                        (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"code_font")) != u"null":
                textArray.append(u"Moneybot Coding (monospaced) Font:   %s" %(MD_REF.getUI().getPreferences().getSetting(u"code_font")))
            else:
                textArray.append(u"Moneybot Coding (monospaced) Font:   (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"print.font_name")) != u"null":
                textArray.append(u"Printing Font:                       %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_name")))
            else:
                textArray.append(u"Printing Font:                       (None/Default)")

            textArray.append(u"Print Font Size:                     %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_size", u"12")))
            textArray.append(u"Screen Font Size:                    +%s" %(MD_REF.getUI().getPreferences().getIntSetting(u"gui.font_increment", 0)))

        textArray.append(u"\n>> NETWORK")
        textArray.append(u"Automatically Download in Background:                             %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.auto_download", False)))
        textArray.append(u"Automatically Merge Downloaded Transactions:                      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.preprocess_dwnlds", False)))
        textArray.append(u"Mark Transactions as Cleared When Confirmed:                      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.clear_confirmed_txns", False)))
        textArray.append(u"Use Bank Dates for Merged Transactions:                           %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"olb.prefer_bank_dates", False)))
        textArray.append(u"Ignore Transaction Types in Favor of Amount Signs:                %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"prefer_amt_sign_to_txn_type", False)))

        dataStorage = MD_REF.getCurrentAccount().getBook().getLocalStorage()
        autocommit = not dataStorage or dataStorage.getBoolean(u"do_autocommits",MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
        textArray.append(u"Auto-Commit Reminders (applies to current file on this computer): %s" %(autocommit))

        textArray.append(u"Use Proxy:                                                        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.use_proxy", False)))
        textArray.append(u" Proxy Host:                                                      %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_host", "")))
        textArray.append(u" Proxy Port:                                                      %s" %(MD_REF.getUI().getPreferences().getIntSetting(u"net.proxy_port", 80)))
        textArray.append(u"Proxy Requires Authentication:                                    %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.auth_proxy", False)))
        textArray.append(u" Proxy Username:                                                  %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_user", "")))
        textArray.append(u" Proxy Password:                                                  %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_pass", "")))
        textArray.append(u"Observe Online Payment Date Restrictions:                         %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"ofx.observe_bp_window", True)))
        i = MD_REF.getUI().getPreferences().getIntSetting(u"net.downloaded_txn_date_window", -1)
        if i < 0: i = u"Default"
        textArray.append(u"Only Match downloaded transactions when they are at most %s days apart" %(i))

        textArray.append(u"\n>> CHEQUE PRINTING")
        textArray.append(u"preferences not listed here...")

        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"\n>> PRINTING")
            textArray.append(u"Font:      %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_name", u"")))
            textArray.append(u"Font Size: %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_size", u"12")))

        textArray.append(u"\n>> BACKUPS")

        destroyBackupChoices = MD_REF.getUI().getPreferences().getSetting(u"backup.destroy_number", u"5")
        returnedBackupType = MD_REF.getUI().getPreferences().getSetting(u"backup.backup_type", u"every_x_days")
        if returnedBackupType == u"every_time":
            dailyBackupCheckbox = True
            destroyBackupChoices = 1
        elif returnedBackupType == u"every_x_days":
            dailyBackupCheckbox = True
        else:
            dailyBackupCheckbox = False

        textArray.append(u"Save Backups Daily:     %s" %(dailyBackupCheckbox))
        textArray.append(u"Keep no more than       %s" %(destroyBackupChoices) + u" backups")

        textArray.append(u"separate Backup Folder: %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"backup.location_selected", True)))
        textArray.append(u"Backup Folder:          %s " %(FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath() ))

        textArray.append(u"\n>> SUMMARY PAGE")
        textArray.append(u"preferences not listed here...")
        textArray.append(u" ======================================================================================\n")

        textArray.append(u"\nHOME SCREEN USER SELECTED PREFERENCES")
        textArray.append(u"----------------------------")
        textArray.append(u"Home Screen Configured:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.configured", u"NOT SET"))

        if MD_REF.getUI().getPreferences().getSetting(u"sidebar_bal_type", False):
            textArray.append(u"Side Bar Balance Type:           %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"sidebar_bal_type",0))))
        textArray.append(u"Dashboard Item Selected:         %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.dashboard.item", u"NOT SET"))
        textArray.append(u"Quick Graph Selected:            %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.quick_graph_type", u"NOT SET"))
        textArray.append(u"Budget Bar Date Range Selected:  %s" %MD_REF.getUI().getPreferences().getSetting(u"budgetbars_date_range", u"NOT SET"))
        textArray.append(u"Reminders View:                  %s" %MD_REF.getUI().getPreferences().getSetting(u"upcoming_setting", u"NOT SET"))

        textArray.append(u"Exchange Rates View - Invert?:   %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.invert_rates", u"NOT SET"))

        textArray.append(u"BANK Accounts Expanded:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.bank_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.bank_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.bank_bal_type",0))))

        textArray.append(u"LOAN Accounts Expanded:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.loan_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.loan_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.loan_bal_type",0))))

        textArray.append(u"LIABILITY Accounts Expanded:     %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.liability_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.liability_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.liability_bal_type",0))))

        textArray.append(u"INVESTMENT Accounts Expanded:    %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.invst_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.invst_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.invst_bal_type",0))))

        textArray.append(u"CREDIT CARD Accounts Expanded:   %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.cc_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.cc_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.cc_bal_type",0))))

        textArray.append(u"ASSET Accounts Expanded:         %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.asset_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.asset_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.asset_bal_type",0))))


        textArray.append(u" ======================================================================================\n")

        try:
            textArray.append(u"\nFONTS")
            textArray.append(u">> Swing Manager default:     %s" %(UIManager.getFont("Label.font")))
            textArray.append(u">> Moneydance default:        %s" %(MD_REF.getUI().getFonts().defaultSystemFont))
            textArray.append(u">> Moneydance mono:           %s" %(MD_REF.getUI().getFonts().mono))
            textArray.append(u">> Moneydance default text:   %s" %(MD_REF.getUI().getFonts().defaultText))
            textArray.append(u">> Moneydance default title:  %s" %(MD_REF.getUI().getFonts().detailTitle))
            textArray.append(u">> Moneydance calendar title: %s" %(MD_REF.getUI().getFonts().calendarTitle))
            textArray.append(u">> Moneydance header:         %s" %(MD_REF.getUI().getFonts().header))
            textArray.append(u">> Moneydance register:       %s" %(MD_REF.getUI().getFonts().register))
            textArray.append(u">> Moneydance report header:  %s" %(MD_REF.getUI().getFonts().reportHeader))
            textArray.append(u">> Moneydance report title:   %s" %(MD_REF.getUI().getFonts().reportTitle))

            textArray.append(u">> Moneydance code:           %s" %(getMonoFont()))

        except:
            myPrint(u"B",u"Error getting fonts..?")
            dump_sys_error_to_md_console_and_errorlog()

        textArray.append(u"\n>> OTHER INTERESTING SETTINGS....")

        if getTheSetting(u"net.default_browser"):
            textArray.append(getTheSetting(u"net.default_browser", 29))
        if getTheSetting(u"gen.import_dt_fmt_idx"):
            textArray.append(getTheSetting(u"gen.import_dt_fmt_idx", 29))
        if getTheSetting(u"txtimport_datefmt"):
            textArray.append(getTheSetting(u"txtimport_datefmt", 29))
        if getTheSetting(u"txtimport_csv_delim"):
            textArray.append(getTheSetting(u"txtimport_csv_delim", 29))
        if getTheSetting(u"txtimport_csv_decpoint"):
            textArray.append(getTheSetting(u"txtimport_csv_decpoint", 29))

        textArray.append(u"")

        if getTheSetting(u"ofx.app_id"):
            textArray.append(getTheSetting(u"ofx.app_id", 29))
        if getTheSetting(u"ofx.app_version"):
            textArray.append(getTheSetting(u"ofx.app_version", 29))
        if getTheSetting(u"ofx.bp_country"):
            textArray.append(getTheSetting(u"ofx.bp_country", 29))
        if getTheSetting(u"ofx.app_version"):
            textArray.append(getTheSetting(u"ofx.app_version", 29))

        textArray.append(u"")
        textArray.append(u"System Properties containing references to Moneydance")
        for x in System.getProperties():

            # noinspection PyUnresolvedReferences
            if u"moneydance" in System.getProperty(x).lower():
                textArray.append(u">> %s%s" %(pad(x,50), System.getProperty(x)))

        textArray.append(u"\n\n<END>\n")

        # This catches exceptions.UnicodeDecodeError 'utf-8' codec can't decode byte 0xa0 in position 46: unexpected code byte'
        # First spotted with South African Locale and nbsp used for decimal grouping character....

        try:
            returnString = u"\n".join(textArray)
            myPrint(u"DB",u"Success joining diagnostics text array.....")
        except:
            myPrint(u"B",u"UH-OH - Seems like we probably caught an utf8 error... trying to rectify")
            myPrint(u"B", dump_sys_error_to_md_console_and_errorlog(True))
            returnString = u""
            for i in range(0, len(textArray)):
                for char in textArray[i]:
                    if ord(char)>=128:
                        myPrint(u"B",u"char ord(%s) found in row %s; position %s" %(ord(char),i,textArray[i].find(char)))
                        myPrint(u"B",u"@@ FAILING ROW STARTS: '%s'" %(textArray[i][:textArray[i].find(char)]))
                        break
                returnString += (u"".join(char for char in textArray[i] if ord(char) < 128) )+u"\n"
            returnString += u"\n(** NOTE: I had to strip non ASCII characters **)\n"

        return returnString

    def get_list_memorised_reports():
        # Build a quick virtual file of Memorized reports and graphs to display
        memz = []

        iCount = 0
        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedGraphs():
            iCount+=1
            memz.append("Graph: %s" % (x.getName()))

        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedReports():
            iCount+=1
            memz.append("Report: %s" % (x.getName()))

        memz = sorted(memz, key=lambda sort_x: ((sort_x[0]).upper()))

        memz.insert(0,"YOUR MEMORIZED REPORTS\n ======================\n")

        memz.append("\nYOUR MEMORIZED REPORTS in detail\n ======================\n")

        iGs = 0
        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedGraphs():
            if iGs:
                memz.append("\n ---")
            iGs+=1
            memz.append("Graph:           %s" % (x.getName()))
            memz.append(">> SyncItemType: %s" %(x.getSyncItemType()))
            # memz.append(">> Graph ID:     %s" %(x.getReportID()))
            memz.append(">> Graph Genr:   %s" %(x.getReportGenerator()))
            y = x.getReportParameters()
            for yy in y:
                if yy.lower().strip() == "accounts" or yy.lower().strip() == "source_accts":
                    memz.append(">> Parameter key: %s: %s" %(yy, "<not displayed - but contains %s accounts>" %(y.get(yy).count(",")+1)))
                else:
                    memz.append(">> Parameter key: %s: %s" %(yy, y.get(yy)))

        iRs = 0
        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedReports():
            if iRs or iGs:
                memz.append("\n ---")
            iRs+=1
            memz.append("Report           %s" % (x.getName()))
            memz.append(">> SyncItemType: %s" %(x.getSyncItemType()))
            # memz.append(">> Report ID:    %s" %(x.getReportID()))
            memz.append(">> Report Genr:  %s" %(x.getReportGenerator()))
            y = x.getReportParameters()
            for yy in y:
                if yy.lower().strip() == "accounts" or yy.lower().strip() == "source_accts":
                    memz.append(">> Parameter key: %s: %s" %(yy, "<not displayed - but contains %s accounts>" %(y.get(yy).count(",")+1)))
                else:
                    memz.append(">> Parameter key: %s: %s" %(yy, y.get(yy)))

        memz.append("\n\n\n====== DEFAULT REPORTS SETTINGS/PARAMETERS (from Local Storage) RAW DUMP ======\n")
        LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

        last = None
        keys=sorted(LS.keys())
        for theKey in keys:
            value = LS.get(theKey)
            if not theKey.lower().startswith("report_params."): continue
            split_key = theKey.split(".",2)
            if split_key[1] != last:
                memz.append("")
                last = split_key[1]

            if theKey.lower().strip().endswith(".accounts") or theKey.lower().strip().endswith(".source_accts"):
                memz.append("Key:%s Value: %s" % (pad(theKey,70), "<not displayed - but contains %s accounts>" %(value.count(",")+1)))
            else:
                memz.append("Key:%s Value: %s" % (pad(theKey,70), value.strip()))

        x=LS.get("grfRepDefaultParams")
        if x:
            memz.append("\n\nDefault Parameters: 'grfRepDefaultParams' (Probably Legacy keys)")
            memz.append("%s" %x)
            memz.append("")

        memz.append("\n<END>")

        for i in range(0, len(memz)):
            memz[i] = memz[i] + "\n"
        memz = "".join(memz)
        return memz

    def view_extensions_details():
        theData = []                                                                                                    # noqa

        theData.append("EXTENSION(s) DETAILS")
        theData.append(" =====================\n")

        if len(MD_REF.getExternalViews()) > 0:
            theData.append("External Views (HomePage widgets) views:\n")

            for ev in MD_REF.getExternalViews():
                theData.append("   - %s" %(ev.getID()))

            theData.append("\n")

        theData.append("Extensions enabled: %s\n" %MD_REF.getUI().getMain().getSourceInformation().getExtensionsEnabled())

        theUpdateList = get_extension_update_info()

        # noinspection PyBroadException
        try:
            x = MD_REF.getLoadedModules()
            for y in x:
                isUpdatable= "(latest version)"
                updateInfo = theUpdateList.get(y.getIDStr().lower())
                if updateInfo:
                    isUpdatable = ("\t******* Updatable to version: %s *******" % (updateInfo[0].getBuild())).upper()
                theData.append("Extension ID:           %s" %y.getIDStr())
                theData.append("Extension Name:         %s" %y.getName())
                theData.append("Extension Display Name: %s" %y.getDisplayName())
                theData.append("Extension Description:  %s" %y.getDescription())
                theData.append("Extension Version:      %s" %(y.getBuild()) + isUpdatable)
                theData.append("Extension Source File:  %s" %(y.getSourceFile()))
                theData.append("Extension Vendor:       %s" %y.getVendor())
                theData.append("Extension isBundled:    %s" %(y.isBundled()))
                theData.append("Extension isVerified:   %s" %(y.isVerified()))
                if MD_REF.getUI().getPreferences().getSetting("confirmedext."+str(y.getName()).strip(), None):
                    theData.append("** User has Confirmed this unsigned Extension can run - version: " + MD_REF.getUI().getPreferences().getSetting("confirmedext."+str(y.getName()).strip(), None))
                theData.append("\n\n")

            x = MD_REF.getSuppressedExtensionIDs()
            for y in x:
                theData.append("Internal/suppressed/secret extensions: %s" %(y))

            if float(MD_REF.getBuild()) < 3051:
                # .getOutdatedExtensionIDs() name changed prior to 3051
                x = MD_REF.getOutdatedExtensionIDs()                                                                    # noqa
            else:
                x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
            for y in x:
                theData.append("Outdated / unloadable extensions (not loaded): %s" %(y))
        except:
            theData.append("\nERROR READING EXTENSION DATA!!!!\n")
            dump_sys_error_to_md_console_and_errorlog()

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            theData.append("\nCONGRATULATIONS - NO ORPHAN EXTENSIONS DETECTED!!\n")

        else:
            theData.append("\nLISTING EXTENSIONS ORPHANED IN CONFIG.DICT OR FILES (*.MXT)\n")

            for x in orphan_prefs.keys():
                theData.append("%s Extension: %s is %s" %(pad("config.dict:",40),pad(x,40),pad(orphan_prefs[x],40)))

            theData.append("")

            for x in orphan_confirmed_extn_keys.keys():
                _theVersion = MD_REF.getUI().getPreferences().getSetting(orphan_confirmed_extn_keys[x][1],None)
                theData.append("%s Extension: %s Key: %s (build: %s) is %s" %(pad("config.dict:",40),pad(x,40),pad(orphan_confirmed_extn_keys[x][1],40),_theVersion, pad(orphan_confirmed_extn_keys[x][0],40)))

            theData.append("")

            for x in orphan_files.keys():
                theData.append("%s Extension: %s is %s" %(pad("File: "+orphan_files[x][1],40),pad(x,40),pad(orphan_files[x][0],40)))

        theData.append("\n<END>")

        # Build a quick virtual 'file' of Memorized reports and graphs to display
        for i in range(0, len(theData)):
            theData[i] = theData[i] + "\n"
        theData = "".join(theData)
        return theData

    class ToolboxBuildInfo:

        def __init__(self, buildObject):
            self.obj =                                  buildObject
            self.build =                                buildObject.getInt("build", 0)
            self.disable =                              buildObject.getBoolean("disable", False)
            self.TOOLBOX_MINIMUM_TESTED_MD_VERSION =    float(buildObject.getStr("TOOLBOX_MINIMUM_TESTED_MD_VERSION", "0.0"))
            self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =    float(buildObject.getStr("TOOLBOX_MAXIMUM_TESTED_MD_VERSION", "0.0"))
            self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =      buildObject.getInt("TOOLBOX_MAXIMUM_TESTED_MD_BUILD", 0)
            self.MD_OFX_BANK_SETTINGS_DIR =             buildObject.getStr("MD_OFX_BANK_SETTINGS_DIR", "")
            self.MD_OFX_DEFAULT_SETTINGS_FILE =         buildObject.getStr("MD_OFX_DEFAULT_SETTINGS_FILE", "")
            self.MD_OFX_DEBUG_SETTINGS_FILE =           buildObject.getStr("MD_OFX_DEBUG_SETTINGS_FILE", "")
            self.MD_EXTENSIONS_DIRECTORY_FILE =         buildObject.getStr("MD_EXTENSIONS_DIRECTORY_FILE", "")
            self.MYPYTHON_DOWNLOAD_URL =                buildObject.getStr("MYPYTHON_DOWNLOAD_URL", "")

            # noinspection PyChainedComparsons
            if self.build > 1000 and self.build < 9999 and self.disable: return                                             # noqa

            # noinspection PyChainedComparsons
            if (self.build < 1000 or self.build > 9999
                    or (self.TOOLBOX_MINIMUM_TESTED_MD_VERSION > 0  and self.TOOLBOX_MINIMUM_TESTED_MD_VERSION < 2020.0)    # noqa
                    or (self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION > 0  and self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION < 2021.1)    # noqa
                    or (self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD > 0    and self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD   < 3034)      # noqa
                    or (len(self.MD_OFX_BANK_SETTINGS_DIR) > 0      and len(self.MD_OFX_BANK_SETTINGS_DIR)     < 10)        # noqa
                    or (len(self.MD_OFX_DEFAULT_SETTINGS_FILE) > 0  and len(self.MD_OFX_DEFAULT_SETTINGS_FILE) < 10)        # noqa
                    or (len(self.MD_OFX_DEBUG_SETTINGS_FILE) > 0    and len(self.MD_OFX_DEBUG_SETTINGS_FILE)   < 10)        # noqa
                    or (len(self.MD_EXTENSIONS_DIRECTORY_FILE) > 0  and len(self.MD_EXTENSIONS_DIRECTORY_FILE) < 10)        # noqa
                    or (len(self.MYPYTHON_DOWNLOAD_URL) > 0         and len(self.MYPYTHON_DOWNLOAD_URL) < 10)):      # noqa

                myPrint("DB","Error with toolbox downloaded data - invalidating it - was: %s" %(self.obj))
                self.build =                                0
                self.disable =                              False
                self.TOOLBOX_MINIMUM_TESTED_MD_VERSION =    None
                self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =    None
                self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =      None
                self.MD_OFX_BANK_SETTINGS_DIR =             None
                self.MD_OFX_DEFAULT_SETTINGS_FILE =         None
                self.MD_OFX_DEBUG_SETTINGS_FILE =           None
                self.MD_EXTENSIONS_DIRECTORY_FILE =         None
                self.MYPYTHON_DOWNLOAD_URL =                None


        def __str__(self):
            return "Toolbox build info Obj. Build: %s Disabled: %s {%s}" %(self.build,self.disable, self.obj)

        def __repr__(self):
            return "Toolbox build info Obj. Build: %s Disabled: %s {%s}" %(self.build,self.disable, self.obj)

    def download_toolbox_version_info():
        global debug, TOOLBOX_STOP_NOW, TOOLBOX_VERSION_VALIDATION_URL, version_build
        global TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_BUILD
        global MD_OFX_BANK_SETTINGS_DIR, MD_OFX_DEFAULT_SETTINGS_FILE, MD_OFX_DEBUG_SETTINGS_FILE, MD_EXTENSIONS_DIRECTORY_FILE, MYPYTHON_DOWNLOAD_URL

        myPrint("B","##################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to the master Toolbox code repository to check version / build information - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","##################################################################################################################################################")

        this_toolbox_build = int(version_build)
        if this_toolbox_build < 1000:
            myPrint("B", "ERROR with Toolbox build %s  - will just proceed without safeguards" %(this_toolbox_build))
            return

        downloadBuilds = StreamTable()

        inx = None
        try:
            url = URL(TOOLBOX_VERSION_VALIDATION_URL)
            inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
            downloadBuilds.readFrom(inx)
            myPrint("DB","Success getting online version/build info for Toolbox....")
        except:
            myPrint("J","")
            myPrint("B", "ERROR downloading version/build info from Toolbox website...: %s" %(TOOLBOX_VERSION_VALIDATION_URL))
        finally:
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing Toolbox Version/build info URL stream: %s" %(TOOLBOX_VERSION_VALIDATION_URL))

        if not downloadBuilds or downloadBuilds is None:
            myPrint("B", "Error: Toolbox version/build info after download is Empty - will just proceed without safeguards")
            return

        lastUpdated = downloadBuilds.getStr("last_updated", "UNKNOWN")
        myPrint("DB","Last Updated: %s" %(lastUpdated))

        TOOLBOX_STOP_NOW = downloadBuilds.getBoolean("disable_all", False)
        if TOOLBOX_STOP_NOW:
            myPrint("B","Uh-oh... disable_all has been set by the Developer.... Toolbox must close... Sorry")
            return
        else:
            myPrint("DB","Phew! disable_all NOT set....")

        buildList = downloadBuilds.get("builds", None)                   # type: StreamVector
        if not buildList or buildList is None:
            myPrint("B","Error - failed to download or decode build list - will just proceed without safeguards")
            return

        buildTable=[]

        try:
            for buildObj in buildList:                                      # type: StreamTable
                if not (isinstance(buildObj, StreamTable)):
                    myPrint("DB", "ERROR - Retrieved toolbox build info is not a StreamTable(). It's %s %s" %(type(buildObj),buildObj))
                    continue

                # myPrint("D", "BuildObj contains: %s" %(buildObj))
                buildTable.append(ToolboxBuildInfo(buildObj))

        except:
            dump_sys_error_to_md_console_and_errorlog()
            myPrint("B", "ERROR decoding downloading toolbox version/build data! - will just proceed without safeguards...")
            return

        if len(buildTable)<1:
            myPrint("B", "ERROR decoded downloaded toolbox version/build data is empty! - will just proceed without safeguards...")
            return

        buildTable = sorted(buildTable, key=lambda _x: (_x.build), reverse=True)          # type: [ToolboxBuildInfo]
        # Already sorted - newest build first
        for moduleBuild in buildTable:          # type: ToolboxBuildInfo
            if moduleBuild.build < 1000:
                myPrint("DB","Found INVALID downloaded module build %s (ignoring and stopping search)... (%s)" %(moduleBuild.build, moduleBuild.obj ))
                return
            elif moduleBuild.build > this_toolbox_build:
                myPrint("DB","Found NEWER downloaded module build %s (ignoring and continuing search).. (%s)" %(moduleBuild.build, moduleBuild.obj ))
                continue
            elif moduleBuild.build == this_toolbox_build:
                myPrint("DB","Found EXACT-HIT downloaded module build %s OVERRIDING PROGRAM's DEFAULTS....! (%s)" %(moduleBuild.build, moduleBuild.obj ))

                if debug:
                    myPrint("DB","Program defaults were...:")
                    myPrint("DB"," TOOLBOX_STOP_NOW:                     %s"     %(TOOLBOX_STOP_NOW))
                    myPrint("DB"," TOOLBOX_MINIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MINIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_BUILD:      %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_BUILD))
                    myPrint("DB"," MD_OFX_BANK_SETTINGS_DIR:             %s"     %(MD_OFX_BANK_SETTINGS_DIR))
                    myPrint("DB"," MD_OFX_DEFAULT_SETTINGS_FILE:         %s"     %(MD_OFX_DEFAULT_SETTINGS_FILE))
                    myPrint("DB"," MD_OFX_DEBUG_SETTINGS_FILE:           %s"     %(MD_OFX_DEBUG_SETTINGS_FILE))
                    myPrint("DB"," MD_EXTENSIONS_DIRECTORY_FILE:         %s"     %(MD_EXTENSIONS_DIRECTORY_FILE))
                    myPrint("DB"," MYPYTHON_DOWNLOAD_URL:                %s"     %(MYPYTHON_DOWNLOAD_URL))

                TOOLBOX_STOP_NOW = moduleBuild.disable
                if moduleBuild.TOOLBOX_MINIMUM_TESTED_MD_VERSION > 0:
                    TOOLBOX_MINIMUM_TESTED_MD_VERSION =     moduleBuild.TOOLBOX_MINIMUM_TESTED_MD_VERSION
                if moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_VERSION:
                    TOOLBOX_MAXIMUM_TESTED_MD_VERSION =     moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_VERSION
                if moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_BUILD > 0:
                    TOOLBOX_MAXIMUM_TESTED_MD_BUILD =       moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_BUILD
                if len(moduleBuild.MD_OFX_BANK_SETTINGS_DIR) > 0:
                    MD_OFX_BANK_SETTINGS_DIR =              moduleBuild.MD_OFX_BANK_SETTINGS_DIR
                if len(moduleBuild.MD_OFX_DEFAULT_SETTINGS_FILE) > 0:
                    MD_OFX_DEFAULT_SETTINGS_FILE =          moduleBuild.MD_OFX_DEFAULT_SETTINGS_FILE
                if len(moduleBuild.MD_OFX_DEBUG_SETTINGS_FILE) > 0:
                    MD_OFX_DEBUG_SETTINGS_FILE =            moduleBuild.MD_OFX_DEBUG_SETTINGS_FILE
                if len(moduleBuild.MD_EXTENSIONS_DIRECTORY_FILE) > 0:
                    MD_EXTENSIONS_DIRECTORY_FILE =          moduleBuild.MD_EXTENSIONS_DIRECTORY_FILE
                if len(moduleBuild.MYPYTHON_DOWNLOAD_URL) > 0:
                    MYPYTHON_DOWNLOAD_URL =                  moduleBuild.MYPYTHON_DOWNLOAD_URL

                if debug:
                    myPrint("DB","Program variables are now...:")
                    myPrint("DB"," TOOLBOX_STOP_NOW:                     %s"     %(TOOLBOX_STOP_NOW))
                    myPrint("DB"," TOOLBOX_MINIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MINIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_BUILD:      %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_BUILD))
                    myPrint("DB"," MD_OFX_BANK_SETTINGS_DIR:             %s"     %(MD_OFX_BANK_SETTINGS_DIR))
                    myPrint("DB"," MD_OFX_DEFAULT_SETTINGS_FILE:         %s"     %(MD_OFX_DEFAULT_SETTINGS_FILE))
                    myPrint("DB"," MD_OFX_DEBUG_SETTINGS_FILE:           %s"     %(MD_OFX_DEBUG_SETTINGS_FILE))
                    myPrint("DB"," MD_EXTENSIONS_DIRECTORY_FILE:         %s"     %(MD_EXTENSIONS_DIRECTORY_FILE))
                    myPrint("DB"," MYPYTHON_DOWNLOAD_URL:                %s"     %(MYPYTHON_DOWNLOAD_URL))

                if TOOLBOX_STOP_NOW:
                    myPrint("B","Uh-oh... disable has been set by the Developer for this build.... Toolbox must close... Sorry")

                return

            else:
                myPrint("D","Found LOWER downloaded module build %s - so I will keep program's defaults, and ignore these - exiting search... (%s) " %(moduleBuild.build, moduleBuild.obj ))
                return

        myPrint("D","No suitable module build info found.. (so I will keep program's defaults, and ignore these - exiting search)")

        return

    def downloadExtensions():
        global MD_EXTENSIONS_DIRECTORY_FILE

        myPrint("B","#######################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind servers to check for extension(s) version data - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","#######################################################################################################################################")

        downloadInfo = StreamTable()
        if MD_REF.getUI().getMain().getSourceInformation().getExtensionsEnabled():
            inx = None
            try:
                url = URL(System.getProperty("moneydance.extension_list_url", MD_EXTENSIONS_DIRECTORY_FILE))
                inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
                downloadInfo.readFrom(inx)
            except:
                myPrint("B", "ERROR downloading from Moneydance extensions list website... ")
                dump_sys_error_to_md_console_and_errorlog()

            finally:
                if inx:
                    try:
                        inx.close()
                    except:
                        myPrint("B", "Error closing URL stream")
                        dump_sys_error_to_md_console_and_errorlog()
            return downloadInfo
        else:
            myPrint("B", "@@ Extensions not enabled!!?? @@")
        return False

    def check_if_key_string_valid(test_str):
        # http://docs.python.org/library/re.html
        # re.search returns None if no position in the string matches the pattern
        # pattern to search for any character other than "._-A-Za-z0-9"
        pattern = r'[^a-zA-Z0-9-_.:&=;,@]'
        if re.search(pattern, test_str):
            myPrint("DB","Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","Valid: %r" %(test_str))
            return True

    def check_if_key_data_string_valid(test_str):
        # http://docs.python.org/library/re.html
        # re.search returns None if no position in the string matches the pattern
        # pattern to search for any character other than "._-A-Za-z0-9"
        pattern = r"[^a-zA-Z0-9-' _.:&=;,@/\\]"
        if re.search(pattern, test_str):
            myPrint("DB","Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","Valid: %r" %(test_str))
            return True

    def get_extension_update_info():
        availableExtensionInfo=downloadExtensions()
        moduleList = availableExtensionInfo.get(u"feature_modules")      # StreamVector

        installed = MD_REF.getUI().getMain().getLoadedModules()          # FeatureModule[]
        excludedIDs = MD_REF.getSuppressedExtensionIDs()            # List<String>
        for installedMod in installed:
            if installedMod.isBundled():
                excludedIDs.add(installedMod.getIDStr().lower())

        miniUpdateList={}

        try:
            if moduleList:
                for obj in moduleList:
                    if not (isinstance(obj, StreamTable)):
                        myPrint(u"J", u"ERROR - Retrieved data is not a StreamTable()", obj)
                        continue

                    extInfo = ModuleMetaData(obj)       # ModuleMetaData

                    # Mirrors code from com.moneydance.apps.md.view.gui.extensions.ExtensionsWindow lines 290-317 (ish)....

                    # noinspection PyUnresolvedReferences
                    if excludedIDs.contains(extInfo.getModuleID().lower()):     # Probably internal modules like Python/Jython
                        continue
                    if not ((float(MD_REF.getBuild())) >= extInfo.getMinimumSupportedBuild() and (float(MD_REF.getBuild())) <= extInfo.getMaximumSupportedBuild()):  # noqa
                        continue
                    if not (extInfo.getMinimumSupportedBuild() >= 1000):
                        continue
                    if (extInfo.isMacSandboxFriendly() or not Platform.isMac() or not MD_REF.getUI().getMain().getPlatformHelper().isConstrainedToSandbox()):
                        pass
                    else:
                        continue
                    existingMod = None          # FeatureModule
                    for mod in installed:

                        # noinspection PyUnresolvedReferences
                        if mod.getIDStr().lower() == extInfo.getModuleID().lower():
                            existingMod = mod
                            break
                    isInstalled = (existingMod is not None)     # boolean
                    isUpdatable = (existingMod is not None and existingMod.getBuild() < extInfo.getBuild())
                    if existingMod and isInstalled and isUpdatable:

                        # noinspection PyUnresolvedReferences
                        miniUpdateList[extInfo.getModuleID().lower()] = [extInfo, isInstalled, isUpdatable]

            else:
                myPrint(u"J", u"ERROR - Failed to download module list!)")
        except:
            myPrint(u"B", u"ERROR decoding downloaded module list!)")
            dump_sys_error_to_md_console_and_errorlog()

        return miniUpdateList

    def get_register_txn_sort_orders():

        # Flush in memory settings to disk
        MD_REF.savePreferences()

        theSortData = []                                                                                                # noqa

        theSortData.append("VIEW REGISTER TXN SORT ORDERS (for Accounts - excluding legacy keys)")
        theSortData.append(" ==================================================================\n")

        theSortData.append("DEFAULTS (from config.dict)\n")

        for x in _COLWIDTHS:

            if      x == "bank":        theType = "Bank"
            elif    x == "cc":          theType = "Credit Card"
            elif    x == "invest":      theType = "Investment"
            elif    x == "loan":        theType = "Loan"
            elif    x == "security":    theType = "Security"
            elif    x == "misc":        theType = "Asset/Liability/Expense/Income/Other"
            elif    x == "rec_credits": theType = "Reconciling window - credits"
            elif    x == "rec_debits":  theType = "Reconciling window - debits"
            elif    x == "secdetail":   theType = "Security Detail"
            elif    x == "split":       theType = "Split Window"
            else:                       theType = "????"

            result = loadMDPreferences(None,x)
            if result:
                oneLineMode = result[0]
                splitReg    = result[1]
                splitSz     = result[2]
                sortID      = result[3]
                position    = result[4]
                ascending   = result[5]
                widths      = result[6]
                position2   = result[7]

                theSortData.append("\nType: %s (%s) Register Sort Data:"%(theType,x))
                theSortData.append(">> Sort Order: %s" %sortID)
                theSortData.append(">> Ascending: %s" %ascending)
                theSortData.append(">> One Line View: %s" %oneLineMode)
                theSortData.append(">> Split Register View: %s (%s)" %(splitReg,splitSz))
                theSortData.append(">> Position: %s Widths: %s Position2 %s\n" %(position, widths, position2))


        theSortData.append("\nDATA SAVED INTERNALLY BY (ACTIVE) ACCOUNT")
        theSortData.append("-----------------------------------------\n")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(1))
        for acct in accounts:

            for x in _COLWIDTHS:

                if      x == "bank":        theType = "Bank"
                elif    x == "cc":          theType = "Credit Card"
                elif    x == "invest":      theType = "Investment"
                elif    x == "loan":        theType = "Loan"
                elif    x == "security":    theType = "Security"
                elif    x == "misc":        theType = "Asset/Liability/Expense/Income/Other"
                elif    x == "rec_credits": theType = "Reconciling window - credits"
                elif    x == "rec_debits":  theType = "Reconciling window - debits"
                elif    x == "secdetail":   theType = "Security Detail"
                elif    x == "split":       theType = "Split Window"
                else:                       theType = "????"

                result = loadMDPreferences(acct,x, False)

                if result:
                    oneLineMode = result[0]
                    splitReg    = result[1]
                    splitSz     = result[2]
                    sortID      = result[3]
                    position    = result[4]
                    ascending   = result[5]
                    widths      = result[6]
                    position2   = result[7]

                    theSortData.append("\nAccount: %s Account Type: %s Key Type: %s (%s) Register Sort Data:"%(acct.getAccountName(), acct.getAccountType(),theType,x))
                    theSortData.append(">> Sort Order: %s" %sortID)
                    theSortData.append(">> Ascending: %s" %ascending)
                    theSortData.append(">> One Line View: %s" %oneLineMode)
                    theSortData.append(">> Split Register View: %s (%s)" %(splitReg,splitSz))
                    theSortData.append(">> Position: %s Widths: %s Position2 %s\n" %(position, widths, position2))

        theSortData.append("\n<END>")

        for i in range(0, len(theSortData)):
            theSortData[i] = theSortData[i] + "\n"
        theSortData = "".join(theSortData)
        return theSortData

    def view_check_num_settings():
        try:
            from com.infinitekind.moneydance.model import CheckNumSettings
        except:
            txt = "Your version of MD is too early to use this function, must be at least Moneydance 2020.1 (1925)"
            setDisplayStatus(txt, "R")
            return

        theData = []                                                                                                    # noqa

        theData.append("CHECK NUMBER SETTINGS")
        theData.append(" =====================\n")

        acct = root = MD_REF.getCurrentAccountBook().getRootAccount()
        x = root.getCheckNumSettings(True)  # False means don't return defaults
        theData.append("\nMaster Dataset & defaults (root account): " + MD_REF.getCurrentAccountBook().getName())
        if not x:  # Assume old style check numbers
            theData.append(
                " >>Old style Check numbers as default: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
            theData.append("\n\n")
        else:
            theData.append(" >>Fixed Chq Items: %s" %(x.getPopupStrings()))
            theData.append(
                " >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
            y = x.getRecentsOption()

            # noinspection PyUnresolvedReferences
            if y == CheckNumSettings.IncludeRecentsOption.ACCOUNT: y = "Include from Same Account"
            elif y == CheckNumSettings.IncludeRecentsOption.GLOBAL: y = "Include from All Accounts"
            elif y == CheckNumSettings.IncludeRecentsOption.NONE: y = "Don't Include"

            theData.append(" >>Recent Entries:          %s" %(y))
            theData.append(" >>Max Entries:             %s" %(x.getMaximumRecents()))
            theData.append(" >>Show Next-Check Number:  %s" %(x.getIncludeNextCheckNumber()))
            theData.append(" >>Show Print-Check Option: %s" %(x.getIncludePrintCheckMarker()))
            theData.append("\n")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(3))

        for acct in accounts:

            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.ROOT: continue

            x = acct.getCheckNumSettings(False)  # False means don't return defaults

            if not x:
                theData.append("Account: " + acct.getFullAccountName() + " (Settings: NONE/Default)")
                theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
                theData.append("\n")
            else:
                theData.append("Account: " + pad(acct.getFullAccountName(), 80))
                theData.append(" >>Fixed Chq Items: %s" %(x.getPopupStrings()))
                if acct.getAccountType() != Account.AccountType.ROOT:                                               # noqa
                    theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))

                y = x.getRecentsOption()
                if y == CheckNumSettings.IncludeRecentsOption.ACCOUNT:                                              # noqa
                    y = "Include from Same Account"
                elif y == CheckNumSettings.IncludeRecentsOption.GLOBAL:                                             # noqa
                    y = "Include from All Accounts"
                elif y == CheckNumSettings.IncludeRecentsOption.NONE:                                               # noqa
                    y = "Don't Include"

                theData.append(" >>Recent Entries:          %s" %(y))
                theData.append(" >>Max Entries:             %s" %(x.getMaximumRecents()))
                theData.append(" >>Show Next-Check Number:  %s" %(x.getIncludeNextCheckNumber()))
                theData.append(" >>Show Print-Check Option: %s" %(x.getIncludePrintCheckMarker()))
                theData.append("\n")
                # CheckNumSettings.IncludeRecentsOption

        theData.append(("\n<END>"))

        # Build a quick virtual file of Memorized reports and graphs to display
        for i in range(0, len(theData)):
            theData[i] = theData[i] + "\n"
        theData = "".join(theData)
        return theData

    def isUserEncryptionPassphraseSet():
        try:
            keyFile = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), "key")
            keyInfo = SyncRecord()
            fin = FileInputStream(keyFile)
            keyInfo.readSet(fin)
            fin.close()
            return keyInfo.getBoolean("userpass", False)
        except: pass
        return False

    def isCachingPasswords():
        return (isUserEncryptionPassphraseSet() and MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage().getBoolean("store_passwords", False))

    def getMDEncryptionKey():

        try:
            keyFile = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), u"key")

            keyInfo = SyncRecord()
            fin = FileInputStream(keyFile)
            keyInfo.readSet(fin)
            fin.close()

            # noinspection PyUnresolvedReferences
            cipherLevel = LocalStorageCipher.MDCipherLevel.GOOD

            keyString=keyInfo.getString(u"key",None)
            test_with_random = u"E6520436865636B2C2062616279206F6E65203220312074776F4D6963726F7068306E6520436865636B204D6963723070686F6"
            y=StringUtils.decodeHex(test_with_random[int(len(test_with_random)/2):]+test_with_random[:int(len(test_with_random)/2)])
            z=""
            for x in y: z+=chr(x)
            newPassphrase = z
            encryptedKeyBytes = StringUtils.decodeHex(keyString)
            if keyInfo.getBoolean(u"userpass", False):
                newPassphrase = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
                if not newPassphrase:
                    return u"Not sure: Error retrieving your Encryption key!"
            try:

                # This next line triggers a message in the console error log file: "loading with 128 bit encryption key"
                myPrint(u"J",u"Checking encryption key....")
                key = LocalStorageCipher.encryptionKeyFromBytesAndPassword(encryptedKeyBytes, list(newPassphrase), cipherLevel)
                # cipher = LocalStorageCipher(key, cipherLevel)
            except:
                return u"Not sure: could not validate your encryption!"

            theFormat  = key.getFormat()
            theAlg = key.getAlgorithm()
        except:
            return u"Not sure: Error in decryption routine - oh well!!"


        return u"%s / %s" % (theFormat, theAlg)

    def check_dropbox_and_suppress_warnings():

        dataFile = MD_REF.getCurrentAccount().getBook().getRootFolder()
        suppressFile = File(dataFile, "suppress_file_in_dropbox_restriction.txt")

        fileIsUnderDropbox = False
        suppressionFileExists = suppressFile.exists()
        parent = dataFile
        while parent is not None:
            if "dropbox" in parent.getName().lower():
                fileIsUnderDropbox = True
                break
            parent = parent.getParentFile()

        return fileIsUnderDropbox, suppressionFileExists

    def OFX_view_all_last_txn_download_dates():

        accountsDL = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(21))
        accountsDL = sorted(accountsDL, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        outputDates = "\nBANK OFX: LAST DOWNLOADED TRANSACTION DATE(s)\n" \
                      "--------------------------------------------\n\n"

        for acct in accountsDL:
            theOnlineTxnRecord = MyGetDownloadedTxns(acct)     # Use my version to prevent creation of default record(s)
            if theOnlineTxnRecord is None:
                prettyLastTxnDate = "Never downloaded = 'Download all available dates'"
            else:
                theCurrentDate = theOnlineTxnRecord.getOFXLastTxnUpdate()
                if theCurrentDate > 0:
                    prettyLastTxnDate = get_time_stamp_as_nice_text(theCurrentDate)
                else:
                    if isMDPlusEnabledBuild():
                        prettyLastTxnDate = "IS SET TO ZERO (MD will prompt for start date)"
                    else:
                        prettyLastTxnDate = "IS SET TO ZERO = 'Download all available dates'"

            outputDates += "%s %s %s\n" %(pad(repr(acct.getAccountType()),12), pad(acct.getFullAccountName(),40), prettyLastTxnDate)

        outputDates += "\n<END>"
        QuickJFrame("LAST DOWNLOAD DATES", outputDates,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()


    def OFX_view_CUSIP_settings():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "OFX: View Security's hidden CUSIP settings"

        PARAM_CURRID = "curr_id."

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, " "*len(_THIS_METHOD_NAME))

        output += "The hidden link between your Financial Institution Investment Securities and your MD Securities when downloading\n" \
                  "is stored as a hidden setting against your security in a key known as the CUSIP. For USA Customers this is the USA\n" \
                  "standard called CUSIP and all Securities have a unique number. In other markets this might be called ISIN for example.\n" \
                  "When matching Securities on Download, this setting needs to be blank or match the CUSIP. Your OFX download will contain\n" \
                  "the tags '<UNIQUEIDTYPE>' (which normally contains 'CUSIP') and '<UNIQUEID>' (which contains the CUSIP number).\n" \
                  "If your MD Security already contains a different CUSIP number, then it will NOT appear in the match list.\n" \
                  "You can edit your hidden CUSIP data in Advanced Mode.\n\n"

        output += " SECURITIES\n" \
                  " ==========\n\n"

        output += "%s %s %s %s %s\n" % (pad("Security", 45),
                                        pad("ID", 15),
                                        pad("Ticker Symbol", 15),
                                        pad("SCHEME", 12),
                                        pad("IDENTIFIER (CUSIP)", 20))

        output += "%s %s %s %s %s\n" % ("-" * 45,
                                        "-" * 15,
                                        "-" * 15,
                                        "-" * 12,
                                        "-" * 20)

        output += "\n"

        securities = sorted(MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies(),
                            key=lambda x: (x.getCurrencyType(), x.getName().upper()))

        iCountFound = 0
        for sec in securities:
            if sec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                       # noqa
            for key in sec.getParameterKeys():

                if key.startswith(PARAM_CURRID):

                    theScheme = key[len(PARAM_CURRID):]
                    theCUSIP = sec.getIDForScheme(theScheme)

                    if not theCUSIP: raise Exception("ERROR: %s - empty CUSIP returned? Security: %s, Scheme: %s" %(_THIS_METHOD_NAME, sec, theScheme))

                    iCountFound += 1
                    output += "%s %s %s %s %s %s %s\n" % (pad(sec.getName(), 45),
                                                    pad(sec.getIDString(), 15),
                                                    pad(sec.getTickerSymbol(), 15),
                                                    pad(theScheme, 12),
                                                    theCUSIP,
                                                    ("** CUSIP & TICKER ARE DIFFERENT **" if (theCUSIP.strip() != sec.getTickerSymbol().strip()) else (""*34)),
                                                    ("id: "+sec.getUUID() if (debug) else ("")))

        if not iCountFound:
            output += "\nNONE FOUND!\n"
        else:
            output += "\n\n%s Security hidden CUSIP record(s) found\n" %(iCountFound)

        output += "\n<END>"

        txt = "%s: - Displaying Security hidden CUSIP Settings" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "B")
        QuickJFrame(_THIS_METHOD_NAME.upper(), output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        del securities

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return


    def OFX_view_online_txns_payees_payments():

        _OBJOFXTXNS     =  0
        _OBJOFXOLPAYEES =  1
        _OBJOFXOLPAYMNT =  2

        objWhat = [
                    "OFX Online Transactions",                  # onlineTxnList             "oltxns"
                    "OFX Online Payees",                        # onlinePayeeList           "olpayees"
                    "OFX Online Payments"                       # onlinePaymentList         "olpmts"
            ]

        selectedAcct = None
        selectedObject = None
        textType = ""

        while True:

            selectedObjType = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the type of Online data you want to view",
                                                       "OFX View Online Data",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       objWhat,
                                                       None)
            if not selectedObjType:
                txt = "No online data type was selected to view .."
                setDisplayStatus(txt, "R")
                return

            if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(16))
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(17))
            else: continue

            accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))
            selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Acct to view Online Data:",
                                                       "Select ACCOUNT",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       accountsListForOlTxns,
                                                       None)  # type: Account
            if not selectedAcct: continue

            textType = ""
            if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                selectedObject = MyGetDownloadedTxns(selectedAcct)           # Use my version to prevent creation of default record(s)
                textType = "Online Txns"
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                selectedObject = MyGetOnlinePayees(selectedAcct)             # Use my version to prevent creation of default record(s)
                textType = "Online Payees"
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                selectedObject = MyGetOnlinePayments(selectedAcct)           # Use my version to prevent creation of default record(s)
                textType = "Online Payments"
            else: continue

            break

        output = "VIEW SAVED ONLINE DATA: %s\n" \
                 " ===================================\n\n" %(textType.upper())

        output += "Object Type: %s\n\n" %(type(selectedObject))

        # noinspection PyUnresolvedReferences
        output += "Linked Account Type: %s Acct Name: %s\n" %(selectedAcct.getAccountType(), selectedAcct.getFullAccountName())

        if isinstance(selectedObject, OnlineTxnList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlineTxnList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getTxnCount():",50),                        selectedObject.getTxnCount()  )
            output += "%s %s (%s)\n" % (pad("getOFXLastTxnUpdate():",50),           selectedObject.getOFXLastTxnUpdate(), DateUtil.convertLongDateToInt(selectedObject.getOFXLastTxnUpdate())  )
            output += "%s %s\n" % (pad("hasOnlineAvailBalance():",50),              selectedObject.hasOnlineAvailBalance()  )
            output += "%s %s\n" % (pad("getOnlineAvailBalance():",50),              selectedObject.getOnlineAvailBalance()  )
            output += "%s %s (%s)\n" % (pad("getOnlineAvailBalanceDate():",50),     selectedObject.getOnlineAvailBalanceDate(), DateUtil.convertLongDateToInt(selectedObject.getOnlineAvailBalanceDate())  )
            output += "%s %s\n" % (pad("hasOnlineLedgerBalance():",50),             selectedObject.hasOnlineLedgerBalance()  )
            output += "%s %s\n" % (pad("getOnlineLedgerBalance():",50),             selectedObject.getOnlineLedgerBalance()  )
            output += "%s %s (%s)\n" % (pad("getOnlineLedgerBalanceDate():",50),    selectedObject.getOnlineLedgerBalanceDate(), DateUtil.convertLongDateToInt(selectedObject.getOnlineLedgerBalanceDate())  )

        if isinstance(selectedObject, OnlinePayeeList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlinePayeeList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getPayeeCount():",50),             selectedObject.getPayeeCount()  )

        if isinstance(selectedObject, OnlinePaymentList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlinePaymentList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getPaymentCount():",50),           selectedObject.getPaymentCount()  )

        output+="\n"

        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
            if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

        keys = sorted(selectedObject.getParameterKeys())
        for theKey in keys:
            # noinspection PyUnresolvedReferences
            value = selectedObject.getParameter(theKey)
            output += pad("Key:%s" %theKey,50)+" Value: '%s'\n" %(value.strip())

        output+="\n\n<END>"

        QuickJFrame("VIEW SAVED ONLINE DATA",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

    # replicates com.moneydance.apps.md.view.gui.MDAccountProxy.getAccountKey()
    def my_get_account_key(acct):
        acctNum = acct.getAccountNum()
        if acctNum <= 0:
            return acct.getUUID()
        return str(acctNum)

    def ofx_view_service_profile_data():

        _THIS_METHOD_NAME = "OFX: View your installed Bank / Service Profiles"

        from java.lang.reflect import Modifier

        OFX = []

        lCachePasswords = isCachingPasswords()

        # Build a list of Moneydance accounts that are enabled for download and have a service profile linked....
        listAccountMDProxies=[]
        olAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(11))
        if len(olAccounts) > 0:
            for acctObj in olAccounts:
                acct = acctObj                                 # type: Account
                svcBank = acct.getBankingFI()                  # type: OnlineService
                svcBP = acct.getBillPayFI()                    # type: OnlineService
                if acct.getBankingFI() is not None:
                    listAccountMDProxies.append([MDAccountProxy(acct, False),svcBank,False])
                if acct.getBillPayFI() is not None:
                    listAccountMDProxies.append([MDAccountProxy(acct, True),svcBP,True])

        OFX.append("VIEW YOUR INSTALLED OFX SERVICE / BANK LOGON PROFILES\n"
                   " ====================================================\n\n")

        if lCachePasswords:
            OFX.append("MD Will allow you to Cache your Authentication (means you have set an encryption key and selected store passwords..")
        else:
            OFX.append("MD Cache Authentication ** DISABLED ** (either no user encryption key or store passwords = no..")

        OFX.append("")

        if not isMDPlusEnabledBuild() and getPlaidService():
            OFX.append("NOTE: Account linkages for MD+/Plaid Services may be incomplete as you are running an older version of Moneydance...!\n")

        OFX.append("MD Accounts enabled for OFX Downloads with linked Service / Bank logon profiles:")
        if len(listAccountMDProxies)<1:
            OFX.append("<NONE FOUND>")
        else:
            for olAcct in listAccountMDProxies:
                if not olAcct[2]:
                    OFX.append("- {:40} ('Key': {:15}) OFXAccNum: {:15} Bank Profile: {}".format(olAcct[0].getAccount().getFullAccountName(), olAcct[0].getAccountKey(), olAcct[0].getOFXAccountNumber(), olAcct[1]))
                else:
                    OFX.append("- {:40} ('Key': {:15}) OFXAccNum: {:15} BillPay Prof: {}".format(olAcct[0].getAccount().getFullAccountName(), olAcct[0].getAccountKey(), olAcct[0].getOFXAccountNumber(), olAcct[1]))
        OFX.append("")

        for service in MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices():

            # Find the MD accounts specifically linked to this service profile
            thisServiceMDAccountProxies=[]
            for olacct in listAccountMDProxies:
                if olacct[1] == service:
                    thisServiceMDAccountProxies.append(olacct)

            OFX.append(" ================================================================================================================================================")
            OFX.append(" ================================================================================================================================================")
            OFX.append(pad("Service/Profile:".upper(),40)       + safeStr(service))
            OFX.append(pad("----------------",40))
            OFX.append(pad(">>Moneydance TIK Service ID:",40)   + safeStr(service.getTIKServiceID()))
            OFX.append(pad(">>Profile's UUID:",40)              + safeStr(service.getUUID()))
            if isMDPlusEnabledBuild():
                OFX.append(pad(">>Protocol:",40)                + safeStr(service.getProtocol()))
                OFX.append(pad(">>isMoneydancePlusService:",40) + safeStr(service.isMoneydancePlusService()))
            OFX.append(pad(">>OFX Version:",40)                 + safeStr(service.getOFXVersion()))
            OFX.append(pad(">>Service Id:",40)                  + safeStr(service.getServiceId()))
            OFX.append(pad(">>Service Type:",40)                + safeStr(service.getServiceType()))
            OFX.append(pad(">>Realms:",40)                      + safeStr(service.getRealms()))
            OFX.append(pad(">>Bootstrap URL:",40)               + safeStr(service.getBootstrapURL()))

            OFX.append(pad(">>Needs FI Profile Check()?:",40)   + safeStr(service.needsFIProfileCheck()))

            mappingObject = None                                                                                        # noqa
            if isMDPlusEnabledBuild():
                OFX.append(pad("\n>>MD2022+ Online Banking Mapping table entries...:",120))
                mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")
                if mappingObject is not None:
                    OFX.append(special_toMultilineHumanReadableString(mappingObject,lSkipSecrets=False,sFilterServiceID=service.getTIKServiceID()))
                else: OFX.append("<NONE>")
            del mappingObject

            if service.getTIKServiceID() == "md:plaid":
                tokens = MD_REF.getCurrentAccountBook().getLocalStorage().getSublist("access_tokens")
                OFX.append(pad("\n>>Moneydance+ Access Tokens (local storage 'access_tokens')...:",120))
                if len(tokens) > 0:
                    for token in tokens:
                        for token_key in token:
                            txtAppendTxt = "(Confidential: '_payloadid', 'timestamp', 'token' values have been hidden for security reasons)"
                            if token_key != "item": continue
                            OFX.append("Key: %s AccountRef: %s %s" %(token_key, token.get(token_key), txtAppendTxt))
                else:
                    OFX.append("<NONE>")
                del tokens

                mdp_cache = MD_REF.getCurrentAccountBook().getLocalStorage().getSubset("mdp_items")
                OFX.append(pad("\n>>Moneydance+ Plaid Cache (local storage 'mdp_items')...:",120))
                if len(mdp_cache) > 0:
                    for cacheItem in mdp_cache:
                        OFX.append("Key: %s Value: %s" %(cacheItem, mdp_cache.get(cacheItem)))
                else:
                    OFX.append("<NONE>")
                del mdp_cache

            OFX.append(pad("\n>>Accounts configured within bank profile:",120))
            if len(service.getAvailableAccounts())<1:
                OFX.append("<NONE FOUND>")
            else:
                OFX.append(" -- List All accounts configured in profile: %s\n" %(service.getAvailableAccounts()))
                for availAccount in service.getAvailableAccounts():
                    OFX.append(">> ACCOUNT: %s (%s) ('Key': %s)" %(availAccount.getDescription(),availAccount.getAccountNumber(),availAccount.getAccountKey()))

                    if service.getTIKServiceID() != "md:plaid":         # Don't bother with MD+ as these are all empty anyway...
                        try:
                            # Rather than listing all methods by hand, just iterate and call them all.. I have checked they are all safe...
                            meths = availAccount.getClass().getDeclaredMethods()
                            for meth in meths:
                                if not Modifier.isPublic(meth.getModifiers()): continue
                                if meth.getName().lower().startswith("get") or meth.getName().lower().startswith("is") \
                                        and meth.getParameterCount()<1:
                                    result = meth.invoke(availAccount)
                                    if result is not None:
                                        OFX.append(" >> %s %s" %(pad(meth.getName(),40),result) )
                            OFX.append("\n")
                        except:
                            pass

            OFX.append("")

            OFX.append(pad("\n>>MD Accounts linked to this service / bank profile:",120))
            if len(thisServiceMDAccountProxies)<1:
                OFX.append("<NONE FOUND>")
            else:
                for olacct in thisServiceMDAccountProxies:
                    if not olacct[2]:
                        OFX.append(" >> Banking: %s ('Key': %s) (OfxAcctNum: %s)" %(olacct[0].getAccount().getFullAccountName(), olacct[0].getAccountKey(), olacct[0].getOFXAccountNumber()))
                    else:
                        OFX.append(" >> BillPay: %s ('Key': %s) (OfxAcctNum: %s)" %(olacct[0].getAccount().getFullAccountName(), olacct[0].getAccountKey(), olacct[0].getOFXAccountNumber()))

            OFX.append("")

            if service.getTIKServiceID() != "md:plaid":         # Don't bother with MD+ as these are all empty anyway...
                try:
                    p_getAuthenticationCachePrefix=service.getClass().getDeclaredMethod("getAuthenticationCachePrefix")
                    p_getAuthenticationCachePrefix.setAccessible(True)
                    OFX.append(pad("AuthenticationCachePrefix:",33) + safeStr(p_getAuthenticationCachePrefix.invoke(service)))
                    p_getAuthenticationCachePrefix.setAccessible(False)

                    p_getSessionCookiePrefix=service.getClass().getDeclaredMethod("getSessionCookiePrefix")
                    p_getSessionCookiePrefix.setAccessible(True)
                    OFX.append(pad("SessionCookiePrefix:",33    ) + safeStr(p_getSessionCookiePrefix.invoke(service)))
                    p_getSessionCookiePrefix.setAccessible(False)
                except:
                    pass

                OFX.append(pad("\n>>ROOT Data associated with service profile:",120))
                authKeyPrefix = "ofx.client_uid"
                root = MD_REF.getRootAccount()
                iCount = 0
                for rk in list(root.getParameterKeys()):
                    if rk.startswith(authKeyPrefix) and (service.getTIKServiceID() in rk):
                        OFX.append("Root key: '%s' value: '%s'" %(rk,root.getParameter(rk)))
                        iCount += 1
                if not iCount: OFX.append("<NONE>")
                del root, iCount, authKeyPrefix

                OFX.append(pad("\n>>REALMs configured:",120))
                realmsToCheck = service.getRealms()
                if "DEFAULT" not in realmsToCheck:
                    realmsToCheck.insert(0,"DEFAULT")

                for realm in realmsToCheck:

                    realmUserID = service.getUserId(realm, None)
                    if realmUserID is not None and realmUserID != "":
                        OFX.append("Realm: %s User ID: %s" %(realm, service.getUserId(realm, None)))

                    for olacct in thisServiceMDAccountProxies:

                        userID=service.getUserId(realm, olacct[0])
                        if userID is not None and userID != "":
                            OFX.append("Realm: %s Account's UserID: %s" %(realm, userID))

                        if not lCachePasswords:
                            OFX.append("** NOTE: Any Cached Authentication Keys listed below will not be saved when you exit **")

                        authKey = "ofx:" + realm
                        authObj = service.getCachedAuthentication(authKey)
                        if authObj is not None and authObj != "":
                            OFX.append("Realm: %s Cached Authentication: %s" %(realm, authObj))

                        authKey = "ofx:" + (realm + "::" + olacct[0].getAccountKey())
                        authObj = service.getCachedAuthentication(authKey)
                        if authObj is not None and authObj != "":
                            OFX.append("Realm: %s Account Key: %s (Key: %s / AccNum: %s) Cached Authentication: %s" %(realm, olacct[0].getAccountKey(), olacct[0].getOFXAccountKey(), olacct[0].getOFXAccountNumber(), authObj))

                        if service.getSessionCookie(userID) is not None:
                            OFX.append("Session Cookie: %s" %(service.getSessionCookie(userID)))

                OFX.append("getFIId()                        %s" %(service.getFIId()                             ))
                if service.getUpdatedFIId() != service.getFIId():
                    OFX.append("getUpdatedFIId()             %s" %(service.getUpdatedFIId()                      ))
                OFX.append("getFIName()                      %s" %(service.getFIName()                           ))
                OFX.append("getFIOrg()                       %s" %(service.getFIOrg()                            ))
                if service.getUpdatedFIOrg() != service.getUpdatedFIOrg():
                    OFX.append("getUpdatedFIOrg()            %s" %(service.getUpdatedFIOrg()                     ))
                OFX.append("usesFITag()                      %s" %(service.usesFITag()                           ))
                OFX.append("usesPTTAcctIDField()             %s" %(service.usesPTTAcctIDField()                  ))
                OFX.append("getFIUrl()                       %s" %(service.getFIUrl()                            ))
                OFX.append("getFIUrlIsRedirect()             %s" %(service.getFIUrlIsRedirect()                  ))

                OFX.append("getIgnoreTxnsBeforeLastUpdate()  %s" %(service.getIgnoreTxnsBeforeLastUpdate()       ))

                OFX.append("getTxnDownloadOverlap()          %s" %(service.getTxnDownloadOverlap()               ))
                OFX.append("getDateAvailAcctsUpdated()       %s" %(service.getDateAvailAcctsUpdated()            ))
                OFX.append("getAlwaysSendDateRange()         %s" %(service.getAlwaysSendDateRange()              ))


                OFX.append("getUseProfileRequest()           %s" %(service.getUseProfileRequest()                ))
                OFX.append("getUseClientSpecificUIDS()       %s" %(service.getUseClientSpecificUIDS()            ))
                OFX.append("getUseFileUIDs()                 %s" %(service.getUseFileUIDs()                      ))
                OFX.append("getUseBPFileUIDs()               %s" %(service.getUseBPFileUIDs()                    ))
                OFX.append("useTerribleTLSV1Hack()           %s" %(service.useTerribleTLSV1Hack()                ))
                OFX.append("getFIEmail()                     %s" %(service.getFIEmail()                          ))
                OFX.append("getTechServicePhone()            %s" %(service.getTechServicePhone()                 ))

                OFX.append("getInvstBrokerID()               %s" %(service.getInvstBrokerID()                    ))

                OFX.append("usesBillPayExtendedAcctTo()      %s" %(service.usesBillPayExtendedAcctTo()           ))

                OFX.append("getServiceType()                 %s" %(service.getServiceType()                      ))

                OFX.append("getUseShortDates()               %s" %(service.getUseShortDates()                    ))
                OFX.append("shouldDecrementLastTxnDate()     %s" %(service.shouldDecrementLastTxnDate()          ))

                OFX.append("getSignupAcctsAvail()            %s" %(service.getSignupAcctsAvail()                 ))
                OFX.append("getSignupCanActivateAcct()       %s" %(service.getSignupCanActivateAcct()            ))
                OFX.append("getSignupCanChgUserInfo()        %s" %(service.getSignupCanChgUserInfo()             ))
                OFX.append("getSignupCanPreauth()            %s" %(service.getSignupCanPreauth()                 ))
                OFX.append("getSignupClientAcctNumReq()      %s" %(service.getSignupClientAcctNumReq()           ))
                OFX.append("getSignupViaClient()             %s" %(service.getSignupViaClient()                  ))
                OFX.append("getSignupViaOther()              %s" %(service.getSignupViaOther()                   ))
                OFX.append("getSignupViaOtherMsg()           %s" %(service.getSignupViaOtherMsg()                ))
                OFX.append("getSignupViaWeb()                %s" %(service.getSignupViaWeb()                     ))
                OFX.append("getSignupViaWebUrl()             %s" %(service.getSignupViaWebUrl()                  ))
                OFX.append("getStopChkCanUseDescription()    %s" %(service.getStopChkCanUseDescription()         ))
                OFX.append("getStopChkCanUseRange()          %s" %(service.getStopChkCanUseRange()               ))
                OFX.append("getStopChkFee()                  %s" %(service.getStopChkFee()                       ))
                OFX.append("getStopChkProcessingDaysOff()    %s" %(service.getStopChkProcessingDaysOff()         ))
                OFX.append("getStopChkProcessingEndTime()    %s" %(service.getStopChkProcessingEndTime()         ))

                for x in service.getRealms():
                    OFX.append("getClientIDRequired(x)           %s" %(service.getClientIDRequired(x)             ))
                    OFX.append("getUserCanChangePIN(x)           %s" %(service.getUserCanChangePIN(x)             ))
                    OFX.append("getMaxPasswdLength(x)            %s" %(service.getMaxPasswdLength(x)              ))
                    OFX.append("getMinPasswdLength(x)            %s" %(service.getMinPasswdLength(x)              ))
                    OFX.append("getMustChngPINFirst(x)           %s" %(service.getMustChngPINFirst(x)             ))
                    OFX.append("getPasswdCanHaveSpaces(x)        %s" %(service.getPasswdCanHaveSpaces(x)          ))
                    OFX.append("getPasswdCanHaveSpecialChars(x)  %s" %(service.getPasswdCanHaveSpecialChars(x)    ))
                    OFX.append("getPasswdCaseSensitive(x)        %s" %(service.getPasswdCaseSensitive(x)          ))
                    OFX.append("getPasswdCharType(x)             %s" %(service.getPasswdCharType(x)               ))
                    OFX.append("getPasswdType(x)                 %s" %(service.getPasswdType(x)                   ))

                OFX.append("getDateUpdated()                 %s (%s)" %(service.getDateUpdated(), DateUtil.convertLongDateToInt(service.getDateUpdated())))
                OFX.append("getLastTransactionID()           %s" %(service.getLastTransactionID()                  ))
                OFX.append("getMaxFITIDLength()              %s" %(service.getMaxFITIDLength()                     ))
                OFX.append("getInvalidAcctTypes()            %s" %(service.getInvalidAcctTypes()                   ))

                p_getMsgSetTag=service.getClass().getDeclaredMethod("getMsgSetTag",[Integer.TYPE])
                p_getMsgSetTag.setAccessible(True)

                for msgType in (0,1,3,4,5,6,7,8,9,10,11,12):
                    if service.supportsMsgSet(msgType) or msgType==0:
                        tag=p_getMsgSetTag.invoke(service,[msgType])
                        OFX.append("---")
                        OFX.append("  Supports Message Tag:            %s" %(tag))
                        OFX.append("  getMsgSetLanguage(msgType)       %s" %(service.getMsgSetLanguage(msgType)             ))
                        OFX.append("  getMsgSetRspnsFileErrors(msgType)%s" %(service.getMsgSetRspnsFileErrors(msgType)      ))
                        OFX.append("  getMsgSetSecurity(msgType)       %s" %(service.getMsgSetSecurity(msgType)             ))
                        OFX.append("  getMsgSetSignonRealm(msgType)    %s" %(service.getMsgSetSignonRealm(msgType)          ))
                        OFX.append("  getMsgSetSyncMode(msgType)       %s" %(service.getMsgSetSyncMode(msgType)             ))
                        OFX.append("  getMsgSetTransportSecure(msgType)%s" %(service.getMsgSetTransportSecure(msgType)      ))
                        OFX.append("  getMsgSetURL(msgType)            %s" %(service.getMsgSetURL(msgType)                  ))
                        OFX.append("  getMsgSetVersion(msgType)        %s" %(service.getMsgSetVersion(msgType)              ))
                p_getMsgSetTag.setAccessible(False)

                OFX.append("---")

                OFX.append("getCreditCardClosingAvail()      %s" %(service.getCreditCardClosingAvail()           ))
                OFX.append("getCustServicePhone()            %s" %(service.getCustServicePhone()                 ))
                OFX.append("getBankClosingAvail()            %s" %(service.getBankClosingAvail()                 ))
                OFX.append("getBankXfrCanModifyModels()      %s" %(service.getBankXfrCanModifyModels()           ))
                OFX.append("getBankXfrCanModifyTransfers()   %s" %(service.getBankXfrCanModifyTransfers()        ))
                OFX.append("getBankXfrCanScheduleRecurring() %s" %(service.getBankXfrCanScheduleRecurring()      ))
                OFX.append("getBankXfrCanScheduleTransfers() %s" %(service.getBankXfrCanScheduleTransfers()      ))
                OFX.append("getBankXfrDaysWithdrawn()        %s" %(service.getBankXfrDaysWithdrawn()             ))
                OFX.append("getBankXfrDefaultDaysToPay()     %s" %(service.getBankXfrDefaultDaysToPay()          ))
                OFX.append("getBankXfrModelWindow()          %s" %(service.getBankXfrModelWindow()               ))
                OFX.append("getBankXfrNeedsTAN()             %s" %(service.getBankXfrNeedsTAN()                  ))
                OFX.append("getBankXfrProcessingDaysOff()    %s" %(service.getBankXfrProcessingDaysOff()         ))
                OFX.append("getBankXfrProcessingEndTime()    %s" %(service.getBankXfrProcessingEndTime()         ))
                OFX.append("getBankXfrSupportsDTAvail()      %s" %(service.getBankXfrSupportsDTAvail()           ))
                OFX.append("getBillPayCanAddPayee()          %s" %(service.getBillPayCanAddPayee()               ))
                OFX.append("getBillPayCanModPayments()       %s" %(service.getBillPayCanModPayments()            ))
                OFX.append("getBillPayDaysWithdrawn()        %s" %(service.getBillPayDaysWithdrawn()             ))
                OFX.append("getBillPayDefaultDaysToPay()     %s" %(service.getBillPayDefaultDaysToPay()          ))
                OFX.append("getBillPayHasExtendedPmt()       %s" %(service.getBillPayHasExtendedPmt()            ))
                OFX.append("getBillPayNeedsTANPayee()        %s" %(service.getBillPayNeedsTANPayee()             ))
                OFX.append("getBillPayNeedsTANPayment()      %s" %(service.getBillPayNeedsTANPayment()           ))
                OFX.append("getBillPayPostProcessingWindow() %s" %(service.getBillPayPostProcessingWindow()      ))
                OFX.append("getBillPayProcessingDaysOff()    %s" %(service.getBillPayProcessingDaysOff()         ))
                OFX.append("getBillPayProcessingEndTime()    %s" %(service.getBillPayProcessingEndTime()         ))
                OFX.append("getBillPaySupportsDifftFirstPmt()%s" %(service.getBillPaySupportsDifftFirstPmt()     ))
                OFX.append("getBillPaySupportsDifftLastPmt() %s" %(service.getBillPaySupportsDifftLastPmt()      ))
                OFX.append("getBillPaySupportsDtAvail()      %s" %(service.getBillPaySupportsDtAvail()           ))
                OFX.append("getBillPaySupportsPmtByAddr()    %s" %(service.getBillPaySupportsPmtByAddr()         ))
                OFX.append("getBillPaySupportsPmtByPayeeId() %s" %(service.getBillPaySupportsPmtByPayeeId()      ))
                OFX.append("getBillPaySupportsPmtByXfr()     %s" %(service.getBillPaySupportsPmtByXfr()          ))
                OFX.append("getBillPaySupportsStatusModRs()  %s" %(service.getBillPaySupportsStatusModRs()       ))
                OFX.append("getBillPayXfrDaysWith()          %s" %(service.getBillPayXfrDaysWith()               ))
                OFX.append("getBillPayXfrDefaultDaysToPay()  %s" %(service.getBillPayXfrDefaultDaysToPay()       ))
                OFX.append("getEmailSupportsGeneric()        %s" %(service.getEmailSupportsGeneric()             ))
                OFX.append("getEmailSupportsGetMime()        %s" %(service.getEmailSupportsGetMime()             ))
                OFX.append("getInvstCanDownloadBalances()    %s" %(service.getInvstCanDownloadBalances()         ))
                OFX.append("getInvstCanDownloadOOs()         %s" %(service.getInvstCanDownloadOOs()              ))
                OFX.append("getInvstCanDownloadPositions()   %s" %(service.getInvstCanDownloadPositions()        ))
                OFX.append("getInvstCanDownloadTxns()        %s" %(service.getInvstCanDownloadTxns()             ))
                OFX.append("getInvstCanEmail()               %s" %(service.getInvstCanEmail()                    ))
                OFX.append("getSecListCanDownloadSecurities()%s" %(service.getSecListCanDownloadSecurities()     ))

            OFX.append("")

            sortKeys=sorted(service.getParameterKeys())
            OFX.append(pad("Raw Parameter keys:",40))
            for x in sortKeys:
                OFX.append("%s %s" %(pad(x,40),service.getParameter(x,None)))

            OFX.append("\n------------------------------------------------------------------\n\n")

        OFX.append("\n<END>")
        for i in range(0, len(OFX)):
            OFX[i] = OFX[i] + "\n"
        OFX = "".join(OFX)

        # <WOW! Phew - we actually made it!>
        QuickJFrame("VIEW INSTALLED SERVICE / BANK LOGON PROFILES",OFX,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        return

    def load_help_file():
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        if u"__file__" not in globals():
            myPrint("DB", " __file__ not found in globals()")
            return None

        helpfile = os.path.splitext(__file__)[0]+"_readme.txt"
        if not os.path.exists(helpfile):
            myPrint("DB", " file: %s not found.." %(helpfile))
            return None

        try:
            fis = FileInputStream(File(helpfile))
        except:
            myPrint("DB", " Error opening file: %s .." %(helpfile))
            dump_sys_error_to_md_console_and_errorlog()
            return None

        return fis

    def display_help():

        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        localHelpFileStream = None                                                                                      # noqa
        stream = None                                                                                                   # noqa

        if MD_EXTENSION_LOADER is None:
            localHelpFileStream = load_help_file()
            if localHelpFileStream is None:
                if debug:
                    return "moneydance_extension_loader is None:\nInternal mxt and also local Help file not found (please run as extension)\n(note: feature only enabled from Moneydance build 3051 onwards)"
                else:
                    return "Internal mxt and also local Help file not found (please run as extension)\n(note: feature only enabled from Moneydance build 3051 onwards)"

        if MD_EXTENSION_LOADER is not None:
            stream = MD_EXTENSION_LOADER.getResourceAsStream("/%s_readme.txt" %(myModuleID))
            if stream is None:
                localHelpFileStream = load_help_file()
                if localHelpFileStream is None:
                    if debug:
                        return "getResourceAsStream() returned None:\nInternal mxt and also local Help file not found (please run as extension)"
                    else:
                        return "Internal mxt and also local Help file not found (please run as extension)"

        if stream is not None:
            myPrint("DB",".. loading help file from mxt internal stream")
            help_data = load_text_from_stream_file(stream)
        elif localHelpFileStream is not None:
            myPrint("DB",".. loading help file from local file stored with the .py file")
            help_data = load_text_from_stream_file(localHelpFileStream)
        else:
            if debug:
                return "all streams are None:\nInternal mxt and also local Help file not found (please run as extension)"
            else:
                return "Internal mxt and also local Help file not found (please run as extension)"

        return help_data

    # noinspection PyArgumentList
    class MyTxnSearchFilter(TxnSearch):

        def __init__(self,dateStart,dateEnd):
            super(TxnSearch, self).__init__()

            self.dateStart = dateStart
            self.dateEnd = dateEnd

        def matchesAll(self):                                                                                           # noqa
            return False

        def matches(self, txn):

            if txn.getDateInt() >= self.dateStart and txn.getDateInt() <= self.dateEnd:                                 # noqa
                return True
            return False

    class MyAcctFilter(AcctFilter):
        selectType = 0

        def __init__(self, selectType=0):
            self.selectType = selectType

        def matches(self, acct):
            if self.selectType == 0:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

            if self.selectType == 10:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

                if acct.getParameter("ofx_import_acct_num", None) is not None \
                        or acct.getParameter("ofx_import_remember_acct_num", None) is not None:
                    return True
                return False

            if self.selectType == 1:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.ROOT
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

            if self.selectType == 2:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.SECURITY: return True
                else: return False

            if self.selectType == 3:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.ROOT):
                    return False

            if self.selectType == 4:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.EXPENSE
                        or acct.getAccountType() == Account.AccountType.INCOME):
                    return False
                return True

            if self.selectType == 5:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            if self.selectType == 6:
                # if not (acct.getAccountType() == Account.AccountType.BANK
                #         or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                #         or acct.getAccountType() == Account.AccountType.LOAN
                #         or acct.getAccountType() == Account.AccountType.ASSET
                #         or acct.getAccountType() == Account.AccountType.ROOT
                #         or acct.getAccountType() == Account.AccountType.LIABILITY
                #         or acct.getAccountType() == Account.AccountType.INVESTMENT):
                #     return False
                return True

            if self.selectType == 7:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            if self.selectType == 8:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.EXPENSE
                        or acct.getAccountType() == Account.AccountType.INCOME):
                    return False
                return True

            if self.selectType == 9:
                # noinspection PyUnresolvedReferences
                if not acct.getAccountType() == Account.AccountType.SECURITY:
                    return False
                return True

            if self.selectType == 11:
                if acct.canDownloadTxns() and not acct.getAccountIsInactive():
                    return True
                else:
                    return False

            if self.selectType == 12:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.ROOT:
                    return True
                else:
                    return False

            if self.selectType == 13:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() != Account.AccountType.SECURITY: return False
                if not acct.getUsesAverageCost(): return False
                else: return True

            if self.selectType == 14:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() != Account.AccountType.SECURITY: return False
                if not acct.getUsesAverageCost():
                    return True
                else:
                    # Check for accounts using avg cost control with LOTS set....
                    txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTransactionsForAccount(acct)
                    for theTxn in txnSet:
                        if (InvestUtil.isSaleTransaction(theTxn.getParentTxn().getInvestTxnType())
                                and (theTxn.getParameter("cost_basis", None) is not None)):
                            myPrint("DB","MyAcctFilter: Account: %s Found LOT Tags %s" %(acct,theTxn.getParameter("cost_basis", None)))
                            return True

                # OK, No LOTs found on average cost controlled accounts.....
                return False

            if self.selectType == 15 or self.selectType == 16 or self.selectType == 17 or self.selectType == 18:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

                if self.selectType == 15:
                    x = MyGetDownloadedTxns(acct)
                    if x is not None and x.getTxnCount() >= 0:          # change to > 0 for only those with txns etc
                        return True
                elif self.selectType == 18:
                    x = MyGetDownloadedTxns(acct)
                    if x is not None and x.getTxnCount() >= 0:
                        return True
                elif self.selectType == 16:
                    x = MyGetOnlinePayees(acct)
                    if x is not None and x.getPayeeCount() >= 0:        # change to > 0 for only those with payees etc
                        return True
                elif self.selectType == 17:
                    x = MyGetOnlinePayments(acct)
                    if x is not None and x.getPaymentCount() >= 0:      # change to > 0 for only those with payments etc
                        return True

                return False

            if self.selectType == 19:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.SECURITY or acct.getAccountType() == Account.AccountType.ROOT: return False
                else: return True

            if self.selectType == 20:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY):
                    return False
                return True

            if self.selectType == 21:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.INVESTMENT
                        or acct.getAccountType() == Account.AccountType.LIABILITY):
                    return False

            # Security sub accounts for stock holdings
            if self.selectType == 22:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.SECURITY):
                    return False
                return True

            # Investment Accounts only
            if self.selectType == 23:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            # Security sub accounts for stock holdings where the relative currency is None - i.e. not properly linked to it's Security Master
            if self.selectType == 24:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.SECURITY):
                    return False
                acctCurr = acct.getCurrencyType()
                if (acctCurr is None or acctCurr.getCurrencyType() != CurrencyType.Type.SECURITY                        # noqa
                        or acct.getParameter("curr", None) is None or acct.getParameter("currid", None) is None):
                    return True
                return False

            # ALL
            if self.selectType == 25:
                return True

            if self.selectType == 26:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                else:
                    return True

            if (acct.getAccountOrParentIsInactive()): return False
            if (acct.getHideOnHomePage() and acct.getBalance() == 0): return False

            return True

    def MyGetOnlinePayees(theAcct):     # Use my version to prevent creation of default record(s)
        payeesListID = theAcct.getParameter("ol_payees_list_id", None)

        if payeesListID is not None:
            payeesObj = MD_REF.getCurrentAccount().getBook().getItemForID(payeesListID)    # type: SyncableItem
            if payeesObj is not None and isinstance(payeesObj, OnlinePayeeList):
                return payeesObj    # type: OnlinePayeeList

        # payees = OnlinePayeeList(MD_REF.getCurrentAccount().getBook())   # type: OnlinePayeeList
        # MD_REF.getCurrentAccount().getBook().logModifiedItem(payees)
        # theAcct.setOnlinePayees(payees)
        # return payees

        return None

    def MyGetOnlinePayments(theAcct):       # Use my version to prevent creation of default record(s)
        paymentsListID = theAcct.getParameter("ol_payments_list_id", None)
        if paymentsListID is not None:
            paymentsObj = MD_REF.getCurrentAccount().getBook().getItemForID(paymentsListID)      # type: SyncableItem
            if paymentsObj is not None and isinstance(paymentsObj, OnlinePaymentList):
                return paymentsObj  # type: OnlinePaymentList

        # payments = OnlinePaymentList(MD_REF.getCurrentAccount().getBook())   # type: OnlinePaymentList
        # MD_REF.getCurrentAccount().getBook().logModifiedItem(payments)
        # theAcct.setOnlinePayments(payments)
        # return payments

        return None

    def MyGetDownloadedTxns(theAcct):       # Use my version to prevent creation of default record(s)

        myID = theAcct.getParameter("id", None)
        defaultTxnsListID = myID + ".oltxns"

        if myID is not None and myID != "":
            defaultTxnList = MD_REF.getCurrentAccount().getBook().getItemForID(defaultTxnsListID)   # type: SyncableItem
            if defaultTxnList is not None and isinstance(defaultTxnList, OnlineTxnList):
                return defaultTxnList

        txnsListID = theAcct.getParameter("ol_txns_list_id", None)
        if txnsListID is None or txnsListID == "":
            if myID is not None and myID != "":
                txnsListID = defaultTxnsListID

        if txnsListID is not None and txnsListID != "":
            txnsObj = MD_REF.getCurrentAccount().getBook().getItemForID(txnsListID)              # type: SyncableItem
            if (txnsObj is not None and isinstance(txnsObj, OnlineTxnList)):
                return txnsObj

        # WE DON'T WANT TO DO THIS!
        # if myID is not None and myID != "":
        #     txns = OnlineTxnList(MD_REF.getCurrentAccount().getBook())                 # type: OnlineTxnList
        #     txns.setParameter("id", defaultTxnsListID)
        #     MD_REF.getCurrentAccount().getBook().logModifiedItem(txns)
        #     return txns
        #
        return None

    class ClipboardButtonAction(AbstractAction):

        def __init__(self, theString):
            self.theString = theString

        def actionPerformed(self, event):

            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            _THIS_METHOD_NAME = "DIAGNOSTIC OUTPUT"

            options = ["Copy the diagnostics to the Clipboard",
                       "Save the diagnostics to a text file",
                       "Print the diagnostics to your printer"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         _THIS_METHOD_NAME.upper(), "Select Option:",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                         options, None)
            if not selectedOption: return

            optionIndex = options.index(selectedOption)
            if optionIndex == 0:
                x = StringSelection(self.theString)
                Toolkit.getDefaultToolkit().getSystemClipboard().setContents(x, None)
                txt = "Contents of all text below copied to Clipboard.."
                setDisplayStatus(txt, "B")
                return

            if optionIndex == 1:
                saveOutputFile(toolbox_frame_, _THIS_METHOD_NAME.upper(), "toolbox_diagnostics.txt", self.theString)
                return

            if optionIndex == 2:
                printOutputFile(_callingClass=None, _theTitle=_THIS_METHOD_NAME.upper(), _theJText=None, _theString=self.theString)
                return

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    class ShowTheConsole(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):
            global debug

            myPrint("D","In ", inspect.currentframe().f_code.co_name, "()", "Event:", event)

            ConsoleWindow.showConsoleWindow(MD_REF.getUI())

            txt = "Standard Moneydance Console Window Launched...."
            setDisplayStatus(txt, "B")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    class CopyConsoleLogFileButtonAction(AbstractAction):

        def __init__(self, theFile): self.theFile = theFile

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            _theFileAsStr = safeStr(self.theFile)
            if not os.path.exists(_theFileAsStr):
                txt = "Sorry, the file does not seem to exist: %s" %(_theFileAsStr)
                setDisplayStatus(txt, "R")
                return

            theTitle = "Select location to copy Console Log file to... (CANCEL=ABORT)"
            theFileName = "copy_of_errlog.txt"
            copyToFile = getFileFromFileChooser(toolbox_frame_,     # Parent frame or None
                                                get_home_dir(),     # Starting path
                                                theFileName,        # Default Filename
                                                theTitle,           # Title
                                                False,              # Multi-file selection mode
                                                False,              # True for Open/Load, False for Save
                                                True,               # True = Files, else Dirs
                                                None,               # Load/Save button text, None for defaults
                                                "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=True,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

            if (copyToFile is None) or copyToFile == "":
                txt = "User did not select file location - no copy performed"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return
            elif not safeStr(copyToFile).endswith(".txt"):
                txt = "Sorry - please use a .txt file extension when copying  console log file"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return
            elif ".moneydance" in os.path.dirname(copyToFile):
                txt = "Sorry, please choose a location outside of the  Moneydance location"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return

            if not check_file_writable(copyToFile):
                txt = "Sorry, that file/location does not appear allowed by the operating system!?"
                setDisplayStatus(txt, "R")

            toFile = File(copyToFile)
            try:
                IOUtils.copy(self.theFile, toFile)
                myPrint("B", "%s copied to %s" %(_theFileAsStr, copyToFile))
                if os.path.exists(copyToFile):
                    play_the_money_sound()
                    txt = "Console Log file save as requested to: %s" %(copyToFile)
                    setDisplayStatus(txt, "B")
                else:
                    myPrint("B", "ERROR - failed to copy file %s to %s" %(_theFileAsStr, copyToFile))
                    txt = "Sorry, failed to save console log file?!"
                    setDisplayStatus(txt, "R")
            except:
                myPrint("B", "ERROR - failed to copy file %s to %s" %(_theFileAsStr, copyToFile))
                dump_sys_error_to_md_console_and_errorlog()
                txt = "Sorry, failed to save console log file?!"
                setDisplayStatus(txt, "R")

            return

    def display_pickle():
        global debug, myParameters

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if myParameters is None: myParameters = {}

        params = []
        for key in sorted(myParameters.keys()):
            params.append("Key: " + pad(safeStr(key),50) + " Type: " + pad(safeStr(type(myParameters[key])),20) + "Value: " + safeStr(myParameters[key]) + "\n")

        params.append("\n<END>")

        params = "".join(params)

        return params

    def can_I_delete_currency():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("B", "Analysing whether you can delete a Currency, or show where it's used....")
        myPrint("P", "------------------------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()

        currOutput = ""

        def accountHasCurrency(acct, curr):

            localOutput = ""

            currCount = 0

            if acct is None: return currCount

            for i in range(0,acct.getSubAccountCount()):

                subAcct = acct.getSubAccount(i)
                if subAcct.getCurrencyType() == curr:
                    currCount += 1
                    localOutput += ".. Account: %s Name: %s is using %s\n" %(subAcct.getAccountType(), subAcct.getFullAccountName(), curr)

                local_i, local_str = accountHasCurrency(subAcct, curr)
                currCount += local_i
                localOutput += local_str

                i+=1

            return currCount, localOutput

        currs = []

        for currency in allCurrencies:
            if currency.getCurrencyType() == CurrencyType.Type.CURRENCY:            # noqa
                currs.append(currency)

        currs = sorted(currs, key=lambda x: (x.getName().upper()))


        selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select Security", "Select the security to analyse",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       currs,
                                                       None)
        if selectedCurrency is None:
            txt = "No currency was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        currOutput += "\nYou want me to look for Currency: %s \n" %(selectedCurrency)

        myPrint("B", "Looking for Currency: %s %s" %(selectedCurrency, selectedCurrency.getName()) )                    # noqa

        base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

        lFailTests = False
        if selectedCurrency == base:
            lFailTests = True
            currOutput += "\n** Currency is set as the base - Deletion not possible!! **\n\n"

        foundCurrCount, outputBuild = accountHasCurrency(MD_REF.getCurrentAccount(), selectedCurrency)
        currOutput += outputBuild

        if foundCurrCount or lFailTests:
            txt = "Currency %s ** IS BEING USED ** - Deletion not possible!" %(selectedCurrency)
            currOutput += "\n%s\n" %(txt)
            myPrint("B",txt)
            setDisplayStatus(txt, "R")
        else:
            txt = "Currency %s is NOT being used - deletion should be possible...."  %(selectedCurrency)
            currOutput += "\n%s\n" %(txt)
            myPrint("B", txt)
            setDisplayStatus(txt, "B")

        currOutput += "\n<END>"

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return currOutput

    def can_I_delete_security():
        global toolbox_frame_, debug
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("B", "Script running to analyse whether you can delete a Security, or show where it's used....")
        myPrint("P", "----------------------------------------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        usageCount = 0
        sumShares = 0

        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()

        securities = []

        for currency in allCurrencies:
            # noinspection PyUnresolvedReferences
            if currency.getCurrencyType() == CurrencyType.Type.SECURITY:
                securities.append(currency)

        securities = sorted(securities, key=lambda x: (x.getName().upper()))

        selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select Security", "Select the security to analyse",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       securities,
                                                       None)
        if selectedSecurity is None:
            txt = "No security was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        output = "\nYou want me to look for Security: %s\n" %(selectedSecurity)

        accountsList = AccountUtil.allMatchesForSearch(book, MyAcctFilter(2))
        output += "Searching through %s security (sub) accounts.." % (len(accountsList)) + "\n"

        for account in accountsList:
            if account.getCurrencyType() == selectedSecurity:
                # noinspection PyUnresolvedReferences
                output += "   >> Security: %s is used in Account: %s - Share holding balance: %s" \
                          % (selectedSecurity, account.getParentAccount().getAccountName(),
                             selectedSecurity.getDoubleValue(account.getBalance())) + "\n"
                # noinspection PyUnresolvedReferences
                sumShares += selectedSecurity.getDoubleValue(account.getBalance())
                usageCount += 1

        if not usageCount:
            output += "   >> Security not found in any accounts.\n"

        output += "\nChecking security for price history...:\n"

        # noinspection PyUnresolvedReferences
        secSnapshots = selectedSecurity.getSnapshots()
        countPriceHistory = secSnapshots.size()
        if countPriceHistory > 0:
            output += "   >> Security has %s historical prices!" % (secSnapshots.size()) + "\n"
        else:
            output += "   >> Security has no historical prices. \n"

        output += "-----------------------------------------------------------------\n"
        if usageCount:
            output += "\nUSAGE FOUND: You are using security: %s in %s accounts!\n... with a share balance of: %s. These would need to be removed before security deletion" \
                      % (selectedSecurity, usageCount, sumShares) + "\n"
            myPrint("J", ">> NO - Security cannot be deleted as it's being used: %s" %(selectedSecurity))

        if countPriceHistory:
            output += "\nPRICE HISTORY FOUND: You have %s price records - If you delete Security then these will be lost..." \
                      % countPriceHistory + "\n"

        if not usageCount and not countPriceHistory:
            txt = "No usage of security %s found! You should be able to safely delete the Security" %(selectedSecurity)
        else:
            txt = "Sorry - usage of Security: %s found - refer to script output for details.." %(selectedSecurity)

        output += "\n%s\n" %(txt)
        setDisplayStatus(txt, "R")

        output += "\n<END>"
        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return output

    def list_security_currency_decimal_places():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("B", "Script is analysing your (hidden) Currency/Security decimal place settings...........")
        myPrint("P", "-------------------------------------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        iWarnings = 0
        myLen = 50

        decimalPoint_MD = MD_REF.getPreferences().getDecimalChar()

        currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()

        currs = sorted(currs, key=lambda x: safeStr(x.getName()).upper())

        output = "List Currency/Security (hidden) Decimal Places setting and related data:\n" \
                 " =======================================================================\n"

        output += "** NOTE: The hidden 'Decimal Places' (dpc) setting is set when you create a new Currency/Security.\n" \
                  "         - This can not normally be changed once set in the Moneydance menus.\n" \
                  "         - However - Toolbox extension has a menu feature to allow you to do this\n" \
                  "         - For a Currency, the dpc controls the decimal precision of both balances and stored values on transactions\n" \
                  "         - For a Security, the dpc controls ONLY the qty of shares/units held and it does NOT affect the stored dpc of prices/rates.\n" \
                  "\n"

        def get_curr_sec_name(curr_sec):
            if curr_sec.getName() is not None and len(curr_sec.getName().strip()) > 0:
                return curr_sec.getName()
            return (curr_sec.getIDString() + ":" + curr_sec.getIDString())

        def analyse_curr(theCurr, theType):
            output = ""                                                                                                 # noqa
            iWarn = 0
            for sec_curr in theCurr:
                if str(sec_curr.getCurrencyType()) != theType: continue

                foo = str(round(CurrencyUtil.getUserRate(sec_curr, sec_curr.getRelativeCurrency()), 30))
                priceDecimals = min(30, len(foo.split(decimalPoint_MD)[-1]))

                output += pad(get_curr_sec_name(sec_curr),myLen) + "\tDPC: " + \
                          str(sec_curr.getDecimalPlaces()) + \
                          "\t" + \
                          "Relative to: " + safeStr(sec_curr.getRelativeCurrency())[:20].ljust(20, " ") + \
                          "\t" + \
                          "Current rate: " + str(foo)[:20].ljust(20, " ") + \
                          "\tRate dpc: " + str(priceDecimals)

                # if (sec_curr.getDecimalPlaces() < priceDecimals and theType == "SECURITY") and \
                #         not foo.endswith(".0"):
                #     iWarn += 1
                #     output += " ***\n"
                # else:
                #     output += "\n"

                output += "\n"
            return iWarn, output

        output += " ==============\n"
        output += " --- SECURITIES ----\n"
        output += " ==============\n"

        result = analyse_curr(currs, "SECURITY")
        iWarnings += result[0]
        output += result[1]

        output += "\n" \
                  " ==============\n"
        output += " --- CURRENCIES ----\n"
        output += " ==============\n"
        result = analyse_curr(currs, "CURRENCY")
        iWarnings += result[0]
        output += result[1]

        output += "\n" \
                  "-----------------------------------------------------------------"
        output += "\n<END>"

        txt = "DIAG: Currency/Security Decimal Places report executed"
        setDisplayStatus(txt, "DG")

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return output

    def manually_edit_price_date_field():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (lAdvancedMode): return

        currencies = list_security_currency_price_date(autofix=False, justProvideFilter=True)
        if currencies is None:
            txt = "No Currency/Security filter option was selected.."
            setDisplayStatus(txt, "R")
            return

        currs = []
        for curr in currencies:
            currs.append(StoreCurrencySecurity(curr))

        selectedCurrSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Currency/Security to edit the current price hidden 'price_date' field:",
                                                      "Edit price_date - Select CURRENCY/SECURITY",
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                      currs,
                                                      None)
        if not selectedCurrSec:
            txt = "No Currency/Security was selected.."
            setDisplayStatus(txt, "R")
            return

        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
        if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD and not checkCurrencyRawRatesOK(selectedCurrSec.obj):                                                            # noqa
            txt = "@@ ERROR: Old format Currency record detected (empty relative rate). Please use 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to fix - No changes allowed!"
            setDisplayStatus(txt, "R")
            myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        currPriceDate = selectedCurrSec.obj.getLongParameter("price_date", 0L)                                          # noqa

        if currPriceDate > 0:
            theCurrentDatePretty = get_time_stamp_as_nice_text(currPriceDate)
        else:
            theCurrentDatePretty = "NOT SET"

        newestSnapshotDate = 0
        newestSnapshotPrice = 0
        relCurr = selectedCurrSec.obj.getRelativeCurrency()                                                             # noqa
        currentPrice = selectedCurrSec.obj.getRelativeRate()                                                            # noqa
        currSnapshots = selectedCurrSec.obj.getSnapshots()                                                              # noqa
        if len(currSnapshots)>0:
            newestSnapshotDate = currSnapshots[-1].getDateInt()
            newestSnapshotPrice = currSnapshots[-1].getRate()

        if newestSnapshotDate > 0:
            theLatestSnapshotDatePretty = "%s" %(convertStrippedIntDateFormattedText(newestSnapshotDate))
        else:
            theLatestSnapshotDatePretty = "NOT SET"

        if isGoodRate(newestSnapshotPrice):
            txtLatestSnapshotPrice = "%s" %(safeInvertRate(newestSnapshotPrice))
        else:
            txtLatestSnapshotPrice = "NOT SET"

        MyPopUpDialogBox(toolbox_frame_,
                         "FOR INFO: Currency/Security details:",
                         "Current price hidden 'price_date' is currently: %s\n"
                         "(which means: %s)\n"
                         "Latest dated price history date: %s\n"
                         "Current Price: %s\n"
                         "Latest Dated History Price: %s"
                         %(currPriceDate, theCurrentDatePretty, theLatestSnapshotDatePretty,safeInvertRate(currentPrice),txtLatestSnapshotPrice),
                         theTitle="MANUALLY EDIT HIDDEN PRICE_DATE FIELD").go()

        labelUpdateDate = JLabel("Select the new current price hidden 'price_date' (enter as yyyy/mm/dd):")
        user_selectDateStart = JDateField(CustomDateFormat("ymd"),15)   # Use MD API function (not std Python)
        if newestSnapshotDate > 0:
            user_selectDateStart.setDateInt(min(newestSnapshotDate,DateUtil.getStrippedDateInt()))
        else:
            user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())

        labelUpdatePrice = JLabel("Choose which current price to use (ie. existing price or latest history price")

        user_selectCurrentPrice = user_selectHistoryPrice = None
        if isGoodRate(newestSnapshotPrice):
            user_selectCurrentPrice = JRadioButton("Keep Current Price: %s" %(safeInvertRate(currentPrice)), True)
            user_selectHistoryPrice = JRadioButton("Switch to Latest History Price: %s" %(safeInvertRate(newestSnapshotPrice)), False)
            bg = ButtonGroup()
            bg.add(user_selectCurrentPrice)
            bg.add(user_selectHistoryPrice)

        datePanel = JPanel(GridLayout(0, 1))
        datePanel.add(labelUpdateDate)
        datePanel.add(user_selectDateStart)
        if isGoodRate(newestSnapshotPrice):
            datePanel.add(JLabel(""))
            datePanel.add(JLabel("----"))
            datePanel.add(labelUpdatePrice)
            datePanel.add(user_selectCurrentPrice)
            datePanel.add(user_selectHistoryPrice)

        options = ["Cancel", "OK"]

        userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                  datePanel,
                                                  "Enter new current price hidden 'price_date' / price/rate fields:",
                                                  JOptionPane.OK_CANCEL_OPTION,
                                                  JOptionPane.QUESTION_MESSAGE,
                                                  None,
                                                  options,
                                                  options[0])

        if userAction != 1:
            txt = "User cancelled entering a new current price hidden 'price_date' - exiting"
            setDisplayStatus(txt, "R")
            return

        if user_selectDateStart.getDateInt() < 20150101 or user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt():

            if user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt() \
                    and myPopupAskQuestion(toolbox_frame_,"Enter Future Date?","Do you really want to enter a future current price hidden 'price_date'?"):
                pass
            else:
                txt = "User cancelled by entering an invalid hidden price_date..."
                setDisplayStatus(txt, "R")
                return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"CURRENCY/SECURITY - UPDATE 'price_date'","Update the current price hidden 'price_date' field to %s?" %(user_selectDateStart.getDateInt())):
            return

        newDate = DateUtil.convertIntDateToLong(user_selectDateStart.getDateInt()).getTime()

        selectedCurrSec.obj.setEditingMode()                                                                            # noqa
        selectedCurrSec.obj.setParameter("price_date", newDate)                                                         # noqa
        if isGoodRate(newestSnapshotPrice) and user_selectHistoryPrice and user_selectHistoryPrice.isSelected():
            selectedCurrSec.obj.setRate(Util.safeRate(newestSnapshotPrice),relCurr)                                     # noqa
        selectedCurrSec.obj.syncItem()                                                                                  # noqa

        play_the_money_sound()
        _msg = "Edit of current price hidden 'price_date' field for curr/sec: %s successfully set to: %s (%s)" %(selectedCurrSec,newDate,user_selectDateStart.getDateInt())
        setDisplayStatus(_msg, "R")
        myPrint("B", _msg)
        if isGoodRate(newestSnapshotPrice) and user_selectHistoryPrice and user_selectHistoryPrice.isSelected():
            myPrint("B", "... current price also updated to: %s" %(safeInvertRate(newestSnapshotPrice)))
        myPopupInformationBox(toolbox_frame_,_msg,"Edit current price hidden 'price_date' field",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def checkCurrencyRawRatesOK(theCurr):

        # Check of 'rate' disabled as this is a legacy field and I no longer try to fix it.. Not required.. Especially since 2021.2 onwards

        # checkRate = theCurr.getParameter("rate", None)
        # checkRateDouble = theCurr.getDoubleParameter("rate", 0.0)

        # if checkRate is None or not isGoodRate(checkRateDouble):
        #     myPrint("DB", "WARNING: checkCurrencyRawRatesOK() 'rate' check failed on %s - checking stopped here" %(theCurr))
        #     return False

        checkRRate = theCurr.getParameter("rrate", None)
        checkRRateDouble = theCurr.getDoubleParameter("rrate", 0.0)

        if checkRRate is None or not isGoodRate(checkRRateDouble):
            myPrint("DB", "WARNING: checkCurrencyRawRatesOK() 'rrate' check failed on %s - checking stopped here" %(theCurr))
            return False

        return True

    def check_all_currency_raw_rates_ok(filterType=None):

        _currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for _curr in _currs:
            if filterType and _curr.getCurrencyType() != filterType: continue
            if not checkCurrencyRawRatesOK(_curr):
                return False

        return True

    def list_security_currency_price_date(autofix=False, justProvideFilter=False):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if justProvideFilter: autofix = False

        if MD_REF.getCurrentAccount().getBook() is None: return None

        listCurrs = []
        currs_to_fix = []

        lMustRunFixCurrenciesFirst = False

        if not justProvideFilter:
            myPrint("B", "Script is analysing your Currency & Security current price hidden 'price_date' fields...........")
            myPrint("P", " -----------------------------------------------------------------------------------------------")

            txt = "Current Price (Hidden) 'price_date' fix"
            if not perform_quote_loader_check(toolbox_frame_, txt): return


        options = ["All (both Currencies & Securities)",
                   "All - Shown on Summary Page Only",
                   "Currencies - All",
                   "Currencies - Shown on Summary Page Only",
                   "Securities - All",
                   "Securities - Shown on Summary Page Only",
                   "Securities - With holdings Only",
                   "All - include OK objects too"]

        displayText = ["REPORT OPTIONS (list objects with error)", "Select your report filters/options"]
        if justProvideFilter:
            displayText = ["EDIT OPTIONS (lists objects with errors)", "Select filters/options for Edit List"]

        selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                       displayText[0], displayText[1],
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       options,                                                         # noqa
                                                       None)

        if not selectedOption:
            if justProvideFilter: return None
            txt = "No report option was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        lAll = lSummaryScreenOnly = lCurrencyOnly = lSecurityOnly = lSecurityHoldings = lEverything = False
        optionIndex = options.index(selectedOption)
        if optionIndex in (0,1,7):  lAll = True
        if optionIndex in (2,3):    lCurrencyOnly = True
        if optionIndex in (4,5,6):  lSecurityOnly = True
        if optionIndex in (1,3,5):  lSummaryScreenOnly = True
        if optionIndex == 6:        lSecurityHoldings = True
        if optionIndex == 7:        lEverything = True

        iWarnings = 0

        currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        currs = sorted(currs, key=lambda x: (x.getCurrencyType(), x.getName().upper()))

        if justProvideFilter and lEverything: return currs

        output = "\nDiagnosing your Security / Currency's current price hidden 'price_date' fields (Normally showing errors only)\n" \
                 " ==============================================================================================================\n\n"

        def get_curr_sec_name(curr_sec):
            if curr_sec.getName() is not None and len(curr_sec.getName().strip()) > 0:
                return curr_sec.getName()
            return (curr_sec.getIDString() + ":" + curr_sec.getIDString())

        MD_decimal = MD_REF.getPreferences().getDecimalChar()
        base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

        def analyse_curr(theCurr, theType):
            output = ""                                                                                                 # noqa
            iWarn = 0
            _lMustRunFixCurrenciesFirst = False
            nowTimeMS = System.currentTimeMillis()
            intNowTime = DateUtil.convertLongDateToInt(nowTimeMS)

            for sec_curr in theCurr:
                if sec_curr == base: continue
                if sec_curr.getCurrencyType() != theType: continue
                if lSummaryScreenOnly and sec_curr.getHideInUI(): continue

                qtyHeld = 0
                if sec_curr.getCurrencyType() == CurrencyType.Type.SECURITY:                                            # noqa
                    qtyHeld = get_security_holdings(sec_curr)
                    if lSecurityHoldings and qtyHeld == 0: continue

                currPriceDate = sec_curr.getLongParameter("price_date", 0L)

                newestRate = newestSnapshotDate = intLatestSnapDate = 0
                currSnapshots = sec_curr.getSnapshots()
                snap = None
                if len(currSnapshots)>0:
                    snap = currSnapshots[-1]
                    newestRate = snap.getRate()
                    intLatestSnapDate = newestSnapshotDate = snap.getDateInt()

                if newestSnapshotDate > 0:
                    newestSnapshotDate = DateUtil.convertIntDateToLong(newestSnapshotDate)

                lSkip = False
                if currPriceDate < 1:
                    lSkip = True
                else:
                    if newestSnapshotDate > 0:
                        if (DateUtil.convertDateToInt(newestSnapshotDate) <= DateUtil.convertLongDateToInt(nowTimeMS)
                                and DateUtil.convertLongDateToInt(currPriceDate) <= DateUtil.convertLongDateToInt(nowTimeMS)
                                and DateUtil.convertLongDateToInt(currPriceDate) == DateUtil.convertDateToInt(newestSnapshotDate)):
                            lSkip = True
                    else:
                        if DateUtil.convertLongDateToInt(currPriceDate) <= DateUtil.convertLongDateToInt(nowTimeMS):
                            lSkip = True

                if not lEverything and lSkip: continue

                if justProvideFilter:
                    listCurrs.append(sec_curr)
                    continue

                if lEverything and not lSkip:
                    output += "** "

                output += "{}".format(get_curr_sec_name(sec_curr))
                if sec_curr.getCurrencyType() == CurrencyType.Type.SECURITY:                                            # noqa
                    output += " ({}:{})".format(sec_curr.getTickerSymbol(),sec_curr.getIDString())
                    if qtyHeld != 0:
                        output += "\tQty Held: {}".format(sec_curr.formatSemiFancy(qtyHeld, MD_decimal))
                else:
                    output += " ({})".format(sec_curr.getIDString())

                if lSkip:
                    if currPriceDate < 1:
                        niceDate = "NOT SET"
                    else:
                        niceDate = get_time_stamp_as_nice_text(currPriceDate)
                    output += " - OK (price_date = %s)\n\n" %(niceDate)
                    continue

                lUpdateRequired = False
                output += "\nprice_date (%s) = %s\n" %(currPriceDate,get_time_stamp_as_nice_text(currPriceDate))

                if DateUtil.convertLongDateToInt(currPriceDate) > DateUtil.convertLongDateToInt(nowTimeMS):
                    lUpdateRequired = True
                    output += "@@ WARNING: Your current price hidden 'price_date' field is future dated! **\n"

                if DateUtil.convertLongDateToInt(currPriceDate) < DateUtil.convertDateToInt(newestSnapshotDate):
                    output += "@@ WARNING: Your current price hidden 'price_date' field is older than latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                    if DateUtil.convertLongDateToInt(currPriceDate) < DateUtil.convertLongDateToInt(nowTimeMS):
                        lUpdateRequired = True

                if newestSnapshotDate > 0 and (DateUtil.convertDateToInt(newestSnapshotDate) > DateUtil.convertLongDateToInt(nowTimeMS)):
                    output += "@@ WARNING: Your price history date(s) are future dated! **\n"
                    output += "... latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                if newestSnapshotDate > 0 and (DateUtil.convertLongDateToInt(currPriceDate) > DateUtil.convertDateToInt(newestSnapshotDate)):
                    lUpdateRequired = True
                    output += "@@ WARNING: current price hidden 'price_date' field is newer than your latest dated price history date....\n"
                    output += "... latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                if not isGoodRate(sec_curr.getRelativeRate()):
                    output += "@@ WARNING: current price/rate is not a valid number: %s\n" %(sec_curr.getRelativeRate())

                if snap and not isGoodRate(snap.getRate()):
                    output += "@@ WARNING: Latest dated price history price/rate is not a valid number: %s\n" %(snap.getRate())

                if lUpdateRequired and snap and sec_curr.getRelativeRate() != snap.getRate():
                    output +=  "... current price/rate %s, latest dated price history price/rate %s\n" %(safeInvertRate(sec_curr.getRelativeRate()), safeInvertRate(snap.getRate()))

                if lUpdateRequired:
                    # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
                    if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD and not checkCurrencyRawRatesOK(sec_curr):
                        output += "@@@ ERROR: Currency object has an old underlying format (empty 'rate' / 'rrate' fields); please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to fix (skipping....) @@@\n"
                        _lMustRunFixCurrenciesFirst = True
                        lUpdateRequired = False

                iWarn += 1
                output += "\n\n"

                if autofix:
                    if not lSkip and snap and lUpdateRequired and currPriceDate > 0 and intLatestSnapDate > 0:
                        relCurr = sec_curr.getRelativeCurrency()
                        currs_to_fix.append([sec_curr,
                                             DateUtil.convertIntDateToLong(min(intNowTime,intLatestSnapDate)).getTime(),
                                             Util.safeRate(newestRate),
                                             relCurr])

            return iWarn, output, _lMustRunFixCurrenciesFirst

        if lAll or lSecurityOnly:
            output += " ===================\n"
            output += " --- SECURITIES ----\n"
            output += " ===================\n"

            # noinspection PyUnresolvedReferences
            result = analyse_curr(currs, CurrencyType.Type.SECURITY)
            iWarnings += result[0]
            output += result[1]
            if result[2]: lMustRunFixCurrenciesFirst = True

        if lAll or lCurrencyOnly:
            output += " ===================\n"
            output += " --- CURRENCIES ----\n"
            output += " ===================\n"

            # noinspection PyUnresolvedReferences
            result = analyse_curr(currs, CurrencyType.Type.CURRENCY)
            iWarnings += result[0]
            output += result[1]
            if result[2]: lMustRunFixCurrenciesFirst = True

        if justProvideFilter: return listCurrs

        output += "-----------------------------------------------------------------"
        if iWarnings:
            output += "\nYou have %s Warning(s)..\n" % iWarnings
            output += "These are where your current price hidden 'price_date' field is future dated, or newer/older than your latest dated price history date\n"
            if not autofix:
                output += "To Fix a Warning use Advanced Mode, MENU: FIX: Manually edit a currency/ security's current price hidden 'price_date' field (will also allow you to fix the current price/rate)\n" \
                          "or consider using FIX: Diagnose then fix your currency / security's current price hidden 'price_date' field (along with the current price/rate)\n"
            _msg = "price_date: You have %s Warning(s).. Refer diagnostic file..." %(iWarnings)
            setDisplayStatus(_msg, "R")
            myPrint("J", _msg)
        else:
            _msg = "All good, current price hidden 'price_date' looks clean! Congratulations!"
            output += "\n%s\n" %(_msg)
            myPrint("J", _msg)
            setDisplayStatus(_msg, "DG")

        output += "\n\n\nReport Parameters:\n"
        output += "All (Both Securities and Currencies): %s\n" %(lAll)
        output += "Securities Only:                      %s\n" %(lSecurityOnly)
        output += "Currencies Only:                      %s\n" %(lCurrencyOnly)
        output += "Shown on Summary Page Only Filter:    %s\n" %(lSummaryScreenOnly)
        output += "Securities with Holdings Only Filter: %s\n" %(lSecurityHoldings)
        output += "All including OK Objects too:         %s\n" %(lEverything)
        output += "-----------------------------------------------------------------\n"

        if not autofix: output += "\n<END>"

        jif = QuickJFrame("DIAGNOSE SECURITY/CURRENCY CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD(S)", output, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if lMustRunFixCurrenciesFirst:
            txt = "@@ ERROR: old format Currency record(s) detected (review output). Consider running Fix relative currencies option @@"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not autofix: return

        if len(currs_to_fix) < 1:
            myPopupInformationBox(jif,"There are no warnings to fix / can be fixed - will exit without changes","AUTOFIX HIDDEN CURRENT PRICE 'PRICE_DATE' FIELD")
            return

        MyPopUpDialogBox(jif,
                         "Proceed to autofix?",
                         "At the next screen you will be asked whether to proceed with the change(s), to backup, and to accept the disclaimer\n"
                         "Clicking YES will fix all the WARNINGS identified/displayed.\n"
                         "It will also then ask you whether you wish to update any Current Prices if they are different from the Last Dated History Price.\n",
                         theTitle="HIDDEN PRICE DATE FIELD AUTOFIX",
                         OKButtonText="NEXT STEP").go()

        if not confirm_backup_confirm_disclaimer(jif, "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELDS",
                                                 "EXECUTE AUTOFIX on %s CURRENCY/SECURITY HIDDEN 'PRICE_DATE' RECORDS?" %(len(currs_to_fix))):
            return

        lUpdatePricesToo = myPopupAskQuestion(jif,"AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELDS","Shall I update the current price(s) to match the latest price history at the same time?")

        jif.dispose()

        myPrint("B","AUTOFIX Currency / Security current price hidden 'price_date' fields running on %s records..." %(len(currs_to_fix)))
        output += "\n\n\nAUTOFIX log....\n ===============\n\n"

        txt = "AUTOFIX: User Response: Update current price to match latest dated history price too: %s" %(lUpdatePricesToo)
        myPrint("B",txt)
        output += ("\n" + txt + "\n\n")

        _CURRS_FIX_CURR = 0
        _CURRS_FIX_DATE = 1
        _CURRS_FIX_NEWRATE = 2
        _CURRS_FIX_RELCURR = 3

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for fix_reqd in currs_to_fix:
            curr = fix_reqd[_CURRS_FIX_CURR]
            newDateLong = fix_reqd[_CURRS_FIX_DATE]
            newRate = fix_reqd[_CURRS_FIX_NEWRATE]
            rCurr = fix_reqd[_CURRS_FIX_RELCURR]
            oldRate = curr.getRelativeRate()

            lUpdateThisPrice = lUpdatePricesToo
            if newRate == 0 or newRate == oldRate or not isGoodRate(newRate):
                lUpdateThisPrice = False

            myPrint("B","")
            myPrint("B", "@@ FIXING: %s (relative curr: %s)." %(curr, rCurr))
            output += ("@@ FIXING: %s (relative curr: %s).\n" %(curr, rCurr))

            myPrint("B", "...Updating current price hidden 'price_date' to %s" %(get_time_stamp_as_nice_text(newDateLong)))
            output += ("...Updating current price hidden 'price_date' to %s\n" %(get_time_stamp_as_nice_text(newDateLong)))

            if lUpdateThisPrice:
                myPrint("B", "...Updating current rate from %s to %s" %(safeInvertRate(oldRate), safeInvertRate(newRate)))
                output += ("...Updating current rate from %s to %s\n" %(safeInvertRate(oldRate), safeInvertRate(newRate)))

            myPrint("B","")
            output += "\n"

            curr.setEditingMode()
            curr.setParameter("price_date", newDateLong)
            if lUpdateThisPrice:
                curr.setRate(Util.safeRate(newRate),rCurr)
            curr.syncItem()

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "AUTOFIX: %s records updated" %(len(currs_to_fix))
        myPrint("B",txt)
        output += txt
        output += "\n<END>\n"

        jif = QuickJFrame("AUTOFIX SECURITY/CURRENCY CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD(S)", output,
                          copyToClipboard=lCopyAllToClipBoard_TB, lQuitMDAfterClose=True).show_the_frame()

        _msg = "AUTOFIX: %s records fixed" %(len(currs_to_fix))
        setDisplayStatus(_msg, "DG")
        play_the_money_sound()
        myPopupInformationBox(jif,_msg,"AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD")

        myPopupInformationBox(jif,"RESTART OF MONEYDANCE REQUIRED - MD WILL QUIT AFTER VIEWING THIS OUTPUT",
                              "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD",
                              theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def read_preferences_file(lSaveFirst=False):

        cf = Common.getPreferencesFile()

        if lSaveFirst:
            MD_REF.savePreferences()

        try:
            st = StreamTable()
            st.readFromFile(str(cf))
            tk = st.getKeyArray()
            tk = sorted(tk)
        except:
            st, tk = None, None
            dump_sys_error_to_md_console_and_errorlog()

        return st,tk

    def check_for_window_display_data( theKey, theValue ):

        if not isinstance(theValue, (str,unicode)):             return False
        if theKey.startswith("gui.current_theme"):              return False
        if theKey.startswith("gui.dashboard.item"):             return False
        if theKey.startswith("gui.font_increment"):             return False
        if theKey.startswith("gui.new_txn_on_record"):          return False
        if theKey.startswith("gui.quickdecimal"):               return False
        if theKey.startswith("gui.register_follows_txns"):      return False
        if theKey.startswith("gui.show_all_accts_in_popup"):    return False
        if theKey.startswith("gui.source_list_visible"):        return False

        # Preferences Home Screen options
        if theKey.startswith("gui.home.lefties"):               return False
        if theKey.startswith("gui.home.righties"):              return False
        if theKey.startswith("gui.home.unused"):                return False

        if not (theKey.startswith("ext_mgmt_win")
                or theKey.startswith("moneybot_py_divider")
                or theKey.startswith("mbot.loc")
                or theKey.startswith("gui.")
                or theKey.endswith("rec_reg.credit")
                or theKey.endswith("rec_reg.debit")
                or "col_widths." in theKey
                or ("sel_" in theKey and theKey.endswith("_filter"))
                or "sel_inv_view" in theKey):
            return False

        if not ("window" in theKey
                or "win_loc" in theKey
                or "width" in theKey
                or "isopen" in theKey
                or "winloc" in theKey
                or "winsize" in theKey
                or "winsz" in theKey
                or "divider" in theKey
                or "location" in theKey
                or "size" in theKey
                or "rec_reg.credit" in theKey
                or "rec_reg.debit" in theKey
                or "mbot.loc" in theKey
                or "_expanded" in theKey
                or "_filter" in theKey
                or "maximized" in theKey
                or "sel_inv_view" in theKey):
            return False

        return True

    def check_for_just_locations_window_display_data( theKey, theValue ):

        # Assumes you have called check_for_window_display_data() first!

        # Locations are  number x number - e.g. 10x100
        if "x" not in theValue.lower(): return False

        if not ("win_loc" in theKey
                or "winloc" in theKey
                or "location" in theKey
                or "mbot.loc" in theKey):
            return False

        return True

    # noinspection PyUnusedLocal
    def check_for_just_register_filters_window_display_data( theKey, theValue ):

        # Assumes you have called check_for_window_display_data() first!

        if  not ("sel_" in theKey and theKey.endswith("_filter") ):
            return False

        return True

    # noinspection PyUnusedLocal
    def check_for_just_initial_view_filters_window_display_data( theKey, theValue ):

        if  not ("sel_" in theKey and theKey.endswith("_view") ):
            return False

        return True

    # copied from Moneydance TxnRegister.class
    def loadMDPreferences(dataObject,  preferencesKey, lGetDefaultForObject=True):   # dataObject should always = Account.

        preferencesKey = preferencesKey

        if not preferencesKey:
            dataPrefKey = "col_widths"
        else:
            dataPrefKey = "col_widths." + preferencesKey

        colWidthPrefs = None

        if dataObject:
            colWidthPrefs = dataObject.getPreference(dataPrefKey, None)

        if not lGetDefaultForObject and dataObject and not colWidthPrefs: return None

        if StringUtils.isBlank(colWidthPrefs) and preferencesKey:
            colWidthPrefs = MD_REF.getUI().getPreferences().getSetting(dataPrefKey, None)

        if not colWidthPrefs or StringUtils.isBlank(colWidthPrefs):
            return None

        if not colWidthPrefs.startswith(":"):
            colWidthPrefs = ":" + colWidthPrefs

        params = SyncRecord()
        try:
            params.readSet(StringReader(colWidthPrefs))
        except IOException:
            myPrint("B", "Error parsing register settings: " + colWidthPrefs + " key=" + preferencesKey)
            return None

        widths = params.getIntArray("cols")                                                     # int[]

        if params.getBoolean("splitreg", False):
            splitReg = True
            splitSz = Dimension(10, Math.max(0, params.getInt("splitsz", 100)))                   # Dimension
        else:
            splitSz = None
            splitReg = False

        ascending = params.getBoolean("ascending", True)
        sortID = TxnSortOrder.fromInt(params.getInt("sort", -1), ascending)                     # TxnSortOrder

        if sortID:
            pass

        oneLineMode = params.getBoolean("oneline", False)                                     # boolean

        position = params.getString("position", params.getString("offset", None))               # String
        if position:
            pass

        position2 = params.getString("position2", params.getString("offset2", None))            # String
        if position2:
            pass

        theUUID = None
        if dataObject: theUUID = dataObject.getUUID()

        if debug:
            myPrint("D","Object: ", dataObject, theUUID)
            myPrint("D","Analysing the key: %s" %preferencesKey)
            myPrint("D",":oneline:", oneLineMode, type(oneLineMode))
            myPrint("D","splitreg:", splitReg, type(splitReg))
            myPrint("D","splitsz:", splitSz, type(splitSz))
            myPrint("D","sort:", sortID, type(sortID))
            myPrint("D","position:", position, type(position))
            myPrint("D","ascending:", ascending, type(ascending))
            myPrint("D","cols:", widths, type(widths))
            myPrint("D","position2:", position2, type(position2))

        return [oneLineMode, splitReg, splitSz, sortID, position, ascending, widths, position2]

    def extract_StuWareSoftSystems_version(theVersionToCheck):

        _MAJOR = 0
        _MINOR = 1

        theVersionToCheck = str(theVersionToCheck).strip()

        if len(theVersionToCheck) < 1: return [0,0]

        if len(theVersionToCheck) == 1: return [int(theVersionToCheck),0]

        if "." in theVersionToCheck:
            x = theVersionToCheck.split(".")
            return [int(x[0]),x[1]]

        major = minor = ""

        for char in theVersionToCheck:
            if (not minor) and (char >= "0" and char <= "9"): # noqa
                major += char
                continue
            minor+=char

        if debug:
            myPrint("D","Decoded: %s.%s" %(major,minor))

        try:
            return [int(major),minor]
        except:
            return [0,0]

    def check_for_updatable_extensions_on_startup():
        global lIgnoreOutdatedExtensions_TB

        Toolbox_version = 0

        displayData = u"\nALERT INFORMATION ABOUT YOUR EXTENSIONS:\n\n"

        try:
            theUpdateList = get_extension_update_info()

            if not theUpdateList or len(theUpdateList)<1:
                return Toolbox_version

            for key in theUpdateList.keys():
                updateInfo = theUpdateList[key]
                displayData+=u"** UPGRADEABLE EXTENSION: %s to version: %s\n" %(pad(key,20),(updateInfo[0].getBuild()))
                myPrint(u"B", u"** UPGRADEABLE EXTENSION: %s to version: %s" %(pad(key,20),(updateInfo[0].getBuild())))
                if key.lower() == u"%s" %myModuleID and int(updateInfo[0].getBuild()) > 0:
                    Toolbox_version = int(updateInfo[0].getBuild())
        except:
            dump_sys_error_to_md_console_and_errorlog()
            return Toolbox_version

        displayData+=u"\n<END>\n"

        howMany = int(len(theUpdateList))

        if not lIgnoreOutdatedExtensions_TB:
            txt = u"ALERT - YOU HAVE %s EXTENSION(S) THAT CAN BE UPGRADED!..." %(howMany)
            setDisplayStatus(txt, "B")
            jif = QuickJFrame(u"EXTENSIONS ALERT!", displayData, 1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            options=[u"OK (keep reminding me)",u"OK - DON'T TELL ME AGAIN ON STARTUP!"]
            response = JOptionPane.showOptionDialog(jif,
                                                    u"INFO: You have %s older Extensions that can be upgraded" %howMany,
                                                    u"OUTDATED EXTENSIONS",
                                                    0,
                                                    JOptionPane.QUESTION_MESSAGE,
                                                    None,
                                                    options,
                                                    options[0])

            if response:
                myPrint(u"B",u"User requested to ignore Outdated warning extensions going forward..... Acknowledged!!")
                lIgnoreOutdatedExtensions_TB = True
        else:
            txt = u"ALERT - YOU HAVE %s EXTENSION(S) THAT CAN BE UPGRADED!...STARTUP POPUP WARNINGS SUPPRESSED (by you)" %(howMany)
            setDisplayStatus(txt, "B")

        return Toolbox_version

    def check_for_old_StuWareSoftSystems_scripts():
        global lPickle_version_warning, myParameters, i_am_an_extension_so_run_headless, debug
        global MYPYTHON_DOWNLOAD_URL

        lVersionWarning = False

        if not myParameters and not lPickle_version_warning:
            return

        displayData = "\nStuWareSoftSystems: ALERT INFORMATION ABOUT SCRIPTS:\n\n"

        if lPickle_version_warning:
            displayData += "I detected an older (encrypted) version of saved parameter file for use with my Python scripts\n"
            displayData += ".... but no problem, I have updated / converted it.\n\n"

        _MAJOR = 0
        _MINOR = 1
        iCountOldScripts = 0

        if myParameters:

            for key in sorted(myParameters.keys()):
                if key.startswith("__") and key != "__Author":
                    myPrint("DB","Decoding old script versions for key: %s version_build: %s" %(key,myParameters[key]))
                    theVersion = extract_StuWareSoftSystems_version(myParameters[key])
                    if key == "__extract_currency_history_csv":
                        if theVersion[_MAJOR] <  1000:
                            pass
                        else: continue
                    elif key.lower() == "__StockGlance2020".lower():
                        if theVersion[_MAJOR] <  1000:
                            pass
                        else: continue
                    elif key == "__extract_reminders_to_csv":     # Old key - renamed... but see if it's around....
                        if theVersion[_MAJOR] <  1000:
                            pass
                        else: continue
                    elif key == "__extract_reminders_csv":
                        if theVersion[_MAJOR] <  1000:
                            pass
                        else: continue
                    elif key == "__extract_investment_transactions":
                        if theVersion[_MAJOR] <  1000:
                            pass
                        else: continue
                    else: continue
                    displayData+="ALERT: Script: %s is out of date - you have version_build: %s_%s\n" %(key,theVersion[_MAJOR],theVersion[_MINOR])
                    myPrint("DB", "Script %s is out of date - PLEASE UPDATE"%key)
                    iCountOldScripts+=1
                    lVersionWarning = True


        if lPickle_version_warning or lVersionWarning:
            displayData+="""

The current versions are available as Extensions from the MD Menu >> Manage Extensions.... 

NOTE: extract_data is a consolidation of all prior extract scripts - including:
- stockglance2020.py:                     
- extract_reminders_csv.py:               
- extract_currency_history_csv.py:        
- extract_investment_transactions_csv.py: 
- extract_account_registers_csv           

Please update any that you use before proceeding....
"""

            jif = QuickJFrame("StuWareSoftSystems - Scripts alert!", displayData, 1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            txt = "PLEASE UPDATE OLDER VERSIONS OF STUWARESOFTSYSTEMS SCRIPTS!..."
            setDisplayStatus(txt, "B")

            myPopupInformationBox(jif, "You have %s older StuWareSoftSystems scripts - please upgrade them!" %(iCountOldScripts), "STUWARESOFTSYSTEMS' SCRIPTS", JOptionPane.WARNING_MESSAGE)

        return

    def find_the_program_install_dir():

        theDir = ""     # noqa

        if Platform.isOSX():
            # Derive from these - not great, but OK: java.home, java.library.path, sun.boot.library.path

            test = System.getProperty("java.home","").strip()
            _i = test.lower().find(".app/")                                                                             # noqa
            if _i > 0:
                theDir = test[:_i+4]
            else:
                theDir = System.getProperty("install4j.exeDir","").strip()
        else:
            theDir = System.getProperty("install4j.exeDir","").strip()

        if not os.path.exists(theDir):
            theDir = ""

        return theDir

    def get_orphaned_extension():

        extension_prefs = MD_REF.getUI().getPreferences().getTableSetting("gen.fmodules",StreamTable())

        # Get all keys in config dict
        st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
        confirmed_extn_keys = {}
        for theKey in tk:
            if not theKey.lower().startswith("confirmedext."):
                continue    # skip
            confirmed_extn_keys[theKey.split('.')[1].lower().strip()]  = theKey

        outdated={}
        if float(MD_REF.getBuild()) < 3051:
            # .getOutdatedExtensionIDs() name changed prior to 3051
            x = MD_REF.getOutdatedExtensionIDs()                                                                        # noqa
        else:
            x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
        for y in x: outdated[y.lower().strip()] = True

        ok={}
        x = MD_REF.getLoadedModules()
        for y in x: ok[str(y.getIDStr()).lower().strip()] = True
        x = MD_REF.getSuppressedExtensionIDs()
        for y in x: ok[str(y).lower().strip()] = True

        orphan_outdated_prefs = {}
        for extn_pref in extension_prefs:
            if not ok.get(extn_pref.lower().strip()) and not outdated.get(extn_pref.lower().strip()):
                orphan_outdated_prefs[extn_pref] = "ORPHAN"
            elif outdated.get(extn_pref.lower().strip()):
                orphan_outdated_prefs[extn_pref] = "OUTDATED"

        orphan_confirmed_extn_keys = {}
        for extn_pref in confirmed_extn_keys:
            if not ok.get(extn_pref.lower().strip()) and not outdated.get(extn_pref.lower().strip()):
                orphan_confirmed_extn_keys[extn_pref] = ["ORPHAN",confirmed_extn_keys.get(extn_pref.lower().strip())]
            elif outdated.get(extn_pref.lower().strip()):
                orphan_confirmed_extn_keys[extn_pref] = ["OUTDATED",confirmed_extn_keys.get(extn_pref.lower().strip())]

        orphan_outdated_files={}
        extn_files_found=[]

        extensionDir = Common.getFeatureModulesDirectory()
        if extensionDir:
            # noinspection PyTypeChecker
            for root, dirs, files in os.walk(extensionDir.getAbsolutePath()):
                for filename in files:
                    for extn in ModuleLoader.FEATURE_MODULE_EXTENSIONS:
                        if filename.endswith("."+extn):
                            # got an Extension
                            extn_files_found.append([os.path.splitext(filename)[0].lower().strip(),filename])
                            pass

        for extn_file in extn_files_found:
            if not ok.get(extn_file[0]):
                if outdated.get(extn_file[0]):
                    orphan_outdated_files[extn_file[0]] = ["OUTDATED",extn_file[1]]
                else:
                    orphan_outdated_files[extn_file[0]] = ["ORPHAN",extn_file[1]]

        myPrint("DB","OK Extensions:", ok)
        myPrint("DB","OUTDATED: Extensions:", outdated)
        myPrint("DB","ORPHAN/OUTDATED Extension Preferences:", orphan_outdated_prefs)
        myPrint("DB","ORPHAN/OUTDATED Extension Files:", orphan_outdated_files)
        return [orphan_outdated_prefs, orphan_outdated_files, orphan_confirmed_extn_keys]

    # noinspection PyUnresolvedReferences
    def diagnose_currencies(lFix=False):

        # MD2017.10 backwards did not use the 'rrate' parameter. It only used 'rate'
        # 'rate' was the raw rate expressed as a factor of the difference in decimal places relative to the base currency.
        # From MD2019 onwards, the 'relative' currency setup changed and 'rrate' was created. 'rrate' stored the actual rate.
        # It was supposed to be the case that MD2019+ would see the missing 'rrate' field and convert the legacy rate in memory
        # Even though new 'rrate' was now in memory (in a variable), the data was not stored back to the parameter 'rrate', and was always missing
        # Once you actually edited a price using Tools/Currencies, then the new 'rrate' parameter would be created...
        # BUT, there is a bug and in fact as well as the new 'rrate' the old 'rate' was changed too. So, backwards compatibility to 2017 was lost.

        # Example: Stock: Price 6.25 Old 'rate' was stored as 16 (2dpc) in MD2017. In MD2019 new 'rrate' is 0.16.
        # Old 'rate' was supposed to always stay as 16, but once edited in MD2019 it became 0.16 too (BUG).
        # This does not matter for MD2019 onwards as it's legacy and ignored.
        # However, if you go back to MD2017, then you will see your Current Price become 625 as 'rate' is now wrong....
        # Also, if you use the edit decimal places function in Toolbox, then you will also have a rate dpc issue if you go back to 2017.

        # There was another bug, in that if you edited any part of the CurrencyType record where the 'rrate' was missing,
        # then .itemWasUpdated() would run and reload the new rate in memory (from 'rrate') which was missing. This then corrupted the rate
        # This was addressed in MD2021.2(3089), and .itemWillSync() was changed so that 'rrate' parameter is set (in memory) if missing.
        # It appears that upon opening a dataset in MD2021.2(3089) onwards, that this change updates all missing rrate parameters in memory.....
        # These in memory changes are not saved by calling .syncIntem(), thus they only exist in memory unless a subsequent update is made and .syncItem() called
        # .... so the change does not exist in trunk or any .txn file until a subsequent change..
        # And so, updating the record in MD2021.2(3089) onwards is not an issue.
        # I'm assuming as these are not sync'd that sync copies must also run the matching MD version and will self-apply the same in memory fixes...

        # Given this knowledge, I have disabled any updates to legacy 'rate', and I now only touch 'rrate'.
        # MD can do whatever it wants (rightly or wrongly to 'rate')
        # I would expect that this fix utility will now only find relative rate errors not rate/rrate errors from MD2021.1(3089)+

        # Other notes:
        # Currencies can only be relative to base (and should be set to None)
        # Securities should be set to Base (as None), or can be relative to another Currency (not Security)
        # Max relative relational depth is SEC>CURR>Base or CURR>Base

        global fixRCurrencyCheck
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "Diagnose currencies / securities (including relative currencies)"
        if lFix: _THIS_METHOD_NAME = "FIX currencies / securities (including relative currencies)"

        PARAM_RATE = "rate"
        PARAM_RRATE = "rrate"
        PARAM_REL_CURR_ID = "rel_curr_id"
        PARAM_RELATIVE_TO_CURRID = "relative_to_currid"

        # reset_relative_currencies.py
        myPrint("B", "Script running to %s ..............." %(_THIS_METHOD_NAME))

        if MD_REF.getCurrentAccount().getBook() is None: return

        VERBOSE = True
        lFixErrors = lFixWarnings = False
        lCurrencies = lSecurities = True


        def validateCurrencyKeys(theCurr):

            _rCurrByIDs = theCurr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
            if _rCurrByIDs: return True

            _get_rel_curr_id = theCurr.getParameter(PARAM_REL_CURR_ID,None)
            _get_relative_to_currid = theCurr.getParameter(PARAM_RELATIVE_TO_CURRID,None)

            if not _get_rel_curr_id and not _get_relative_to_currid: return True

            return False


        if lFix:
            if not fixRCurrencyCheck:
                txt = "Sorry, you must run 'DIAG: Diagnose Currencies / Securities' first! - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            elif fixRCurrencyCheck == 1:
                txt = "'DIAG: Diagnose Currencies / Securities' reported no issues - so I will not run fixes - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            elif fixRCurrencyCheck == 2:
                pass
            elif fixRCurrencyCheck != 3:
                txt = "LOGIC ERROR reviewing 'DIAG: Diagnose Currencies / Securities' - so I will not run fixes - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            user_fixOnlyErrors = JRadioButton("Fix only Errors (ignore warnings)?", False)
            user_fixErrorsAndWarnings = JRadioButton("Fix Errors AND warnings?", False)
            bg1 = ButtonGroup()
            bg1.add(user_fixOnlyErrors)
            bg1.add(user_fixErrorsAndWarnings)

            user_fixOnlyCurrencies = JRadioButton("Fix only Currencies?", False)
            user_fixOnlySecurities = JRadioButton("Fix only Securities?", False)
            user_fixBothCurrenciesAndSecurities = JRadioButton("Fix BOTH Currencies AND Securities?", False)
            bg2 = ButtonGroup()
            bg2.add(user_fixOnlyCurrencies)
            bg2.add(user_fixOnlySecurities)
            bg2.add(user_fixBothCurrenciesAndSecurities)

            user_VERBOSE = JCheckBox("Verbose Output?",True)
            userFilters = JPanel(GridLayout(0, 1))

            if fixRCurrencyCheck != 2:
                userFilters.add(user_fixOnlyErrors)
            userFilters.add(user_fixErrorsAndWarnings)
            userFilters.add(JLabel("-------------"))
            userFilters.add(user_fixOnlyCurrencies)
            userFilters.add(user_fixOnlySecurities)
            userFilters.add(user_fixBothCurrenciesAndSecurities)
            userFilters.add(JLabel("-------------"))
            userFilters.add(user_VERBOSE)

            while True:
                options = ["EXIT", "PROCEED"]
                userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                           userFilters,
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.OK_CANCEL_OPTION,
                                                           JOptionPane.QUESTION_MESSAGE,
                                                           MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                           options, options[0]))
                if userAction != 1:
                    txt = "'%s' - No changes made....." %(_THIS_METHOD_NAME.upper())
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,_THIS_METHOD_NAME,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if not user_fixOnlyErrors.isSelected() and not user_fixErrorsAndWarnings.isSelected():
                    continue
                if not user_fixOnlyCurrencies.isSelected() and not user_fixOnlySecurities.isSelected() and not user_fixBothCurrenciesAndSecurities.isSelected():
                    continue
                break

            del userFilters, bg1, bg2

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "EXECUTE '%s'?" %(_THIS_METHOD_NAME.upper())):
                return

            VERBOSE = user_VERBOSE.isSelected()
            lFixErrors=True
            lFixWarnings=user_fixErrorsAndWarnings.isSelected()
            lCurrencies=(user_fixOnlyCurrencies.isSelected() or user_fixBothCurrenciesAndSecurities.isSelected())
            lSecurities=(user_fixOnlySecurities.isSelected() or user_fixBothCurrenciesAndSecurities.isSelected())

        else:

            txt = "Diagnosing Currencies/Securities"
            if not perform_quote_loader_check(toolbox_frame_, txt): return


        # OK - let's do it!
        fixRCurrencyCheck = None

        lNeedFixScript = False
        iWarnings = 0

        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies()
        baseCurr = currencies.getBaseType()

        output = "%s: \n" \
                 " ===================================================\n\n" %(_THIS_METHOD_NAME)

        # Catch any error during update - this would be bad! :-<
        try:
            if lFix:
                output += "FIX MODE:\n" \
                          " ========\n" \
                          "Parameters Selected:\n" \
                          "- Fix Errors: %s\n" \
                          "- Fix Errors and Warnings: %s\n" \
                          "- Fix Currencies: %s\n" \
                          "- Fix Securities: %s\n" \
                          "- VERBOSE: %s\n\n" \
                          % (lFixErrors, lFixWarnings, lCurrencies, lSecurities, VERBOSE)

                MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
                MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
                MD_REF.getUI().setSuspendRefresh(True)

            # ##########################################################################################################
            # BASE CURRENCY FIRST
            # ##########################################################################################################
            if not lFix or lCurrencies:
                output += "Analysing the Base currency setup....\n"
                output += "Base currency: %s\n" % baseCurr

                lSyncNeeded = False

                # Relative Rate - should always be 1.0
                if baseCurr.getParameter(PARAM_RRATE, None) is None or not isGoodRate(baseCurr.getDoubleParameter(PARAM_RRATE, 0.0)) or baseCurr.getDoubleParameter(PARAM_RRATE, 0.0) != 1.0:
                    txt = "@@ERROR@@ - base currency '%s' has (new) relative 'rrate' <> 1: %s (whereas legacy 'rate' is set to: %s)" \
                          %(baseCurr, baseCurr.getParameter(PARAM_RRATE, None), baseCurr.getParameter(PARAM_RATE, None))
                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    lNeedFixScript = True
                    if lFix:
                        lSyncNeeded = True
                        baseCurr.setEditingMode()
                        baseCurr.setParameter(PARAM_RATE, 1.0)
                        baseCurr.setParameter(PARAM_RRATE, 1.0)
                        baseCurr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                        txt = "@@BASE CURRENCY FIX APPLIED (set 'rrate' to 1.0) @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                # The Rate - should always be 1.0
                # if baseCurr.getParameter(PARAM_RATE, None) is None or not isGoodRate(baseCurr.getDoubleParameter(PARAM_RATE, 0.0)) or baseCurr.getDoubleParameter(PARAM_RATE, 0.0) != 1.0:
                #     txt = "@@ERROR@@ - base currency has (legacy) 'rate' <> 1: %s" %(baseCurr.getParameter(PARAM_RATE, None))
                #     myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                #     lNeedFixScript = True
                #     if lFix:
                #         lSyncNeeded = True
                #         baseCurr.setEditingMode()
                #         baseCurr.setParameter(PARAM_RATE, 1.0)
                #         baseCurr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
                #         txt = "@@BASE CURRENCY FIX APPLIED (set legacy 'rate' to 1.0) @@"
                #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                if lSyncNeeded:
                    baseCurr.syncItem(); lSyncNeeded = False                                                            # noqa

                if not lNeedFixScript:
                    output += ("Base currency has legacy 'rate' of: %s and new relative 'rrate': of %s >> 'rrate' is correct...\n"
                               % (baseCurr.getParameter(PARAM_RATE, None), baseCurr.getParameter(PARAM_RRATE, None)))

                # Check for price history - should be none on base currency (also now handled by MD launch)
                baseSnapshots = baseCurr.getSnapshots()
                if baseSnapshots.size() > 0:
                    lNeedFixScript = True
                    txt = "ERROR: base currency has %s historical prices! These need to be deleted!" %(baseSnapshots.size())
                    myPrint("J",txt); output += "----\n%s\n----\n" %(txt)
                    for baseSnapshot in baseSnapshots:
                        if lFix:
                            output += "  @@DELETING@@: %s\n" % (baseSnapshot)
                            baseSnapshot.deleteItem()
                        else:
                            if VERBOSE:
                                output += "  snapshot: %s\n" % baseSnapshot
                else:
                    output += "\nBase currency has no historical prices. This is correct\n"

                # Check Root account's currency is base
                root = MD_REF.getCurrentAccount().getBook().getRootAccount()
                if root.getCurrencyType() != baseCurr:
                    lNeedFixScript = True

                    txt = "Root account's currency: '%s', Base currency: '%s'" %(root.getCurrencyType(), baseCurr)
                    myPrint("J", txt); output += "%s\n" %(txt)

                    txt = "ERROR - The root account's currency is not set to base! This needs correcting!"
                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                    if lFix:
                        root.setCurrencyType(baseCurr); root.syncItem()
                        txt = "@@ROOT ACCOUNT CURRENCY FIX APPLIED (set to base)@@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                else:
                    output += "GOOD, the 'root' account's currency is set to the base currency! Root: '%s', Base: '%s'\n" % (root.getCurrencyType(), baseCurr)


            # Sort the table so that Currencies and Securities are together and by name
            currencies = sorted(currencies, key=lambda x: (x.getCurrencyType(), x.getName().upper()))

            last = None
            lWarning = False
            output += "\nAnalysing the Currency / Security table...\n" \
                      " ===========================================\n"

            for curr in currencies:

                if curr.getCurrencyType() != last:
                    output += "\n\n TYPE: %s\n" \
                              " ========================\n" %(curr.getCurrencyType())
                    last = curr.getCurrencyType()

                if curr.getCurrencyType() == CurrencyType.Type.SECURITY:

                    # ##################################################################################################
                    # SECURITIES
                    # ##################################################################################################
                    if lFix and not lSecurities: continue

                    lSyncNeeded = False

                    if VERBOSE:
                        output += "-----------------------------------------------------------------------------------------\n" \
                                  "Checking security: '%s' (uuid: %s)\n" %(curr, curr.getUUID())

                    get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID,None)
                    get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID,None)

                    rCurr = curr.getRelativeCurrency()
                    rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                    # This might still miss where one of the parameters is set, but the other is not, or where one is 'invalid'.... but let's see
                    if get_relative_to_currid is None and get_rel_curr_id is None:
                        pass    # This is OK, None is fine and means base
                    elif rCurrByIDs is None and rCurr is None:
                        pass    # This is OK, None is fine and means base
                    elif rCurrByIDs is not None and rCurrByIDs != baseCurr and rCurrByIDs.getCurrencyType() == CurrencyType.Type.CURRENCY:
                        pass    # This is OK, non-base currency is OK
                    elif rCurr is not None and rCurr != baseCurr and rCurr.getCurrencyType() == CurrencyType.Type.CURRENCY:
                        pass    # This is OK, non-base currency is OK
                    else:
                        if validateCurrencyKeys(curr):
                            lValidateCurrencies = True
                            txt = "@@ WARNING: '%s' relative_to_currid / rel_curr_id should only be None or NOT your base currency (currently %s : %s)!" %(curr,get_relative_to_currid,get_rel_curr_id)
                        else:
                            lValidateCurrencies = False
                            txt = "@@ WARNING: '%s' The relative currency appears to be missing? Either use Tools>Securities to fix manually, or this fix will reset it to base currency." %(curr)
                        myPrint("J", txt); output += "---\n%s\n" %(txt)
                        if lFix and lFixWarnings:
                            lSyncNeeded = True
                            curr.setEditingMode()
                            curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)  # Force the parameters in regardless!
                            if lValidateCurrencies:
                                txt = "@@SECURITY FIX APPLIED (set relative currency parameters to None) @@"
                            else:
                                txt = "@@SECURITY FIX APPLIED (reset the missing relative currency back to None - PLEASE VERIFY PRICE AND HISTORY IN TOOLS>SECURITIES!) @@"
                            myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                        else:
                            lWarning = True; iWarnings += 1

                    # reset in case I changed these above....
                    get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID,None)
                    get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID,None)
                    rCurr = curr.getRelativeCurrency()
                    rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                    get_rate = curr.getParameter(PARAM_RATE, None)
                    get_rateDbl = curr.getDoubleParameter(PARAM_RATE, 0.0)

                    get_rrate = curr.getParameter(PARAM_RRATE, None)
                    get_rrateDbl = curr.getDoubleParameter(PARAM_RRATE, 0.0)

                    # if get_rate is None or get_rateDbl == 0.0 or not isGoodRate(get_rateDbl):
                    #     txt = "@@ WARNING: '%s' has legacy rate (rate) of ZERO/Invalid" %(curr)
                    #     myPrint("J", txt); output += "----\n%s\n" %(txt)
                    #
                    #     if lFix and lFixWarnings:
                    #         lSyncNeeded = True
                    #         curr.setEditingMode()
                    #         curr.setParameter(PARAM_RATE, 1.0)
                    #         curr.setParameter(PARAM_RRATE, 1.0)
                    #         txt = "@@SECURITY FIX APPLIED (reset both legacy rate and new rrate to 1.0) @@"
                    #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #     else:
                    #         lWarning = True; iWarnings  += 1
                    #
                    if get_rrate is None or get_rrateDbl == 0.0 or not isGoodRate(get_rrateDbl):

                        if rCurr is None or rCurrByIDs is None:
                            isRelativeBase = True
                        elif rCurr == baseCurr or rCurrByIDs == baseCurr:
                            isRelativeBase = True
                        else:
                            isRelativeBase = False

                        if isRelativeBase:  # Relative to base currency
                            newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                            txt = "@@ WARNING: '%s' new relative 'rrate' is set to: %s (whereas legacy 'rate' is currently %s). New 'rrate' should be %s (inverted %s)\n"\
                                  %(curr, get_rrate, get_rate, newRate, safeInvertRate(newRate))
                            myPrint("J", txt); output += "---\n%s\n" %(txt)

                            if lFix and lFixWarnings:
                                lSyncNeeded = True
                                curr.setEditingMode()
                                # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters)...
                                if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                                curr.setParameter(PARAM_RRATE, newRate)
                                # curr.setRate(newRate, baseCurr)
                                curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
                                txt = "@@SECURITY FIX APPLIED (reset new 'rrate') @@"
                                myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                            else:
                                lWarning = True; iWarnings  += 1

                        else:  # Relative to another currency....

                            newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                            newRRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, rCurr))

                            txt = "@@ WARNING: '%s' ** Relative Curr is: '%s' ** legacy 'rate' is currently %s, whereas new relative 'rrate' is set to: %s. Should be new 'rrate': %s (inversed: %s)\n"\
                                  %(curr, rCurr, get_rate, get_rrate, newRRate, safeInvertRate(newRRate))
                            myPrint("J", txt); output += "---\n%s\n" %(txt)

                            if lFix and lFixWarnings:
                                lSyncNeeded = True
                                curr.setEditingMode()
                                # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters...
                                if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                                curr.setParameter(PARAM_RRATE, newRRate)
                                # curr.setRate(newRRate, rCurr)
                                txt = "@@SECURITY FIX APPLIED (reset new 'rrate') @@"
                                myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                                # Doing this here so as not to trigger MD to set rrate to 1.0 (bug)
                                if rCurrByIDs is not None \
                                        and rCurrByIDs != baseCurr \
                                        and rCurrByIDs.getCurrencyType() == CurrencyType.Type.CURRENCY \
                                        and (get_relative_to_currid is None or get_rel_curr_id is None):

                                    curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, rCurrByIDs)
                                    txt = "@@EXTRA SECURITY FIX APPLIED (set both relative currency parameters) @@"
                                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                            else:
                                lWarning = True; iWarnings  += 1


                    iCountSnapErrors = 0
                    currSnapshots = curr.getSnapshots()
                    for snap in currSnapshots:
                        if not isGoodRate(snap.getRate()):
                            iCountSnapErrors += 1
                    if iCountSnapErrors > 0:
                        output += "\n  ** NOTE: You have %s history records with a zero or infinity price/rate! **\n" %(iCountSnapErrors)

                    if lFix and lSyncNeeded:
                        curr.syncItem()

                    continue

                # ######################################################################################################
                # CURRENCIES
                # ######################################################################################################
                if lFix and not lCurrencies: continue

                lSyncNeeded = False

                if VERBOSE:
                    output += "\n-----------------------------------------------------------------------------------------------" \
                              "\nChecking currency: %s\n" % curr

                get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID, None)
                get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID, None)
                rCurr = curr.getRelativeCurrency()                                                                      # noqa
                rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                if validateCurrencyKeys(curr):
                    lValidateCurrencies = True
                else:
                    lValidateCurrencies = False

                if rCurrByIDs is not None:
                    strEnd = ""
                elif not lValidateCurrencies:
                    strEnd = " - YOU APPEAR TO HAVE A MISSING RELATIVE CURRENCY?"
                else:
                    strEnd = " - None / NOT SET (this is OK and means the Base Rate will be used)"

                if VERBOSE:
                    output += "relative_to_currid: %s, rel_curr_id: %s %s\n" %(get_relative_to_currid, get_rel_curr_id, strEnd)

                if rCurrByIDs is not None or not lValidateCurrencies:
                    if lValidateCurrencies:
                        txt = "@@ WARNING: '%s' relative_to_currid & rel_curr_id should both be set to None (which means use base currency)!" %(curr)
                    else:
                        txt = "@@ WARNING: '%s' You have a missing Relative Currency. This fix can reset it back to base currency." %(curr)
                    myPrint("J", "%s" %(txt)); output += "----\n%s\n----\n" %(txt)

                    if lFix and lFixWarnings:
                        lSyncNeeded = True
                        curr.setEditingMode()
                        curr.setRelativeCurrency(None)  # This converts the snaps too!
                        curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)  # Force the parameters in regardless
                        if lValidateCurrencies:
                            if rCurrByIDs == baseCurr:
                                txt = "@@CURRENCY FIX APPLIED (set both relative currency parameters to None) @@"
                            else:
                                txt = "@@CURRENCY FIX APPLIED (set relative currency parameters to None, rates, price history converted back to base) >> REVIEW CURRENT PRICE & HISTORICAL PRICES IN TOOLS>CURRENCIES! @@"
                        else:
                            txt = "@@CURRENCY FIX APPLIED (missing relative currency reset to base) >> REVIEW CURRENT PRICE & HISTORICAL PRICES IN TOOLS>CURRENCIES! @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    else:
                        lWarning = True; iWarnings += 1

                get_rate = curr.getParameter(PARAM_RATE, None)
                get_rateDbl = curr.getDoubleParameter(PARAM_RATE, 0.0)

                get_rrate = curr.getParameter(PARAM_RRATE, None)
                get_rrateDbl = curr.getDoubleParameter(PARAM_RRATE, 0.0)

                if VERBOSE:
                    output += "Legacy 'rate': %s (inverted: %s)\n" % (get_rate, safeInvertRate(get_rateDbl))

                if get_rate is not None and isGoodRate(get_rateDbl) and get_rrate is not None and isGoodRate(get_rateDbl):

                    if VERBOSE:
                        output += "New relative 'rrate': %s (inverted: %s)\n" % (get_rrate, safeInvertRate(get_rrateDbl))

                elif curr == baseCurr:
                    # Note: We fix base earlier on....
                    pass

                else:

                    # if get_rate is None or get_rateDbl == 0.0 or not isGoodRate(get_rateDbl):
                    #     txt = "@@ WARNING: '%s' has legacy 'rate' of ZERO/Invalid" %(curr)
                    #     myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #
                    #     if lFix and lFixWarnings:
                    #         lSyncNeeded = True
                    #         curr.setEditingMode()
                    #         curr.setParameter(PARAM_RATE, 1.0)
                    #         curr.setParameter(PARAM_RRATE, 1.0)
                    #         txt = "@@CURRENCY FIX APPLIED (reset both 'rate' and 'rrate' to 1.0) @@"
                    #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #     else:
                    #         lWarning = True; iWarnings  += 1
                    #

                    # should always be set and always relative to base (1.0)
                    newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                    txt = "@@ WARNING: '%s' new relative 'rrate' is set to: %s (whereas legacy 'rate' is currently %s). 'rrate' should be %s (inverted %s)" \
                          %(curr, get_rrate, get_rate, newRate, safeInvertRate(newRate))
                    myPrint("J", txt); output += "---\n%s\n---\n" %(txt)

                    if lFix and lFixWarnings:
                        lSyncNeeded = True
                        curr.setEditingMode()
                        # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters...
                        if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                        curr.setParameter(PARAM_RRATE, newRate)
                        # curr.setRate(newRate, baseCurr)
                        txt = "@@CURRENCY FIX APPLIED (reset new 'rrate') @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    else:
                        lWarning = True; iWarnings  += 1

                if lFix and lSyncNeeded:
                    curr.syncItem()

                if not lFix and VERBOSE:
                    output += "  details:\n"
                    output += "\t" + "ID:             %s    (uuid: %s)\n" %(curr.getID(), curr.getUUID())
                    output += "\t" + "Name:           %s\n" %(curr.getName())
                    if curr.getTickerSymbol():
                        output += "\t" + "Ticker:         %s\n" %(curr.getTickerSymbol())
                    output += "\t" + "Curr_ID:        %s\n" %(curr.getIDString())
                    output += "\t" + "Decimal Places: %s\n" %(curr.getDecimalPlaces())
                    if curr.getHideInUI():
                        output += "\t" + "Hide in UI:     %s\n" %(curr.getHideInUI())
                    output += "\t" + "Effective Date: %s\n" %(curr.getEffectiveDateInt())
                    if curr.getPrefix():
                        output += "\t" + "Prefix:         %s\n" %(curr.getPrefix())
                    if curr.getSuffix():
                        output += "\t" + "Suffix:         %s\n" %(curr.getSuffix())

                    output += "  pricing history (latest 2 prices):\n"
                    currSnapshots = curr.getSnapshots()
                    if currSnapshots.size() > 0:
                        i = 0
                        for currSnapshot in reversed(currSnapshots):
                            i += 1
                            output += "    snapshot: %s (reversed: %s)\n" % (currSnapshot, currSnapshot.getRate())
                            if i >= 2:
                                break
                    else:
                        if curr != baseCurr:
                            output += "  This currency has no historical prices? Is this correct?\n"
                        else:
                            output += "  Good - This currency has no historical prices...\n"

                    iCountSnapErrors = 0
                    for snap in currSnapshots:
                        if not isGoodRate(snap.getRate()):
                            iCountSnapErrors += 1
                    if iCountSnapErrors > 0:
                        output += "\n  ** NOTE: You have %s history records with a zero or infinity price/rate! **\n" %(iCountSnapErrors)

            output += "-----------------------------------------------------------------\n"

        except:

            txt = ("MAJOR ERROR - '%s' crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()

            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:
            if lFix:
                MD_REF.getUI().getMain().saveCurrentAccount()
                MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
                MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        if lFix:
            fixRCurrencyCheck = None
            myPrint("B", ">> Currency / Security errors / warning - FIXES APPLIED..")
            output += "\nRELEVANT FIXES APPLIED\n\n"
            output += "\nDISCLAIMER: Please verify your data before proceeding\n"

            if lWarning:
                output += "\n@@@@ You still have %s Warning(s)..\n" % iWarnings

            txt = "@@ CURRENCY / SECURITY FIXES APPLIED - Please review diagnostic report for details!"
            play_the_money_sound()
            msgType = JOptionPane.WARNING_MESSAGE
            statusColor = "R"

        else:

            if lNeedFixScript:
                fixRCurrencyCheck = 3
                txt = ">> Currency / Security errors detected - Consider running the FIX option.."
                myPrint("B", txt); output += "%s\n" %(txt)
                output += "\nERROR: You have Currency / Security errors..\n"
                output += "Consider running the 'FIX CURRENCIES & SECURITIES' option\n"
                output += "DISCLAIMER: Always backup your data before running change scripts and verify the result before continuing...\n"
                txt = "ERROR: You have Currency / Security errors.. Please review diagnostic report!"
                msgType = JOptionPane.ERROR_MESSAGE
                statusColor = "R"

            elif lWarning:
                fixRCurrencyCheck = 2
                txt = "You have %s Warning(s).." %(iWarnings)
                myPrint("B", txt); output += "%s\n" %(txt)
                output += "These are where your Currency records show a relative currency that's not None...;\n" \
                          "... or where Securities have an incorrect relative currency set..\n"\
                          "... or where a Currency/Security's new 'rrate' (relative rate) is not set, or different to the legacy 'rate'...\n"\
                          "... or where an 'invalid' / 'infinity' / ZERO / Not A Number (NaN) rate / 'rrate' was found\n" \
                          "NOTE: Often these issues are from 'legacy' MD2017 records that need updating to MD2019+ format by adding the 'rrate' field\n" \
                          "      MD2021.2 has fixes built in to address the 'rrate' issues....\n"
                output += "Consider running the 'FIX CURRENCIES & SECURITIES' option\n"
                output += "DISCLAIMER: Always backup your data before running change scripts and verify the result before continuing...\n"
                txt = "ERROR: You have %s Currency / Security warnings.. Please review diagnostic report!" %(iWarnings)
                msgType = JOptionPane.WARNING_MESSAGE
                statusColor = "R"

            else:
                fixRCurrencyCheck = 1
                txt = "All good, Currencies / Securities look clean! Congratulations!"
                myPrint("J", txt); output += "\n%s\n" %(txt)
                msgType = JOptionPane.INFORMATION_MESSAGE
                statusColor = "DG"

        output += "\n<END>"

        if lFix:
            theTitle = "%s: (FIX ERRORS)" %(_THIS_METHOD_NAME.upper())
        else:
            theTitle = "%s: (LOOK FOR ERRORS)" %(_THIS_METHOD_NAME.upper())

        alertLevel = 0
        if iWarnings: alertLevel = 1
        if lNeedFixScript: alertLevel = 2

        jif = QuickJFrame(theTitle,output,lAlertLevel=alertLevel, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lQuitMDAfterClose=lFix).show_the_frame()

        setDisplayStatus(txt, statusColor)
        myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME.upper(), theMessageType=msgType)

        if lFix:
            myPopupInformationBox(jif,"RESTART OF MONEYDANCE REQUIRED - MD WILL QUIT AFTER VIEWING THIS OUTPUT", _THIS_METHOD_NAME.upper(), theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return output

    class BackupButtonAction(AbstractAction):
        theString = ""

        def __init__(self, theQuestion):
            self.theQuestion = theQuestion

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            if myPopupAskBackup(toolbox_frame_, self.theQuestion, lReturnTheTruth=True):
                txt = "Backup created as requested.."
                setDisplayStatus(txt, "B")
            else:
                txt = "User declined to create backup.."
                setDisplayStatus(txt, "R")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    def backup_custom_theme_file():

        # noinspection PyUnresolvedReferences
        themeFile = ThemeInfo.customThemeFile

        newFileName = os.path.splitext(themeFile.getName())[0]+get_filename_addition()+os.path.splitext(themeFile.getName())[1]+"_$SAVED$"
        newFile = File(themeFile.getParent(), newFileName)

        try:
            IOUtils.copy(themeFile, newFile)
            myPrint("B", "Custom theme file: backup / copied to %s prior to deletion...."%newFileName)
            return True
        except:
            myPrint("B", "Error: Failed to backup/copy custom theme file prior to deletion....")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def backup_local_storage_settings( lSaveFirst=True ):

        if lSaveFirst:
            MD_REF.getCurrentAccount().getBook().getLocalStorage().save()  # Flush settings to disk before changes

        # I would rather have called LocalStorage() to get the filepath, but it doesn't give the path
        # NOTE  - This backup copy will be encrypted, so you can just put it back to ./safe/settings.
        localStorage_file = File(os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"safe","settings"))
        copy_localStorage_filename = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"settings")

        try:
            newFileName = copy_localStorage_filename+get_filename_addition()+"_$SAVED$"
            newFile = File(newFileName)

            IOUtils.copy(localStorage_file, newFile)
            myPrint("B", "LocalStorage() ./safe/settings copied to %s prior to any changes...."%newFileName)
            return True

        except:
            myPrint("B","@@ ERROR - failed to copy LocalStorage() ./safe/settings prior to any changes!?")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def backup_config_dict( lSaveFirst=True ):

        if lSaveFirst:
            MD_REF.savePreferences()  # Flush settings to disk before copy

        try:
            configFile = Common.getPreferencesFile()
            newFileName = os.path.splitext(configFile.getName())[0]+get_filename_addition()+os.path.splitext(configFile.getName())[1]+"_$SAVED$"
            newFile = File(configFile.getParent(), newFileName)

            IOUtils.copy(configFile, newFile)
            myPrint("B", "config.dict backup/copy made to %s prior to changes...."%newFileName)
            return True
        except:
            myPrint("B","@@ ERROR - failed to backup/copy config.dict prior to changes!?")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def get_sync_folder():

        try:
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

            # New feature and Mac only
            if Platform.isOSX() and int(MD_REF.getBuild()) >= MD_ICLOUD_ENABLED and isinstance(syncMethod, ICloudSyncConfigurer):

                syncF = syncMethod.getSyncFolder()

                p_icloud = syncF.getClass().getDeclaredField("icloud")                                                  # noqa
                p_icloud.setAccessible(True)
                p_icloudObject = p_icloud.get(syncF)        # type: ICloudContainer
                p_icloud.setAccessible(False)

                # p_getPathToDocFile = syncF.getClass().getDeclaredMethod("getPathToDocFile",[String])
                # p_getPathToDocFile.setAccessible(True)
                # syncBaseFolder = p_getPathToDocFile.invoke(syncF,[""])
                # p_getPathToDocFile.setAccessible(False)

                p_nativeGetICloudPath = p_icloudObject.getClass().getDeclaredMethod("nativeGetICloudPath")
                p_nativeGetICloudPath.setAccessible(True)
                syncBaseFolder = p_nativeGetICloudPath.invoke(p_icloudObject)
                p_nativeGetICloudPath.setAccessible(False)

                del p_icloud, p_icloudObject, p_nativeGetICloudPath,

                saveSyncFolder = syncBaseFolder

                if os.path.exists(saveSyncFolder):
                    myPrint("DB","icloud folder found:", saveSyncFolder)
                    return saveSyncFolder

            elif syncMethod is not None and syncMethod.getSyncFolder() is not None:
                syncBaseFolder = syncMethod.getSyncFolder().getSyncBaseFolder()                                         # noqa
                saveSyncFolder = syncBaseFolder.getCanonicalPath()
                if os.path.exists(saveSyncFolder):
                    myPrint("DB","sync folder found:", syncBaseFolder)
                    return saveSyncFolder
        except:
            pass

        return None

    def check_for_dropbox_folder():

        try:
            # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
            # MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

            dropboxOption = SyncFolderUtil.configurerForIDFromList("dropbox_folder", syncMethods)

            if (not dropboxOption) or syncMethod.getSyncFolder():
                return True
        except:
            # If there is a problem with Dropbox, .getSyncFolder() will crash....
            return True

        userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
        baseFolder = File(userHomeProperty, "Dropbox")
        dropbox = File(baseFolder, ".moneydancesync")

        # If Dropbox folder does not exist then do nothing
        if not (baseFolder.exists() and baseFolder.isDirectory()):
            return True

        if dropbox.exists() and dropbox.isDirectory():
            return True

        return False

    def tell_me_if_dropbox_folder_exists():

        userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
        baseFolder = File(userHomeProperty, "Dropbox")
        dropbox = File(baseFolder, ".moneydancesync")

        # If Dropbox folder does not exist then do nothing
        if baseFolder.exists() and baseFolder.isDirectory() and dropbox.exists() and dropbox.isDirectory():
            return dropbox.getCanonicalPath()

        return False

    def terminate_script():
        global debug, toolbox_frame_, lGlobalErrorDetected

        myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")

        try:
            # NOTE - .dispose() - The windowClosed event should set .isActiveInMoneydance False and .removeAppEventListener()
            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(GenericDisposeRunnable(toolbox_frame_))
            else:
                toolbox_frame_.dispose()
        except:
            myPrint("B","Error. Final dispose failed....?")
            dump_sys_error_to_md_console_and_errorlog()


    def confirm_backup_confirm_disclaimer(theFrame, theTitleToDisplay, theAction):

        if not myPopupAskQuestion(theFrame,
                                  theTitle=theTitleToDisplay,
                                  theQuestion=theAction,
                                  theOptionType=JOptionPane.YES_NO_OPTION,
                                  theMessageType=JOptionPane.ERROR_MESSAGE):

            txt = "'%s' User did not say yes to '%s' - no changes made" %(theTitleToDisplay, theAction)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(theFrame,"User did not agree to proceed - no changes made...","NO UPDATE",JOptionPane.ERROR_MESSAGE)
            return False

        if not myPopupAskBackup(theFrame, "Would you like to perform a backup before %s" %(theTitleToDisplay)):
            txt = "'%s' - User chose to exit without the fix/update...."%(theTitleToDisplay)
            setDisplayStatus(txt, "R")
            myPrint("B","'%s' User aborted at the backup prompt to '%s' - no changes made" %(theTitleToDisplay, theAction))
            myPopupInformationBox(theFrame,"User aborted at the backup prompt - no changes made...","DISCLAIMER",JOptionPane.ERROR_MESSAGE)
            return False

        disclaimer = myPopupAskForInput(theFrame,
                                        theTitle=theTitleToDisplay,
                                        theFieldLabel="DISCLAIMER:",
                                        theFieldDescription="Are you really sure you want to '%s' Type 'IAGREE' to continue.." %(theAction),
                                        defaultValue="NO",
                                        isPassword=False,
                                        theMessageType=JOptionPane.ERROR_MESSAGE)

        if not disclaimer == 'IAGREE':
            setDisplayStatus("'%s' - User declined the disclaimer - no changes made...." %(theTitleToDisplay), "R")
            myPrint("B","'%s' User did not say accept Disclaimer to '%s' - no changes made" %(theTitleToDisplay, theAction))
            myPopupInformationBox(theFrame,"User did not accept Disclaimer - no changes made...","DISCLAIMER",JOptionPane.ERROR_MESSAGE)
            return False

        myPrint("B","'%s' - User has been offered opportunity to create a backup and they accepted the DISCLAIMER on Action: %s - PROCEEDING" %(theTitleToDisplay, theAction))
        return True

    def getUserSelectedServiceProfile(_theFrame, _theTitle, _theQuestion, lIncludePlaidWhenUnlocked=False):

        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        newServiceList = []
        for sv in serviceList:
            if sv.getTIKServiceID() == "md:plaid":
                if not lIncludePlaidWhenUnlocked:   continue
                if not isToolboxUnlocked():         continue
            newServiceList.append(StoreService(sv))

        service = JOptionPane.showInputDialog(_theFrame,
                                              _theQuestion,
                                              _theTitle,
                                              JOptionPane.INFORMATION_MESSAGE,
                                              MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                              newServiceList,
                                              None)             # type: StoreService

        if not service:
            txt = "%s: - No Service was selected - no changes made.." %(_theTitle)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return None
        return service.getService()

    class StoreUserID():
        def __init__(self, _userID, _password="NOT SET"):
            self.userID = _userID.strip()
            self.password = _password
            self.clientUID = None
            self.accounts = []

        @staticmethod
        def findUserID(findUserID, listOfUserIDs):
            # type: (str, [StoreUserID]) -> StoreUserID
            """
            Static Method to search a [list] of StoreUserID()
            """
            for userIDFromList in listOfUserIDs:
                if findUserID.lower().strip() == userIDFromList.getUserID().lower().strip(): return userIDFromList
            return None

        def setPassword(self, _password):       self.password = _password
        def setClientUID(self, _clientUID):     self.clientUID = _clientUID
        def setAccounts(self, _accounts):       self.accounts = _accounts

        def getUserID(self):    return self.userID
        def getPassword(self):  return self.password
        def getClientUID(self): return self.clientUID
        def getAccounts(self):  return self.accounts

        def __str__(self): return "UserID: %s Password: <%s>" %(self.getUserID(), ("*"*len(self.getPassword())))
        def __repr__(self): return self.__str__()


    def clearOneServiceAuthCache():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "CLEAR AUTHENTICATION FROM ONE SERVICE"

        output = "VIEW ALL CACHED AUTHENTICATION KEYS\n" \
                 " ==================================\n\n"

        lCachePasswords = isCachingPasswords()
        _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
        if len(_auth) > 0:
            keys = sorted(_auth.keys())                                                                                 # noqa
            for theKey in keys:
                value = _auth.get(theKey)                                                                               # noqa
                output += pad("Key:%s" %(theKey),40)+" Value: %s\n" %(value.strip())
        else:
            if not lCachePasswords: output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
            output += "<NONE>\n"

        output+="\n<END>"
        jif = QuickJFrame("VIEW ALL CACHED AUTHENTICATION KEYS",output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        service = getUserSelectedServiceProfile(jif, _THIS_METHOD_NAME, "Select a service clear the Authentication Cache", lIncludePlaidWhenUnlocked=False)  # type: OnlineService
        if not service:
            jif.dispose()
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()       # already within the EDT
            return

        if confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Clear Authentication Password(s) for service:%s?" %(service)):
            # noinspection PyUnresolvedReferences
            service.clearAuthenticationCache()
            MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
            play_the_money_sound()
            txt = "%s: Password(s) for %s have been cleared" %(_THIS_METHOD_NAME, service)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            play_the_money_sound()
            myPopupInformationBox(jif,"Password(s) for %s have been cleared" %(service), _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        jif.dispose()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def clearAllServicesAuthCache():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "CLEAR ALL SERVICE(S)' AUTHENTICATION"

        output = "VIEW ALL CACHED AUTHENTICATION KEYS\n" \
                 " ==================================\n\n"

        lCachePasswords = isCachingPasswords()
        _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
        if len(_auth) > 0:
            keys = sorted(_auth.keys())                                                                                 # noqa
            for theKey in keys:
                value = _auth.get(theKey)                                                                               # noqa
                output += pad("Key:%s" %(theKey),40)+" Value: %s\n" %(value.strip())
        else:
            if not lCachePasswords: output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
            output += "<NONE>\n"

        output+="\n<END>"
        jif = QuickJFrame("VIEW ALL EXISTING AUTHENTICATION KEYS",output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()       # already within the EDT
            return

        if confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Clear Authentication All Password(s) for **ALL** service(s)?"):
            MD_REF.getUI().getOnlineManager().clearAuthenticationCache()
            MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
            play_the_money_sound()
            txt = "%s: **ALL** Password(s) for ALL Services have been cleared" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        jif.dispose()       # already within the EDT

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class MyOFXAuthInfo(OFXAuthInfo):
        def __init__(self, _user, _pass, _extra, _cookie, _type):
            self.originalCookie = _cookie
            self.newPassword = None
            super(OFXAuthInfo, self).__init__(_user, _pass, _extra, _cookie, _type)                                     # noqa

        def getCookie(self): return self.originalCookie

        def setNewPassword(self, _newPassword):
            self.newPassword = _newPassword

        def getNewPassword(self): return self.newPassword

        def getNewEncodedAuthObj(self):
            return MyOFXAuthInfo(self.getUserId(), self.getNewPassword(), self.getExtraAuth(), self.getCookie(), self.getAuthType())

        @staticmethod
        def fromCacheString(_fromRecord):
            if _fromRecord is None: return None
            params = {}
            StringUtils.parseURLParameters(_fromRecord, params)
            authTypeStr = params.get("type")
            authType = 0
            try: authType = int(authTypeStr)
            except: pass

            return (MyOFXAuthInfo(params.get("userid"),
                                  params.get("pass"),
                                  params.get("extra"),
                                  params.get("cookie"),
                                  authType))


    def editStoredOFXPasswords():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "EDIT OFX STORED PASSWORDS"

        service = getUserSelectedServiceProfile(toolbox_frame_, _THIS_METHOD_NAME, "Select a service to manage a stored Password", lIncludePlaidWhenUnlocked=False)  # type: OnlineService
        if not service: return

        output = "VIEW STORED AUTHENTICATION KEYS FOR SERVICE\n" \
                 " ==========================================\n\n"

        class StoreAuthKeyData:
            def __init__(self, _theKey, _theData):
                self.theKey = _theKey
                self.theData = _theData
                self.authObj = MyOFXAuthInfo.fromCacheString(_theData)
                self.thePassword = self.authObj.getPasswd()
                self.theUserID = self.authObj.getUserId()

            def __str__(self): return "%s User: %s Pswd: %s" %(self.theKey, self.theUserID, self.thePassword)
            def __repr__(self): return self.__str__()

        saveAuthKeys = []
        authKeys = getUpdatedAuthenticationKeys()
        for theAuthKey in sorted(authKeys.keys()):                                                                      # noqa
            if (service.getFIOrg() + "--" + service.getFIId() + "--") in theAuthKey:
                saveAuthKeys.append(StoreAuthKeyData(theAuthKey,authKeys.get(theAuthKey)))                                              # noqa
                tempAuthObj = MyOFXAuthInfo.fromCacheString(authKeys.get(theAuthKey))                                   # noqa
                output += "Key:%s" %(theAuthKey) + " Value: %s (decoded password: %s)\n" %(authKeys.get(theAuthKey), tempAuthObj.getPasswd())                     # noqa
        del authKeys

        if len(saveAuthKeys) < 1:
            txt = "%s: WARNING No stored Authentication records found for this service - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        output+="\n<END>"
        jif = QuickJFrame("VIEW EXISTING AUTHENTICATION KEYS FOR SERVICE",output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        selectedAuthKeyRecord = JOptionPane.showInputDialog(jif,
                                                     "Select an Authentication Key to edit",
                                                     _THIS_METHOD_NAME,
                                                     JOptionPane.INFORMATION_MESSAGE,
                                                     MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                     saveAuthKeys,
                                                     None)      # type: StoreAuthKeyData
        if not selectedAuthKeyRecord:
            txt = "%s: No Authentication Key selected - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if isinstance(selectedAuthKeyRecord, StoreAuthKeyData): pass
        authObj = selectedAuthKeyRecord.authObj

        if authObj is None or authObj.toString() != selectedAuthKeyRecord.theData:
            txt = "%s: ERROR - Failed to decode Authentication key (refer console) - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        newPassword = myPopupAskForInput(jif,
                                         _THIS_METHOD_NAME,
                                         "New password:",
                                         "Enter new password for user %s" %(authObj.getUserId()),
                                         defaultValue=authObj.getPasswd())
        if newPassword is None or newPassword == "" or newPassword == authObj.getPasswd():
            txt = "%s: User did not enter a new password - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Edit password for user %s within this service?" %(authObj.getUserId())):
            txt = "%s: User did not agree to proceed with changes - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()
            return

        authObj.setNewPassword(newPassword)

        MD_REF.getCurrentAccount().getBook().getLocalStorage().cacheAuthentication(selectedAuthKeyRecord.theKey, authObj.getNewEncodedAuthObj().toCacheString())
        # service.cacheAuthentication(selectedAuthKeyRecord.theKey, authObj.getNewEncodedAuthObj().toCacheString())

        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
        play_the_money_sound()
        txt = "%s: UserID: %s Password set to: %s" %(_THIS_METHOD_NAME, authObj.getUserId(), authObj.getNewPassword())
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
        jif.dispose()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def my_createNewClientUID():
        # com.moneydance.apps.md.view.gui.DefaultOnlineUIProxy.createNewClientUID()
        _uid = UUID.randomUUID().toString()
        _uid = StringUtils.replaceAll(_uid, "-", "").strip()
        if len(_uid) > 32: _uid = String(_uid).substring(0, 32)
        return _uid

    def manuallyPrimeUSAARootUserIDClientIDs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "USAA: Manually 'prime' Root UserIDs/ClientUIDs".upper()

        if isMDPlusEnabledBuild() and float(MD_REF.getBuild()) < 4059:
            txt = ("WARNING: You need to upgrade to at least version MD2022.1(4059) for USAA Connections to work properly! - No changes made!")
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt, _THIS_METHOD_NAME,JOptionPane.ERROR_MESSAGE)
            return

        USAA_FI_ID = "67811"
        USAA_FI_ORG = "USAA Federal Savings Bank"
        OLD_TIK_FI_ID = "md:1295"
        USAA_PROFILE_NAME = "USAA Custom Profile (ofx_create_new_usaa_bank_profile_custom.py)"

        NEW_TIK_FI_ID = "md:custom-1295"    # as of 23rd Oct, the 'official' custom profile ID

        authKeyPrefix="ofx.client_uid"
        specificAuthKeyPrefix = authKeyPrefix+"::" + NEW_TIK_FI_ID + "::"
        defaultUserPrefix = authKeyPrefix+"_default_user"+"::" + NEW_TIK_FI_ID

        root = MD_REF.getCurrentAccount().getBook().getRootAccount()
        rootKeys = list(sorted(root.getParameterKeys()))

        pdfURL = "https://github.com/yogi1967/MoneydancePythonScripts/raw/master/source/useful_scripts/ofx_create_new_usaa_bank_custom_profile.pdf"
        try: Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(pdfURL), None)
        except: pass

        output = "INSTRUCTIONS:\n" \
                 "Read the latest walk through guide: ofx_create_new_usaa_bank_custom_profile.pdf\n" \
                 "Latest: %s\n" \
                 "(url has been copied to the clipboad)\n\n\n" %(pdfURL)

        output += "LIST OF OFX USAA USERIDs/ClientUIDs STORED ON THE ROOT ACCOUNT\n" \
                  " =============================================================\n\n"

        harvestedDefaultUserID = None
        harvestedUserIDList = []
        for i in range(0,len(rootKeys)):
            rk = rootKeys[i]
            rk_value = root.getParameter(rk)
            if rk.startswith(specificAuthKeyPrefix):
                harvestedUID = StoreUserID(rk[len(specificAuthKeyPrefix):])
                output+="Harvested existing authKey %s: ClientUID: %s\n" %(rk,rk_value)
                if harvestedUID.getUserID() != "null":
                    harvestedUID.setClientUID(rk_value)
                    harvestedUserIDList.append(harvestedUID)
            elif rk.startswith(defaultUserPrefix):
                output+="Harvested existing Default UserID: %s\n" %(rk_value)
                harvestedDefaultUserID = rk_value

        if len(harvestedUserIDList)<1: output+="\n<NONE PRE-EXISTING>\n"

        output += "\n<END>"

        jif = QuickJFrame("REVIEW EXISTING USAA USERIDs/ClientUIDs (stored on ROOT) BEFORE CHANGES",output,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        defaultEntry = ""
        while True:
            userID = myPopupAskForInput(jif, "PRIME USERID/CLIENTUID SUPPLIED BY USAA", "UserID", "Type/Paste the UserID to prime very carefully (this will overwrite existing)", defaultEntry)
            myPrint("DB", "userID entered: %s" %userID)
            if userID is None:
                txt = "ERROR - No userID supplied to prime! Aborting"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
                jif.dispose()
                return
            defaultEntry = userID
            if userID is None or userID == "" or userID == "UserID" or len(userID)<4:
                myPrint("DB", "\n ** ERROR - No valid UserID supplied to prime - try again ** \n")
                continue
            break
        del defaultEntry

        findStoredUser = StoreUserID(userID)
        if len(harvestedUserIDList) > 0:
            foundHarvestedStoredUser = StoreUserID.findUserID(findStoredUser.getUserID(),harvestedUserIDList)    # type: StoreUserID
            if foundHarvestedStoredUser is not None:
                if foundHarvestedStoredUser.getClientUID() is not None:
                    findStoredUser.setClientUID(foundHarvestedStoredUser.getClientUID())
                else:
                    raise Exception("LOGIC ERROR: Found harvested UserID (%s) with no ClientUID?! Aborting" %(findStoredUser))
            del foundHarvestedStoredUser
            myPrint("DB", "UserID entered: %s (Harvested ClientUID: %s)" %(userID, findStoredUser.getClientUID()))
        else:
            myPrint("DB","Skipping matching ClientUID into UserID as did not harvest any UserIDs from USAA root record(s)...")

        myPrint("B","")

        if findStoredUser.getClientUID() is not None:
            defaultEntry = findStoredUser.getClientUID()
        else:
            # defaultEntry = "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn"
            defaultEntry = ""
        del findStoredUser

        while True:
            uuid = myPopupAskForInput(jif, "PRIME CLIENT UUID FOR USERID: %s (SUPPLIED BY USAA)" %(userID),
                                      "PRIME UUID",
                                      "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn\n"
                                      " (Paste your USAA UUID 36 digits 8-4-4-4-12 carefully)", defaultEntry)
            myPrint("DB", "UUID entered: %s" %uuid)
            if uuid is None:
                txt = "ERROR - No uuid entered! Aborting"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
                jif.dispose()
                return
            defaultEntry = uuid
            if (uuid is None or uuid == "" or len(uuid) != 36 or uuid == "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn" or
                    (str(uuid)[8]+str(uuid)[13]+str(uuid)[18]+str(uuid)[23]) != "----"):
                myPrint("DB", "\n ** ERROR - no valid uuid supplied - try again ** \n")
                continue
            break
        del defaultEntry

        lSetDefaultUserID = False
        if myPopupAskQuestion(jif,_THIS_METHOD_NAME, "Do you want to make UserID: %s the DEFAULT (current default: %s)" %(userID, harvestedDefaultUserID)):
            myPrint("DB","UserID: %s will be primed as the default in root (replacing: %s as default)" %(userID, harvestedDefaultUserID))
            lSetDefaultUserID = True

        if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Prime UserID: %s with ClientUID: %s?" %(userID, uuid)):
            txt = "%s: User did not agree to proceed with changes - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        ####################################################################################################################
        serviceList = MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices()  # type: [OnlineService]

        deleteServices = []
        for svc in serviceList:
            if svc.getTIKServiceID() == NEW_TIK_FI_ID: continue     # Skip deleting the new custom profile as that will refresh anyway
            if (svc.getTIKServiceID() == OLD_TIK_FI_ID
                    or svc.getServiceId() == ":%s:%s" %(USAA_FI_ORG, USAA_FI_ID)
                    or "USAA" in svc.getFIOrg()
                    or "USAA" in svc.getFIName()):
                myPrint("DB", "Found old USAA service - to potentially delete: %s" %(svc))
                deleteServices.append(svc)

        if len(deleteServices):
            if myPopupAskQuestion(jif, "DELETE EXISTING OLD USAA SERVICE PROFILES", "DELETE %s EXISTING (old) USAA SERVICE PROFILES TOO [optional]?" % (len(deleteServices)), theMessageType=JOptionPane.WARNING_MESSAGE):
                for service in deleteServices:
                    service.clearAuthenticationCache()
                    service.deleteItem()
                    myPrint("B","Deleted existing (old) USAA service profile: %s" %(service))
                MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
                cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        del serviceList, deleteServices
        ####################################################################################################################

        root.setEditingMode()
        root.setParameter(specificAuthKeyPrefix+userID, uuid)

        if lSetDefaultUserID:
            root.setParameter(defaultUserPrefix, userID)
            root.setParameter(specificAuthKeyPrefix+"null", uuid)

        lOverrideRootUUID = False
        theDefaultUUID = root.getParameter(authKeyPrefix, "")
        if lOverrideRootUUID or theDefaultUUID == "":
            theDefaultUUID = my_createNewClientUID()
            myPrint("B","Overriding Root's default UUID. Was: '%s' >> changing to >> '%s'" %(root.getParameter(authKeyPrefix, ""),theDefaultUUID))
            root.setParameter(authKeyPrefix, theDefaultUUID)
        del theDefaultUUID, lOverrideRootUUID

        root.syncItem()

        play_the_money_sound()
        txt = "SUCCESS! UserID: %s >> ClientUID primed to: %s (Default: %s)" %(userID, uuid, lSetDefaultUserID)
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        MyPopUpDialogBox(jif,
                         txt,
                         "Please now return to Moneydance and use Menu: Online>Set up Online Banking\n"
                         "at the select financial institution selection window, please select:\n"
                         "%s" %(USAA_PROFILE_NAME),
                         theTitle=_THIS_METHOD_NAME,
                         theWidth=125,
                         OKButtonText="SUCCESS").go()

        jif.dispose()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def check_OFX_USERID_Key_valid(test_str):
        pattern = r'[^a-zA-Z0-9-_.:]'
        if re.search(pattern, test_str):
            myPrint("DB","OFX UserID Key Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","OFX UserID Key Valid: %r" %(test_str))
            return True

    def check_OFX_USERID_Data_valid(test_str):
        pattern = r'[^a-zA-Z0-9-_.]'
        if re.search(pattern, test_str):
            myPrint("DB","OFX UserID Data Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","OFX UserID Data Valid: %r" %(test_str))
            return True

    def manualEditOfRootUserIDs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        userIDKeyPrefix="ofx.client_uid"
        root = MD_REF.getCurrentAccount().getBook().getRootAccount()

        _DELETEONE  = 0
        _DELETEALL  = 1
        _EDITONE    = 2
        _ADDONE     = 3

        what = [
            "Delete One OFX UserID/ClientUID record (from root)",
            "Delete All OFX UserID/ClientUID record(s) (from root)",
            "Edit One OFX UserID/ClientUID record (key and data) (from root)",
            "Add One OFX UserID/ClientUID record (key and data) (from root)"]

        while True:

            lDoIHaveAnyKeys=True

            output = "LIST OF OFX BANK USERIDs/ClientUIDs STORED ON THE ROOT ACCOUNT\n" \
                     " =============================================================\n\n"
            userIDKeys=[]
            rootKeys=sorted(root.getParameterKeys())
            for userKey in rootKeys:
                if userKey.startswith(userIDKeyPrefix):
                    userIDKeys.append(userKey)
                    output+="Key: %s Data: %s\n" %(pad(userKey,40),root.getParameter(userKey, None))

            output+="\n<END>"

            if len(userIDKeys)<1:
                txt = "You have no Bank OFX UserIDs/ClientUIDs stored on the Root Account"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,"OFX BANK UserIDs/ClientUIDs",JOptionPane.WARNING_MESSAGE)
                lDoIHaveAnyKeys=False

            jif=QuickJFrame("REVIEW OFX BANK USERIDs/ClientUIDs (stored on ROOT) BEFORE CHANGES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if lDoIHaveAnyKeys:
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "What you want to do?",
                                                           "OFX USERID/ClientUID MANAGEMENT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                           what,
                                                           None)
            else:
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "What you want to do?",
                                                           "OFX USERID/ClientUIDs MANAGEMENT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                           [what[_ADDONE]],
                                                           None)

            if not selectedWhat:
                txt = "OFX USERID MANAGEMENT - No option was selected.."
                setDisplayStatus(txt, "R")
                jif.dispose()       # already within the EDT
                return

            lEditOne = lDeleteOne = lDeleteAll = lAddOne = False

            if selectedWhat == what[_EDITONE]:      lEditOne=True
            elif selectedWhat == what[_DELETEONE]:  lDeleteOne=True
            elif selectedWhat == what[_DELETEALL]:  lDeleteAll=True
            elif selectedWhat == what[_ADDONE]:     lAddOne=True
            else:
                jif.dispose()       # already within the EDT
                continue

            do_what=""
            if lDeleteOne:  do_what="DELETE"
            if lEditOne:    do_what="EDIT"
            if lDeleteAll:  do_what="DELETE ALL"
            if lAddOne:     do_what="ADD ONE"

            selectedUserIDKey=None
            UserIDKeyValue=None

            if lDeleteOne or lEditOne:

                selectedUserIDKey = JOptionPane.showInputDialog(jif,
                                                             "Select a UserID/ClientUIDs to %s" %(do_what),
                                                             "OFX USERID/ClientUIDs MANAGEMENT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                             userIDKeys,
                                                             None)
                if not selectedUserIDKey:
                    jif.dispose()       # already within the EDT
                    continue

                UserIDKeyValue = root.getParameter(selectedUserIDKey, None)

            chgKey=None
            chgValue=None
            if lEditOne:
                chgKey = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="EDIT USERID/ClientUID PARAMETER KEY [optional]:",
                                              theFieldDescription="Carefully edit/change the key. (JUST ENTER TO KEEP THE SAME))",
                                              defaultValue=selectedUserIDKey,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)   # type: str

                if not chgKey or len(chgKey.strip()) <1:
                    myPopupInformationBox(jif,"ERROR - The edited key was not specified or blank!","OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue
                chgKey = chgKey.strip()
                if not chgKey.startswith(userIDKeyPrefix) or not check_OFX_USERID_Key_valid(chgKey) \
                        or (chgKey != selectedUserIDKey and root.getParameter(chgKey,None) is not None):
                    myPopupInformationBox(jif,"ERROR - The new key %s was invalid or must start with '%s'" %(chgKey,userIDKeyPrefix),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                chgValue = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="EDIT USERID/ClientUID PARAMETER VALUE:",
                                              theFieldDescription="Carefully edit/change the data. NOTE: There will be little validation...",
                                              defaultValue=UserIDKeyValue,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)    # type: str
                if not chgValue or len(chgValue.strip()) <1:
                    jif.dispose()       # already within the EDT
                    continue
                chgValue = chgValue.strip()
                if not check_OFX_USERID_Key_valid(chgValue):
                    myPopupInformationBox(jif,"ERROR - The changed key data %s was invalid" %(chgValue),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

            if lAddOne:
                chgKey = myPopupAskForInput(jif,
                                            theTitle="OFX USERID/ClientUID MANAGEMENT",
                                            theFieldLabel="ADD NEW USERID/ClientUID PARAMETER KEY:",
                                            theFieldDescription="Carefully complete the new key (must start with '%s')" %(userIDKeyPrefix),
                                            defaultValue=userIDKeyPrefix,
                                            isPassword=False,
                                            theMessageType=JOptionPane.WARNING_MESSAGE)    # type: str

                if not chgKey or len(chgKey.strip()) <1:
                    myPopupInformationBox(jif,"ERROR - The new key was not specified or blank!","OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue
                chgKey = chgKey.strip()
                if not chgKey.startswith(userIDKeyPrefix) or not check_OFX_USERID_Key_valid(chgKey) or root.getParameter(chgKey,None) is not None:
                    myPopupInformationBox(jif,"ERROR - The new key %s was invalid or must start with '%s'" %(chgKey,userIDKeyPrefix),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                chgValue = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="ADD NEW USERID/ClientUID PARAMETER VALUE:",
                                              theFieldDescription="Carefully enter the new data. NOTE: There will be little validation...",
                                              defaultValue=UserIDKeyValue,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)   # type: str
                if not chgValue or len(chgValue.strip()) <1:
                    jif.dispose()       # already within the EDT
                    continue
                chgValue = chgValue.strip()
                if not check_OFX_USERID_Key_valid(chgValue):
                    myPopupInformationBox(jif,"ERROR - The new key data %s was invalid" %(chgValue),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

            if not confirm_backup_confirm_disclaimer(jif,"OFX USERID/ClientUID MANAGEMENT","OFX USERIDs/ClientUIDs %s?" %(do_what)):
                jif.dispose()       # already within the EDT
                return

            if lEditOne:
                if chgKey != selectedUserIDKey:
                    myPrint("B","setting new key %s to %s" %(chgKey,chgValue))
                    myPrint("DB", "NEW pre %s %s" %(chgKey,root.getParameter(chgKey)))

                    root.setEditingMode()

                    root.setParameter(chgKey, chgValue)
                    myPrint("DB", "NEW post %s %s" %(chgKey,root.getParameter(chgKey)))

                    myPrint("B","setting old key %s to None" %(selectedUserIDKey))
                    myPrint("DB", "OLD pre %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                    root.setParameter(selectedUserIDKey,None)

                    root.syncItem()
                    myPrint("DB", "OLD post %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                else:
                    myPrint("DB", "KEYSAME pre %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                    myPrint("B","setting %s to %s" %(selectedUserIDKey,chgValue))
                    root.setParameter(selectedUserIDKey, chgValue)
                    root.syncItem()
                    myPrint("DB", "KEYSAME post %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                txt = "OFX UserID/ClientUID Record key %s now %s changed from %s to %s" %(selectedUserIDKey,chgKey,UserIDKeyValue,chgValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lAddOne:
                root.setParameter(chgKey,chgValue)
                root.syncItem()
                txt = "OFX new UserID/ClientUID parameter %s CREATED with data: %s" %(chgKey,chgValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteOne:
                root.setParameter(selectedUserIDKey, None)
                root.syncItem()
                txt = "OFX UserID/ClientUID parameter %s DELETED (was: %s)" %(selectedUserIDKey,UserIDKeyValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteAll:
                for keyToDelete in userIDKeys:
                    root.setParameter(keyToDelete, None)
                    root.syncItem()
                    myPrint("B", "DELETED OFX UserID/ClientUID Parameter %s from ROOT!" %(keyToDelete))
                txt = "ALL OFX UserID/ClientUID records DELETED from ROOT"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            del userIDKeys
            play_the_money_sound()
            myPopupInformationBox(jif,"Your %s changes have been made and saved!" %(do_what),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.WARNING_MESSAGE)
            jif.dispose()       # already within the EDT
            continue

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def scriptRunner(_runThisScript, _method):

        if MD_EXTENSION_LOADER is None:
            txt = "%s: Sorry - You must be running Toolbox as an extension to run this extra script...." %(_method)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        if GlobalVars.SCRIPT_RUNNING_LOCK.locked():
            txt = "%s: Sorry - a script is already running with an active Lock" %(_method)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        with GlobalVars.SCRIPT_RUNNING_LOCK:
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            py = MD_REF.getPythonInterpreter()
            py.set("toolbox_script_runner", _runThisScript)
            # py.getSystemState().setClassLoader(MD_EXTENSION_LOADER)
            # py.set("moneydance_extension_loader", MD_EXTENSION_LOADER)

            class ScriptRunnable(Runnable):

                def __init__(self, _context, _python, _scriptStream, _scriptToRun):
                    self.context = _context
                    self.python = _python
                    self.scriptStream = _scriptStream
                    self.scriptToRun = _scriptToRun

                def run(self):  # NOTE: This will not start in the EDT (the same as Moneybot Console)
                    myPrint("B","..About to execfile(%s)" %(self.scriptToRun))
                    self.python.execfile(self.scriptStream,"Toolbox:Executing_Script_%s" %(self.scriptToRun))
                    myPrint("DB", "....I am back from script, within the special Thread().....")
                    self.scriptStream.close()
                    self.context.resetPythonInterpreter(self.python)

            scriptStream = MD_EXTENSION_LOADER.getResourceAsStream("/%s" %(_runThisScript))

            t = Thread(ScriptRunnable(MD_REF, py, scriptStream, _runThisScript))
            t.start()

            myPrint("DB", ".... post calling Thread().....")

            del py, t
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")

        return True

    def editSetupMultipleUserIDs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Edit/Setup (multiple) UserIDs / Passwords".upper()

        scriptToRun = "ofx_populate_multiple_userids.py"

        # ask = MyPopUpDialogBox(toolbox_frame_,
        #                  "This is a special process that will run a script",
        #                  "You do not need to leave Toolbox....\n"
        #                  "Script: %s" %(scriptToRun),
        #                  theTitle=_THIS_METHOD_NAME, lCancelButton=True, OKButtonText="Proceed?")
        #
        # if not ask.go():
        #     txt = "%s: User abandoned script execution (%s)" %(_THIS_METHOD_NAME, scriptToRun)
        #     setDisplayStatus(txt, "B"); myPrint("B", txt)
        #     myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
        #     return False

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute the script: %s?" %(scriptToRun)):
            return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    def createUSAAProfile():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Create USAA OFX Profile".upper()

        scriptToRun = "ofx_create_new_usaa_bank_custom_profile.py"

        # ask = MyPopUpDialogBox(toolbox_frame_,
        #                  "This is a special process that will run a script",
        #                  "You do not need to leave Toolbox....\n"
        #                  "Script: %s" %(scriptToRun),
        #                  theTitle=_THIS_METHOD_NAME, lCancelButton=True, OKButtonText="Proceed?")
        #
        # if not ask.go():
        #     txt = "%s: User abandoned script execution (%s)" %(_THIS_METHOD_NAME, scriptToRun)
        #     setDisplayStatus(txt, "B"); myPrint("B", txt)
        #     myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
        #     return False

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute the script: %s?" %(scriptToRun)):
            return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    class StoreAccountList():
        def __init__(self, obj):
            if isinstance(obj,Account):
                self.obj = obj                          # type: Account
            else:
                self.obj = None

        def __str__(self):
            if self.obj is None:
                return "Invalid Acct Obj or None"
            return "%s : %s" %(self.obj.getAccountType(),self.obj.getFullAccountName())

        def __repr__(self):
            if self.obj is None:
                return "Invalid Acct Obj or None"
            return "%s : %s" %(self.obj.getAccountType(),self.obj.getFullAccountName())

    class StoreTheOnlineTxnList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlineTxnList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.txnCount = obj.getTxnCount()
            else:
                self.txnCount = 0

        def __str__(self):
            return "OnlineTxnList Obj on Acct %s (holding %s Txns)" %(self.acct,self.txnCount)

        def __repr__(self):
            return "OnlineTxnList Obj on Acct %s (holding %s Txns)" %(self.acct,self.txnCount)

    # noinspection PyUnresolvedReferences
    def get_security_holdings(security):
        if security.getCurrencyType() != CurrencyType.Type.SECURITY:
            return 0

        acctHoldings = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(22))
        balance = 0
        for acct in acctHoldings:
            if acct.getCurrencyType() == security:
                balance += acct.getBalance()

        return balance

    class StoreCurrencySecurity():
        def __init__(self, obj):
            if isinstance(obj,CurrencyType):
                self.obj = obj                          # type: CurrencyType
            else:
                self.obj = None
            self.qtyHeld = 0
            # noinspection PyUnresolvedReferences
            if self.obj and self.obj.getCurrencyType() == CurrencyType.Type.SECURITY:
                self.qtyHeld = get_security_holdings(self.obj)
            self.decimal = MD_REF.getPreferences().getDecimalChar()

        def __str__(self):
            if self.obj is None:
                return "Invalid CurrencyType Obj or None"
            if self.qtyHeld == 0:
                return "%s: %s" %(self.obj.getCurrencyType(), self.obj.getName())
            return "%s: %s (%s)" %(self.obj.getCurrencyType(), self.obj.getName(),self.obj.formatSemiFancy(self.qtyHeld,self.decimal))

        def __repr__(self): return self.__str__()

    class StoreTheOnlinePayeeList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlinePayeeList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.payeeCount = obj.getPayeeCount()
            else:
                self.payeeCount = 0

        def __str__(self):
            return "OnlinePayeeList Obj on Acct %s (holding %s Payees)" %(self.acct,self.payeeCount)

        def __repr__(self):
            return "OnlinePayeeList Obj on Acct %s (holding %s Payees)" %(self.acct,self.payeeCount)

    class StoreTheOnlinePaymentList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlinePaymentList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.paymentCount = obj.getPaymentCount()
            else:
                self.paymentCount = 0

        def __str__(self):
            return "OnlinePaymentList Obj on Acct %s (holding %s Payments)" %(self.acct,self.paymentCount)

        def __repr__(self):
            return "OnlinePaymentList Obj on Acct %s (holding %s Payments)" %(self.acct,self.paymentCount)

    def OFX_update_OFXLastTxnUpdate():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (lAdvancedMode): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to Hack the OFXLastTxnUpdate date field:",
                                                   "OFX OFXLastTxnUpdate - Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "OFXLastTxnUpdate: No Account was selected.."
            setDisplayStatus(txt, "R")
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "OFXLastTxnUpdate: No OnlineTxnList record found... Exiting.."
            setDisplayStatus(txt, "R")
            return

        theCurrentDate = theOnlineTxnRecord.obj.getOFXLastTxnUpdate()

        if theCurrentDate > 0:
            theCurrentDatePretty = get_time_stamp_as_nice_text(theCurrentDate)
        else:
            if isMDPlusEnabledBuild():
                theCurrentDatePretty = "NOT SET (MD will prompt you for start date)"
            else:
                theCurrentDatePretty = "NOT SET"

        myPopupInformationBox(toolbox_frame_,"OFXLastTxnUpdate is currently: %s (which means: %s)" %(theCurrentDate, theCurrentDatePretty))

        if not isMDPlusEnabledBuild():

            labelUpdateDate = JLabel("Select the new OFXLastTxnUpdate download Date (enter as yyyy/mm/dd):")
            user_selectDateStart = JDateField(CustomDateFormat("ymd"),15)   # Use MD API function (not std Python)
            user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())

            datePanel = JPanel(GridLayout(0, 1))
            datePanel.add(labelUpdateDate)
            datePanel.add(user_selectDateStart)

            options = ["Cancel", "OK"]

            while True:
                userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                          datePanel,
                                                          "Select new Date for the OFXLastTxnUpdate field:",
                                                          JOptionPane.OK_CANCEL_OPTION,
                                                          JOptionPane.QUESTION_MESSAGE,
                                                          None,
                                                          options,
                                                          options[0])

                if userAction != 1:
                    txt = "OFX: User cancelled entering a new OFXLastTxnUpdate date - exiting"
                    setDisplayStatus(txt, "R")
                    return

                if user_selectDateStart.getDateInt() < 20150101 or user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt():
                    txt = "OFX: User cancelled entering an invalid OFXLastTxnUpdate date..."
                    setDisplayStatus(txt, "R")
                    user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())
                    user_selectDateStart.setForeground(getColorRed())                                                           # noqa
                    continue

                break   # Valid date

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX UPDATE OFXLastTxnUpdate","Update the OFXLastTxnUpdate field to %s?" %(user_selectDateStart.getDateInt())):
                return

            newDate = DateUtil.convertIntDateToLong(user_selectDateStart.getDateInt()).getTime()
            newDateTxt = user_selectDateStart.getDateInt()

        else:

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX UPDATE OFXLastTxnUpdate","Reset date so that MD Prompts you for start date?"):
                return

            newDate = 0L
            newDateTxt = "RESET SO MD PROMPTS FOR START DATE"

        theOnlineTxnRecord.obj.setOFXLastTxnUpdate(newDate)
        theOnlineTxnRecord.obj.syncItem()

        play_the_money_sound()
        txt = "OFX HACK OFXLastTxnUpdate date for acct: %s successfully set to: %s (%s)" %(selectedAcct,newDate,newDateTxt)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,"OFX UPDATE OFXLastTxnUpdate",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def OFX_delete_ALL_saved_online_txns():
        # delete_intermediate_downloaded_transaction_caches.py
        # delete_orphaned_downloaded_txn_lists.py

        # CREATE TEST DATA
        # allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), AcctFilter.NON_CATEGORY_FILTER)
        # for acct in allAccounts:
        #     if "TEST"  != acct.getFullAccountName().upper() and "TEST2"  != acct.getFullAccountName().upper(): continue
        #     print "found: %s" %(acct)
        #     olTxns = acct.getDownloadedTxns()  # Note - this actually creates a new OnlineTxnList object if it didn't exist
        #     for i in range(0,10):
        #         olTxn = olTxns.newTxn()
        #         olTxn.setFIID("qif")
        #         olTxn.setName("Desc1" +str(i))
        #         olTxn.setDatePostedInt(	20200115+i )
        #         olTxn.setAmount( 9999+i )
        #         olTxn.setAllowDuplicateIDs(True)
        #         olTxns.addNewTxn(olTxn)
        #     olTxns.syncItem()
        #     print olTxns.getSyncInfo()
        # END CREATE TEST DATA

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (lAdvancedMode): return

        # quick check first...
        olTxnLists = MD_REF.getCurrentAccount().getBook().getItemsWithType("oltxns")
        lAny=False
        for txnList in olTxnLists:
            if txnList.getTxnCount() > 0:
                lAny=True
                break

        if not lAny and not myPopupAskQuestion(toolbox_frame_,"OFX PURGE OnlineTxnList OBJECTS","You don't seem to have any cached Online Txns. Proceed anyway (with general cleanup)?",theMessageType=JOptionPane.WARNING_MESSAGE):
            txt = "OFX PURGE OnlineTxnList OBJECTS. You have no cached Txns - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX PURGE OnlineTxnList OBJECTS","Purge/Clean all Cached OnlineTxnList Txns (very safe to run)?"):
            return

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes....

        myPrint("B","Purging / cleaning all OnlineTxnList Cached txns.....")

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), AcctFilter.NON_CATEGORY_FILTER)

        output = "PURGE/CLEAN ALL CACHED OnlineTxnList TXN RECORDS\n" \
                 " ===============================================\n\n"

        output += (" Found %s accounts and %s OnlineTxnList objects\n" % (len(allAccounts), len(olTxnLists)))
        shouldSaveTrunk = False

        # delete all online transactions from all downloaded-transaction-list objects,
        # which includes lists that are no longer associated with accounts
        for txnList in olTxnLists:
            output+=("OnlineTxnList %s    with    %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            if txnList.getTxnCount() > 0:
                myPrint("J", "OnlineTxnList %s - DELETING %s cached txns" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
                shouldSaveTrunk = True
                output+=("   >> DELETING Cached Txns....\n")
                txnList.setEditingMode()
                while txnList.getTxnCount() > 0:
                    txnList.removeTxn(txnList.getTxnCount() - 1)
                txnList.syncItem()
                output+=("   OnlineTxnList %s now has %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))

        output += "\n--------\n\n"

        for acct in allAccounts:
            olTxns = acct.getDownloadedTxns()  # Note - this actually creates a new OnlineTxnList object if it didn't exist
            olTxnsIdx = olTxnLists.indexOf(olTxns)
            if olTxnsIdx >= 0:
                if olTxns.getTxnCount() > 0:    # Note - I think this never finds any, as it will have been caught in the loop above....
                    shouldSaveTrunk = True
                    output+=("Found OnlineTxnList %s at index %s for account %s - DELETING %s cached txns\n"
                          % (pad(olTxns.getUUID(),50), rpad(olTxnsIdx,10), pad(acct.getAccountName(),30), olTxns.getTxnCount()))
                    myPrint("J", "Found OnlineTxnList %s at index %s for account %s - DELETING %s cached txns"
                            % (pad(olTxns.getUUID(),50), rpad(olTxnsIdx,10), pad(acct.getAccountName(),30), olTxns.getTxnCount()))
                    olTxns.setEditingMode()
                    while olTxns.getTxnCount() > 0:
                        olTxns.removeTxn(olTxns.getTxnCount() - 1)
                    olTxns.syncItem()
                    output+=("   OnlineTxnList %s                        >now has %s cached txns\n" % (pad(olTxns.getUUID(),50), rpad(olTxns.getTxnCount(),12)))
                olTxnLists.remove(olTxns)  # This check is OK though.....
            # else:
            #     output+=("@@ OnlineTxnList record NOT FOUND (orphaned), containing %s cached txns\n" % (rpad(olTxns.getTxnCount(),12)))

        output += "\n--------\n\n"

        output+=("Remaining/orphan OnlineTxnList objects to delete:\n")

        for txnList in olTxnLists:
            output+=(">> DELETING ORPHAN >> OnlineTxnList %s with %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            myPrint("J", ">> DELETING ORPHAN >> OnlineTxnList %s with %s cached txns" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            txnList.deleteItem()
            shouldSaveTrunk = True

        output += "\n--------\n\n"

        MD_REF.getCurrentAccount().getBook().logRemovedItems(olTxnLists)
        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes....

        if shouldSaveTrunk:
            myPrint("J","Purge/Clean ALL OnlineTxnList objects - Saving Trunk file now....")
            output+=("SAVING TRUNK FILE...\n")
            MD_REF.getCurrentAccount().getBook().saveTrunkFile()
        else:
            myPrint("J","Purge/Clean ALL OnlineTxnList objects - NO CHANGES MADE....")
            output+=("Purge/Clean ALL OnlineTxnList objects - NO CHANGES MADE....\n")

        output+="\n<END>"

        myPrint("P",output)

        jif = QuickJFrame("OFX PURGE ALL OnlineTxnList OBJECTS",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        play_the_money_sound()
        txt = "OFX: Purge / Clean ALL OnlineTxnList Objects cached Txns completed..."
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        myPopupInformationBox(jif,txt,"OFX PURGE ALL OnlineTxnList",JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def OFX_delete_saved_online_txns():

        # delete_intermediate_downloaded_transaction_caches.py
        # delete_orphaned_downloaded_txn_lists.py

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (lAdvancedMode): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(18))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to Hack the Online Txn List record:",
                                                   "Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "Delete saved OnlineTxnList txns: No Account was selected.."
            setDisplayStatus(txt, "R")
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "Delete saved OnlineTxnList txns: No OnlineTxnList record found... Exiting.."
            setDisplayStatus(txt, "R")
            return

        saveTxnCount = theOnlineTxnRecord.txnCount

        while True:
            _options=["HACK: DELETE All %s Txns stored on this record" %(saveTxnCount),
                      "HACK: DELETE the whole OnlineTxnList record"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "What type of Hack to OnlineTxnList record do you want to make?",
                                                         "OFX Hack OnlineTxns",
                                                         JOptionPane.WARNING_MESSAGE,
                                                         None,
                                                         _options,
                                                         None)

            if not selectedOption:
                txt ="No Hack for OnlineTxnList record selected - exiting.."
                setDisplayStatus(txt, "R")
                return

            lDeleteAllTxns  = (_options.index(selectedOption) == 0)
            lDeleteRecord   = (_options.index(selectedOption) == 1)

            if lDeleteAllTxns and saveTxnCount<1: continue

            break

        do_what=""
        if lDeleteAllTxns: do_what="Delete all %s stored Txns within the record" %(saveTxnCount)
        if lDeleteRecord:  do_what="Delete the whole OnlineTxnList record"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX DELETE HACK OnlineTxnList","%s?" %(do_what)):
            return

        if lDeleteRecord:
            theOnlineTxnRecord.obj.deleteItem()
            play_the_money_sound()
            txt = "OFX HACK OnlineTxnList whole record for acct: %s successfully deleted: " %(selectedAcct)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,"OFX DELETE HACK OnlineTxnList",JOptionPane.ERROR_MESSAGE)

        elif lDeleteAllTxns:

            theOnlineTxnRecord.obj.setEditingMode()
            while theOnlineTxnRecord.obj.getTxnCount() > 0:
                theOnlineTxnRecord.obj.removeTxn(theOnlineTxnRecord.obj.getTxnCount() - 1)
            theOnlineTxnRecord.obj.syncItem()

            # for i in reversed(range(0,saveTxnCount)):
            #     theOnlineTxnRecord.obj.removeTxn(i)
            # theOnlineTxnRecord.obj.syncItem()
            #
            play_the_money_sound()
            txt = "OFX HACK OnlineTxnList Record for acct: %s: %s Txns deleted" %(selectedAcct, saveTxnCount)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,"OFX DELETE HACK OnlineTxnList Txns",JOptionPane.ERROR_MESSAGE)

        del theOnlineTxnRecord

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def quick_check_cached_online_txns():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        countCachedAccounts = 0
        countCachedTxns = 0

        myPrint("DB","Quick check looking for Cached OFX Downloaded txns (that shouldn't be there)")
        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(18))
        for acct in accountsListForOlTxns:
            cached = MyGetDownloadedTxns(acct)
            if cached.getTxnCount() > 0:
                myPrint("DB", "Account: %s contains %s cached txns" %(acct,cached.getTxnCount()))
                countCachedAccounts += 1
                countCachedTxns += cached.getTxnCount()

        myPrint("DB","... found: %s accounts containing %s cached txns" %(countCachedAccounts, countCachedTxns))
        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return countCachedAccounts, countCachedTxns

    def OFX_authentication_management():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if not isCachingPasswords():
            myPopupInformationBox(toolbox_frame_,"WARNING: Your system is not setup to cache/store Authentication details!","Manage OFX Authentication",JOptionPane.ERROR_MESSAGE)

        user_clearOneServiceAuthCache = JRadioButton("Clear the Authentication Cache (Passwords) for One Service / Bank Profile", False)
        user_clearOneServiceAuthCache.setToolTipText("Clears all remembered passwords for the OFX Service profile you select - THIS WILL CHANGE DATA!")

        user_clearAllServicesAuthCache = JRadioButton("Clear ALL Authentication Cache (Passwords)", False)
        user_clearAllServicesAuthCache.setToolTipText("Clears all remembered passwords for all OFX Service profiles - THIS WILL CHANGE DATA!")

        user_editSetupMultipleUserIDs = JRadioButton("Edit/Setup (multiple) UserIDs / Passwords (executes a special script)", False)
        user_editSetupMultipleUserIDs.setToolTipText("Allows setup of multiple UserIDs/Passwords on an OFX service profile - executes: ofx_populate_multiple_userids.py")

        user_editStoredOFXPasswords = JRadioButton("Edit stored authentication passwords linked to a working OFX Profile", False)
        user_editStoredOFXPasswords.setToolTipText("Manual edit of remembered OFX passwords linked to an OFX profile...")

        user_manualEditOfRootUserIDs = JRadioButton("Manual Edit of stored Root UserIDs/ClientUIDs", False)
        user_manualEditOfRootUserIDs.setToolTipText("Manual edit of any stored UserID/ClientUID raw record (from root account)")

        userFilters = JPanel(GridLayout(0, 1))

        bg = ButtonGroup()
        bg.add(user_clearOneServiceAuthCache)
        bg.add(user_clearAllServicesAuthCache)
        bg.add(user_editSetupMultipleUserIDs)
        bg.add(user_editStoredOFXPasswords)
        bg.add(user_manualEditOfRootUserIDs)
        bg.clearSelection()

        userFilters.add(user_clearOneServiceAuthCache)
        userFilters.add(user_clearAllServicesAuthCache)
        userFilters.add(user_editSetupMultipleUserIDs)
        userFilters.add(user_editStoredOFXPasswords)
        userFilters.add(user_manualEditOfRootUserIDs)

        while True:
            options = ["EXIT", "PROCEED"]
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       userFilters,
                                                       "Online Banking (OFX) AUTHENTICATION MANAGEMENT",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       options, options[0]))

            if userAction != 1:
                txt = "Online Banking (OFX) AUTHENTICATION MANAGEMENT - No changes made....."
                setDisplayStatus(txt, "B")
                return False

            if user_clearOneServiceAuthCache.isSelected():
                clearOneServiceAuthCache()

            if user_clearAllServicesAuthCache.isSelected():
                clearAllServicesAuthCache()

            if user_editSetupMultipleUserIDs.isSelected():
                if editSetupMultipleUserIDs():
                    return True

            if user_editStoredOFXPasswords.isSelected():
                editStoredOFXPasswords()

            if user_manualEditOfRootUserIDs.isSelected():
                manualEditOfRootUserIDs()

            continue

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def OFX_cookie_management():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not lAdvancedMode or not lHackerMode: return

        cookieKey="ofxcookies"

        LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

        _EDITONE = 0
        _DELETEONE = 1
        _DELETEALL = 2

        what = [
            "Edit One OFX Cookie's data",
            "Delete One OFX Cookie",
            "Delete All OFX Cookies"]

        while True:

            allCookieStrings = LS.getStringList(cookieKey)

            # LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
            # LS.put("ofxcookies.0","CBDIdleTimer=1585100844282|false|13|15; path=%2F; domain=google.com")
            # LS.put("ofxcookies.1","HNWPRD=A11; path=%2F; domain=google.com")
            # LS.put("ofxcookies.2","ADRUM_BTs=R:0|s:p; Sun, 10-Jan-2021 20:34:19 MST; path=%2F; domain=vesnc.billy.com")
            # LS.put("ofxcookies.3","ADRUM_BT1=R:0|i:52128|e:20; Tue, 12-Jan-2021 16:24:22 MST; path=%2F; domain=vesnc.apple.com")

            _i = 0
            msgStr=""
            for _i in range(0, len(allCookieStrings)):
                msgStr+="%s\n" %(allCookieStrings.get(_i))
                # print MDCookie.loadFromStorage(allCookieStrings.get(_i))
                _i+=1

            MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Your current cookies are:",
                             theMessage=msgStr,
                             theWidth=300,
                             theTitle="OFX COOKIE MANAGEMENT",
                             OKButtonText="CONTINUE").go()

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "What you want to do?",
                                                       "OFX COOKIE MANAGEMENT",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       what,
                                                       None)
            if not selectedWhat:
                txt = "No data type was selected to Geek out on.."
                setDisplayStatus(txt, "R")
                return

            lEditOne = lDeleteOne = lDeleteAll = False

            if selectedWhat == what[_EDITONE]: lEditOne=True
            elif selectedWhat == what[_DELETEONE]: lDeleteOne=True
            elif selectedWhat == what[_DELETEALL]: lDeleteAll=True
            else: continue

            do_what=""
            if lDeleteOne: do_what="DELETE"
            if lEditOne: do_what="EDIT"
            if lDeleteAll: do_what="DELETE ALL"

            selectedCookie=None
            selectedCookieIndex=None

            if lDeleteOne or lEditOne:

                selectedCookie = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select a Cookie to %s" %(do_what),
                                                             "OFX COOKIE MANAGEMENT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                             allCookieStrings,
                                                             None)
                if not selectedCookie: continue
                selectedCookieIndex=allCookieStrings.indexOf(selectedCookie)

            chgValue=None
            if lEditOne:
                chgValue = myPopupAskForInput(toolbox_frame_,
                                              theTitle="OFX COOKIE MANAGEMENT",
                                              theFieldLabel="EDIT COOKIE VALUE:",
                                              theFieldDescription="Carefully edit/change the data. NOTE: There will be no validation...",
                                              defaultValue=selectedCookie,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)
                if not chgValue or len(chgValue.strip()) <1 or chgValue == selectedCookie: continue
                chgValue = chgValue.strip()

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX BANK MANAGEMENT","OFX COOKIES %s?" %(do_what)):
                continue

            if not backup_local_storage_settings():
                txt = "'OFX COOKIE MANAGEMENT': ERROR making backup of LocalStorage() ./safe/settings - no changes made!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                return

            if lEditOne:
                allCookieStrings[selectedCookieIndex] = chgValue
                txt = "OFX Cookie %s changed from %s to %s" %(selectedCookieIndex+1,selectedCookie,chgValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteOne:
                allCookieStrings.remove(selectedCookieIndex)
                txt = "OFX Cookie %s DELETED (was: %s)" %(selectedCookieIndex+1,selectedCookie)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteAll:
                allCookieStrings.clear()
                txt = "ALL OFX Cookies DELETED"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            myPrint("B","OFX Bank Management: Writing all Cookies back to Local Storage (after: %s)...." %(do_what))
            LS.put(cookieKey, allCookieStrings)
            LS.save()
            myPopupInformationBox(toolbox_frame_,"Your %s changes have been made and saved!" %(do_what),"OFX BANK MANAGEMENT",JOptionPane.WARNING_MESSAGE)
            continue

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def OFXDEBUGToggle():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        key = "ofx.debug.console"
        props_ofx_debug = System.getProperty(key, None)

        toggleText = "ON"
        if (props_ofx_debug is not None and props_ofx_debug!="false"):
            toggleText = "OFF"

        ask = MyPopUpDialogBox(toolbox_frame_,"OFX DEBUG CONSOLE STATUS:",
                               'System.getProperty("%s") currently set to: %s\n'%(key,props_ofx_debug),
                               200,"TOGGLE MONEYDANCE INTERNAL OFX DEBUG",
                               lCancelButton=True,OKButtonText="SET to %s" %toggleText)
        if not ask.go():
            txt = "HACKER MODE: NO CHANGES MADE TO OFX DEBUG CONSOLE!"
            setDisplayStatus(txt, "B")
            return

        myPrint("B","HACKER MODE: User requested to toggle System Property '%s' to %s - setting this now...!" %(key,toggleText))
        if toggleText == "OFF":
            System.clearProperty(key)
        else:
            System.setProperty(key, "true")

        txt = "Internal debug ofx debug console setting turned %s" %(toggleText)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"TOGGLE MONEYDANCE INTERNAL OFX DEBUG",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def CUSIPFix():
        global toolbox_frame_, debug

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        currID = "curr_id."

        # Credit to: Finite Mobius, LLC / Jason R. Miller" for original code (https://github.com/finitemobius/moneydance-py)
        # change-security-cusip.py
        # Variant of remove_ofx_security_bindings.py

        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
        if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD and not check_all_currency_raw_rates_ok(CurrencyType.Type.SECURITY):
            myPrint("B","@@ Error: failed check_all_currency_raw_rates_ok(SECURITY) check... Exiting CUSIPFix() without any changes...")
            txt = "ERROR: You have old format Security record(s). Consider running 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' option first"
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            setDisplayStatus(txt, "R")
            return

        # Find Securities with CUSIP(s) set...
        dropdownSecs = ArrayList()
        allSecs = ArrayList()
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() != CurrencyType.Type.SECURITY: continue
            allSecs.append(curr)
            for key in curr.getParameterKeys():
                if key.startswith(currID):
                    dropdownSecs.add(curr)
                    break

        theSchemes = None
        selectedSecurity = None
        selectedSecurityMoveTo = None
        lReset = lEdit = lMove = lAdd = False

        if len(dropdownSecs)<1:
            x="You have no existing CUSIP(s); Would you like to add a CUSIP?"
        else:
            x="You have %s securities with CUSIP(s) set; Would you like to manually add a CUSIP? (No brings up more options)" %(len(dropdownSecs))

        if not myPopupAskQuestion(toolbox_frame_,"FIX CUSIP",x,theMessageType=JOptionPane.WARNING_MESSAGE):
            if len(dropdownSecs)<1:
                txt = "FIX CUSIP - You have no existing CUSIP(s) set on Securities - No changes made..."
                setDisplayStatus(txt, "B")
                return
        else:
            allSecs=sorted(allSecs, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the security to add CUSIP data",
                                                           "FIX CUSIP",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                           allSecs,
                                                           None)

            if not selectedSecurity:
                txt = "FIX CUSIP - No Security was selected - no changes made.."
                setDisplayStatus(txt, "B")
                return

            lAdd = True

        if not lAdd:
            dropdownSecs=sorted(dropdownSecs, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the security with CUSIP data to view/change",
                                                           "FIX CUSIP",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                           dropdownSecs,
                                                           None)

            if not selectedSecurity:
                txt = "FIX CUSIP - No Security was selected - no changes made.."
                setDisplayStatus(txt, "B")
                return

            del dropdownSecs

            schemeText=""
            theSchemes=[]
            for key in selectedSecurity.getParameterKeys():
                if key.startswith(currID):
                    findScheme = key[len(currID):]
                    theSchemes.append([selectedSecurity,findScheme,selectedSecurity.getIDForScheme(findScheme)])
                    schemeText+="Scheme: %s ID: %s\n" %(findScheme,selectedSecurity.getIDForScheme(findScheme))

            if len(theSchemes)<1:
                txt = "FIX CUSIP - error iterating keys on %s for CUSIP(s) - NO CHANGES MADE!" %(selectedSecurity)
                setDisplayStatus(txt, "R")
                myPrint("B",txt)
                return

            ask=MyPopUpDialogBox(toolbox_frame_,"Showing CUSIP data for Security: %s" %(selectedSecurity),schemeText,theTitle="FIX CUSIP",OKButtonText="NEXT STEP",lCancelButton=True)
            if not ask.go():
                txt = "FIX CUSIP - no changes made.."
                setDisplayStatus(txt, "B")
                return

            options = ["EXIT", "RESET CUSIP(s)", "EDIT ONE CUSIP", "MOVE ALL TO DIFFERENT SECURITY", "ADD NEW CUSIP KEY"]
            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "Select CUSIP Option you want to action",
                                                         "FIX CUSIP",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                         options,
                                                         None)

            if not selectedOption or options.index(selectedOption) == 0:
                txt = "FIX CUSIP - No CUSIP option selected - no changes made.."
                setDisplayStatus(txt, "R")
                return

            if options.index(selectedOption) == 1: lReset = True
            elif options.index(selectedOption) == 2: lEdit = True
            elif options.index(selectedOption) == 3: lMove = True
            elif options.index(selectedOption) == 4: lAdd = True
            else:
                txt = "FIX CUSIP - Unknown option selected - no changes made"
                setDisplayStatus(txt, "R")
                return

            dropdownSecsMoveTo = selectedSecurityMoveTo = None                                                      # noqa

        if lMove:
            dropdownSecsMoveTo = ArrayList()
            currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            for curr in currencies:
                if curr.getCurrencyType() != CurrencyType.Type.SECURITY: continue                               # noqa
                if curr == selectedSecurity: continue
                dropdownSecsMoveTo.add(curr)

            if len(dropdownSecsMoveTo)<1:
                txt = "FIX CUSIP - You have no other Securities to move to - No changes made..."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,"FIX CUSIP",JOptionPane.ERROR_MESSAGE)
                return

            dropdownSecsMoveTo=sorted(dropdownSecsMoveTo, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurityMoveTo = JOptionPane.showInputDialog(toolbox_frame_,
                                                                 "Select the security to move the CUSIP data to:",
                                                                 "FIX CUSIP",
                                                                 JOptionPane.INFORMATION_MESSAGE,
                                                                 MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                                 dropdownSecsMoveTo,
                                                                 None)

            if not selectedSecurityMoveTo:
                txt = "FIX CUSIP - No Move to Security was selected - no changes made.."
                setDisplayStatus(txt, "R")
                return

            lAlreadyHasData = False
            for key in selectedSecurityMoveTo.getParameterKeys():
                if key.startswith(currID):
                    lAlreadyHasData=True
                    break
            if lAlreadyHasData:
                if not myPopupAskQuestion(toolbox_frame_,
                                          "FIX CUSIP",
                                          "Security: %s already has CUSIP data. OK will overwrite matching CUSIP key(s) (Cancel to exit)" %(selectedSecurityMoveTo),
                                          theMessageType=JOptionPane.WARNING_MESSAGE):
                    txt = "FIX CUSIP - Security: %s already has CUSIP data. User asked to Exit..." %(selectedSecurityMoveTo)
                    setDisplayStatus(txt, "R")
                    return
                myPrint("B", "FIX CUSIP - User selected to overwrite existing CUSIP data in Security: %s" %selectedSecurityMoveTo)

        if confirm_backup_confirm_disclaimer(toolbox_frame_,"FIX CUSIP","Are you sure you want to change CUSIP data on security: %s?" %(selectedSecurity)):
            if lReset:
                selectedSecurity.setEditingMode()
                for key in list(selectedSecurity.getParameterKeys()):
                    if key.startswith(currID):
                        findScheme = key[len(currID):]
                        # noinspection PyUnresolvedReferences
                        oldData = selectedSecurity.getIDForScheme(findScheme)
                        # noinspection PyUnresolvedReferences
                        selectedSecurity.setIDForScheme(findScheme, None)
                        myPrint("B","FIX CUSIP: Deleted CUSIP on Security: %s (Was: Scheme: %s ID: %s)" %(selectedSecurity,findScheme,oldData) )
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s Reset/Deleted!" %(selectedSecurity),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lMove:
                selectedSecurity.setEditingMode()
                selectedSecurityMoveTo.setEditingMode()
                for key in list(selectedSecurity.getParameterKeys()):
                    if key.startswith(currID):
                        findScheme = key[len(currID):]
                        moveData = selectedSecurity.getIDForScheme(findScheme)

                        moveToOldData = selectedSecurityMoveTo.getIDForScheme(findScheme)
                        if moveToOldData:
                            myPrint("B", "FIX CUSIP: Overwriting old data on destination security: %s (Was: Scheme: %s ID: %s)" %(selectedSecurityMoveTo,findScheme,moveToOldData))

                        myPrint("B","FIX CUSIP: Moving CUSIP data from %s to %s Scheme: %s ID: %s" %(selectedSecurity, selectedSecurityMoveTo,findScheme,moveData))
                        selectedSecurityMoveTo.setIDForScheme(findScheme, moveData)
                        selectedSecurity.setIDForScheme(findScheme, None)

                selectedSecurity.syncItem()
                selectedSecurityMoveTo.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s Moved to Security: %s!" %(selectedSecurity,selectedSecurityMoveTo),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lEdit:

                listData=[]
                for x in theSchemes:
                    listData.append(x[1])

                selectedSchemeToChange = JOptionPane.showInputDialog(toolbox_frame_,
                                                                     "Select the CUSIP to edit:",
                                                                     "FIX CUSIP",
                                                                     JOptionPane.INFORMATION_MESSAGE,
                                                                     MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                                     listData,
                                                                     None)

                if not selectedSchemeToChange:
                    txt = "FIX CUSIP - No CUSIP selected to edit - no changes made.."
                    setDisplayStatus(txt, "R")
                    return

                newID = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","ENTER NEW ID DATA:","Enter the new CUSIP data for Security: %s CUSIP: %s"
                                           %(selectedSecurity,selectedSchemeToChange),selectedSecurity.getIDForScheme(selectedSchemeToChange))

                if not newID or newID == selectedSecurity.getIDForScheme(selectedSchemeToChange):
                    txt = "FIX CUSIP - EDIT - new data not entered - no changes made"
                    setDisplayStatus(txt, "R")
                    return

                myPrint("B","FIX CUSIP - EDIT. Changing Security: %s CUSPID: %s from %s to %s"
                        %(selectedSecurity,selectedSchemeToChange,selectedSecurity.getIDForScheme(selectedSchemeToChange),newID))

                selectedSecurity.setIDForScheme(selectedSchemeToChange,newID)
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s CUSIP: %s changed to: %s"
                                      %(selectedSecurity, selectedSchemeToChange,newID),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lAdd:

                newScheme = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","NEW CUSIP Scheme/Key:","Enter Scheme Type to add (normally 'CUSIP'): %s"
                                               %(selectedSecurity), defaultValue="CUSIP")

                if not newScheme or newScheme == "":
                    txt = "FIX CUSIP - EDIT - new CUSIP Scheme Type not entered - no changes made"
                    setDisplayStatus(txt, "R")
                    return

                newID = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","NEW CUSIP ID:","Enter the new CUSIP ID for Scheme Type: %s to add to Security: %s"
                                           %(newScheme,selectedSecurity))

                if not newID or newID == "":
                    txt = "FIX CUSIP - EDIT - new CUSIP ID not entered for new Scheme: %s to add to Security: %s - no changes made" %(newScheme,selectedSecurity)
                    setDisplayStatus(txt, "R")
                    return

                myPrint("B","FIX CUSIP - ADD. Adding CUSIP: %s ID %s to Security: %s"
                        %(newScheme, newID, selectedSecurity))

                selectedSecurity.setIDForScheme(newScheme,newID)
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP Scheme/Key: %s ID: %s added to Security: %s"
                                      %(newScheme, newID, selectedSecurity),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            else:
                txt = "FIX CUSIP - Unknown option selected - no changes made"
                setDisplayStatus(txt, "R")
                return

            play_the_money_sound()
            txt = "FIX CUSIP - Changes successfully applied to Security: %s" %(selectedSecurity)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class StoreService():
        def __init__(self, obj):
            if isinstance(obj,OnlineService):
                self.obj = obj                          # type: OnlineService
            else:
                self.obj = None

        def getService(self):
            # type: () -> OnlineService
            return (self.obj)

        def __str__(self):
            if self.obj is None:
                return "Invalid OnlineService Obj or None"
            return "Connection profile: %s (%s)" %(self.obj.getFIName(), self.obj.getTIKServiceID())

        def __repr__(self): return self.__str__()


    def deleteOFXService():
        # remove_one_service.py

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "DELETE ONLINE BANKING SERVICE / PROFILE"

        service = getUserSelectedServiceProfile(toolbox_frame_, _THIS_METHOD_NAME, "Select an Online Banking Service / Profile to delete", lIncludePlaidWhenUnlocked=True)  # type: OnlineService

        if service.getTIKServiceID() == "md:plaid":
            if not myPopupAskQuestion(toolbox_frame_,
                                  _THIS_METHOD_NAME.upper(),
                                  "Are you SURE you want to delete the Moneydance+ profile? - You should NOT normally touch this! (But it should recreate itself)",
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "%s: User declined to delete the Moneydance+ profile (phew) - no changes made.." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                return

            myPrint("B","%s: User confirmed to delete the Moneydance+ Online Banking Profile...." %(_THIS_METHOD_NAME))

        if confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Delete Bank Service/Logon profile %s?" %(service)):
            # noinspection PyUnresolvedReferences
            service.clearAuthenticationCache()
            # noinspection PyUnresolvedReferences
            service.deleteItem()
            LS = MD_REF.getCurrentAccount().getBook().getLocalStorage()
            LS.save()

            cleanupMissingOnlineBankingLinks(lAutoPurge=True)

            play_the_money_sound()
            txt = "Online Banking Service / Logon Profile successfully deleted: %s" %(service)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def cleanupMissingOnlineBankingLinks(lAutoPurge=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "OFX Cleanup Missing Banking Links"

        PLAID_MAP_KEY = "map.md:plaid:::"

        mappingObject = None
        if isMDPlusEnabledBuild():
            p_osl = OnlineServiceLink.getDeclaredConstructor([String, String, Account])                                 # noqa
            p_osl.setAccessible(True)
            mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")

        ####################################################################################################################
        invalid_olblink_links = []      # New for MD2022 onwards
        invalid_mapping_links = []      # New for MD2022 onwards
        invalidBankingLinks = []
        invalidBillPayLinks = []

        myPrint("B","Searching for Account Online Banking / Bill Pay links with no profile (general cleanup routine)....")
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(26))

        for a in accounts:

            for pk in a.getParameterKeys():
                p_value = a.getParameter(pk, "")
                if pk == "olbfi" and a.getBankingFI() is None and p_value != "":
                    invalidBankingLinks.append(a)
                    myPrint("B","... Found account '%s' with a OFX banking link (to %s), but no service profile exists (thus dead)..." %(a,p_value))

                if pk == "bpfi" and a.getBillPayFI() is None and p_value != "":
                    invalidBillPayLinks.append(a)
                    myPrint("B","... Found account '%s' with a BillPay link (to %s), but no service profile exists (thus dead)..." %(a,p_value))

                if isMDPlusEnabledBuild():
                    if pk.startswith("olblink.") and p_value != "":
                        # link = OnlineServiceLink(pk[len("olblink."):], p_value, a)                                    # noqa
                        link = p_osl.newInstance(pk[len("olblink."):], p_value, a)                                      # noqa
                        if link.getService() is None:
                            invalid_olblink_links.append([a,link.onlineServiceID])
                            myPrint("B","... Found account '%s' with new 'olblink.' link ('%s' : '%s'), but no service profile exists (thus dead)..." %(a,pk, p_value))

        if isMDPlusEnabledBuild(): p_osl.setAccessible(False)

        if mappingObject is not None:
            myPrint("B","Searching for Orphaned mapping links (MD2022 onwards) (general cleanup routine)....")

            acctXRefDict = getAvailAccountsXRefDict()

            for objectKey in mappingObject.getParameterKeys():
                _value = mappingObject.getParameter(objectKey)

                if objectKey.startswith("map.none") or _value == "_none_": continue

                if objectKey.startswith("map."):
                    if objectKey.startswith(PLAID_MAP_KEY):
                        plaid_acct = objectKey[len(PLAID_MAP_KEY):].strip()
                        acctLookup = acctXRefDict.get(plaid_acct)           # type: StoreMDPlusLinkages
                        if acctLookup is None:
                            myPrint("B","...Found dead/orphaned MD+/Plaid mapping link ('%s' : '%s')" %(objectKey, _value))
                            invalid_mapping_links.append(objectKey)

                    mappedAccount = MD_REF.getCurrentAccountBook().getAccountByUUID(_value)
                    if mappedAccount is None:
                        myPrint("B","...Found orphaned mapping link ('%s' : '%s')" %(objectKey, _value))
                        invalid_mapping_links.append(objectKey)

        totalDead = len(invalidBankingLinks) + len(invalidBillPayLinks) + len(invalid_olblink_links) + len(invalid_mapping_links)
        myPrint("B", "%s: WARNING - %s dead banking links (and/or orphaned mapping links) found!" %(_THIS_METHOD_NAME.upper(), totalDead))

        if totalDead < 1:
            txt = "%s: CONGRATULATIONS - I found no Invalid Online Banking Links / Orphaned Mapping links......." %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            if not lAutoPurge:
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt)
            return

        if not lAutoPurge and not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Cleanup (remove) %s missing/dead online banking links?" %(totalDead)):
            return

        for a in invalidBankingLinks:
            a.setBankingFI(None)
            a.syncItem()
            myPrint("B","...removed the dead link Banking link on account %s" %(a))

        for a in invalidBillPayLinks:
            a.setBillPayFI(None)
            a.syncItem()
            myPrint("B","...removed the dead link BillPay link on account %s" %(a))

        for alink in invalid_olblink_links:
            alink[0].setOnlineIDForServiceID(alink[1], None)
            alink[0].syncItem()
            myPrint("B","...removed the dead link 'olblink.' link on account %s" %(alink[0]))

        if mappingObject is not None and len(invalid_mapping_links) > 0:
            mappingObject.setEditingMode()
            for maplink in invalid_mapping_links:
                myPrint("B","...removed the orphaned mapping link: %s : %s" %(maplink, mappingObject.getParameter(maplink)))
                mappingObject.setParameter(maplink, None)
            mappingObject.syncItem()

        del invalidBankingLinks, invalidBillPayLinks, invalid_olblink_links, accounts, invalid_mapping_links, mappingObject
        ####################################################################################################################

        txt = "%s dead/missing Online Banking links successfully removed (review console for details)" %(totalDead)
        myPrint("B", txt)

        if not lAutoPurge:
            play_the_money_sound()
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class StoreMDPlusLinkages():

        def __init__(self, _svc, _acct_ref, _map_key, _plaidID, _desc):
            self._svc = _svc
            self._acct_ref = _acct_ref
            self._map_key = _map_key
            self._plaidID = _plaidID
            self._desc = _desc

        def getPlaidID(self): return self._plaidID

        def getDesc(self): return self._desc

    def getPlaidService():
        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        for service in serviceList:
            if service.getTIKServiceID() == "md:plaid": return service
        return None

    def getAvailAccountsXRefDict():
        """Searches all Online Banking profiles and builds a x-ref list of Accounts to Plaid Connection refs"""

        mdplus_linkages = {}
        if isMDPlusEnabledBuild():
            service = getPlaidService()     # type: OnlineService
            if service is not None:
                for availAccount in service.getAvailableAccounts():
                    mdplus_linkages[availAccount.getAccountNumber()] = StoreMDPlusLinkages(service,
                                                                       availAccount.getAccountNumber(),
                                                                       availAccount.getMappingKey(),
                                                                       availAccount.getPlaidItemID(),
                                                                       availAccount.getDescription())
        return mdplus_linkages

    def special_toMultilineHumanReadableString(_object, lSkipSecrets=True, sFilterServiceID=None):
        _output = ""
        if not _object: return _output

        if not sFilterServiceID:
            _output = "Object Parameter Keys:\n" \
                      "----------------------\n"

        PLAID_MAP_KEY = "map.md:plaid:::"

        acctXRefDict = getAvailAccountsXRefDict() if (_object.getParameter("id", None) == "online_acct_mapping") else {}

        hide_keys = ["mdplus.priv", "mdplus.pub"]
        for objectKey in sorted(_object.getParameterKeys()):
            _value = _object.getParameter(objectKey)

            acctText = ""
            acctXRef = ""

            if sFilterServiceID and not objectKey.startswith("map.%s" %(sFilterServiceID)): continue

            if objectKey.startswith("map."):
                if isMDPlusEnabledBuild() and objectKey.startswith(PLAID_MAP_KEY):
                    plaid_acct = objectKey[len(PLAID_MAP_KEY):].strip()
                    acctLookup = acctXRefDict.get(plaid_acct)           # type: StoreMDPlusLinkages
                    if acctLookup is not None:
                        acctXRef = "(Plaid ref: %s, Desc: %s) " %(acctLookup.getPlaidID(), acctLookup.getDesc())
                    else:
                        acctXRef = "(Orphan) "

                mappedAccount = MD_REF.getCurrentAccountBook().getAccountByUUID(_value)
                acctText = "(%s)" %("Missing Account" if (mappedAccount is None) else mappedAccount.getFullAccountName())

            if lSkipSecrets:
                if objectKey in hide_keys: _value = "****** hidden ****** (length: %s)" %(len(_value))
            _output += "Key: %s %sValue: %s %s\n" %(objectKey, acctXRef, _value, acctText)

        if not sFilterServiceID: _output += "----------------------\n"
        return _output

    def getUserIDFromEmail(_emailAddress):
        if (_emailAddress is None): return ""
        digest = MessageDigest.getInstance("MD5")
        digest.update(String(String(String(_emailAddress).toLowerCase(Locale.ROOT)).trim()).getBytes(StandardCharsets.UTF_8))
        return StringUtils.encodeHex(digest.digest(), False)

    def getKeyID(_pubKeyHex):
        pubKeyBytes = StringUtils.decodeHex(_pubKeyHex)
        digest = MessageDigest.getInstance("MD5")
        digest.update(pubKeyBytes)
        keyID = StringUtils.encodeHex(digest.digest(), False)
        return keyID

    def getByteArray(syncObj, key):
        result = String(syncObj.get(key))
        return None if result is None else StringUtils.decodeHex(result)

    def decodePrivKey(pubKeyHex, privKeyHex):
        pubKeyBytes = StringUtils.decodeHex(pubKeyHex)
        privKeyBytes = StringUtils.decodeHex(privKeyHex)
        digest = MessageDigest.getInstance("MD5")
        digest.update(pubKeyBytes)
        kf = KeyFactory.getInstance("RSA")
        privkey = kf.generatePrivate(PKCS8EncodedKeySpec(privKeyBytes))
        pubkey = kf.generatePublic(X509EncodedKeySpec(pubKeyBytes))
        if privkey is None or pubkey is None: return None, None
        return pubkey, privkey

    def decrypt(cipherText, pubkey, privkey):                                                                           # noqa
        # noinspection PyUnresolvedReferences
        ENCRYPTION_PARAM_SPEC = OAEPParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec("SHA-256"), PSource.PSpecified.DEFAULT)
        if (FileUtils.byteArraysMatch(String("eparcel").getBytes(StandardCharsets.UTF_8), cipherText, 7)):
            parcel = SyncRecord()
            parcel.readSet(ByteArrayInputStream(cipherText))
            if (not parcel.containsKey("key") or  not parcel.containsKey("payload")):                                   # noqa
                return None  # Invalid encrypted parcel
            cipher1 = Cipher.getInstance("RSA/ECB/OAEPPadding")
            cipher1.init(2, privkey, ENCRYPTION_PARAM_SPEC)
            decryptedKey = cipher1.doFinal(getByteArray(parcel, "key"))
            originalKey = SecretKeySpec(decryptedKey, 0, len(decryptedKey), "AES")
            aesCipher = Cipher.getInstance("AES")
            aesCipher.init(2, originalKey)
            return aesCipher.doFinal(getByteArray(parcel, "payload"))

        cipher = Cipher.getInstance("RSA/ECB/OAEPPadding")
        cipher.init(2, privkey, ENCRYPTION_PARAM_SPEC)
        return cipher.doFinal(cipherText)

    def UNLOCKMDPlusDiagnostic():

        if not isToolboxUnlocked() or not isMDPlusEnabledBuild(): return

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "UNLOCKED Moneydance+ Diagnostics"

        output = "%s:\n %s\n\n" %(_THIS_METHOD_NAME, "-"*len(_THIS_METHOD_NAME))

        licenseObject = getMDPlusLicenseInfoForBook()               # Note: Builds prior to 2006 will return None anyway...
        if licenseObject is None:
            output += "No Moneydance+ License Object found\n".upper()
        else:
            output += "Moneydance+ License Object found... Details:\n"

            mdplus_email = licenseObject.getParameter("mdplus.account_email", None)                                     # noqa
            mdplus_pend_email = licenseObject.getParameter("mdplus.pending_email", None)                                # noqa
            mdplus_signup_status = licenseObject.getParameter("signup_status", None)                                    # noqa
            mdplus_keyRegenDate = licenseObject.getLongParameter("mdplus.date", 0L)                                     # noqa
            mdplus_refreshDate = licenseObject.getLongParameter("mdplus.refresh_date", 0L)                              # noqa
            mdplus_keypairCreated = licenseObject.getLongParameter("mdplus.keypair_created", 0L)                        # noqa
            mdplus_privKeyHex = licenseObject.getParameter("mdplus.priv", None)                                         # noqa
            mdplus_pubKeyHex = licenseObject.getParameter("mdplus.pub", None)                                           # noqa

            output += "Dataset's UUID:          %s\n" %(MD_REF.getCurrentAccountBook().getFileUUID())
            output += "Email:                   %s\n" %(mdplus_email)
            output += "Email's MD5 encoded hex: %s\n" %(getUserIDFromEmail(mdplus_email))
            output += "Pending Email:           %s\n" %(mdplus_pend_email)
            if mdplus_signup_status:    output += "Signup status:           %s\n" %(mdplus_signup_status)
            if mdplus_keyRegenDate:     output += "MD+ date:                %s\n" %(get_time_stamp_as_nice_text(mdplus_keyRegenDate))
            if mdplus_refreshDate:      output += "MD+ refresh date:        %s\n" %(get_time_stamp_as_nice_text(mdplus_refreshDate))
            if mdplus_keypairCreated:   output += "MD+ keypair date:        %s\n" %(get_time_stamp_as_nice_text(mdplus_keypairCreated))
            if mdplus_privKeyHex:       output += "MD+ Private Key (raw):   %s\n" %(mdplus_privKeyHex)
            if mdplus_pubKeyHex:
                output += "MD+ Public Key (raw):    %s\n\n" %(mdplus_pubKeyHex)
                output += "Dataset/license 'KeyID': %s\n" %(getKeyID(mdplus_pubKeyHex))

            statusURL = None
            if mdplus_pubKeyHex and mdplus_email:
                statusURL = ("https://mdplus.infinitekind.com/tik/get_status/%s/%s"
                             %(getUserIDFromEmail(mdplus_email), getKeyID(mdplus_pubKeyHex)))
                output += "\nMD Check Key Status URL:\n%s\n\n" %(statusURL)

            if statusURL:
                output += "\nDATA DOWNLOADED FROM URL:\n"
                pubkey = privkey = None                                                                                 # noqa
                try:
                    grabGson = Gson()
                    url = URL(statusURL)
                    inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
                    status_outerJson = grabGson.fromJson(inx, Map); inx.close()                                         # type: HashMap

                    for o in status_outerJson:
                        output += "Key: %s: Value: %s\n" %(o, status_outerJson.get(o))                                  # noqa

                    status = status_outerJson.getOrDefault("status", "none")                                            # noqa
                    responseMsg = String.valueOf(status_outerJson.getOrDefault("message", ""))                          # noqa

                    pubkey, privkey = decodePrivKey(mdplus_pubKeyHex, mdplus_privKeyHex)

                    userInfo = SyncRecord()
                    userDataObject = status_outerJson.get("user_data")                                                  # noqa
                    userPayloadsJSON = HashMap() if userDataObject is None else userDataObject
                    for payloadKey in userPayloadsJSON.keySet():
                        cipherValue = StringUtils.decodeHex(String.valueOf(userPayloadsJSON.get(payloadKey)))
                        try:
                            accessTokenInfo = SyncRecord()
                            accessTokenInfo.readSet(ByteArrayInputStream(decrypt(cipherValue, pubkey, privkey)))
                            output += "'user_data' User Payload key: %s Decrypted value: %s\n" %(String.valueOf(payloadKey), accessTokenInfo)
                        except:
                            output += "'user_data' unable to decrypt user payload:       %s\n" % (payloadKey)

                    keyDataObject = status_outerJson.get("key_data")                                                    # noqa
                    keyPayloadsJSON = HashMap() if keyDataObject is None else keyDataObject
                    for payloadKey in keyPayloadsJSON.keySet():
                        cipherValue = StringUtils.decodeHex(String.valueOf(keyPayloadsJSON.get(payloadKey)))
                        try:
                            accessTokenInfo = SyncRecord()
                            accessTokenInfo.readSet(ByteArrayInputStream(decrypt(cipherValue, pubkey, privkey)))
                            output += "'key_data' Key Payload key: %s Decrypted value:   %s\n" %(String.valueOf(payloadKey), accessTokenInfo)
                        except:
                            output += "'key_data' unable to decrypt key payload:         %s\n" % (payloadKey)

                    if status_outerJson.containsKey("encrypted"):                                                       # noqa
                        ciphertext = StringUtils.decodeHex(String.valueOf(status_outerJson.get("encrypted")))           # noqa
                        clearbytes = decrypt(ciphertext, pubkey, privkey)
                        userInfo.readSet(ByteArrayInputStream(clearbytes))
                        for ui in userInfo:
                            output += "'encrypted'... Key: %s Value %s\n" %(ui, userInfo.get(ui))                       # noqa

                    output += "<END OF URL DATA>\n\n"
                except:
                    output += "Error downloading, decrypting status data from IK URL...!?\n"
                    output += dump_sys_error_to_md_console_and_errorlog(True)
                    output += "<END OF URL DATA>\n\n"

                finally:
                    del pubkey, privkey

            tokens = MD_REF.getCurrentAccountBook().getLocalStorage().getSublist("access_tokens")
            output += "\n>>Moneydance+ Access Tokens (local storage 'access_tokens')...:\n"
            if len(tokens) > 0:
                for token in tokens:
                    for token_key in token:
                        output += "Key: %s Value: %s\n" %(token_key, token.get(token_key))
            else:
                output += "<NONE>\n"

            mdp_cache = MD_REF.getCurrentAccountBook().getLocalStorage().getSubset("mdp_items")
            output += "\n>>Moneydance+ Plaid Cache (local storage 'mdp_items')...:\n"
            if len(mdp_cache) > 0:
                for cacheItem in mdp_cache:
                    output += "Key: %s Value: %s\n" %(cacheItem, mdp_cache.get(cacheItem))
            else:
                output += "<NONE>\n"
            del mdp_cache

            output += "\n>>Account Mappings Object's PARAMETER KEYS (MD2022 onwards)\n"
            mappingObject = MD_REF.getCurrentAccount().getBook().getItemForID("online_acct_mapping")
            if mappingObject is None:
                output += "<NO ACCOUNT MAPPING OBJECT FOUND>\n"
            else:
                output += special_toMultilineHumanReadableString(mappingObject, lSkipSecrets=False)

        output += "\n<END>"
        QuickJFrame(_THIS_METHOD_NAME.upper(),output,lAlertLevel=1,copyToClipboard=False,lWrapText=False).show_the_frame()

        txt = "%s: CONFIDENTIAL Moneydance+ settings displayed... DO NOT SHARE THESE WITH ANYONE" %(_THIS_METHOD_NAME.upper())
        setDisplayStatus(txt, "R"); myPrint("B", txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def export_MDPlus_Profile():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Export Moneydance+ (Plaid) settings to file"
        _TEST_KEY = "Confidential data: KEYTEST123$"

        licenseObject = getMDPlusLicenseInfoForBook()

        if licenseObject is None:
            myPopupInformationBox(toolbox_frame_,"No Moneydance+ settings/profile found - NO EXPORT PERFORMED!",_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        mdplus_email = licenseObject.getParameter("mdplus.account_email", None)                                         # noqa
        mdplus_pend_email = licenseObject.getParameter("mdplus.pending_email", None)                                    # noqa
        mdplus_signup_status = licenseObject.getParameter("signup_status", None)                                        # noqa
        mdplus_keyRegenDate = licenseObject.getLongParameter("mdplus.date", 0L)                                         # noqa
        mdplus_refreshDate = licenseObject.getLongParameter("mdplus.refresh_date", 0L)                                  # noqa
        mdplus_keypairCreated = licenseObject.getLongParameter("mdplus.keypair_created", 0L)                            # noqa
        mdplus_privKeyHex = licenseObject.getParameter("mdplus.priv", None)                                             # noqa
        mdplus_pubKeyHex = licenseObject.getParameter("mdplus.pub", None)                                               # noqa

        if not mdplus_email or not mdplus_pubKeyHex or not mdplus_privKeyHex or not mdplus_signup_status:
            txt = "No Valid Moneydance+ settings/profile found - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME.upper(),"ALERT: This Exports your confidential MD+(Plaid) private/public keys to an encrypted file. Continue?"):
            return

        theTitle = "Select location to Export your encrypted Moneydance+ settings/profile... (CANCEL=ABORT)"
        exportFile = getFileFromFileChooser(toolbox_frame_,                                 # Parent frame or None
                                            get_home_dir(),                                 # Starting path
                                            "MoneydancePlus_settings_CONFIDENTIAL.mdp",     # Default Filename
                                            theTitle,                                       # Title
                                            False,                                          # Multi-file selection mode
                                            False,                                          # True for Open/Load, False for Save
                                            True,                                           # True = Files, else Dirs
                                            "EXPORT",                                       # Load/Save button text, None for defaults
                                            "mdp",                                          # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if exportFile is None or exportFile == "": return

        encryptionKey = myPopupAskForInput(toolbox_frame_,
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           theFieldLabel="Encryption password:",
                                           theFieldDescription="Enter any password you like to encrypt the exported data (YOU MUST REMEMBER THIS!)",
                                           isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if encryptionKey is None or encryptionKey == "":
            txt = "Encryption password not entered - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        verifyEncryptionKey = myPopupAskForInput(toolbox_frame_,
                                                theTitle=_THIS_METHOD_NAME.upper(),
                                                theFieldLabel="RE-ENTER the same Encryption password:",
                                                theFieldDescription="REENTER the password to verify it's the same....",
                                                isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if verifyEncryptionKey is None or verifyEncryptionKey == "" or verifyEncryptionKey != encryptionKey:
            txt = "Encryption password not re-entered successfully - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return
        del verifyEncryptionKey

        p_cipher = MDSyncCipher.getDeclaredConstructor([String])                                                        # noqa
        p_cipher.setAccessible(True)
        cipher = p_cipher.newInstance(encryptionKey)
        p_cipher.setAccessible(False)
        del encryptionKey

        p_ges = cipher.getClass().getDeclaredMethod("getEncryptStream", [OutputStream])
        p_ges.setAccessible(True)
        fout = FileOutputStream(File(exportFile))
        export_encryptedStream = p_ges.invoke(cipher,[fout])
        p_ges.setAccessible(False)

        exportMDPlusData = StreamTable()
        exportMDPlusData.put("_TOOLBOX_",_TEST_KEY)
        for object_key in licenseObject.getParameterKeys():
            # encryptedData = String(MDSyncCipher.encryptString(licenseObject.getParameter(object_key), encryptionKey), StandardCharsets.UTF_8)
            theData = licenseObject.getParameter(object_key)
            exportMDPlusData.put(object_key, theData)
            del theData

        MD_REF.getUI().getMain().saveCurrentAccount()

        try:
            exportMDPlusData.writeTo(export_encryptedStream)
            export_encryptedStream.flush(); export_encryptedStream.close()
            fout.close()
            del cipher, exportMDPlusData, licenseObject

            play_the_money_sound()
            txt = "Moneydance+ settings encrypted & exported to: %s" %(exportFile)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

            txt = "Exported (encrypted) file contains confidential MD+(Plaid) key data. Use then DELETE file ASAP!"
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR exporting & decrypting Moneydance+ settings to: %s (review console)" %(exportFile)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def import_MDPlus_Profile():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Import Moneydance+ (Plaid) settings from file"
        _TEST_KEY = "Confidential data: KEYTEST123$"

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME.upper(), "WARNING: This will overwrite/replace/transplant your MD+(Plaid) settings with data from a file. Continue?"):
            return False

        book = MD_REF.getCurrentAccountBook()
        licenseObject = getMDPlusLicenseInfoForBook()

        theTitle = "Select file to Import ('transplant') your Moneydance+ settings/profile from... (CANCEL=ABORT)"
        importFile = getFileFromFileChooser(toolbox_frame_,                                 # Parent frame or None
                                            get_home_dir(),                                 # Starting path
                                            "MoneydancePlus_settings_CONFIDENTIAL.mdp",     # Default Filename
                                            theTitle,                                       # Title
                                            False,                                          # Multi-file selection mode
                                            True,                                           # True for Open/Load, False for Save
                                            True,                                           # True = Files, else Dirs
                                            "IMPORT",                                       # Load/Save button text, None for defaults
                                            "mdp",                                          # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if importFile is None or importFile == "": return False

        encryptionKey = myPopupAskForInput(toolbox_frame_,
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           theFieldLabel="Decryption password:",
                                           theFieldDescription="Enter the encryption password you used when Exporting the data...",
                                           isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if encryptionKey is None or encryptionKey == "":
            txt = "Decryption password not entered - NO IMPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        p_cipher = MDSyncCipher.getDeclaredConstructor([String])                                                        # noqa
        p_cipher.setAccessible(True)
        cipher = p_cipher.newInstance(encryptionKey)
        p_cipher.setAccessible(False)
        del encryptionKey

        p_gds = cipher.getClass().getDeclaredMethod("getDecryptStream", [InputStream])
        p_gds.setAccessible(True)
        fin = FileInputStream(File(importFile))
        import_decryptedStream = p_gds.invoke(cipher,[fin])
        p_gds.setAccessible(False)

        try:
            importMDPlusData = StreamTable()
            importMDPlusData.readFrom(import_decryptedStream)
            import_decryptedStream.close(); fin.close()
            del cipher
            myPrint("DB","Import... StreamTable read & decrypted from file: %s" %(importFile))
        except:
            txt = "ERROR decrypting IMPORT file >> Wrong password entered? (review console) - NO CHANGES MADE!"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return False

        mdplus_keys = [ "mdplus.account_email",
                        "mdplus.pending_email",
                        "signup_status",
                        "mdplus.date",
                        "mdplus.refresh_date",
                        "mdplus.keypair_created",
                        "mdplus.priv",
                        "mdplus.pub"]

        mdplus_validateKeys = [ "_TOOLBOX_",
                                "mdplus.account_email",
                                "signup_status",
                                "mdplus.priv",
                                "mdplus.pub"]

        mdplus_skipKeys = ["_TOOLBOX_",
                           "id",
                           "obj_type",
                           "ts",
                           "_txnfile"]

        # noinspection PyUnresolvedReferences
        for checkKey in mdplus_validateKeys:

            if not importMDPlusData.get(checkKey):
                myPrint("B","Import validation: Failed checking for key '%s' (missing)" %(checkKey))
                txt = "Import file for Moneydance+ settings/profile INVALID - NO IMPORT PERFORMED!"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
                return False

            if checkKey == "_TOOLBOX_":
                if importMDPlusData.get(checkKey) != _TEST_KEY:
                    txt = "Decryption test failed.. Did you enter the correct password? >> NO IMPORT PERFORMED!"
                    setDisplayStatus(txt, "R"); myPrint("B", txt)
                    myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
                    return
                myPrint("B","Verified that the _TOOLBOX_ Key Test properly decrypted... Proceeding....")

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(), "Import ('transplant') Moneydance+ settings/profile from file & OVERWRITE EXISTING SETTINGS?"):
            return False

        if licenseObject is not None:
            myPrint("B","Moneydance+ IMPORT.. Existing settings will be overwritten.. Settings were..:\n", special_toMultilineHumanReadableString(licenseObject))
            licenseObject.setEditingMode()
            for key_to_delete in mdplus_keys: licenseObject.setParameter(key_to_delete, None)
        else:
            myPrint("B","Creating new Moneydance+(Plaid) license object....")
            licenseObject = MoneydanceSyncableItem(book)
            licenseObject.setEditingMode()
            licenseObject.setParameter("id", "tik.mdplus-license")
            licenseObject.setParameter("obj_type", "misc")

        for object_key in importMDPlusData:
            if object_key in mdplus_keys:
                licenseObject.setParameter(object_key, importMDPlusData.get(object_key))
                myPrint("B","IMPORT... Setting key %s into MD+ license object..." %(object_key))
            elif object_key in mdplus_skipKeys: pass
            else: myPrint("B","IMPORT.. Ignoring/skipping the setting: '%s', Value: '%s'" %(object_key,importMDPlusData.get(object_key)))

        licenseObject.syncItem()
        MD_REF.getUI().getMain().saveCurrentAccount()

        # Clear the cache of tokens.... It will rebuild itself...
        MD_REF.getCurrentAccountBook().getLocalStorage().removeSubset("mdp_items")
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()

        del importMDPlusData, licenseObject

        myPrint("B", "Deleting Moneydance+ Import file...: %s" %(importFile))
        try: os.remove(importFile)
        except: pass

        play_the_money_sound()
        txt = "Moneydance+ settings IMPORTED (import file deleted) >> MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD!"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        MD_REF.getUI().exit()

    def zap_MDPlus_Profile():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Zap Dataset's Moneydance+ (Plaid) settings"

        licenseObject = getMDPlusLicenseInfoForBook()

        if licenseObject is None:
            myPopupInformationBox(toolbox_frame_,"NO Moneydance+ settings/profile found - NO CHANGES MADE!",_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return False

        if isMDPlusLicenseActivated():
            ask = MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="WARNING: Attempting to ZAP MD+ settings when Dataset status is ACTIVATED!?",
                                 theTitle=_THIS_METHOD_NAME.upper(),
                                 theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                            "This dataset has an Activated MD+ License.\n"
                                            "If you ZAP, then your Account linkages will still be stored on the IK/Plaid servers ('Zombies')\n"
                                            "You should use the Online/Setup Moneydance+ menu to Disconnect this dataset's account links (first)\n"
                                            "However, if you have 'transplanted' your MD+ license to other datasets, then it's OK to Zap...\n"
                                            "         (as your account links will be accessible from the other dataset with the same MD+ license)\n"
                                            "NOTE: Running ZAP will not cause any harm, but you will have to setup MD+ / PLaid links again (in this dataset)\n"
                                            "\n",
                                 lCancelButton=True,
                                 OKButtonText="I AGREE - PROCEED",
                                 lAlertLevel=2)

            if not ask.go():
                txt = "User did not say yes to ZAP an Activated MD+ license - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return False
            del ask

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"ZAP this Dataset's Moneydance+ settings/profile (USE WITH CARE)?"):
            return False

        myPrint("B", "User requested to delete Moneydance+ settings.... Settings before deletion were..:\n", special_toMultilineHumanReadableString(licenseObject))
        licenseObject.deleteItem()
        MD_REF.getUI().getMain().saveCurrentAccount()
        play_the_money_sound()

        txt = "Moneydance+ settings deleted..! MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        MD_REF.getUI().exit()

    def forgetOFXImportLink():
        global toolbox_frame_, debug

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(10))
        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select an account (only these have remembered links)",
                                                      "FORGET OFX banking link",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      None,
                                                      accounts.toArray(),
                                                      None)
        if not selectedAccount:
            txt = "'RESET BANKING LINK' No Account was selected - no changes made.."
            setDisplayStatus(txt, "R")
            return

        if confirm_backup_confirm_disclaimer(toolbox_frame_,"RESET BANKING LINK", "Forget OFX banking Import link for Acct: %s?" %(selectedAccount) ):

            selectedAccount.setEditingMode()                                                                # noqa
            selectedAccount.removeParameter("ofx_import_acct_num")                                          # noqa
            selectedAccount.removeParameter("ofx_import_remember_acct_num")                                 # noqa
            selectedAccount.syncItem()                                                                      # noqa

            txt = "Banking Import link on account: %s forgotten!" %(selectedAccount)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_, txt, "RESET BANKING LINK",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def download_md_fiscal_setup_for_one_bank(bankID):
        global globalSaveFI_data, MD_OFX_BANK_SETTINGS_DIR

        if globalSaveFI_data is None or len(globalSaveFI_data)<1:
            return

        FI=MD_OFX_BANK_SETTINGS_DIR+bankID.strip()+".dct"
        output = ""
        inx = None

        myPrint("B","######################################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind Servers to download the banking connection profiles for the bank you selected - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","######################################################################################################################################################################")

        try:
            url = URL(FI)
            urlConn = url.openConnection()
            if urlConn is not None:
                rc = urlConn.getResponseCode()                                                                          # noqa
                if rc == 200:
                    inx = BufferedReader(InputStreamReader(urlConn.getInputStream(), "UTF8"))
                    while True:
                        lineofdata = inx.readLine()
                        if lineofdata is None: break
                        output+=(lineofdata+"\n")                                                                      # noqa
        except:
            myPrint("B", "ERROR downloading from Moneydance Fiscal Setup profiles link: %s " %(FI))
            output+="\n@@ERROR downloading from Moneydance Fiscal Setup profiles link: %s\n" %(FI)
            output+=dump_sys_error_to_md_console_and_errorlog(True)
        finally:
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing URL stream %s" %(FI))
                    output+="\n@@Error closing URL stream %s\n" %(FI)
                    output+=dump_sys_error_to_md_console_and_errorlog(True)

        return output

    class FIInfo():
        def __init__(self, info):
            self.info = info
            self.id = info.getStr("id", "")
            self.name = info.getStr("fi_name", "")
            self.lowerName = self.name.lower()

        def __str__(self):
            return "%s (%s)" %(self.name,self.id)

        def __repr__(self):
            return "%s (%s)" %(self.name,self.id)

    # noinspection PyUnresolvedReferences
    def download_md_fiscal_setup():
        global globalSaveFI_data, globalSave_DEBUG_FI_data
        global MD_OFX_DEFAULT_SETTINGS_FILE, MD_OFX_DEBUG_SETTINGS_FILE

        downloadInfo = StreamTable()

        inx = None
        tagText=""
        wait = None

        if globalSaveFI_data is None or len(globalSaveFI_data)<1:

            wait = MyPopUpDialogBox(toolbox_frame_,"PLEASE WAIT - RETRIEVING FISCAL SETUP DATA...",theWidth=100,lModal=False)
            wait.go()

            myPrint("B","###################################################################################################################################################")
            myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind Servers to download the latest banking connection profiles - IT IS NOT SENDING ANY DATA ###")
            myPrint("B","###################################################################################################################################################")

            for theFile in [MD_OFX_DEBUG_SETTINGS_FILE,MD_OFX_DEFAULT_SETTINGS_FILE]:
                myPrint("DB", "Attempting to download: %s" %(theFile))
                try:
                    url = URL(theFile)
                    urlConn = url.openConnection()
                    if urlConn is not None:
                        rc = urlConn.getResponseCode()                                                                     # noqa
                        if rc == 200:
                            inx = BufferedReader(InputStreamReader(urlConn.getInputStream(), "UTF8"))
                            downloadInfo.readFrom(inx)
                            myPrint("DB", "Success downloading: %s" %(theFile))
                except:
                    myPrint("B", "ERROR downloading from Moneydance Fiscal Setup profiles link: %s " %(theFile))
                    dump_sys_error_to_md_console_and_errorlog(False)
                finally:
                    if inx:
                        try:
                            inx.close()
                        except:
                            myPrint("B", "Error closing URL stream %s" %(theFile))
                            dump_sys_error_to_md_console_and_errorlog()

                matches=None
                overrideMessage = downloadInfo.getStr("override_msg", None)
                ifNoneAvailableMessage = downloadInfo.getStr("no_fis_msg", None)
                infoMessage = downloadInfo.getStr("extra_msg", None)
                if overrideMessage is not None:
                    tagText=overrideMessage
                else:
                    matchesObj = downloadInfo.get("matches")
                    matches = ArrayList()
                    if isinstance(matchesObj,(StreamVector)):
                        matchesVector = matchesObj
                        for matchObj in matchesVector:
                            if isinstance(matchObj, StreamTable):
                                matches.add(FIInfo(matchObj))
                    matchCount = 0
                    for i in range(0, matches.size()):
                        if matches is None: break
                        match = matches.get(i)
                        minVersion = match.info.getInt("min_version", 0)                                                    # noqa
                        maxVersion = match.info.getInt("max_version", 99999999)                                             # noqa

                        # Mirrors code (ish) from: com.moneydance.apps.md.view.gui.ofxsetup.OFXNewFIPanel.run() Line 294 ("min_version", "max_version)
                        if ((float(MD_REF.getBuild())) < minVersion or (float(MD_REF.getBuild())) > maxVersion):
                            matches.remove(i)
                            # i-=1
                        else:
                            matchCount+=1
                            i+=1
                    if matchCount == 0 and ifNoneAvailableMessage is not None:
                        tagText= ifNoneAvailableMessage
                    elif infoMessage is not None:
                        tagText=infoMessage

                if theFile == MD_OFX_DEFAULT_SETTINGS_FILE:
                    globalSaveFI_data=matches
                    globalSaveFI_data = sorted(globalSaveFI_data, key=lambda sort_x: (sort_x.lowerName, sort_x.id))
                else:
                    globalSave_DEBUG_FI_data=matches
                    globalSave_DEBUG_FI_data = sorted(globalSave_DEBUG_FI_data, key=lambda sort_x: (sort_x.lowerName, sort_x.id))

        output="Moneydance's Fiscal Institution Initial Dynamic Setup profiles..\n" \
               " ==============================================================\n\n"

        if len(tagText)>0:
            output+="\n%s\n\n" %(tagText)

        miniList=[]
        for bankSetup in globalSaveFI_data:
            output += "\nName: %s (%s)\n" %(bankSetup.name,bankSetup.id)
            miniList.append(bankSetup.lowerName)
            for element in bankSetup.info:
                if element == "id" or element == "fi_name": continue
                output+=" %s %s\n" %(pad(element+":",30), bankSetup.info.get(element))

        miniListDEBUG=[]
        for bankSetup in globalSave_DEBUG_FI_data:
            miniListDEBUG.append(bankSetup.lowerName)

        if len(globalSaveFI_data)<1:
            output+="\nNO SETUP FOUND... DID SOMETHING GO WRONG? REVIEW CONSOLE ERROR LOG..!\n\n"

        output+="\n<END>"

        if wait is not None: wait.kill()

        jif = QuickJFrame("VIEW Moneydance's Dynamic / live Fiscal Institution setup profiles", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if len(miniList)>0:
            selectedID = JOptionPane.showInputDialog(jif,
                                                     "Select Bank Profile to view specific setup data",
                                                      "VIEW SPECIFIC SETUP DATA",
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      None,
                                                      globalSaveFI_data,
                                                      None)
            if selectedID:
                specificText = download_md_fiscal_setup_for_one_bank(selectedID.id)

                output="Moneydance's Fiscal Institution Initial Dynamic Setup profiles..\n" \
                       " ==============================================================\n\n" \
                       "Initial/Default Setup:\n" \
                       "----------------------\n"

                output += "\nName: %s (%s)\n" %(selectedID.name,selectedID.id)
                for element in selectedID.info:
                    if element == "id" or element == "fi_name": continue

                    extraText=""
                    if element == "dt_prof_updated": extraText="(%s)" %(get_time_stamp_as_nice_text(int(selectedID.info.get(element))))
                    output+=" %s %s %s\n" %(pad(element+":",30), selectedID.info.get(element),extraText)

                try:
                    output += "\n\nDEBUG Setup:\n" \
                              "--------------------------\n"
                    for findID in globalSave_DEBUG_FI_data:
                        if findID.id == selectedID.id:
                            for element in findID.info:
                                if element == "id" or element == "fi_name": continue
                                extraText=""
                                if element == "dt_prof_updated": extraText="(%s)" %(get_time_stamp_as_nice_text(int(findID.info.get(element))))
                                output+=" %s %s %s\n" %(pad(element+":",30), findID.info.get(element),extraText)
                            break
                except:
                    pass

                output += "\n\nSPECIFIC OVERRIDING Setup:\n" \
                       "--------------------------\n"
                output+=specificText
                output+="\n<END>"

                QuickJFrame("VIEW Moneydance's Specific (dynamic) Fiscal Institution setup profiles", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        return

    def get_the_objects_for_geekout_and_hacker_edit(objWhat, selectedObjType, titleStr, lForceOneTxn):

        # Yes, I know, repeated from calling function.... EDIT IN BOTH PLACES!
        # You need to edit the below in the sub def function too!!! (sorry ;-> )
        _OBJROOT        =  0
        _OBJACCT        =  1
        _OBJCAT         =  2
        _OBJACCTSEC     =  3
        _OBJCURR        =  4
        _OBJSEC         =  5
        _OBJREMINDERS   =  6
        _REPORT_MEM     =  7
        _GRAPH_MEM      =  8
        _REPORT_DEF     =  9
        _GRAPH_DEF      =  10
        _OBJADDRESSES   =  11
        _OBJOFXONLINE   =  12
        _OBJBYUUID      =  13
        _OBJTRANSACTION =  14
        _OBJSECSUBTYPES =  15
        _OBJMDPLUSLIC   =  16
        _OBJOFXMAPPINGS =  17
        _OBJOFXOLPAYEES =  18
        _OBJOFXOLPAYMNT =  19
        _OBJOFXTXNS     =  20

        lReportDefaultsSelected = False

        def getCurrTable(cType):

            cTable=ArrayList()
            myTable = MD_REF.getCurrentAccountBook().getCurrencies()
            myTable = sorted(myTable, key=lambda sort_x: (sort_x.getCurrencyType(), sort_x.getName().upper()))
            for curr in myTable:
                if curr.getCurrencyType() == cType:
                    cTable.add(curr)
            return cTable

        def getReportsTable(memorized_default_or_all, report_or_graph_or_all):

            theReports = None

            repTable=ArrayList()
            if report_or_graph_or_all == "ALL":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllItems()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllMemorizedItems()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllItems()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            elif report_or_graph_or_all == "REPORT":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllReports()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedReports()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllReports()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            elif report_or_graph_or_all == "GRAPH":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllGraphs()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedGraphs()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllGraphs()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            else:
                assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))

            # For Default return non memorized Items
            for rep in theReports:
                if not rep.isMemorized():
                    repTable.add(rep)

            return repTable

        objects = None
        try:
            if objWhat.index(selectedObjType) == _OBJROOT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(12))
                # The palaver below is to get the list sorted.....
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJACCT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(7))
                # The palaver below is to get the list sorted.....
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJCAT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(8)).toArray()
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJACCTSEC:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(9)).toArray()
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJCURR:
                # noinspection PyUnresolvedReferences
                objects = getCurrTable(CurrencyType.Type.CURRENCY)
            elif objWhat.index(selectedObjType) == _OBJSEC:
                # noinspection PyUnresolvedReferences
                objects = getCurrTable(CurrencyType.Type.SECURITY)
            elif objWhat.index(selectedObjType) == _REPORT_MEM:
                objects = getReportsTable("MEMORIZED", "REPORT")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _GRAPH_MEM:
                objects = getReportsTable("MEMORIZED", "GRAPH")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _REPORT_DEF:
                lReportDefaultsSelected = True
                objects = getReportsTable("DEFAULT", "REPORT")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _GRAPH_DEF:
                lReportDefaultsSelected = True
                objects = getReportsTable("DEFAULT", "GRAPH")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _OBJREMINDERS:
                root = MD_REF.getCurrentAccountBook()
                objects = root.getReminders().getAllReminders()
                objects = sorted(objects, key=lambda x: (x.getDescription().upper()))
            elif objWhat.index(selectedObjType) == _OBJADDRESSES:
                root = MD_REF.getCurrentAccountBook()
                objects = root.getAddresses().getAllEntries()
                objects = sorted(objects, key=lambda x: (x.getName().upper()))
            elif objWhat.index(selectedObjType) == _OBJOFXONLINE:
                objects = MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices()
                objects = sorted(objects, key=lambda x: (x.getFIName().upper()))
            elif objWhat.index(selectedObjType) == _OBJBYUUID:
                pass
            elif objWhat.index(selectedObjType) == _OBJTRANSACTION:
                pass
            elif objWhat.index(selectedObjType) == _OBJSECSUBTYPES:
                item = MD_REF.getCurrentAccount().getBook().getItemForID("security_subtypes")             # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have a 'security_subtypes' to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif objWhat.index(selectedObjType) == _OBJMDPLUSLIC:
                item = getMDPlusLicenseInfoForBook()                        # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have a Moneydance+ license object to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif objWhat.index(selectedObjType) == _OBJOFXMAPPINGS:
                item = MD_REF.getCurrentAccount().getBook().getItemForID("online_acct_mapping")           # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have an OFX Account Mappings object to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif (objWhat.index(selectedObjType) == _OBJOFXOLPAYEES
                  or objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT
                  or objWhat.index(selectedObjType) == _OBJOFXTXNS):

                accountsListForOlTxns = None
                if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(16))
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(17))

                accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

                selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the Acct to find Online Data about:",
                                                             "Select ACCOUNT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                             accountsListForOlTxns,
                                                             None)
                if not selectedAcct:
                    txt = "No Account was selected.."
                    setDisplayStatus(txt, "R")
                    return None, lReportDefaultsSelected

                if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                    objects = [StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                    objects = [StoreTheOnlinePayeeList(MyGetOnlinePayees(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                    objects = [StoreTheOnlinePaymentList(MyGetOnlinePayments(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)

            else:
                return None, lReportDefaultsSelected
        except:
            dump_sys_error_to_md_console_and_errorlog( True )
            return None, lReportDefaultsSelected

        if objWhat.index(selectedObjType) == _OBJTRANSACTION:

            dateStart = 20251231
            dateEnd = 20251231

            dateTxt=""
            if lForceOneTxn:
                labelDateStart = JLabel("Select the Date (enter as yyyy/mm/dd):")
            else:
                dateTxt="Range "
                labelDateStart = JLabel("Date range start (enter as yyyy/mm/dd):")
            user_selectDateStart = JDateField(CustomDateFormat("ymd"),15)   # Use MD API function (not std Python)
            user_selectDateStart.setDateInt(dateStart)

            labelDateEnd = JLabel("Date range end (enter as yyyy/mm/dd):")
            user_selectDateEnd = JDateField(CustomDateFormat("ymd"),15)   # Use MD API function (not std Python)
            user_selectDateEnd.setDateInt(dateEnd)

            datePanel = JPanel(GridLayout(0, 2))
            datePanel.add(labelDateStart)
            datePanel.add(user_selectDateStart)

            if not lForceOneTxn:
                datePanel.add(labelDateEnd)
                datePanel.add(user_selectDateEnd)

            options = ["Cancel", "OK"]

            while True:
                userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                          datePanel,
                                                          "%s: Select Date %sfor TXNs (less is better)" %(titleStr,dateTxt),
                                                          JOptionPane.OK_CANCEL_OPTION,
                                                          JOptionPane.QUESTION_MESSAGE,
                                                          None,
                                                          options,
                                                          options[1])

                if userAction != 1:
                    txt = "%s: User cancelled Date Selection for TXN Search" %(titleStr)
                    setDisplayStatus(txt, "R")
                    return None, lReportDefaultsSelected

                if lForceOneTxn:
                    user_selectDateEnd.setDateInt( user_selectDateStart.getDateInt() )

                if user_selectDateStart.getDateInt() <= user_selectDateEnd.getDateInt() \
                        and user_selectDateEnd.getDateInt() >= user_selectDateStart.getDateInt():
                    break   # Valid date range

                user_selectDateStart.setForeground(getColorRed())                                                       # noqa
                user_selectDateEnd.setForeground(getColorRed())                                                         # noqa
                continue   # Loop

            if objWhat.index(selectedObjType) == _OBJTRANSACTION:
                txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactions(
                                            MyTxnSearchFilter(user_selectDateStart.getDateInt(),user_selectDateEnd.getDateInt()))
            else:
                txns = []

            if not txns or txns.getSize() <1:
                txt = "%s: No Transactions Found.."  %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            if not lForceOneTxn:
                if txns.getSize() > 50:
                    txt = "%s:TXN SEARCH FOUND %s TXNs. TOO MANY, WILL ABORT...."%(titleStr,txns.getSize())
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt)
                    return None, lReportDefaultsSelected

            if lForceOneTxn:
                objects=ArrayList()
                for txn in txns:
                    objects.add(txn)
            else:
                objects = txns

        if objWhat.index(selectedObjType) == _OBJBYUUID:
            theUUID = myPopupAskForInput(toolbox_frame_, "GET SINGLE OBJECT BY UUID", "UUID:", "%s: Enter the UUID of the Object to get" %(titleStr), "", False)

            if not theUUID or theUUID == "":
                txt = "%s: No Object UUID was entered.." %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            selectedObject = MD_REF.getCurrentAccount().getBook().getItemForID(theUUID.strip())
            if selectedObject is None:
                txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
                selectedObject = txnSet.getTxnByID(theUUID.strip())

            objects  = [selectedObject]
            if not selectedObject:
                txt = "%s: No Object was found for UUID: %s" %(titleStr,theUUID)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected


        if (objWhat.index(selectedObjType) == _OBJTRANSACTION and not lForceOneTxn):
            pass
        else:
            if len(objects) > 0 and isinstance(objects[0],(ParentTxn,SplitTxn)):

                class StoreTheTxn:
                    def __init__(self, obj):
                        if isinstance(obj,(ParentTxn,SplitTxn)):
                            self.obj = obj
                        else:
                            self.obj = None

                    def __str__(self):
                        MD_decimal = MD_REF.getPreferences().getDecimalChar()
                        if self.obj is None: return "Invalid Txn Obj or None"
                        _txt = "PARENT TXN: "
                        if isinstance(self.obj, SplitTxn): _txt = "SPLIT TXN:  "
                        curr = self.obj.getAccount().getCurrencyType()
                        _txt += "Date: %s " %(convertStrippedIntDateFormattedText(self.obj.getDateInt()))
                        _txt += "%s " %(pad(self.obj.getDescription(),40))
                        _txt += "Value: %s" %(rpad(curr.formatFancy(self.obj.getValue(),MD_decimal),15))
                        return _txt

                    def __repr__(self): return self.__str__()

                storeTheTxns = []
                for storeTxn in objects:
                    storeTheTxns.append( StoreTheTxn(storeTxn))

                selectedObject = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the specific Txn to %s" %(titleStr),
                                                             "Select Specific Txn",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                             storeTheTxns,
                                                             None)

                objects  = [selectedObject.obj]                                                                         # noqa

            else:

                selectedObject = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the specific Object to %s" %(titleStr),
                                                             "Select Specific Object",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                             objects,
                                                             None)
                objects  = [selectedObject]

            if not selectedObject:
                txt = "%s: No Object was selected.." %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            if (objWhat.index(selectedObjType) == _OBJOFXTXNS
                    or objWhat.index(selectedObjType) == _OBJOFXOLPAYEES
                    or objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT):
                # noinspection PyUnresolvedReferences
                objects = [selectedObject.obj]       # Use my version to prevent creation of default record(s)

        return objects, lReportDefaultsSelected

    def hackerRemoveInternalFilesSettings():
        thisDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

        filesToRemove = []
        for wrapper in AccountBookUtil.getInternalAccountBooks():
            internal_filepath = wrapper.getBook().getRootFolder().getCanonicalPath()
            if internal_filepath == thisDataset:
                continue
            filesToRemove.append(internal_filepath)

        if len(filesToRemove)<1:
            txt = "HACK: DELETE internal / Default Dataset(s) from DISK - You have no files to DELETE - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        iFilesOnDiskRemoved = 0

        while True:

            selectedFile = None
            if len(filesToRemove) > 0:
                saveOK = UIManager.get("OptionPane.okButtonText")
                saveCancel = UIManager.get("OptionPane.cancelButtonText")
                UIManager.put("OptionPane.okButtonText", "DELETE DATASET FROM DISK")
                UIManager.put("OptionPane.cancelButtonText", "EXIT")

                selectedFile = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the default/internal location Dataset to DELETE from disk",
                                                           "HACKER - DELETE FROM DISK",
                                                           JOptionPane.ERROR_MESSAGE,
                                                           None,
                                                           filesToRemove,
                                                           None)

                UIManager.put("OptionPane.okButtonText", saveOK)
                UIManager.put("OptionPane.cancelButtonText", saveCancel)

            if not selectedFile:
                if iFilesOnDiskRemoved<1:
                    txt = "Thank you for using HACKER MODE!.. No changes made"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                else:
                    txt = "Thank you for using HACKER MODE!.. %s Datasets DELETED" %(iFilesOnDiskRemoved)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if os.path.exists(selectedFile):
                if not myPopupAskQuestion(toolbox_frame_,
                                      "HACKER - DISCLAIMER - ARE YOU SURE?",
                                      "Are you SURE you REALLY want me to DELETE the %s dataset from disk?" %(selectedFile),
                                      theMessageType=JOptionPane.ERROR_MESSAGE):
                    continue

                filesToRemove.remove(selectedFile)

                try:
                    shutil.rmtree(selectedFile)
                    iFilesOnDiskRemoved+=1
                    play_the_money_sound()
                    txt = "@@ HACKERMODE: Dataset %s removed from disk" %(selectedFile)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_,
                                          txt,
                                          "HACKER - DELETE FILE FROM DISK",
                                          JOptionPane.ERROR_MESSAGE)
                except:
                    dump_sys_error_to_md_console_and_errorlog()
                    txt = "@ERROR@ Hacker - Dataset %s FAILED TO remove from disk" %(selectedFile)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_,
                                          "@ERROR@ Hacker - Dataset %s FAILED TO remove from disk" %(selectedFile),
                                          "HACKER - ERROR",
                                          JOptionPane.ERROR_MESSAGE)

            continue

        del filesToRemove

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hackerRemoveExternalFilesSettings():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if not backup_config_dict():
            txt = "HACK: Remove files from 'External' (non-default) filelist in File/Open - Error backing up config.dict preferences file - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        theKey = "external_files"
        prefs = MD_REF.getUI().getPreferences()
        thisDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

        externalFilesVector = prefs.getVectorSetting("external_files", StreamVector())

        filesToRemove = []
        for externalFileObj in externalFilesVector:
            if externalFileObj != thisDataset:
                filesToRemove.append(externalFileObj)

        if externalFilesVector is None or len(filesToRemove)<1:
            txt = "HACK: Remove files from 'External' (non-default) filelist in File/Open - You have no %s files in config.dict to edit - no changes made...." %(theKey)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,"You have no 'External' file references in config.dict to remove - NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        iReferencesRemoved = 0
        iFilesOnDiskRemoved = 0

        while True:

            selectedFile = None
            if len(filesToRemove) > 0:
                saveOK = UIManager.get("OptionPane.okButtonText")
                saveCancel = UIManager.get("OptionPane.cancelButtonText")
                UIManager.put("OptionPane.okButtonText", "REMOVE FILE REFERENCE FROM File/Open")
                UIManager.put("OptionPane.cancelButtonText", "EXIT")

                selectedFile = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the 'External' (non-default) file reference to remove",
                                                           "HACKER",
                                                           JOptionPane.WARNING_MESSAGE,
                                                           None,
                                                           filesToRemove,
                                                           None)

                UIManager.put("OptionPane.okButtonText", saveOK)
                UIManager.put("OptionPane.cancelButtonText", saveCancel)

            if not selectedFile:
                if (iReferencesRemoved+iFilesOnDiskRemoved)<1:
                    txt = "HACKER MODE!.. No changes made"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return
                else:
                    txt = "HACKER MODE!.. %s references removed and %s Datasets DELETED - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD" %(iReferencesRemoved, iFilesOnDiskRemoved)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                    MD_REF.getUI().exit()

            iReferencesRemoved+=1
            filesToRemove.remove(selectedFile)

            externalFilesVector.remove(selectedFile)
            prefs.setSetting("external_files", externalFilesVector)
            MD_REF.savePreferences()
            txt = "I have removed the reference to file %s from config.dict (and file/open menu if present)" %(selectedFile)
            myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_,txt,"HACKER",JOptionPane.WARNING_MESSAGE)

            if not os.path.exists(selectedFile): continue

            if not myPopupAskQuestion(toolbox_frame_,
                                  "HACKER",
                                  "Would you like me to DELETE the %s dataset from disk too?" %(selectedFile),
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
                continue

            try:

                shutil.rmtree(selectedFile)
                iFilesOnDiskRemoved+=1

                myPrint("B","Hacker - Dataset %s removed from disk" %(selectedFile))
                play_the_money_sound()
                txt = "Hacker - Dataset %s removed from disk" %(selectedFile)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt, "HACKER", theMessageType=JOptionPane.ERROR_MESSAGE)
            except:
                dump_sys_error_to_md_console_and_errorlog()
                txt = "@ERROR@ Hacker - Dataset %s FAILED TO remove from disk" %(selectedFile)
                myPrint("B",txt)
                myPopupInformationBox(toolbox_frame_, txt, "HACKER", theMessageType=JOptionPane.WARNING_MESSAGE)

            continue

        del filesToRemove

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    class MyMoneydanceEventListener(AppEventListener):

        def __init__(self, theFrame):
            self.alreadyClosed = False
            self.theFrame = theFrame
            self.myModuleID = myModuleID

        def getMyself(self):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
            fm = MD_REF.getModuleForID(self.myModuleID)
            if fm is None: return None, None
            try:
                pyo = fm.getClass().getDeclaredField("extensionObject")
                pyo.setAccessible(True)
                pyObject = pyo.get(fm)
                pyo.setAccessible(False)
            except:
                myPrint("DB","Error retrieving my own Python extension object..?")
                dump_sys_error_to_md_console_and_errorlog()
                return None, None

            return fm, pyObject

        def handleEvent(self, appEvent):
            global debug

            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))
            myPrint("DB", "I am .handleEvent() within %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
            myPrint("DB","Extension .handleEvent() received command: %s" %(appEvent))

            if self.alreadyClosed:
                myPrint("DB","....I'm actually still here (MD EVENT %s CALLED).. - Ignoring and returning back to MD...." %(appEvent))
                return

            # MD doesn't call .unload() or .cleanup(), so if uninstalled I need to close myself
            fm, pyObject = self.getMyself()
            myPrint("DB", "Checking myself: %s : %s" %(fm, pyObject))
            # if (fm is None or pyObject is None) and appEvent != "md:app:exiting":
            if (fm is None or (self.theFrame.isRunTimeExtension and pyObject is None)) and appEvent != "md:app:exiting":
                myPrint("B", "@@ ALERT - I've detected that I'm no longer installed as an extension - I will deactivate.. (switching event code to :close)")
                appEvent = "%s:customevent:close" %self.myModuleID

            # I am only closing Toolbox when a new Dataset is opened.. I was calling it on MD Close/Exit, but it seemed to cause an Exception...
            if (appEvent == "md:file:closing"
                    or appEvent == "md:file:closed"
                    or appEvent == "md:file:opening"
                    or appEvent == "md:app:exiting"):
                myPrint("DB","@@ Ignoring MD handleEvent: %s" %(appEvent))

            elif (appEvent == "md:file:opened" or appEvent == "%s:customevent:close" %self.myModuleID):
                if debug:
                    myPrint("DB","MD event %s triggered.... Will call GenericWindowClosingRunnable (via the Swing EDT) to push a WINDOW_CLOSING Event to %s to close itself (while I exit back to MD quickly) ...." %(appEvent, self.myModuleID))
                else:
                    myPrint("B","Moneydance triggered event %s triggered - So I am closing %s now...." %(appEvent, self.myModuleID))
                self.alreadyClosed = True
                try:
                    # t = Thread(GenericWindowClosingRunnable(self.theFrame))
                    # t.start()
                    SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.theFrame))
                    myPrint("DB","Back from calling GenericWindowClosingRunnable to push a WINDOW_CLOSING Event (via the Swing EDT) to %s.... ;-> ** I'm getting out quick! **" %(self.myModuleID))
                except:
                    dump_sys_error_to_md_console_and_errorlog()
                    myPrint("B","@@ ERROR calling GenericWindowClosingRunnable to push  a WINDOW_CLOSING Event (via the Swing EDT) to %s.... :-< ** I'm getting out quick! **" %(self.myModuleID))
                if not debug: myPrint("DB","Returning back to Moneydance after calling for %s to close...." %self.myModuleID)

            # md:file:closing	The Moneydance file is being closed
            # md:file:closed	The Moneydance file has closed
            # md:file:opening	The Moneydance file is being opened
            # md:file:opened	The Moneydance file has opened
            # md:file:presave	The Moneydance file is about to be saved
            # md:file:postsave	The Moneydance file has been saved
            # md:app:exiting	Moneydance is shutting down
            # md:account:select	An account has been selected by the user
            # md:account:root	The root account has been selected
            # md:graphreport	An embedded graph or report has been selected
            # md:viewbudget	One of the budgets has been selected
            # md:viewreminders	One of the reminders has been selected
            # md:licenseupdated	The user has updated the license

    def getUpdatedAuthenticationKeys():

        _storage = SyncRecord()
        _authenticationCache = SyncRecord()

        try:
            LS = MD_REF.getCurrentAccount().getBook().getLocalStorage()
            LS.save()

            localFile = File(os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"safe","settings"))
            if localFile.exists() and localFile.canRead():
                inx = LS.openFileForReading("settings")
                _storage.readSet(inx)
                _authenticationCache = _storage.getSubset("_authentication")
                inx.close()
        except:
            myPrint("B","@@@ ERROR Reading authentication cache from settings @@@")
            dump_sys_error_to_md_console_and_errorlog()

        del _storage
        return _authenticationCache

    class GeekOutModeButtonAction(AbstractAction):

        def __init__(self, lOFX=False, EDIT_MODE=False):
            self.lOFX = lOFX
            self.EDIT_MODE = EDIT_MODE

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            if MD_REF.getCurrentAccount().getBook() is None: return

            _SEARCH   = 0
            _ROOTKEYS = 1
            _BOOKKEYS = 2
            _PREFKEYS = 3
            _ACCTKEYS = 4
            _OBJKEYS  = 5
            _SYNCKEYS = 6
            _BANKKEYS = 7
            _SIZEKEYS = 8
            _OSPROPS  = 9
            _OSENV    = 10

            what = [
                "Search for a key/data (in most places  - but not txns)",
                "Show ROOT Account's Parameter Keys and data",
                "Show Dataset's Local Storage Keys and data (from ./safe/settings)",
                "Show All User Preferences loaded into Memory (from config.dict)",
                "Show Accounts' Parameter's Keys and Data",
                "Show an Obj's settings/data (Acct, Cat, Curr, Security, Reports, Reminders, Addrs, OFX, by UUID, TXNs)",
                "Show All Sync Settings",
                "Show All Online Banking (Searches for OFX) Settings",
                "Show all Settings relating to Window Locations/Sizes/Widths/Sort Order/Filters/Initial Reg View etc..",
                "Show all Operating 'System' Properties",
                "Show all Operating System Environment Variables"]

            # You need to edit the below in the sub function and edit function too!!! (sorry ;-> )
            _OBJROOT        =  0
            _OBJACCT        =  1
            _OBJCAT         =  2
            _OBJACCTSEC     =  3
            _OBJCURR        =  4
            _OBJSEC         =  5
            _OBJREMINDERS   =  6
            _REPORT_MEM     =  7
            _GRAPH_MEM      =  8
            _REPORT_DEF     =  9
            _GRAPH_DEF      =  10
            _OBJADDRESSES   =  11
            _OBJOFXONLINE   =  12
            _OBJBYUUID      =  13
            _OBJTRANSACTION =  14
            _OBJSECSUBTYPES =  15
            _OBJMDPLUSLIC   =  16
            _OBJOFXMAPPINGS =  17
            _OBJOFXOLPAYEES =  18
            _OBJOFXOLPAYMNT =  19
            _OBJOFXTXNS     =  20

            objWhat = [                 # Note - I haven't included csnaps/csplit - they don't actually return the map / keys.....
                "ROOT (the master/parent/top-level Account)",
                "Account",
                "Category",
                "Security sub-account",
                "Currency",
                "Security (from Currency Table)",
                "Reminders",
                "Report (Memorized)",
                "Graph (Memorized)",
                "Report (Default)",
                "Graph (Default)",
                "Address Book Entry",
                "Online OFX Services (Bank Logon Profiles)",
                "Object by UUID",
                "Object Transactions (by date)",                    # TransactionSet(ParentTxn) "txn"
                "Security Sub Types",                               # moneydanceSyncableItem    ID:"secsubtypes"
                "Moneydance+ Settings/Profile (MD2022 onwards)",    # moneydanceSyncableItem    ID:"tik.mdplus-license"
                "OFX Account Mappings (MD2022 onwards)"             # moneydanceSyncableItem    ID:"online_acct_mapping"
            ]

            if not self.lOFX:                                   # ... and not self.EDIT_MODE:
                objWhat += [
                    "OFX Online Payees",                         # onlinePayeeList           "olpayees"
                    "OFX Online Payments",                       # onlinePaymentList         "olpmts"
                    "OFX Online Transactions"                    # onlineTxnList             "oltxns"
                ]

            if self.lOFX:
                selectedWhat = what[_BANKKEYS]
            elif self.EDIT_MODE:
                selectedWhat = what[_OBJKEYS]
            else:
                selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the type of Key data you want to view",
                                                           "GEEK OUT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                           what,
                                                           None)
                if not selectedWhat:
                    txt = "GEEKOUT: No data type was selected to Geek out on.."
                    setDisplayStatus(txt, "B")
                    return

            myPrint("J", "User has requested to view internal Moneydance Settings (Geek Out Mode): %s"%selectedWhat)

            lObject = False
            selectedObject = None                                                                               # noqa
            lReportDefaultsSelected = False

            root = MD_REF.getCurrentAccountBook().getRootAccount()

            output = ""

            searchWhat = ""
            lSearch = lKeys = lKeyData = False
            if selectedWhat == what[_SEARCH]:
                lSearch = True

                selectedSearch = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "SEARCH: Keys or Key Data?",
                                                             "GEEK OUT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                             ["Keys","Key Data"],
                                                             None)
                if not selectedSearch:
                    txt = "GEEKOUT: No Search type selected (to Geek out on..)"
                    setDisplayStatus(txt, "B")
                    return

                if selectedSearch == "Keys": lKeys = True
                elif selectedSearch == "Key Data": lKeyData = True
                else:
                    raise(Exception("ERROR: Unknown Geekout Search Key type selected!?"))

                searchWhat = myPopupAskForInput(toolbox_frame_, "GEEK OUT: SEARCH", "%s:" % selectedSearch, "Enter the (partial) string to search for within %s..." % selectedSearch, "", False)
                if not searchWhat or searchWhat == "":
                    txt = "GEEKOUT: No Search data selected (to Geek out on..)"
                    setDisplayStatus(txt, "B")
                    return
                searchWhat=searchWhat.strip()

            if selectedWhat == what[_OBJKEYS]:
                lObject = True

                titleText="GEEK OUT"
                moreText="VIEW"
                lFindInHackerMode=False
                if self.EDIT_MODE:
                    titleText="HACK"
                    lFindInHackerMode=True
                    moreText="HACK/CHANGE"

                selectedObjType = JOptionPane.showInputDialog(toolbox_frame_,
                                                              "Select the type of Object you want to %s" %(moreText),
                                                              "%s" %(titleText),
                                                              JOptionPane.INFORMATION_MESSAGE,
                                                              MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                              objWhat,
                                                              None)
                if not selectedObjType:
                    txt = "%s: No Object type was selected.."%(titleText)
                    setDisplayStatus(txt, "B")
                    return

                baseCurr = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

                objects, lReportDefaultsSelected = get_the_objects_for_geekout_and_hacker_edit(objWhat, selectedObjType,"%s" %(titleText), lFindInHackerMode)
                if self.EDIT_MODE:
                    return objects
                else:
                    if objects is None:
                        return

            lSync = lOFX = lSizes = False
            if selectedWhat == what[_SYNCKEYS]: lSync = True
            if selectedWhat == what[_BANKKEYS]: lOFX = True
            if selectedWhat == what[_SIZEKEYS]: lSizes = True

            try:
                if lObject:  # selected object

                    output += "\n ====== SELECTED OBJECT's RAW PARAMETER KEYS ======\n"

                    for selectedObject in objects:                                                                      # noqa
                        # noinspection PyUnresolvedReferences
                        keys=sorted(selectedObject.getParameterKeys())
                        output += "\nObject Type: %s\n" %type(selectedObject)

                        if isinstance(selectedObject, Account):
                            # noinspection PyUnresolvedReferences
                            if selectedObject.getAccountType() == Account.AccountType.ROOT:
                                output += "\n@@OBJECT IS ACCOUNT AND IT IS ROOT\n"
                            else:
                                output += "\nAccount  Type: %s\n" %selectedObject.getAccountType()

                        if isinstance(selectedObject, (ParentTxn,SplitTxn)):
                            output += "Account: %s\n" %selectedObject.getAccount()

                        for theKey in keys:
                            # noinspection PyUnresolvedReferences
                            value = selectedObject.getParameter(theKey)
                            output += pad("Key:%s" %theKey,50)+" Value: '%s'\n" %(value.strip())

                        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                            if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

                        if isinstance(selectedObject, OnlineTxnList):
                            output += "\nMD User Representation of Data Held by this Account/OnlineTxnList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getTxnCount():",50),                        selectedObject.getTxnCount()  )
                            output += "%s %s (%s)\n" % (pad("getOFXLastTxnUpdate():",50),           selectedObject.getOFXLastTxnUpdate(), DateUtil.convertLongDateToInt(selectedObject.getOFXLastTxnUpdate())  )
                            output += "%s %s\n" % (pad("hasOnlineAvailBalance():",50),              selectedObject.hasOnlineAvailBalance()  )
                            output += "%s %s\n" % (pad("getOnlineAvailBalance():",50),              selectedObject.getOnlineAvailBalance()  )
                            output += "%s %s (%s)\n" % (pad("getOnlineAvailBalanceDate():",50),     selectedObject.getOnlineAvailBalanceDate(), DateUtil.convertLongDateToInt(selectedObject.getOnlineAvailBalanceDate())  )
                            output += "%s %s\n" % (pad("hasOnlineLedgerBalance():",50),             selectedObject.hasOnlineLedgerBalance()  )
                            output += "%s %s\n" % (pad("getOnlineLedgerBalance():",50),             selectedObject.getOnlineLedgerBalance()  )
                            output += "%s %s (%s)\n" % (pad("getOnlineLedgerBalanceDate():",50),    selectedObject.getOnlineLedgerBalanceDate(), DateUtil.convertLongDateToInt(selectedObject.getOnlineLedgerBalanceDate())  )

                        if isinstance(selectedObject, OnlinePayeeList):
                            output += "\nMD User Representation of Data Held by this Account/OnlinePayeeList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getPayeeCount():",50),             selectedObject.getPayeeCount()  )

                        if isinstance(selectedObject, OnlinePaymentList):
                            output += "\nMD User Representation of Data Held by this Account/OnlinePaymentList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getPaymentCount():",50),           selectedObject.getPaymentCount()  )

                        if isinstance(selectedObject, Account):
                            try:
                                theCurr = selectedObject.getCurrencyType()
                                output += "\nMD User Representation of Data Held by this Account/Category\n"
                                output += " =============================================================\n"
                                output += "%s %s\n" % (pad("Object's Sync Type:",50),                selectedObject.getSyncItemType()  )
                                output += "%s %s\n" % (pad("Account Name:",50),                      selectedObject.getAccountName()   )
                                if selectedObject.getParentAccount() is not None:
                                    output += "%s %s\n" % (pad("Parent Account Name:",50),           selectedObject.getParentAccount().getAccountName() )
                                output += "%s %s\n" % (pad("Full Account Name:",50),                 selectedObject.getFullAccountName()                )
                                output += "%s %s\n" % (pad("Account Type:",50),                      selectedObject.getAccountType()                    )
                                output += "%s %s\n" % (pad("Account Description:",50),               selectedObject.getAccountDescription()             )
                                output += "%s %s\n" % (pad("Account Start Date:",50),                selectedObject.getCreationDateInt()                )
                                output += "%s %s\n" % (pad("Comment:",50),                           selectedObject.getComment()                        )
                                output += "%s %s\n" % (pad("Account Number (Legacy):",50),           selectedObject.getAccountNum()                     )
                                output += "%s %s\n" % (pad("Account Is Inactive:",50),               selectedObject.getAccountIsInactive()              )
                                output += "%s %s\n" % (pad("Account Or Parent Is Inactive:",50),     selectedObject.getAccountOrParentIsInactive()      )
                                output += "%s %s\n" % (pad("Hidden from Home Screen:",50),           selectedObject.getHideOnHomePage()                 )
                                output += "%s %s\n" % (pad("This Accounts Depth (from top):",50),    selectedObject.getDepth()                          )
                                output += "%s %s\n" % (pad("Parent Accounts back to Root:",50),      selectedObject.getAllAccountNames()                )
                                output += "%s %s\n" % (pad("This Acct's sub accounts:",50),          selectedObject.getSubAccounts()                    )
                                output += "%s %s\n" % (pad("Account Currency:",50),                  selectedObject.getCurrencyType()                   )
                                output += "%s %s\n" % (pad("Count of Sub Accounts:",50),             selectedObject.getSubAccountCount()                )
                                output += "%s %s\n" % (pad("Account Number:",50),                    selectedObject.getBankAccountNumber()              )
                                output += "%s %s\n" % (pad("Bank Name:",50),                         selectedObject.getBankName()                       )
                                output += "%s %s\n" % (pad("Default Category:",50),                  selectedObject.getDefaultCategory()                )
                                if selectedObject.getDefaultTransferAccount():
                                    output += "%s %s\n" % (pad("Default Transfer Acct:",50),         selectedObject.getDefaultTransferAccount()         )
                                output += "%s %s\n" % (pad("Tax related:",50),                       selectedObject.isTaxRelated()                      )
                                if selectedObject.isDeductible():
                                    output += "%s %s\n" % (pad("is Deductible:",50),                 selectedObject.isDeductible()                      )
                                if selectedObject.getTaxCategory():
                                    output += "%s %s\n" % (pad("Tax Category:",50),                 selectedObject.getTaxCategory()                     )

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD:
                                    output += "%s %s\n" % (pad("Card Number:",50),                  selectedObject.getCardNumber()                 )
                                    output += "%s %s\n" % (pad("Card Expiration Month:",50),        selectedObject.getCardExpirationMonth()        )
                                    output += "%s %s\n" % (pad("Card Expiation Year:",50),          selectedObject.getCardExpirationYear()         )
                                    output += "%s %s\n" % (pad("Credit Limit:",50),                 selectedObject.getCreditLimit()                )
                                    output += "%s %s\n" % (pad("APR %:",50),                        selectedObject.getAPRPercent()                 )

                                output += "%s %s\n" % (pad("Transactions within this Account:",50),  selectedObject.getTxnCount()                  )
                                output += "%s %s\n" % (pad("Unconfirmed Transactions:",50),          selectedObject.getUnconfirmedTxnCount()       )

                                if selectedObject.getReminder():
                                    output += "%s %s\n" % (pad("Reminder:",50),                      selectedObject.getReminder()                  )

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.BANK \
                                        or selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD \
                                        or selectedObject.getAccountType() == Account.AccountType.INVESTMENT:
                                    if selectedObject.isOnlineEnabled():
                                        output += "%s %s\n" % (pad("Online Enabled:",50),                selectedObject.isOnlineEnabled()                 )
                                    if selectedObject.isOnlineBankingCandidate():
                                        output += "%s %s\n" % (pad("Online Banking Candidate:",50),      selectedObject.isOnlineBankingCandidate()        )
                                    if selectedObject.isOnlineBillpayCandidate():
                                        output += "%s %s\n" % (pad("Online Bill Pay Candidate:",50),     selectedObject.isOnlineBillpayCandidate()        )
                                    if selectedObject.getBankingFI():
                                        output += "%s %s\n" % (pad("OFX Banking Service:",50),           selectedObject.getBankingFI()                    )
                                    if selectedObject.getBillPayFI():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Service:",50),          selectedObject.getBillPayFI()                    )
                                    if selectedObject.getOFXAccountType():
                                        output += "%s %s\n" % (pad("OFX Account Type:",50),              selectedObject.getOFXAccountType()               )
                                    if selectedObject.getOFXAccountNumber():
                                        output += "%s %s\n" % (pad("OFX Account Number:",50),            selectedObject.getOFXAccountNumber()             )
                                    if selectedObject.getOFXBankID():
                                        output += "%s %s\n" % (pad("OFX Bank ID:",50),                   selectedObject.getOFXBankID()                    )
                                    if selectedObject.getOFXBranchID():
                                        output += "%s %s\n" % (pad("OFX Branch ID:",50),                 selectedObject.getOFXBranchID()                  )
                                    if selectedObject.getOFXBrokerID():
                                        output += "%s %s\n" % (pad("OFX Broker ID:",50),                 selectedObject.getOFXBrokerID()                  )
                                    if selectedObject.getOFXAccountKey():
                                        output += "%s %s\n" % (pad("OFX Account Key:",50),               selectedObject.getOFXAccountKey()                )
                                    if selectedObject.getOFXAccountMsgType():
                                        output += "%s %s\n" % (pad("OFX Acct Message Type:",50),         selectedObject.getOFXAccountMsgType()            )
                                    if selectedObject.getOFXBillPayAccountNumber():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Acct Number:",50),      selectedObject.getOFXBillPayAccountNumber()      )
                                    if selectedObject.getOFXBillPayAccountType():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Acct Type:",50),        selectedObject.getOFXBillPayAccountType()        )
                                    if selectedObject.getOFXBillPayBankID():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Bank ID:",50),          selectedObject.getOFXBillPayBankID()             )

                                output += "%s %s\n" % ( pad("Start Balance:",50),                        theCurr.getDoubleValue(selectedObject.getStartBalance()))
                                output += "%s %s\n" % ( pad("Balance:",50),                              theCurr.getDoubleValue(selectedObject.getBalance()))
                                output += "%s %s\n" % ( pad("Cleared Balance:",50),                      theCurr.getDoubleValue(selectedObject.getClearedBalance()))
                                output += "%s %s\n" % ( pad("Current Balance:",50),                      theCurr.getDoubleValue(selectedObject.getCurrentBalance()))
                                output += "%s %s\n" % ( pad("Confirmed Balance:",50),                    theCurr.getDoubleValue(selectedObject.getConfirmedBalance()))
                                output += "%s %s\n" % ( pad("Reconciling Balance:",50),                  theCurr.getDoubleValue(selectedObject.getReconcilingBalance()))

                                output += "%s %s\n" % ( pad("User Start Balance:",50),                   theCurr.getDoubleValue(selectedObject.getUserStartBalance()))
                                output += "%s %s\n" % ( pad("User Balance:",50),                         theCurr.getDoubleValue(selectedObject.getUserBalance()))
                                output += "%s %s\n" % ( pad("User Cleared Balance:",50),                 theCurr.getDoubleValue(selectedObject.getUserClearedBalance()))
                                output += "%s %s\n" % ( pad("User Confirmed Balance:",50),               theCurr.getDoubleValue(selectedObject.getUserConfirmedBalance()))
                                output += "%s %s\n" % ( pad("User Current Balance:",50),                 theCurr.getDoubleValue(selectedObject.getUserCurrentBalance()))
                                output += "%s %s\n" % ( pad("User Reconciling Balance:",50),             theCurr.getDoubleValue(selectedObject.getUserReconcilingBalance()))

                                output += "%s %s\n" % ( pad("Recursive Start Balance:",50),              theCurr.getDoubleValue(selectedObject.getRecursiveStartBalance()))
                                output += "%s %s\n" % ( pad("Recursive Balance:",50),                    theCurr.getDoubleValue(selectedObject.getRecursiveBalance()))
                                output += "%s %s\n" % ( pad("Recursive Cleared Balance:",50),            theCurr.getDoubleValue(selectedObject.getRecursiveClearedBalance()))
                                output += "%s %s\n" % ( pad("Recursive Current Balance:",50),            theCurr.getDoubleValue(selectedObject.getRecursiveCurrentBalance()))
                                output += "%s %s\n" % ( pad("Recursive Reconciling Balance:",50),        theCurr.getDoubleValue(selectedObject.getRecursiveReconcilingBalance()))

                                output += "%s %s\n" % ( pad("User Recursive Start Balance:",50),         theCurr.getDoubleValue(selectedObject.getRecursiveUserStartBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Balance:",50),               theCurr.getDoubleValue(selectedObject.getRecursiveUserBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Cleared Balance:",50),       theCurr.getDoubleValue(selectedObject.getRecursiveUserClearedBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Current Balance:",50),       theCurr.getDoubleValue(selectedObject.getRecursiveUserCurrentBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Reconciling Balance:",50),   theCurr.getDoubleValue(selectedObject.getRecursiveUserReconcilingBalance()))

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD \
                                        or selectedObject.getAccountType() == Account.AccountType.LOAN:

                                    if selectedObject.getInstitutionName():
                                        output += "%s %s\n" % (pad("Institution Name:",50),               selectedObject.getInstitutionName())
                                    if selectedObject.getInitialPrincipal():
                                        output += "%s %s\n" % (pad("Initial Principle:",50),             selectedObject.getInitialPrincipal())
                                    if selectedObject.getPermanentAPR():
                                        output += "%s %s\n" % (pad("Permanent APR:",50),                  selectedObject.getPermanentAPR())
                                    if selectedObject.getPoints():
                                        output += "%s %s\n" % (pad("%loan added as fee to Principle.:",50),selectedObject.getPoints())
                                    if selectedObject.getPaymentsPerYear():
                                        output += "%s %s\n" % (pad("Payments per year:",50),              selectedObject.getPaymentsPerYear())
                                    if selectedObject.getInterestAccount():
                                        output += "%s %s\n" % (pad("Interest Account:",50),               selectedObject.getInterestAccount())
                                    if selectedObject.getEscrowAccount():
                                        output += "%s %s\n" % (pad("Escrow Account:",50),                selectedObject.getEscrowAccount())
                                    if selectedObject.getEscrowPayment():
                                        output += "%s %s\n" % (pad("Escrow Payment:",50),                selectedObject.getEscrowPayment())
                                    if selectedObject.getInterestRate():
                                        output += "%s %s\n" % (pad("Interest Rate:",50),                 selectedObject.getInterestRate())
                                    if selectedObject.getFixedMonthlyPaymentAmount():
                                        output += "%s %s\n" % (pad("Fixed Payment Amt:",50),             selectedObject.getFixedMonthlyPaymentAmount())
                                    if selectedObject.getRateChangeDate():
                                        output += "%s %s\n" % (pad("Date Rate  Changed:",50),            selectedObject.getRateChangeDate())
                                    if selectedObject.getDebtPaymentAmount():
                                        output += "%s %s\n" % (pad("Val Pmts made to this CC:",50),      selectedObject.getDebtPaymentAmount())
                                    if selectedObject.getDebtPaymentProportion():
                                        output += "%s %s\n" % (pad("%value Pmts made to this cc:",50),   selectedObject.getDebtPaymentProportion())
                                    if selectedObject.getDebtPaymentSpec():
                                        output += "%s %s\n" % (pad("Pmt  Plan Used:",50),                selectedObject.getDebtPaymentSpec())

                                    if selectedObject.getPaymentSchedule():
                                        output += "%s %s\n" % (pad("Payment Schedule:",50),               selectedObject.getPaymentSchedule())
                                    if selectedObject.hasExpiringRate():
                                        output += "%s %s\n" % (pad("Has Expiring Rate:",50),              selectedObject.hasExpiringRate())
                                    if selectedObject.getCalcPmt():
                                        output += "%s %s\n" % (pad("Calc Payment:",50),                   selectedObject.getCalcPmt())

                                if selectedObject.getInvestAccountNumber():
                                    output += "%s %s\n" % (pad("Investment Account Number:",50),          selectedObject.getInvestAccountNumber())

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.SECURITY:
                                    if selectedObject.getBroker():
                                        output += "%s %s\n" % (pad("Broker:",50),                           selectedObject.getBroker())
                                    if selectedObject.getBrokerPhone():
                                        output += "%s %s\n" % (pad("Broker Phone:",50),                     selectedObject.getBrokerPhone())
                                    if selectedObject.getInvstCommissionAcct():
                                        output += "%s %s\n" % (pad("Investment Commission Account",50),     selectedObject.getInvstCommissionAcct())
                                    if selectedObject.getAnnualFee():
                                        output += "%s %s\n" % (pad("Annual Fee:",50),                       selectedObject.getAnnualFee())
                                    if selectedObject.getDividend():
                                        output += "%s %s\n" % (pad("Dividend:",50),                         selectedObject.getDividend())
                                    if selectedObject.getUsesAverageCost():
                                        output += "%s %s\n" % (pad("Uses Average Cost:",50),                selectedObject.getUsesAverageCost())
                                    if selectedObject.getSecurityType():
                                        output += "%s %s\n" % (pad("Security Type:",50),                    selectedObject.getSecurityType())
                                    if selectedObject.getSecuritySubType():
                                        output += "%s %s\n" % (pad("`Security Sub Type`:",50),              selectedObject.getSecuritySubType())
                                    if selectedObject.getBondType():
                                        output += "%s %s\n" % (pad("Bond Type:",50),                        selectedObject.getBondType())
                                    if selectedObject.getMaturity():
                                        output += "%s %s\n" % (pad("Maturity:",50),                         selectedObject.getMaturity())
                                    if selectedObject.getNumYears():
                                        output += "%s %s\n" % (pad("Maturity Year (6=six Mnths):",50),      selectedObject.getNumYears())
                                    if selectedObject.getCompounding():
                                        output += "%s %s\n" % (pad("CD Compounding:",50),                   selectedObject.getCompounding())
                                    if selectedObject.getOptionPrice():
                                        output += "%s %s\n" % (pad("Option Price:",50),                     selectedObject.getOptionPrice())
                                    if selectedObject.getMonth():
                                        output += "%s %s\n" % (pad("Option Exercise Month (0-11 3rd Fri):",50),selectedObject.getMonth())
                                    if selectedObject.getStrikePrice():
                                        output += "%s %s\n" % (pad("Option Strike Price:",50),               selectedObject.getStrikePrice())
                                    if selectedObject.getPut():
                                        output += "%s %s\n" % (pad("Option Put(T), Call(F):",50),           selectedObject.getPut())
                                    if selectedObject.getEscrow():
                                        output += "%s %s\n" % (pad("Escrow?:",50),                          selectedObject.getEscrow())
                                    if selectedObject.getExchange():
                                        output += "%s %s\n" % (pad("Trading Platform:",50),                 selectedObject.getExchange())
                                    if selectedObject.getFaceValue():
                                        output += "%s %s\n" % (pad("Bond face value:",50),                  selectedObject.getFaceValue())

                            except:
                                output += dump_sys_error_to_md_console_and_errorlog( True )

                        elif isinstance(selectedObject, CurrencyType):
                            try:
                                output += "\nMD User Representation of Data Held by this Currency/Security\n"
                                output += " =============================================================-\n"
                                if selectedObject == baseCurr:                                                              # noqa
                                    output += "THIS IS THE BASE RATE!\n"
                                output += "%s %s\n" % (pad("Sync Item Type:",50),       selectedObject.getSyncItemType()  )
                                output += "%s %s\n" % (pad("Currency Type:",50),        selectedObject.getCurrencyType()  )
                                output += "%s %s\n" % (pad("Name:",50),                 selectedObject.getName()  )
                                output += "%s %s\n" % (pad("Hide in UI?:",50),          selectedObject.getHideInUI()  )
                                output += "%s %s\n" % (pad("ID:",50),                   selectedObject.getID()  )
                                output += "%s %s\n" % (pad("ID String:",50),            selectedObject.getIDString()  )
                                output += "%s %s\n" % (pad("Ticker Symbol:",50),        selectedObject.getTickerSymbol()  )
                                output += "%s %s\n" % (pad("Prefix:",50),               selectedObject.getPrefix()  )
                                output += "%s %s\n" % (pad("Suffix:",50),               selectedObject.getSuffix()  )
                                output += "%s %s\n" % (pad("Decimal Places:",50),       selectedObject.getDecimalPlaces()  )
                                output += "%s %s\n" % (pad("Curr Start Date:",50),      selectedObject.getEffectiveDateInt()  )

                                for convertTimeStamp in ["price_date"]:
                                    if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

                                snaps = selectedObject.getSnapshots()

                                output += "%s %s\n" % (pad("RATE (to base):",50),           selectedObject.getRate(None)  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getRate(None))  )
                                output += "%s %s\n" % (pad("RATE in terms of Base:",50),    selectedObject.getBaseRate()  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getBaseRate())  )
                                output += "%s %s\n" % (pad("Relative Currency:",50),        selectedObject.getRelativeCurrency()  )
                                output += "%s %s\n" % (pad("Relative Rate:",50),            selectedObject.getRelativeRate()  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getRelativeRate())  )
                                output += "%s %s\n" % (pad("Count Price History:",50),      snaps.size() )
                                output += "%s %s\n" % (pad("Count Stock Splits:",50),       len(selectedObject.getSplits()  ))
                                output += "%s %s\n" % (pad("Daily Change:",50),             selectedObject.getDailyChange()  )
                                output += "%s %s\n" % (pad("Daily Volume:",50),             selectedObject.getDailyVolume()  )

                                output += "\n" \
                                          "Oldest and Newest (max) 5 Price History Records (RAW records) (use 1.0/rate to convert values):\n" \
                                          " ----------------------------------------------------------------------------------------------\n"

                                if snaps.size():
                                    # Put all maps back for snapshots listed.....
                                    dummySyncR = SyncRecord()

                                    iCountSnapsPrinted = iSnap = 0
                                    maxToPrint = min(10, snaps.size())

                                    output += "<-- Oldest (max) 5 records -->>\n"
                                    while iCountSnapsPrinted <= maxToPrint:
                                        snaps[iSnap].itemWillSync(dummySyncR)
                                        output += dummySyncR.toMultilineHumanReadableString()+"---\n"
                                        dummySyncR.clear()                                                                  # noqa
                                        iSnap += 1
                                        iCountSnapsPrinted += 1
                                        if iCountSnapsPrinted >= snaps.size() or iSnap >= snaps.size(): break
                                        if iCountSnapsPrinted < 5: continue
                                        if iCountSnapsPrinted == 5:
                                            output += "<-- Newest (max) 5 records -->>\n"
                                            iSnap = max(5, snaps.size() - (maxToPrint-iCountSnapsPrinted))
                                        if iCountSnapsPrinted > 10: break
                                    del dummySyncR
                                del snaps
                                output += "<END>\n"
                            except:
                                output += dump_sys_error_to_md_console_and_errorlog( True )

                        elif isinstance(selectedObject, ReportSpec):

                            if lReportDefaultsSelected:
                                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                                keys=sorted(LS.keys())

                                found_any = False
                                for theKey in keys:
                                    value = LS.get(theKey)
                                    if not theKey.lower().startswith("report_params."+selectedObject.getReportGenerator().getShortID()): continue
                                    if not found_any:
                                        output += "\nDEFAULT REPORT PARAMETERS (SET BY USER):\n"
                                        found_any = True
                                    output += "Key:%s Value: %s\n" % (pad(theKey,70), value.strip())
                        elif isinstance(selectedObject, Reminder):
                            pass
                        elif isinstance(selectedObject, AddressBookEntry):
                            pass
                        elif isinstance(selectedObject, OnlineService):
                            pass

                if selectedWhat == what[_PREFKEYS] or lSync or lOFX or lSizes or lSearch:  # User  Preferences

                    output += "\n ====== USER PREFERENCES LOADED INTO MEMORY (May or may not be quite the same as config.dict) ======\n"

                    # This bit below is really, really cool!!!! But I am not using it as it only gets pre-defined settings from config.dict.
                    # prefs=[]
                    # what_x = MD_REF.getUI().getPreferences()
                    # members = [attr for attr in dir(what_x) if not callable(getattr(what_x, attr)) and not attr.startswith("__")]
                    # for mem in members:
                    #     if not mem.upper() == mem: continue
                    #     try:
                    #         convertKey = getattr(UserPreferences, mem)
                    #     except:
                    #         continue
                    #     if not convertKey or convertKey=="" : continue
                    #     value = MD_REF.getUI().getPreferences().getSetting(getattr(UserPreferences, mem))
                    #     if value: prefs.append([convertKey, mem, value])
                    # prefs =sorted(prefs) # Sort the result (as the input is only a reference to a reference)

                    # As all settings in memory actually come from config.dict (or go back to config.dict) then we look there instead to get the keys
                    st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
                    prefs=sorted(tk)

                    for theKey in prefs:
                        value = st.get(theKey)
                        if lSync and not ("sync" in theKey.lower()): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()): continue
                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            myTestValue = value
                            if not isinstance(myTestValue,(str,unicode)): myTestValue  = repr(myTestValue)  # Force the StreamTable / StreamVector into a string for search comparison
                            # noinspection PyUnresolvedReferences
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in myTestValue.lower()): continue
                        # noinspection PyUnresolvedReferences
                        output += (pad("Key:%s" % (theKey),35)+ " Value: %s\n" %((value)))


                if selectedWhat == what[_ROOTKEYS] or lSync or lOFX or lSizes or lSearch:  # ROOT

                    keys=sorted(root.getParameterKeys())
                    output += '\n ====== ROOT PARAMETER KEYS (Preferences will mostly be in Local Storage) ======\n'
                    for theKey in keys:

                        value = root.getParameter(theKey)

                        if lSync and ("sync" not in theKey.lower()): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()): continue
                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                        if not debug:
                            if theKey.lower() == "netsync.synckey": value = "<*****> (hidden >> enable DEBUG to view)"

                        output += pad("Key:%s" %theKey,70)+" Value: %s\n" %(value.strip())

                    if selectedWhat == what[_ROOTKEYS]:
                        output+="\n"
                        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                            if root.getLongParameter(convertTimeStamp, 0) > 0:
                                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),70), get_time_stamp_as_nice_text(root.getLongParameter(convertTimeStamp, 0))  )


                if selectedWhat == what[_BOOKKEYS] or lOFX or lSearch:  # Local Storage - authentication cache

                    output += '\n ====== BOOK>LOCAL STORAGE KEYS - CACHED AUTHENTICATION ======\n'

                    lCachePasswords = isCachingPasswords()

                    _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
                    if len(_auth) > 0:
                        if not lCachePasswords: output += "** NOTE THESE WILL NOT BE SAVED/REMEMBERED WHEN YOU RESTART MD **\n"
                        keys = sorted(_auth.keys())                                                                     # noqa
                        for theKey in keys:
                            value = _auth.get(theKey)                                                                   # noqa

                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue
                            output += pad("Key:%s" %theKey,90)+" Value: %s\n" %(value.strip())
                    else:
                        if not lCachePasswords:
                            output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
                            output += "** Use Menu Online Banking (OFX) Tools > View installed Bank / Service Profiles to view specific cached items **\n"
                        output += "<NONE>\n"


                if selectedWhat == what[_BOOKKEYS] or lSync or lOFX or lSizes or lSearch:  # Local Storage

                    output += '\n ====== BOOK>LOCAL STORAGE KEYS ======\n'

                    LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                    keys=sorted(LS.keys())

                    last = None
                    for theKey in keys:
                        value = LS.get(theKey)    # NOTE: .get loses the underlying type and thus becomes a string

                        if theKey.startswith("_authentication"): continue

                        if lSync and "sync" not in theKey.lower(): continue
                        if lSync and "netsync.del_item" in theKey.lower(): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()
                                         or "access_tokens" in theKey.lower() or "mdp_items" in theKey.lower()): continue

                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                        if not debug:
                            if (theKey.lower() == "netsync.synckey"): value = "<*****> (hidden >> enable DEBUG to view)"

                        if ("._payloadid" in theKey.lower() or ".token" in theKey.lower()): value = "<*****> (hidden)"

                        splitKey = theKey.split('.')
                        if splitKey[0] != last:
                            last = splitKey[0]
                            lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])
                            if lookupAcct:
                                output += ("\n>> Account: %s\n" %(lookupAcct.getFullAccountName()))
                            else:
                                output += "\n"

                        output += pad("Key:%s" %theKey,90)+" Value: %s\n" %(value.strip())

                if selectedWhat == what[_ACCTKEYS] or lSync or lOFX or lSizes or lSearch:  # Accounts (excluding Root)

                    output += "\n ====== ACCOUNTS' PARAMETER KEYS  (Preferences will mostly be in Local Storage) ======\n"
                    accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(5))
                    lastAcct = None
                    for acct in accounts:

                        if acct != lastAcct:
                            output += "\n>> Account: %s\n" %acct.getFullAccountName()
                            lastAcct = acct

                        if lOFX:
                            output += "\nSpecific OFX Data:\n"
                            if (acct.canDownloadTxns() and not acct.getAccountIsInactive()):
                                output += pad(">> Can Download Txns:",50)+safeStr(acct.canDownloadTxns() and not acct.getAccountIsInactive())+"\n"

                            # if isMDPlusEnabledBuild() and acct.getBankingServices().size() > 0:
                            #     # Sean advised that always take the first item (there are duplicates in the list, but it is sorted)
                            #     output += pad(">> Banking Services first candidate:",50)+safeStr(acct.getBankingServices()[0].getService())+"\n"
                            #
                            if acct.getOFXAccountNumber() is not None and acct.getOFXAccountNumber() != "":
                                output += pad(">> OFX Account Number:",50)+safeStr(acct.getOFXAccountNumber())+"\n"

                            if acct.getBankingFI() is not None:
                                output += pad(">> Bank Service/Logon profile:",50)+safeStr(acct.getBankingFI())+"\n"
                                if my_get_account_key(acct):
                                    output += pad(">> (Account Key):",50)+safeStr(my_get_account_key(acct))+"\n"

                            if acct.getBillPayFI() is not None:
                                output += pad(">> BillPay Service/Logon profile:",50)+safeStr(acct.getBillPayFI())+"\n"
                                if my_get_account_key(acct):
                                    output += pad(">> (Account Key):",50)+safeStr(my_get_account_key(acct))+"\n"

                            getOnlineData = MyGetDownloadedTxns(acct)
                            if (getOnlineData is not None and
                                    (getOnlineData.getParameter("ofx_last_txn_update", None) is not None
                                            or getOnlineData.getParameter("ol.availbal", None) is not None
                                            or getOnlineData.getParameter("ol.ledgerbal", None) is not None)):
                                output += (">> OnlineTxnList data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", "ofx_last_txn_update", "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            getOnlineData = MyGetOnlinePayees(acct)
                            if getOnlineData is not None:
                                output += (">> OnlinePayees data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", "ofx_last_txn_update", "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            getOnlineData = MyGetOnlinePayments(acct)
                            if getOnlineData is not None:
                                output += (">> OnlinePayments data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", "ofx_last_txn_update", "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            output += "\n"

                        keys = sorted(acct.getParameterKeys())
                        for theKey in keys:

                            value = acct.getParameter(theKey)
                            if lSync and not ("sync" in theKey.lower()): continue
                            if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()
                                             or "olblink." in theKey.lower()
                                             or "olbfi" in theKey.lower()
                                             or "bpfi" in theKey.lower()): continue
                            if lSizes and not check_for_window_display_data(theKey,value): continue
                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                            if not debug:
                                if theKey.lower() == "netsync.synckey": value = "<*****> (hidden >> enable DEBUG to view)"
                                if theKey.lower() == "bank_account_number": value = "<*****> (hidden >> enable DEBUG to view)"

                            if lOFX and value.strip() == "": continue

                            output += pad("Key:%s" %(theKey),50)+" Value: %s\n" %(value.strip())

                        if selectedWhat == what[_ACCTKEYS]:
                            output+="\n"
                            for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                                if acct.getLongParameter(convertTimeStamp, 0) > 0:
                                    output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(acct.getLongParameter(convertTimeStamp, 0))  )

                if lOFX or lSearch:
                    output += "\n ========= OFX Online Banking Service's PARAMETER KEYS =========\n"
                    output += "\n (NOTE: More information will be in view bank service / login profiles)\n"

                    lastService = None
                    services = MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices()
                    for service in services:
                        keys = sorted(service.getParameterKeys())
                        for theKey in keys:

                            value = service.getParameter(theKey)

                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                            if service != lastService:
                                output += "\nOFX SERVICE: %s\n" %service
                                output += "--------------------------------------------\n"
                                lastService = service

                            output += pad("Key:%s" %theKey,50)+ " Value: %s\n" %(value)

                if lOFX:
                    output += "\n ========= Moneydance+ license object's PARAMETER KEYS (MD2022 onwards) =========\n"
                    licenseObject = getMDPlusLicenseInfoForBook()
                    if licenseObject is None:
                        output += "<NO LICENSE OBJECT FOUND>\n"
                    else:
                        output += special_toMultilineHumanReadableString(licenseObject)
                        del licenseObject

                    output += "\n ========= OFX Account Mappings Object's PARAMETER KEYS (MD2022 onwards) =========\n"
                    mappingObject = MD_REF.getCurrentAccount().getBook().getItemForID("online_acct_mapping")
                    if mappingObject is None:
                        output += "<NO ACCOUNT MAPPING OBJECT FOUND>\n"
                    else:
                        output += special_toMultilineHumanReadableString(mappingObject, lSkipSecrets=False)
                        del mappingObject

                if selectedWhat == what[_OSPROPS]:  # System.Properties

                    output += "\n ====== (Operating) System.Properties.....======\n"

                    props = sorted(System.getProperties())
                    for prop in props:
                        output += pad("Property:%s" %prop,50)+ " Value: %s\n"%(System.getProperty(prop))

                if selectedWhat == what[_OSENV]:    # Environment variables

                    output += "\n ====== Operating System Environment Variables.....======\n"

                    for k, v in os.environ.items():
                        output += pad("Variable: %s" %k,50)+ " Value: %s\n" %(v)

            except:
                output += dump_sys_error_to_md_console_and_errorlog( True )

            output += "<END>\n"

            jif = QuickJFrame("Geek Out on....: %s" % selectedWhat, output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

            if self.lOFX:
                return jif
            else:
                txt = "I hope you enjoyed Geeking Out on...: %s" %(selectedWhat)
                setDisplayStatus(txt, "DG")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    def prune_internal_backups(lStartup=False):
        myPrint("D","In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("J","Auto-prune is enabled.... auto-pruning internal backups of config.dict and settings now.....")

        try:

            backup_extn = "_$SAVED$"

            backup_localStorage_path = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath())
            backup_config_path = os.path.dirname(Common.getPreferencesFile().getCanonicalPath())
            # backup_custom_theme_path = os.path.dirname(ThemeInfo.customThemeFile.getCanonicalPath())

            settingsFile = "settings"
            # backup_localStorage_filename = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"settings")
            # configFile = Common.getPreferencesFile().getName()
            # themeFile = ThemeInfo.customThemeFile.getName()

            themeFiles = []
            configFiles = []
            settingsFiles = []

            iCountConfig = iCountSettings = iCountTheme = 0

            for _path in [backup_localStorage_path, backup_config_path]:
                for _file in os.listdir(_path):
                    filepath = os.path.join(_path, _file)
                    if _file.startswith(settingsFile) and _file.endswith(backup_extn):
                        settingsFiles.append(filepath)
                        iCountSettings+=1
                    elif _file.startswith("config-") and _file.endswith(".dict"+backup_extn):
                        configFiles.append(filepath)
                        iCountConfig+=1
                    elif _file.startswith("custom_theme-") and _file.endswith(".properties"+backup_extn):
                        themeFiles.append(filepath)
                        iCountTheme+=1
                    else:
                        pass

            myPrint("DB", "Found %s settings backup files" %(iCountSettings))
            myPrint("DB", "Found %s config.dict backup files" %(iCountConfig))
            myPrint("DB", "Found %s custom themes backup files" %(iCountTheme))

            settingsFiles = sorted(settingsFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)
            configFiles = sorted(configFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)
            themeFiles = sorted(themeFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)

            files_to_keep = 5
            days_to_look_back = 5

            lookBack = datetime.datetime.today() - datetime.timedelta(days=(days_to_look_back+1))

            myPrint("DB", "Look-back cutoff date for auto-prune internal backup files set to: %s " %(get_time_stamp_as_nice_text(lookBack)))

            iDeletedConfig = iDeletedThemes = iDeletedSettings = 0

            iErrors=0
            for filelist in [settingsFiles, configFiles, themeFiles]:
                iRecords=0
                for _fp in filelist:
                    iRecords += 1
                    if iRecords <= files_to_keep:
                        myPrint("D", "skipping-keeping %s files: %s %s" %(files_to_keep,datetime.datetime.fromtimestamp(os.path.getmtime(_fp)).strftime('%Y-%m-%d %H:%M:%S'),_fp))
                        continue
                    file_ts = datetime.datetime.fromtimestamp(os.path.getmtime(_fp))
                    if file_ts >= lookBack:
                        myPrint("D","skipping < %s days: %s %s" %(days_to_look_back, file_ts.strftime('%Y-%m-%d %H:%M:%S'),_fp))
                        continue
                    myPrint("DB", "DELETING: %s %s" %(file_ts.strftime('%Y-%m-%d %H:%M:%S'),_fp))
                    if "settings" in _fp:
                        iDeletedSettings+=1
                    elif "config-" in _fp:
                        iDeletedConfig+=1
                    elif "custom_theme-" in _fp:
                        iDeletedThemes+=1
                    try:
                        os.remove(_fp)
                    except:
                        iErrors+=1
                        myPrint("B","@ERROR deleting file: %s - skipping and moving on....." %(_fp))
                        dump_sys_error_to_md_console_and_errorlog()
        except:
            txt = "@@ ERROR auto-pruning internal backup files... continuing....."
            setDisplayStatus(txt, "R")
            myPrint("B",txt)
            dump_sys_error_to_md_console_and_errorlog()
            return

        del themeFiles
        del configFiles
        del settingsFiles

        myPrint("J","Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..."
                %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors))

        if not lStartup:
            txt = "Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..." %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors)
            setDisplayStatus(txt, "R")

        if iErrors:
            myPopupInformationBox(toolbox_frame_, "Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..."
                                  %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors),
                                  "AUTO-PRUNE INTERNAL BACKUPS",
                                  JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class ViewFileButtonAction(AbstractAction):

        class CloseAction(AbstractAction):

            def __init__(self, the_frame):
                self.theFrame = the_frame

            # noinspection PyUnusedLocal
            def actionPerformed(self, event):
                global debug
                myPrint("DB", "Inner View File Frame shutting down....")
                self.theFrame.dispose()     # Listener will already be on the EDT
                return

        def __init__(self, theFile, displayText, lFile=True):
            self.theFile = theFile
            self.displayText = displayText
            self.lFile = lFile

        def actionPerformed(self, event):
            global toolbox_frame_, debug, myParameters, lIgnoreOutdatedExtensions_TB
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            lViewExtensions=False
            lDisplayPickle=False

            lWrap = True

            x = safeStr(self.theFile)

            if x == "display_pickle()":
                x = display_pickle()
                lDisplayPickle=True
                lWrap = False

            if x == "display_help()":
                x = display_help()
                lWrap = False

            if x == "get_list_memorised_reports()":
                x = get_list_memorised_reports()
                lWrap = False

            if x == "get_register_txn_sort_orders()":
                x = get_register_txn_sort_orders()
                lWrap = False

            if x == "view_check_num_settings()":
                x = view_check_num_settings()
                lWrap = False

            if x == "view_extensions_details()":
                x = view_extensions_details()
                lViewExtensions=True
                lWrap = False

            if x == "can_I_delete_security()":
                x = can_I_delete_security()
                if not x: return

            if x == "can_I_delete_currency()":
                x = can_I_delete_currency()
                if not x: return

            if x == "list_security_currency_decimal_places()":
                x = list_security_currency_decimal_places()
                lWrap = False
                if not x: return

            if not self.lFile:
                myPrint("DB", "User requested to view " + self.displayText + " data...")
                if not x or x == "":
                    if x:
                        txt = "Sorry - " + self.displayText + " data is empty!?: " + x
                        setDisplayStatus(txt, "R")
                    return
            else:
                myPrint("DB", "User requested to view " + self.displayText + " file...")
                if not os.path.exists(x):
                    txt = "Sorry - " + self.displayText + " file does not exist or is not available to view!?: " + x
                    setDisplayStatus(txt, "R")
                    return

            if not self.lFile:
                displayFile = x
            else:
                try:
                    with open(x, "r") as myFile:
                        displayFile = myFile.readlines()
                    # displayFile = '\n'.join(displayFile)

                    # If VMOptions, stick a "'" at the beginning for clipboard to Excel to work OK
                    if lCopyAllToClipBoard_TB and x.lower().endswith(".vmoptions"):
                        newDisplayFile=[]
                        for line in displayFile:
                            line ="'"+line
                            newDisplayFile.append(line)
                        displayFile = newDisplayFile
                    else:
                        displayFile.append("\n<END>")

                    displayFile = ''.join(displayFile)
                except:
                    displayFile = "Sorry - error opening file...."
                    dump_sys_error_to_md_console_and_errorlog()

            if x.lower().endswith(".vmoptions"):
                displayFile += """
-------------------------------------------------------------------------------------------------------------------------------------------
<INSTRUCTIONS - MEMORY>
======================
You can allow for more memory by editing the 'Moneydance.vmoptions' file and set it to increase the amount of memory that
Moneydance is allowed to use. To achieve this you can try the following:

Navigate to the Moneydance.vmoptions file, located in the folder where Moneydance is installed:

If you open that file with Notepad or any other text editor, you'll see some instructions for how to change it.
Close Moneydance first!

The basic recommendation is to changing the -Xmx1024m setting to -Xmx2048m which doubles the amount of memory that Moneydance is allowed to use.
You can give it more if you wish, E.g.: you make it -Xmx3072m, for optimal results.

NOTE: The limit is set deliberately low to enable it to work with computers having very small amounts of RAM.

"""  # noqa
                windowsExtra = """
-----
Windows file location: c:\Program Files\Moneydance\Moneydance.vmoptions

In Windows - due to permissions, you will need to do this:
In the 'Type here to Search' box on the Windows 10 Toolbar, type CMD (do not press enter)
When Command Prompt appears, click Run as Administrator
Click yes/agree to allow this app to make changes to this device / grant administrator permissions
cd "\Program Files\Moneydance"      (and enter)
notepad Moneydance.vmoptions        (and enter)
edit the file and change the -Xmx1024 setting
ctrl-s to save and then exit Notepad
exit
restart Moneydance
-------------------------------------------------------------------------------------------------------------------------------------------
"""  # noqa

                linuxExtra = """
<INSTRUCTIONS - Linux and High Resolution Screens>
=================================================
When running Linux on a computer with a high resolution display, some distributions will let you adjust the "scaling" of 
the interface to provide clearer graphics at a larger size. If you use scaling on your Linux desktop but the contents of
the Moneydance window appears very small then you may need to adjust Moneydance's scaling.

To change the scaling, open Moneydance.vmoptions with a text editor (as per instructions below) add the following two
lines to the bottom of the file:

-Dsun.java2d.uiScale=2
-Dsun.java2d.uiScale.enabled=true

>>PLEASE NOTE: that as of this writing, non-integer scales (for example, 1.2) are not supported.
refer: https://infinitekind.tenderapp.com/kb/linux/linux-and-hidpi-high-resolution-screens

-----
Linux file location: /opt/Moneydance/Moneydance.vmoptions

In Linux - due to permissions, you will need to do this:
a) Either edit in Terminal using sudo before the command (e.g. sudo vi Moneydance.vmoptions) , or;

b) You ideally need to be able to open files as root via a right click.
- This assumes you are on a Debian based system
1. Open the Terminal
2. Type sudo su and press enter. Provide your password and press enter
3. Then type apt-get install -y nautilus-admin and press enter
4. Now type nautilus -q and press enter
5. Finally type exit and press enter, and close the terminal window
6. All set. Now when you want to open a file as root, simply right click the FOLDER and select Open as Root (or Administrator).

So, now find the /Opt folder, right click on the Moneydance FOLDER, Open as Root. Enter your password. Now you can edit the Moneydance.vmoptions file....
>> Note: You may need to logoff and then login to see the changes!

now after saving the file, restart Moneydance
-------------------------------------------------------------------------------------------------------------------------------------------
"""  # noqa
                if Platform.isWindows():
                    displayFile += windowsExtra
                elif Platform.isUnix():
                    displayFile += linuxExtra
                try:
                    helper = MD_REF.getPlatformHelper()
                    helper.openDirectory(self.theFile)
                except:
                    pass
                time.sleep(0.5)

            if self.lFile:
                jif = QuickJFrame("View " + self.displayText + " file: " + x, displayFile,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            else:
                jif = QuickJFrame("View " + self.displayText + " data", displayFile,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=lWrap).show_the_frame()

            jif.toFront()

            if lViewExtensions and lIgnoreOutdatedExtensions_TB:
                if myPopupAskQuestion(jif,
                                      "OUTDATED EXTENSIONS",
                                      "Turn startup warnings back on for Outdated Extns?",
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.QUESTION_MESSAGE):

                    txt = "OUTDATED EXTENSIONS - Startup warnings re-enabled"
                    setDisplayStatus(txt, "B")
                    myPrint("B", txt)
                    lIgnoreOutdatedExtensions_TB = False

            if lDisplayPickle:

                if not myPopupAskQuestion(jif,
                                          "STUWARESOFTSYSTEMS' SAVED PARAMETERS PICKLE FILE",
                                          "Would you like to RESET/DELETE/EDIT saved parameters?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.WARNING_MESSAGE):
                    return

                _PICKLEDELALL          = 0
                _PICKLECHGONE          = 1
                _PICKLEDELONE          = 2
                _PICKLEADDONE          = 3

                what = ["PICKLE: DELETE ALL","PICKLE: CHANGE one variable","PICKLE: DELETE one variable", "PICKLE: ADD one variable"]

                while True:

                    lAdd = lChg = lDelAll = lDelOne = False
                    selectedWhat = JOptionPane.showInputDialog(jif,
                                                               "Select the type of change you want to make?",
                                                               "STUWARESOFTSYSTEMS' SAVED PARAMETERS PICKLE FILE",
                                                               JOptionPane.WARNING_MESSAGE,
                                                               None,
                                                               what,
                                                               None)

                    if not selectedWhat:
                        try:
                            save_StuWareSoftSystems_parameters_to_file()
                        except:
                            myPrint("B", "Error - failed to save parameters to pickle file...!")
                            dump_sys_error_to_md_console_and_errorlog()
                        return

                    if selectedWhat == what[_PICKLEADDONE]: lAdd = True
                    if selectedWhat == what[_PICKLECHGONE]: lChg = True
                    if selectedWhat == what[_PICKLEDELONE]: lDelOne = True
                    if selectedWhat == what[_PICKLEDELALL]: lDelAll = True

                    if lDelAll:
                        myParameters = {}
                        txt = "STUWARESOFTSYSTEMS' PARAMETERS SAVED TO PICKLE FILE DELETED/RESET"
                        setDisplayStatus(txt, "DG")
                        myPrint("B", txt)

                        try:
                            save_StuWareSoftSystems_parameters_to_file()
                        except:
                            myPrint("B", "Error - failed to save parameters to pickle file...!")
                            dump_sys_error_to_md_console_and_errorlog()
                        return

                    text = ""
                    if lChg: text = "CHANGE"
                    if lDelOne: text = "DELETE"

                    if lAdd:
                        addKey = myPopupAskForInput(jif,
                                                    "PICKLE: ADD KEY",
                                                    "KEY NAME:",
                                                    "Carefully enter the name of the key you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                                    "",
                                                    False,
                                                    JOptionPane.WARNING_MESSAGE)

                        if not addKey or len(addKey.strip()) < 1: continue
                        addKey = addKey.strip()

                        if not check_if_key_string_valid(addKey):
                            myPopupInformationBox(jif, "ERROR: Key %s is NOT valid!" % addKey, "PICKLE: ADD", JOptionPane.ERROR_MESSAGE)
                            continue    # back to menu

                        testKeyExists = myParameters.get(addKey)

                        if testKeyExists:
                            myPopupInformationBox(jif, "ERROR: Key %s already exists - cannot add - aborting..!" % addKey, "PICKLE: ADD", JOptionPane.ERROR_MESSAGE)
                            continue    # back to menu

                        addValue = myPopupAskForInput(jif,
                                                      "PICKLE: ADD KEY VALUE",
                                                      "KEY VALUE:",
                                                      "Carefully enter the key value you want to add (STRINGS ONLY!):",
                                                      "",
                                                      False,
                                                      JOptionPane.WARNING_MESSAGE)

                        if not addValue or len(addValue.strip()) <1: continue
                        addValue = addValue.strip()

                        if not check_if_key_data_string_valid(addValue):
                            myPopupInformationBox(toolbox_frame_, "ERROR: Key value %s is NOT valid!" % addValue, "PICKLE: ADD ", JOptionPane.ERROR_MESSAGE)
                            continue    # back to menu

                        myParameters[addKey] = addValue
                        myPrint("B","@@ PICKLEMODE: key: %s value: %s added @@" %(addKey,addValue))
                        myPopupInformationBox(jif,
                                              "SUCCESS: Key %s added!" % (addKey),
                                              "PICKLE: ADD ",
                                              JOptionPane.WARNING_MESSAGE)
                        continue

                    pickleKeys=sorted( myParameters.keys() )
                    # OK, so we are changing or deleting
                    if lChg or lDelOne:
                        selectedKey = JOptionPane.showInputDialog(jif,
                                                                  "Select the key/setting you want to %s" % (text),
                                                                  "PICKLE",
                                                                  JOptionPane.WARNING_MESSAGE,
                                                                  None,
                                                                  pickleKeys,
                                                                  None)
                        if not selectedKey: continue

                        value = myParameters.get(selectedKey)
                        chgValue = None

                        if lChg:
                            chgValue = myPopupAskForInput(jif,
                                                          "PICKLE: CHANGE KEY VALUE",
                                                          "KEY VALUE:",
                                                          "Carefully enter the new key value (as type: %s):" %type(value),
                                                          str(value),
                                                          False,
                                                          JOptionPane.WARNING_MESSAGE)

                            if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                            chgValue = chgValue.strip()

                            if isinstance(value, (int, float, bool, list)):
                                try:
                                    if isinstance(eval(chgValue), type(value) ):
                                        chgValue = eval(chgValue)
                                    else:
                                        myPopupInformationBox(jif,"ERROR: you must match the variable type to %s" %(type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                        continue
                                except:
                                    myPopupInformationBox(jif,"ERROR: *EVAL* Could not set Key value %s - type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                    continue
                            elif isinstance(value,(str,unicode)):
                                if not check_if_key_data_string_valid(chgValue):
                                    myPopupInformationBox(jif,"ERROR: Key value %s is NOT valid!" %chgValue,"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                    continue    # back to menu
                            else:
                                myPopupInformationBox(jif,"SORRY: I cannot change Key value %s as it's type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                continue    # back to menu

                        if lDelOne:
                            myParameters.pop(selectedKey)
                        if lChg:
                            try:
                                myParameters[selectedKey] = chgValue
                            except:
                                myPopupInformationBox(jif,"ERROR: *set* Could not set Key value %s - type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                continue

                        if lDelOne:
                            myPrint("B","@@ PICKLEMODE: key: %s DELETED (old value: %s) @@" %(selectedKey,value))
                            myPopupInformationBox(jif,
                                                  "SUCCESS: key: %s DELETED (old value: %s)" %(selectedKey,value),
                                                  "PICKlE: DELETE",
                                                  JOptionPane.WARNING_MESSAGE)
                        if lChg:
                            myPrint("B","@@ PICKLERMODE: key: %s CHANGED to %s @@" %(selectedKey,chgValue))
                            myPopupInformationBox(jif,
                                                  "SUCCESS: key: %s CHANGED to %s" %(selectedKey,chgValue),
                                                  "PICKLE: CHANGE",
                                                  JOptionPane.WARNING_MESSAGE)
                        continue

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return


    def view_shouldBeIncludedInNetWorth_settings():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "View Accounts' shouldBeIncludedInNetWorth() settings"

        PARAM_APPLIES_TO_NW = "applies_to_net_worth"

        output = "\n" \
                 "%s:\n" \
                 " ======================================================\n\n" %(_THIS_METHOD_NAME.upper())

        output += "Moneydance predefines rules to include/exclude Accounts in the Home Summary Page NetWorthView widget, & also the Titlebar NW instant graph\n" \
                  "- If the Account or Parent is Inactive, then it's excluded\n" \
                  "- ROOT and Income/Expense Categories are excluded\n" \
                  "- Then it checks for a hidden Account setting >> You can set this in Toolbox Advanced Mode\n" \
                  "- You cannot force include an account into these, you can only force exclude accounts....\n" \
                  "\n" \
                  "Other NetWorth rules for information:\n" \
                  "- NW Reports / Graphs are based on transactions up to the date you specify; uses Price history data for balance valuations\n" \
                  "- The Top title bar NW Graph's cutoff date can be changed: 'All Dates' includes future Balances; uses Price history data for balance valuations\n" \
                  "- The Home Screen View NW widget total ALWAYS uses Current Balance(s) - so future balances are excluded; uses Current Price\n" \
                  "\n\n"

        output += "%s %s %s %s\n" %(pad("Account Name",50),
                                    pad("Account Type",20),
                                    pad("shouldBeIncludedInNetWorth()",30),
                                    pad("Override Setting",20))

        output += "%s %s %s %s\n" %("-"*50,
                                    "-"*20,
                                    "-"*30,
                                    "-"*20)

        output += "\n"

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(25))
        allAccounts = sorted(allAccounts, key=lambda x: (x.getAccountType(), x.getFullAccountName().upper()))

        for acct in allAccounts:
            output += "%s %s %s %s\n" %(pad(acct.getFullAccountName(),50),
                                        pad(str(acct.getAccountType()),20),
                                        pad(str(acct.shouldBeIncludedInNetWorth()),30),
                                        ("NOT SET" if (not acct.getParameter(PARAM_APPLIES_TO_NW, None)) else (str(acct.getBooleanParameter(PARAM_APPLIES_TO_NW, True)))))
        output += "\n<END>"

        txt = "%s: - Displaying NetWorth Settings" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "B")
        QuickJFrame(_THIS_METHOD_NAME.upper(), output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        del allAccounts

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return


    def edit_shouldBeIncludedInNetWorth_settings():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "EDIT an Account's shouldBeIncludedInNetWorth() setting"

        PARAM_APPLIES_TO_NW = "applies_to_net_worth"

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(25))
        allAccounts = sorted(allAccounts, key=lambda x: (x.getAccountType(), x.getFullAccountName().upper()))

        newAccounts = []
        for acct in allAccounts: newAccounts.append(StoreAccountList(acct))
        del allAccounts

        lPresentedBackupDisclaimer = False
        iCountChanges = 0

        while True:

            selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Acct edit the shouldBeIncludedInNetWorth() setting",
                                                       _THIS_METHOD_NAME.upper(),
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       newAccounts,
                                                       None)
            if not selectedAcct: break

            selectedAcct = selectedAcct.obj       # type: Account                                                       # noqa

            currentNWsettingBool = selectedAcct.getBooleanParameter(PARAM_APPLIES_TO_NW, True)

            options = ["YES - Include", "NO - Exclude"]
            if currentNWsettingBool:
                current = options[0]
            else:
                current = options[1]

            selectedIncludeInNW = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select whether to include/exclude this account in the default NW Home Screen Widget & Titlebar Graph",
                                                       _THIS_METHOD_NAME.upper()+" for: %s" %(selectedAcct.getAccountName()),
                                                       JOptionPane.WARNING_MESSAGE,
                                                       None,
                                                       options,
                                                       current)
            if not selectedIncludeInNW: continue

            if not lPresentedBackupDisclaimer:
                if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "Change 'include in NW' to '%s'?" %(selectedIncludeInNW)):
                    return
                lPresentedBackupDisclaimer = True

            if options.index(selectedIncludeInNW) == 0:
                # Include selected
                selectedAcct.setParameter(PARAM_APPLIES_TO_NW, None)
            else:
                # Exclude selected
                selectedAcct.setParameter(PARAM_APPLIES_TO_NW, False)

            selectedAcct.syncItem()
            iCountChanges += 1

            txt = "%s: Account: '%s' Parameter: '%s' set to %s" %(_THIS_METHOD_NAME, selectedAcct, PARAM_APPLIES_TO_NW, selectedIncludeInNW)
            setDisplayStatus(txt, "B")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt)

            continue

        del newAccounts

        if iCountChanges:
            txt = "%s: Updated the NW setting in %s Account(s)!" %(_THIS_METHOD_NAME, iCountChanges)
        else:
            txt = "%s: No Accounts changed" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return


    def zero_bal_categories(lFix):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if lFix:
            myPrint("DB","User requested to Inactivate Zero Balance Categories!")
        else:
            myPrint("D", "User requested to View Zero Balance Categories!")

        if lFix:
            myPrint("B", "Script running to Analyse your Active Categories for Zero Balance...............")
            myPrint("P", "---------------------------------------------------------")
        else:
            myPrint("B", "Script running to de-activate your Categories with Zero Balance...............")
            myPrint("P", "---------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        output = ""
        output += "Analysing your categories for Zero Balances....\n\n"

        baseCurr = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()


        # ==========================================
        # Search reminders first
        root = MD_REF.getCurrentAccountBook()
        rems = root.getReminders().getAllReminders()

        listOfRems={}

        for rem in rems:
            remType = rem.getReminderType()  # NOTE or TRANSACTION

            if str(remType) != 'TRANSACTION': continue

            lastDate = rem.getLastDateInt()
            if not lastDate:
                pass    # No end date set, so proceed
            else:
                remDate = rem.getNextOccurance(lastDate)    # Stop at enddate
                if not remDate: continue    # Expired so skip

                if not remDate >= DateUtil.getStrippedDateInt(): continue
                # Right, got one!

            desc = rem.getDescription()

            txnParent = rem.getTransaction()

            for index2 in range(0, int(txnParent.getOtherTxnCount())):
                splitDesc = txnParent.getOtherTxn(index2).getDescription()
                acct = txnParent.getAccount()
                cat = txnParent.getOtherTxn(index2).getAccount()
                catValue = baseCurr.getDoubleValue(txnParent.getOtherTxn(index2).getValue()) * -1

                if catValue:
                    theReminder = [acct, cat, catValue, desc, splitDesc]
                    listOfRems[cat]=theReminder

        # ==========================================


        # Now the Categories
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(4))    # This returns active and inactive accounts
        accounts = sorted(accounts, key=lambda x: (x.getAccountType(), safeStr(x.getFullAccountName()).upper()))

        categoriesToInactivate = {}

        output += "LISTING ACTIVE CATEGORIES WITH ZERO BALANCES:\n\n"

        # Run 1 - get the initial list
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0
                    # and cat.getRecursiveReconcilingBalance() == 0
            ):
                if listOfRems.get(cat):     # Found a reminder!
                    pass
                else:
                    categoriesToInactivate[cat]=True

        # Run 2 - filter out parents.... if we are retaining any sub cats
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if not categoriesToInactivate.get(cat):     # Select categories that we are not deactivating

                # Look for its parents in the list of Cats to deactivate
                parentCats = cat.getPath()
                for theParent in parentCats:
                    if categoriesToInactivate.get(theParent):   # Found a parent - so don't deactivate it!
                        categoriesToInactivate[theParent]=False

        last = None
        iCountForInactivation = 0
        sortedCategoriesToInactivate=sorted(list(categoriesToInactivate), key=lambda x: (x.getAccountType(),x.getFullAccountName()) )

        # for cat in categoriesToInactivate.keys():
        for cat in sortedCategoriesToInactivate:
            if categoriesToInactivate.get(cat):
                iCountForInactivation+=1

                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "Category: %s has Zero Balances\n" % pad(cat.getFullAccountName(),100)
            else:
                output += "Category: %s ** But cannot be deactivated as it's the Parent of an active Category **\n" % pad(cat.getFullAccountName(),100)


        output += "--------------------------------------------------------------------------------------------------\n"
        output += ("You have %s categories with Zero Balances - these can be made Inactive using Advanced Mode......\n" % iCountForInactivation).upper()
        output += "---------------------------------------------------------------------------------------------------\n\n"

        output += "LISTING ACTIVE CATEGORIES WITH ZERO BALANCES - BUT WITH FUTURE REMINDERS PRESENT:\n\n"

        output += pad("Category Name", 78)
        output += " " + pad("Account", 20)
        output += " " + pad("Reminder Description", 35)
        output += " " + rpad("Rem Amount", 12)
        output += " " + pad("Split Desc", 35)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        last = None
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0
                    # and cat.getRecursiveReconcilingBalance() == 0
            ):
                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                foundRem = listOfRems.get(cat)
                if foundRem:    # Found a reminder!
                    output += "Category: %s Reminder Details: " % pad(cat.getFullAccountName(),50)
                    output += pad(foundRem[0].getAccountName(),20)+" "
                    output += pad(foundRem[3],35)+" "
                    output += rpad(foundRem[2],12)+" "
                    output += pad(foundRem[4],35)+"\n"

        output += "-----------------------------------------------------------------------------------------------------------\n"


        output += "\n\nLISTING INACTIVE CATEGORIES WITH ZERO BALANCES:\n\n"

        ii=0
        last = None
        for cat in accounts:
            if not cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0 ):  # and cat.getRecursiveReconcilingBalance() == 0


                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "Inactive Category: %s has Zero Balances\n" % pad(cat.getFullAccountName(),100)
                ii+=1

        if not ii:
            output += "<NONE FOUND>\n\n"

        output += "--------------------------------------------------------------------------------------------------\n"

        output += "LISTING ACTIVE CATEGORIES WITH BALANCES:\n\n"

        output += pad("Category Name", 85)
        output += " " + rpad("Balance", 12)
        # output += " " + rpad("ClrdBal", 12)
        # output += " " + rpad("ConfBal", 12)
        output += " " + rpad("CurrBal", 12)
        # output += " " + rpad("RecBal", 12)
        output += " " + rpad("RcrsBal", 12)
        # output += " " + rpad("RcrsClrdBal", 12)
        output += " " + rpad("RcrsCurrBal", 12)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        ii = 0
        last = None
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if not (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0):     # and cat.getRecursiveReconcilingBalance() == 0
                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "%s" % pad(cat.getFullAccountName(), 85)

                mult = 1
                # noinspection PyUnresolvedReferences
                if cat.getAccountType() == Account.AccountType.EXPENSE: mult = -1

                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserClearedBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserConfirmedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserReconcilingBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserClearedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserReconcilingBalance()*-1), 12)
                output += "\n"
                ii+=1
        if not ii:
            output += "<NONE FOUND>\n\n"

        output += "----------------------------------------------------------------------------\n\n"

        output += "LISTING INACTIVE CATEGORIES WITH BALANCES:\n\n"

        output += pad("Category Name", 85)
        output += " " + rpad("Balance", 12)
        # output += " " + rpad("ClrdBal", 12)
        # output += " " + rpad("ConfBal", 12)
        output += " " + rpad("CurrBal", 12)
        # output += " " + rpad("RecBal", 12)
        output += " " + rpad("RcrsBal", 12)
        # output += " " + rpad("RcrsClrdBal", 12)
        output += " " + rpad("RcrsCurrBal", 12)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        ii=0
        last = None
        for cat in accounts:
            if not cat.getAccountOrParentIsInactive(): continue
            if not (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0):       # and cat.getRecursiveReconcilingBalance() == 0

                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "%s" % pad(cat.getFullAccountName(), 85)

                mult = 1
                # noinspection PyUnresolvedReferences
                if cat.getAccountType() == Account.AccountType.EXPENSE: mult = -1

                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserClearedBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserConfirmedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserReconcilingBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserClearedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserReconcilingBalance()*mult), 12)
                output += "\n"
                ii+=1

        if not ii:
            output += "<NONE FOUND>\n\n"

        output += "----------------------------------------------------------------------------\n\n"

        output += "\nLEGEND:\n"
        output += "** NOTE: The Balances shown on a Parent Category in any section may not be the sum of its Child Categories shown in the same section.\n"
        output += "         The calculation matches the Moneydance Tools>Categories method and will include the balances(s) from all its Child Categories whether active, inactive or otherwise....\n\n"
        output += "Balance = Account Balance\n"
        # output += "ClrdBal = Cleared Balance (Normally Zero on a Category). Balance excluding uncleared or reconciling txns\n"
        # output += "ConfBal = Confirmed Balance (The Balance less any unconfirmed Online / Downloaded Bank txns\n"
        output += "CurrBal = Current Balance\n"
        # output += "RecBal = Reconciling Balance (Normally Zero on a Category)\n"
        output += "RcrsBal = Recursive (through all sub categories) Account Balance (Note: may contain balances from inactive sub-categories as per Moneydance)\n"
        # output += "RcrsClrdBal = Recursive (through all sub categories) Cleared Balance (Normally Zero on a Category)\n"
        output += "RcrsCurrBal = Recursive (through all sub categories) Current Balance (Note: may contain balances from inactive sub-categories as per Moneydance)\n"
        # output += "RcrsRecBal = Recursive (through all sub categories) Reconciling Balance (Normally Zero on a Category)\n"
        output += "----------------------------------------------------------------------------\n\n"
        output += "<END>"

        if lFix:
            output += "\nDISCLAIMER: I take no responsibility if you decide to execute the Inactivate Zero Balance Category fix script!\n"

        if not lFix:
            jif = QuickJFrame("View your Active Categories with Zero Balances....", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        else:
            jif = QuickJFrame("View your Active Categories with Zero Balances.... CLICK OK WHEN READY TO PROCEED", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        myPrint("J", "There are %s Active Categories with Zero Balances that could be Inactivated!" % iCountForInactivation)

        if not lFix:
            txt = "VIEW ZERO BALANCE CATEGORIES: YOU HAVE %s Zero Balance Categories..." %(iCountForInactivation)
            setDisplayStatus(txt, "DG")
            myPopupInformationBox(jif, txt, "ZERO BALANCE CATEGORIES", JOptionPane.INFORMATION_MESSAGE)
            return

        if iCountForInactivation < 1:
            txt = "FIX ZERO BALANCE CATEGORIES: You have no Zero Balance Categories to fix - no fixes applied..."
            setDisplayStatus(txt, "DG")
            myPopupInformationBox(jif, txt, "ZERO BALANCE CATEGORIES", JOptionPane.INFORMATION_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(jif, "FIX - INACTIVATE ZERO BALANCE CATEGORIES", "Inactivate these %s Zero Balance Categories?" %(iCountForInactivation)):
            return

        # OK - so we are fixing...!
        myPrint("B", ">> User selected to Inactivate %s Zero Balance Categories!?" % iCountForInactivation)

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for cat in categoriesToInactivate.keys():
            if categoriesToInactivate.get(cat):
                myPrint("B", "Cat: " + cat.getFullAccountName() + " with Zero Balances, Set to INACTIVE!")
                cat.setAccountIsInactive(True)
                cat.syncItem()

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        myPrint("B", "Finished Inactivating %s Categories with Zero Balances..." % iCountForInactivation)

        txt = "FIX - I have set %s Categories with Zero Balances to Inactive as requested!" %(iCountForInactivation)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(jif,txt,"INACTIVATE ZERO BALANCE CATEGORIES",JOptionPane.WARNING_MESSAGE)
        play_the_money_sound()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_account_parent():
        global toolbox_frame_, debug

        # fix_account_parent.py (and old check_root_structure.py)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("B", "Diagnosing INVALID Parent Accounts....")
        myPrint("P", "--------------------------------------")

        book = MD_REF.getCurrentAccountBook()
        root = book.getRootAccount()
        allAccounts = book.getItemsWithType(Account.SYNCABLE_TYPE_VALUE)


        def validate_path(check_acct):
            _acct = check_acct
            iterations = 0
            while True:
                # noinspection PyUnresolvedReferences
                if _acct.getAccountType() == Account.AccountType.ROOT:      return True
                if _acct is None:                                           return False
                if iterations > 100:                                        return False
                iterations+=1
                _acct = _acct.getParentAccount()
                continue


        output = "FIX ACCOUNT(s)' INVALID PARENT ACCOUNTS:\n" \
                 " ========================================\n\n"

        def check_fix_accounts(lFix=False):

            iErrors=0
            textFixed=""

            for acct in allAccounts:

                # skip root
                # noinspection PyUnresolvedReferences
                if acct == root or acct.getAccountType() == Account.AccountType.ROOT: continue

                parent = acct.getParentAccount()
                if ((parent is None or parent == acct)
                        or (parent is not None and parent != root and not validate_path(acct))):
                    iErrors+=1
                    if lFix:
                        myPrint("B","Resetting parent account for %s to root" %(acct.getAccountName()))
                        textFixed+=("Resetting parent account for %s to root\n" %(acct.getAccountName()))
                        acct.setParentAccount(root)
                        acct.syncItem()
                    else:
                        myPrint("B", "@@ ERROR - NEEDS RESET - Account: %s\n" % acct.getAccountName())
                        textFixed+="NEEDS RESET - Account: %s\n" % acct.getAccountName()

            return iErrors, textFixed

        iCountErrors, x =  check_fix_accounts(lFix=False)
        output += x

        if iCountErrors<1:
            txt = "'FIX: Account(s)'s Invalid Parent - CONGRATULATIONS - I found no Invalid parents......."
            setDisplayStatus(txt, "B")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        myPrint("B","FIX - Account(s)' Invalid Parent Accounts - found %s errors..." %(iCountErrors))

        jif=QuickJFrame("VIEW ACCOUNT(s) WITH INVALID PARENT ACCOUNTS", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if not confirm_backup_confirm_disclaimer(jif, "FIX ACCOUNT(S)' INVALID PARENTS","FIX %s Acct(s)'s Invalid Parent Accts?" %(iCountErrors)):
            return

        jif.dispose()       # already within the EDT
        myPrint("B", "User accepted disclaimer to FIX Account(s)' Invalid Parent Accounts. Proceeding.....")

        output += "\n\nRUNNING FIX ON PARENT ACCOUNTS\n" \
                  "--------------------------------\n\n"

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes...
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        iCountErrors, x = check_fix_accounts(lFix=True)
        output += x
        output += "\n<END>"

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)
        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        play_the_money_sound()
        txt = "FIXED %s invalid Parent Accounts" %(iCountErrors)
        setDisplayStatus(txt, "DG")
        myPrint("B", txt)
        jif = QuickJFrame("VIEW ACCOUNT(s) WITH INVALID PARENT ACCOUNTS", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        myPopupInformationBox(jif,txt, "FIX INVALID PARENT ACCOUNTS", JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_root_account_name():
        global toolbox_frame_, debug

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        bookName = MD_REF.getCurrentAccountBook().getName().strip()
        root = MD_REF.getCurrentAccountBook().getRootAccount()
        rootName = root.getAccountName().strip()

        if rootName == bookName:
            myPopupInformationBox(toolbox_frame_,
                                  "The name of your Root Account is already the same as your Dataset(or 'Book'): %s" % (bookName),
                                  "RENAME ROOT ACCOUNT",
                                  JOptionPane.INFORMATION_MESSAGE)
            txt = "No changed applied as your Root Account name is already the same as your Dataset ('Book') name: %s" %(bookName)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B", "User requested to fix Root Account Name")
        myPrint("B", "Dataset's ('Book') Name: ", bookName)
        myPrint("B", "Root's Account Name: ", rootName)

        MyPopUpDialogBox(toolbox_frame_,
                         "RENAME ROOT ACCOUNT",
                         "Your Dataset ('book') name is: %s (this is the name that will be used)\nYour Root Account name is: %s" %(bookName,rootName),
                         theTitle="RENAME ROOT ACCOUNT").go()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "RENAME ROOT ACCOUNT", "rename your Root Account to: %s?" %(bookName)):
            return

        myPrint("B", "User accepted disclaimer to reset Root Account Name. Proceeding.....")
        # Flush all in memory settings to config.dict file on disk
        MD_REF.savePreferences()

        root.setAccountName(bookName)
        root.syncItem()

        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        myPrint("B", "Root account renamed to: %s" % (bookName))
        play_the_money_sound()

        txt = "Root Account Name changed to : %s - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD" %(bookName)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,"RENAME ROOT",JOptionPane.WARNING_MESSAGE)

        MD_REF.getUI().exit()

    # noinspection PyUnresolvedReferences
    def force_change_account_type():
        global toolbox_frame_, debug

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # set_account_type.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change an Account's Type?",
                             theTitle="FORCE CHANGE TYPE",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have have created an Account with the wrong Type\n"
                                        "This fix will NOT attempt to check that the Acct has Txns that are valid in the new Account Type.\n"
                                        "It simply changes the Type set on the account to the new Type.\n"
                                        "You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change an Account's type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to FORCE change its Type",
                                                      "FORCE CHANGE ACCOUNT's TYPE",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      None,
                                                      newAccounts,
                                                      None)  # type: StoreAccountList
        if not selectedAccount:
            txt = "User did not Select an Account to FORCE change its Type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        if selectedAccount.getAccountType() == Account.AccountType.ROOT:
            if not myPopupAskQuestion(toolbox_frame_,"FORCE CHANGE ACCOUNT TYPE","THIS ACCOUNT IS ROOT (SPECIAL). DO YOU REALLY WANT TO CHANGE IT'S TYPE (Normally a bad idea!) ?", theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "User Aborted change of Root's Account Type (phew!) - no changes made"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

        possTypes = Account.AccountType.values()
        possTypes.remove(Account.AccountType.ROOT)
        possTypes.remove(Account.AccountType.SECURITY)
        if selectedAccount.getAccountType() in possTypes:
            possTypes.remove(selectedAccount.getAccountType())

        selectedType = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the new Account Type",
                                                   "FORCE CHANGE ACCOUNT's TYPE",
                                                   JOptionPane.WARNING_MESSAGE,
                                                   None,
                                                   possTypes,
                                                   None)  # type: Account.AccountType
        if not selectedType:
            txt = "User did not Select a new Account Type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if selectedType == Account.AccountType.ROOT:
            if not myPopupAskQuestion(toolbox_frame_,"FORCE CHANGE ACCOUNT TYPE","DO YOU REALLY WANT TO CHANGE TO ROOT (Normally a bad idea!)?", theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "User Aborted change Account to type Root (phew!) - no changes made"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change this Account's Type?",
                             theTitle="FORCE CHANGE TYPE",
                             theMessage="Account: %s\n"
                                        "Old Type: %s\n"
                                        "New Type: %s\n"
                                        %(selectedAccount.getFullAccountName(), selectedAccount.getAccountType(),selectedType),  # noqa
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User aborted the FORCE change to an Account's type - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE TYPE", "FORCE CHANGE ACCOUNT %s TYPE to %s" %(selectedAccount.getFullAccountName(),selectedType)):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Type of Account: %s from: %s to %s - APPLYING UPDATE NOW...."
                %(selectedAccount.getFullAccountName(),selectedAccount.getAccountType(),selectedType))          # noqa

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        selectedAccount.setAccountType(selectedType)                                                            # noqa
        selectedAccount.syncItem()                                                                              # noqa

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = "The Account: %s has been changed to Type: %s- MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD & REVIEW" %(selectedAccount.getAccountName(),selectedAccount.getAccountType())  # noqa
        setDisplayStatus(txt, "R")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        MD_REF.getUI().exit()

    # noinspection PyUnresolvedReferences
    def force_change_all_accounts_currencies():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # force_change_all_currencies.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change ALL Account's Currencies?",
                             theTitle="FORCE CHANGE ALL ACCOUNTS' CURRENCIES",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have a missing currency, or need to change them all\n"
                                        "This fix will not touch the ROOT account nor Security sub-accounts (which are stocks/shares)\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "set on all accounts to the new currency. You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change ALL Account's currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        currencies=[]
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                               # noqa
                currencies.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))

        if len(currencies) < 1:
            myPrint("B", "FORCE CHANGE ALL ACCOUNTS' CURRENCIES - Creating new currency record!")
            selectedCurrency = CurrencyType(book.getCurrencies())       # Creates a null:null CT record
            selectedCurrency.setName("NEW CURRENCY - PLEASE EDIT ME LATER")
            selectedCurrency.setIDString("AAA")
            selectedCurrency.setDecimalPlaces(2)
            selectedCurrency.syncItem()
            myPrint("B", "FORCE CHANGE ALL ACCOUNTS' CURRENCIES - Creating new currency: %s" %(selectedCurrency))
            myPopupInformationBox(toolbox_frame_,"FYI - I have created a new Currency %s for you (Edit me later)" %(selectedCurrency),
                                  "FORCE CHANGE ALL ACCOUNTS' CURRENCIES")
        else:
            selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select a currency to assign to *ALL* accounts",
                                                           "FORCE CHANGE ALL ACCOUNT's CURRENCIES",
                                                           JOptionPane.ERROR_MESSAGE,
                                                           None,
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedCurrency:
            txt = "User did not Select a new currency for FORCE change ALL Accounts' Currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE ALL ACCOUNTS' CURRENCIES", "FORCE CHANGE ALL %s ACCOUNT's CURRENCIES TO %s?" %(len(accounts),selectedCurrency)):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Currency of ALL %s Accounts to %s - APPLYING UPDATE NOW...."
                %(len(accounts),selectedCurrency))     # noqa

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        accountsChanged = 0
        for account in accounts:
            if account.getAccountType() == Account.AccountType.ROOT:
                continue
            if account.getAccountType() == Account.AccountType.SECURITY:
                continue
            if account.getCurrencyType() == selectedCurrency:
                continue

            myPrint("B","Setting account %s to currency %s" %(account, selectedCurrency))
            account.setCurrencyType(selectedCurrency)
            account.syncItem()
            accountsChanged += 1

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = "FORCE CHANGE ALL ACCOUNTS' CURRENCIES: %s Accounts changed to curr: %s - MONEYDANCE WILL NOW EXIT - RELAUNCH MD & REVIEW" %(accountsChanged,selectedCurrency)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        MD_REF.getUI().exit()

    def fix_invalid_relative_currency_rates():
        global toolbox_frame_, debug

        myPrint(u"D", u"In ", inspect.currentframe().f_code.co_name, u"()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        txt = "fix_invalid_relative_currency_rates"
        if not perform_quote_loader_check(toolbox_frame_, txt): return

        book = MD_REF.getCurrentAccountBook()
        currencies = book.getCurrencies().getAllCurrencies()
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getCurrencyType(),sort_x.getName().upper()))

        output=u"FIX INVALID RELATIVE CURRENCIES\n" \
               u" ==============================\n\n"

        upperLimit = 9999999999

        output += u"** Wild rates set to %s <= (rate) >= %s\n" %((1.0 / upperLimit), upperLimit)

        iErrors = 0
        for curr in currencies:
            if not isGoodRate(curr.getRelativeRate()) or curr.getRelativeRate() <= (1.0 / upperLimit) or curr.getRelativeRate() >= upperLimit:
                iErrors += 1
                output += u"Invalid - Type: %s Name: %s Relative Rate: %s\n" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20))

        if iErrors < 1:
            txt = u"FIX INVALID REL CURR RATES: You have no relative rates <= %s or >= %s to fix - NO CHANGES MADE" %((1.0 / upperLimit),upperLimit)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, u"FIX INVALID REL CURR RATES")
            return

        jif=QuickJFrame(u"FIX INVALID RELATIVE CURRENCIES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        # force_change_account_currency.py
        ask=MyPopUpDialogBox(jif,
                             theStatus=u"Are you sure you want to FIX these %s INVALID RELATIVE CURRENCIES?" %iErrors,
                             theTitle=u"FIX INVALID RELATIVE CURRENCIES",
                             theMessage=u"Do not proceed unless you know you want to do this....!\n"
                                        u"This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the relative rate(s)\n"
                                        u"You should carefully review your data afterwards and revert to a backup if you are not happy with the results....\n",
                             lCancelButton=True,
                             OKButtonText=u"I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = u"User did not say yes to fix invalid relative currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(jif, u"FIX INVALID RELATIVE CURR RATES", u"FIX %s INVALID RELATIVE CURRENCY RATES" %(iErrors)):
            return

        jif.dispose()       # already within the EDT

        myPrint(u"B",u"@@ User requested to fix %s invalid relative currency rates - APPLYING UPDATE NOW...." %(iErrors) )

        output += u"\n\n APPLYING FIXES\n" \
                  u" ==============\n\n"

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for curr in currencies:
            if not isGoodRate(curr.getRelativeRate()) or curr.getRelativeRate() <= (1.0 / upperLimit) or curr.getRelativeRate() >= upperLimit:
                output += u"FIXING >> Invalid - Type: %s Name: %s Relative Rate: %s - RESET TO 1.0\n" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20))

                myPrint(u"B", u"FIXING >> Invalid - Type: %s Name: %s Relative Rate: %s - RESET TO 1.0" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20)))

                curr.setRelativeRate(1.0)
                curr.syncItem()

        myPrint(u"P", output)

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        output += "\n<END"

        jif = QuickJFrame(u"FIX INVALID RELATIVE CURRENCIES",output,copyToClipboard=lCopyAllToClipBoard_TB,lQuitMDAfterClose=True).show_the_frame()

        txt = u"%s Invalid Currency relative rates reset to 1.0 - RESTART OF MONEYDANCE REQUIRED - MD WILL QUIT AFTER VIEWING THIS OUTPUT" %(iErrors)
        setDisplayStatus(txt, "R")
        play_the_money_sound()
        myPopupInformationBox(jif,txt, u"FIX INVALID RELATIVE CURRENCIES", theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint(u"D", u"Exiting ", inspect.currentframe().f_code.co_name, u"()")
        return

    def fix_invalid_price_history():
        global toolbox_frame_, debug

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, u"()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        txt = "Fix Invalid Price History Records"
        if not perform_quote_loader_check(toolbox_frame_, txt): return

        output="FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES\n" \
               " ===================================================\n\n"

        upperLimit = 9999999999

        output += "** Wild rates set to %s <= (rate) >= %s\n" %((1.0 / upperLimit), upperLimit)

        allSnaps = MD_REF.getCurrentAccount().getBook().getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE)
        output += "\nFound price history records (snaps): %s" %(len(allSnaps))

        iGood = 0
        badSnaps = []
        output += "\n.. scanning snaps for 'wild' rates....\n"

        for snap in allSnaps:
            snapRate = snap.getRate()
            if not isGoodRate(snapRate) or snapRate <= (1.0 / upperLimit) or snapRate >= upperLimit:
                badSnaps.append(snap)
            else:
                iGood += 1

        if len(badSnaps) < 1:
            txt = "CONGRATULATIONS >> No snaps with 'wild' rates (out of %s good found) found! No changes made!" %(iGood)
            myPrint("DB", txt)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt)
            return

        badSnaps = sorted(badSnaps, key=lambda sort_x: (sort_x.getParameter("curr", None),sort_x.getDateInt()))
        for badSnap in badSnaps:
            output += "Invalid rate found: %s\n" %(badSnap)

        output += "\n\n--------------------------------------\n"
        output += "Good snaps: %s\n" %(iGood)

        txt = "Bad snaps with 'wild' rates found: %s" %(len(badSnaps))
        myPrint("B", txt); output += "%s\n" %(txt)

        jif = QuickJFrame("FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        ask=MyPopUpDialogBox(jif,
                             theStatus="Are you sure you want to DELETE these %s INVALID PRICE HISTORY RECORDS?" %(len(badSnaps)),
                             theTitle="FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",
                             theMessage="Do not proceed unless you know you want to do this....!\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply deletes the invalid rate(s)",
                             lCancelButton=True,
                             OKButtonText="I AGREE - DELETE",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to delete %s invalid price history records - no changes made" %(len(badSnaps))
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(jif,
                                                 "DELETE INVALID PRICE HISTORY RECORDS WITH 'WILD' RATES",
                                                 "DELETE %s INVALID PRICE HISTORY RECORDS" %(len(badSnaps))):
            return
        jif.dispose()       # already within the EDT


        txt = "@@ User requested to delete %s invalid price history with 'wild' rates - DELETING NOW...." %(len(badSnaps))
        myPrint("B", txt); output += "%s\n\n" %(txt)

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        output += "Logging snaps with 'wild' rates for deletion....\n"
        MD_REF.getCurrentAccount().getBook().logRemovedItems(badSnaps)

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        output += "Flushing dataset changes in memory back to disk....\n"
        MD_REF.getCurrentAccount().getBook().saveTrunkFile()

        txt = "%s snaps with 'wild' rates DELETED." %(len(badSnaps))
        myPrint("B", txt); output += "%s\n\n" %(txt)

        output += "\n<END>"

        setDisplayStatus(txt, "R")
        play_the_money_sound()
        jif = QuickJFrame("FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, u"()")
        return

    def force_change_account_currency():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # force_change_account_currency.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change an Account's Currency?",
                             theTitle="FORCE CHANGE CURRENCY",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have duplicated Currencies and you want to move\n"
                                        "transactions from one account to another, but the system prevents you unless they are the same currency\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "set on the account to the new currency. You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change an Account's currency - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        currencies=[]
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                               # noqa
                currencies.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(5))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to FORCE change currency",
                                                      "FORCE CHANGE ACCOUNT's CURRENCY",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      None,
                                                      newAccounts,
                                                      None)  # type: StoreAccountList
        if not selectedAccount:
            txt = "User did not Select an Account to FORCE change currency - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        # noinspection PyUnresolvedReferences
        currencies.remove(selectedAccount.getCurrencyType())

        selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Old Currency: %s >> Select the new currency for the account" %(selectedAccount.getCurrencyType()),                    # noqa
                                                       "FORCE CHANGE ACCOUNT's CURRENCY",
                                                       JOptionPane.ERROR_MESSAGE,
                                                       None,
                                                       currencies,
                                                       None)  # type: CurrencyType
        if not selectedCurrency:
            txt = "User did not Select an new currency for Account FORCE change - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change this Account's Currency?",
                             theTitle="FORCE CHANGE CURRENCY",
                             theMessage="Account: %s\n"
                                        "Old Currency: %s\n"
                                        "New Currency: %s\n"
                                        %(selectedAccount.getFullAccountName(), selectedAccount.getCurrencyType(),selectedCurrency),  # noqa
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User aborted the FORCE change to an Account's currency - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE CURRENCY", "FORCE CHANGE ACCOUNT %s CURRENCY" %(selectedAccount.getFullAccountName())):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Currency of Account: %s from: %s to %s - APPLYING UPDATE NOW...."
                %(selectedAccount.getFullAccountName(),selectedAccount.getCurrencyType(),selectedCurrency))     # noqa

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        selectedAccount.setCurrencyType(selectedCurrency)                                                       # noqa
        selectedAccount.syncItem()                                                                              # noqa

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = "The Account: %s has been changed to Curr: %s - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD & REVIEW"\
              %(selectedAccount.getAccountName(),selectedAccount.getCurrencyType())                                     # noqa
        setDisplayStatus(txt, "R")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        MD_REF.getUI().exit()

    def reverse_txn_amounts():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # reverse_txn_amounts.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to REVERSE Transaction amounts on an Account's Transactions (between two dates)?",
                             theTitle="REVERSE TRANSACTIONAL AMOUNTS",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you perhaps imported transactions with the wrong +/- sign\n"
                                        "..or perhaps you  have changed an account's type\n"
                                        "This fix will not touch the ROOT account nor Investment/Security sub-accounts (which are stocks/shares)\n"
                                        "You should carefully review your data afterwards and revert to a backup if you are not happy with the results....",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to REVERSE TXN AMOUNTS - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(20))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to REVERSE Transactional Amounts",
                                                      "REVERSE ACCOUNT's TXN AMOUNTS",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      None,
                                                      newAccounts,
                                                      None)  # type: StoreAccountList

        if not selectedAccount:
            txt = "User did not Select an Account to REVERSE Transactional Amounts - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        dateField = JDateField(MD_REF.getUI())
        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select Starting Date for reverse", JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION:
            txt = "User did not select start date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        startDate = dateField.getDateInt()

        dateField.gotoToday()

        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select Ending Date for reverse", JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION:
            txt = "User did not select end date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        endDate = dateField.getDateInt()

        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        txns = txnSet.iterableTxns()

        iTxnsFound = 0
        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue
            acct = txn.getAccount()
            if not acct == selectedAccount: continue
            iTxnsFound += 1

        if iTxnsFound < 1:
            txt = "REVERSE TXN AMOUNTS - Sorry - no transactions found - NO CHANGES MADE"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "REVERSE ACCT TXN AMOUNTS", "ACCOUNT %s - REVERSE %s Txns' amounts between %s - %s?" %(selectedAccount,iTxnsFound,startDate,endDate)):
            return

        myPrint("B","@@ User requested to REVERSE the (%s) Txn Amounts on Account %s between %s to %s - APPLYING UPDATE NOW...." %(iTxnsFound, selectedAccount, startDate, endDate))

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue
            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            myPrint("B","Reversing the amount on %s" %(txn))
            ptxn = txn.getParentTxn()

            ptxn.setEditingMode()

            if ptxn == txn:             # this is the parent part of the txn
                myPrint("B", "  - is a parent, changing each split")
                for splitIdx in range(0, txn.getSplitCount()):
                    txn.getSplit(splitIdx).negateAmount()
            else:
                myPrint("B", "  - is a split")
                txn.negateAmount()

            ptxn.syncItem()

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "REVERSE %s Txns Amounts on Account %s between %s - %s COMPLETED - PLEASE REVIEW" %(iTxnsFound,selectedAccount,startDate, endDate)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def reverse_txn_exchange_rates_by_account_and_date():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # reverse_txn_exchange_rates_by_account_and_date.py

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to REVERSE Exchange Rates on an Account's Transactions (between two dates)?",
                             theTitle="REVERSE TRANSACTIONAL EXCHANGE RATES",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you perhaps imported transactions with the fx rates inversed \n"
                                        "This fix will not touch the Currency price history...!\n"
                                        "This fix will not touch the ROOT account nor Investment/Security sub-accounts (which are stocks/shares)\n"
                                        "You should carefully review your data afterwards and revert to a backup if you are not happy with the results....",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to REVERSE TXN EXCHANGE RATES - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(20))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to REVERSE Transactional Exchange Rates",
                                                      "REVERSE ACCOUNT's TXN EXCHANGE RATES",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      None,
                                                      newAccounts,
                                                      None)  # type: StoreAccountList

        if not selectedAccount:
            txt = "User did not select an Account to REVERSE Transactional Exchange Rates - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        dateField = JDateField(MD_REF.getUI())
        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select STARTING Date for reverse", JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION:
            txt = "User did not select start date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        startDate = dateField.getDateInt()

        dateField.gotoToday()

        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select ENDING Date for reverse", JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION:
            txt = "User did not select end date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        endDate = dateField.getDateInt()

        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        txns = txnSet.iterableTxns()

        iTxnsFound = 0

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue

            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            if txn.getParentTxn() == txn:   # Parent
                for splitNum in range(0, txn.getSplitCount()):
                    split = txn.getSplit(splitNum)
                    if split.getAmount() != split.getValue():
                        iTxnsFound += 1
                        break
            else:   # Split
                if txn.getAmount() != txn.getValue():
                    iTxnsFound += 1

        if iTxnsFound < 1:
            txt = "REVERSE TXN EXCHANGE RATES - Sorry - no transactions found (with fx) - NO CHANGES MADE"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "REVERSE ACCT TXN EXCHANGE RATES", "ACCOUNT %s - REVERSE %s Txns' exchange rates between %s - %s?" %(selectedAccount,iTxnsFound,startDate,endDate)):
            return

        myPrint("B","@@ User requested to REVERSE the (%s) Txn Exchange Rates on Account %s between %s to %s - APPLYING UPDATE NOW...." %(iTxnsFound, selectedAccount, startDate, endDate))

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue

            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            ptxn = txn.getParentTxn()
            needsSync = False

            if ptxn == txn:
                for splitNum in range(0, txn.getSplitCount()):
                    split = txn.getSplit(splitNum)
                    if split.getAmount() != split.getValue():
                        if not needsSync:
                            myPrint("B","Reversing exchange rate on %s" %(txn))
                            myPrint("B", "  - is a parent, changing each split")
                            ptxn.setEditingMode()
                        needsSync = True
                        parentVal = split.getParentValue()
                        rate = split.getRate()
                        split.setParentAmount(safeInvertRate(rate), parentVal)
            else:
                split = txn
                if split.getAmount() != split.getValue():
                    myPrint("B","Reversing exchange rate on %s" %(txn))
                    myPrint("B", "  - This is a split - changing...")
                    if not needsSync:
                        ptxn.setEditingMode()
                    needsSync = True
                    parentVal = split.getParentValue()
                    rate = split.getRate()
                    split.setParentAmount(safeInvertRate(rate), parentVal)

            if needsSync:
                ptxn.syncItem()

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "REVERSE %s Txns Exchange Rates on Account %s between %s - %s COMPLETED - PLEASE REVIEW" %(iTxnsFound,selectedAccount,startDate, endDate)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def thin_price_history():
        global toolbox_frame_, debug, lMustRestartAfterSnapChanges

        # based on: price_history_thinner.py
        # (also includes elements from 2017_remove_orphaned_currency_history_entries.py)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if lMustRestartAfterSnapChanges:
            x="Sorry - you have to RESTART MD after running 'FIX - Thin/Purge Price History' to update the csnap cache....."
            myPrint("B",x)
            setDisplayStatus(x, "R")
            myPopupInformationBox(toolbox_frame_,x,"FIX - THIN/PURGE PRICE HISTORY",JOptionPane.ERROR_MESSAGE)
            return

        txt = "Purge/Thin Price History"
        if not perform_quote_loader_check(toolbox_frame_, txt): return


        # prune historical exchange rates and price history from the given currency
        # this thins price history older than a year by keeping no more than one price per week
        # prices within the last year (or the age_limit_days parameter) are not removed

        totalChangesMade = 0

        diagDisplay = "DIAGNOSE CURRENCY PRICE HISTORY (csnaps)\n"
        diagDisplay += " =======================================\n\n"

        def objects_by_type():
            text = "Objects by type summary:\n"
            objectTypes = [ CurrencyType.SYNCABLE_TYPE_VALUE, CurrencySnapshot.SYNCABLE_TYPE_VALUE, CurrencySplit.SYNCABLE_TYPE_VALUE]
            for objectType in objectTypes:
                xx=""
                if objectType == CurrencyType.SYNCABLE_TYPE_VALUE: xx=" (Currency/Security records)"                     # noqa
                if objectType == CurrencySnapshot.SYNCABLE_TYPE_VALUE: xx=" (Currency/Security price history records)"   # noqa
                if objectType == CurrencySplit.SYNCABLE_TYPE_VALUE: xx=" (Security Stock Split records)"                 # noqa
                objects = MD_REF.getCurrentAccount().getBook().getItemsWithType(objectType)
                text+="  %s: %s %s\n"%(pad(objectType,9), rpad(len(objects),12), xx)
            text+="\n"
            return text

        diagDisplay += objects_by_type()

        def hunt_down_orphans():
            # Hunt down the poor little orphans...!
            orphanSnaps = totalSnaps = 0                                                                        # noqa
            text = ""
            saveRawSnaps={}
            for mdItem in MD_REF.getRootAccount().getBook().getSyncer().getSyncedDocument().allItems():
                if not (isinstance(mdItem, MoneydanceSyncableItem)): continue
                if mdItem.getParameter("obj_type", None) != CurrencySnapshot.SYNCABLE_TYPE_VALUE: continue
                saveRawSnaps[mdItem.getParameter("id")] = mdItem
            _currencies = MD_REF.getCurrentAccount().getBook().getCurrencies()
            for _curr in _currencies:
                snapshots = _curr.getSnapshots()
                for snap in snapshots:
                    saveRawSnaps.pop(snap.getParameter("id"))

            oList=[]
            if len(saveRawSnaps)>0:
                lAllValid=True
                for _value in saveRawSnaps.values():
                    if not _value.getCurrencyParameter(None, "curr", None): lAllValid=False
                    oList.append(_value)
                if lAllValid:
                    # Sort and make pretty for Derek ;->
                    oList = sorted(oList, key=lambda sort_x: (sort_x.getCurrencyParameter(None, "curr", None).getCurrencyType(),sort_x.getParameter("curr", None),sort_x.getDateInt()))

                _last = None
                for _x in oList:
                    orphanSnaps += 1
                    chk = _x.getCurrencyParameter(None, "curr", None)
                    if chk: chk = _x.getCurrencyParameter(None, "curr", None).getCurrencyType()
                    if _last != chk:
                        text+=" \n%s:\n" %(chk)
                        _last = chk
                    if debug:
                        text+=" >> Orp/Dup: %s %s\n" %(_x.getUUID(),_x)
                    else:
                        text+=" >> Orp/Dup: %s\n" %(_x)

            for snap in MD_REF.getCurrentAccount().getBook().getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE):
                totalSnaps += 1
                if snap.getParameter("curr", None) is None or MD_REF.getCurrentAccount().getBook().getItemForID(snap.getParameter("curr", None)) is None:
                    if not saveRawSnaps.get(snap.getParameter("id",None)):
                        orphanSnaps += 1
                        saveRawSnaps[snap.getParameter("id")] = snap
                        if debug:
                            text+=" >> Orp (no Curr): %s %s\n" %(snap.getUUID(), snap)
                        else:
                            text+=" >> Orp (no Curr): %s\n" %(snap)
                        oList.append(snap)

            if orphanSnaps:
                text+="\nWARNING: %s of %s currency or security snapshots were orphans/duplicates/stranded (or had no Currency link)\n" %(orphanSnaps, totalSnaps)
                text+="(NOTE: The system 'hides' duplicate price history records for the same currency/date.....)   \n"
            else:
                text+="No price history snapshot orphans/duplicates detected!\n"

            del saveRawSnaps

            oList = sorted(oList, key=lambda sort_x: (sort_x.getParameter("curr", None),sort_x.getDateInt()))

            return text, orphanSnaps, oList

        txt, orphanSnaps, orphans_to_delete = hunt_down_orphans()
        diagDisplay += txt

        def snaps_by_currency():
            text = ""
            _currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            _currencies = sorted(_currencies, key=lambda sort_x: (sort_x.getName().upper()))
            lastC = None
            # noinspection PyUnresolvedReferences
            iAll=iCurrs=iSecs=0
            for theCType in [CurrencyType.Type.CURRENCY, CurrencyType.Type.SECURITY]:                           # noqa
                for _currency in _currencies:
                    if _currency.getCurrencyType() != theCType: continue
                    iAll+=1
                    if _currency.getCurrencyType() == CurrencyType.Type.CURRENCY: iCurrs+=1                     # noqa
                    if _currency.getCurrencyType() == CurrencyType.Type.SECURITY: iSecs+=1                      # noqa
                    if lastC != _currency.getCurrencyType():
                        text+="\n%s:\n" % _currency.getCurrencyType()
                        lastC = _currency.getCurrencyType()
                    _snapshots = _currency.getSnapshots()
                    text+="  %s (snapshots: %s, splits: %s)\n" %(pad(_currency.getName(), 45), rpad(_snapshots.size(),10), rpad(_currency.getSplits().size(),10))

            text+="\n-----\nTotal Curr/Sec listed: %s Currencies: %s Securities: %s\n" %(iAll,iCurrs,iSecs)

            return text

        diagDisplay += snaps_by_currency()

        def does_base_has_snaps(lDelete=False,lVerbose=True):

            baseCurr = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()
            baseSnapshots = baseCurr.getSnapshots()

            iCountBaseSnapsDeleted = 0
            text = ""
            if baseSnapshots.size() > 0:
                text += "ERROR: base currency %s has %s historical prices! These should be deleted!" % (baseCurr, baseSnapshots.size())
                if lDelete and not lVerbose: myPrint("J","@@ Deleting all snapshots from base Currency @@")
                for baseSnapshot in baseSnapshots:
                    if lDelete:
                        if lVerbose:
                            text += "  @@DELETING@@: %s\n" %(baseSnapshot)
                            myPrint("J","Deleting Base Currency snapshot: %s" %(baseSnapshot))
                        baseSnapshot.deleteItem()
                        iCountBaseSnapsDeleted+=1
                    else:
                        if lVerbose:
                            text += "  snapshot: %s\n" %(baseSnapshot)
            else:
                text += "\n\nBase currency %s has NO historical prices! These is correct!\n\n" % (baseCurr)

            return text, iCountBaseSnapsDeleted

        x, y = does_base_has_snaps()
        diagDisplay += x

        jif = QuickJFrame("Price History Analysis", diagDisplay,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()


        if orphanSnaps>0:
            MyPopUpDialogBox(jif,
                             "YOU HAVE ORPHAN/STRANDED Price History Records - READ THIS FIRST",
                             theMessage="These are either 'Orphaned' records with no Currency linkage;\n"
                                        "or they are duplicated records (i.e. multiple records with the same date due to a MD bug)..\n"
                                        "These are 'stranded' / hidden from view. Once you delete the visible record, any Orphan on the same date will reappear\n"
                                        "BEST PRACTICE (after reviewing the Simulation Log) is as follows:\n"
                                        "1. Select 'Only Delete Orphans Mode' and ALL Currencies and ALL Securities. Then Execute\n"
                                        "2. Exit and restart Moneydance (as MD's cache needs refreshing)\n"
                                        "3. Come back here and then choose your desired Purge/Thin mode (if required - optional)\n"
                                        "If you don't follow this sequence, then as you purge, previously hidden records will start appearing\n"
                                        "..(inside or outside the purge/thin window date range you selected)\n"
                                        "(NOTE: Any 'Orphans' that start appearing are harmless, it means they've become visible)",
                             theWidth=180,
                             theTitle="THIN/PURGE PRICE HISTORY",
                             OKButtonText="ACKNOWLEDGE",lAlertLevel=1).go()

        saveColor = JLabel("TEST").getForeground()

        # prune historical exchange rates and price history from the given currency
        # this thins price history older than a year by keeping no more than one price per week
        # prices within the last year (or the age_limit_days parameter) are not removed

        dropdownCurrs=ArrayList()
        dropdownSecs=ArrayList()
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() == CurrencyType.Type.CURRENCY: dropdownCurrs.add(curr)                    # noqa
            if curr.getCurrencyType() == CurrencyType.Type.SECURITY: dropdownSecs.add(curr)                     # noqa
        dropdownCurrs=sorted(dropdownCurrs, key=lambda sort_x: (sort_x.getName().upper()))
        dropdownSecs=sorted(dropdownSecs, key=lambda sort_x: (sort_x.getName().upper()))
        dropdownCurrs.insert(0,"<EXCLUDE Currencies>")
        dropdownCurrs.insert(0,"<ALL Currencies>")
        dropdownSecs.insert(0,"<EXCLUDE Securities>")
        dropdownSecs.insert(0,"<ALL Securities>")
        del currencies

        label_simulate = JLabel("Simulate with no changes?")
        user_simulate = JCheckBox("(Uncheck to make changes)", True)
        user_simulate.setName("user_simulate")

        purgeStrings = ["<DO NOTHING>",
                        "Thin Mode (Thin older than cutoff)",
                        "Purge Mode (Delete all older than cutoff)",
                        "Only Delete Orphans Mode (No Purge/Thin, just Delete Orphans)"]

        if MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0:
            purgeStrings.append("Only Delete Base Records (No Purge/Thin, just Delete Base Records)")

        labelPurgeOrThinMode = JLabel("Select the mode of operation:")
        user_purgeOrThinMode = JComboBox(purgeStrings)
        user_purgeOrThinMode.setName("user_purgeOrThinMode")
        user_purgeOrThinMode.setSelectedIndex(0)

        label_age_limit_days = JLabel("Thin/Purge records older than how many days? (1 to 1825 days)")
        user_age_limit_days = JTextField(5)
        user_age_limit_days.setDocument(JTextFieldLimitYN(5, False, "CURR"))
        user_age_limit_days.setText("")
        user_age_limit_days.setName("user_age_limit_days")
        user_age_limit_days.setEnabled(False)

        label_max_days_between_thinned = JLabel("When Thinning, keep no more than one price per x days? (1 to 31 days)")
        user_max_days_between_thinned = JTextField(3)
        user_max_days_between_thinned.setDocument(JTextFieldLimitYN(3, False, "CURR"))
        user_max_days_between_thinned.setText("")
        user_max_days_between_thinned.setName("user_max_days_between_thinned")
        user_max_days_between_thinned.setEnabled(False)

        label_includeCurrencies = JLabel("Thin/purge Currencies (All/Exclude/Select)?")
        user_includeCurrencies = JComboBox(dropdownCurrs)
        user_includeCurrencies.setSelectedIndex(1)
        user_includeCurrencies.setName("user_includeCurrencies")
        user_includeCurrencies.setEnabled(False)

        label_includeSecurities = JLabel("Thin/purge Securities (All/Exclude/Select)?")
        user_includeSecurities = JComboBox(dropdownSecs)
        user_includeSecurities.setSelectedIndex(1)
        user_includeSecurities.setName("user_includeSecurities")
        user_includeSecurities.setEnabled(False)

        labelPurgeOrphans = JLabel("While Purging/Thinning, also delete any/all Orphan/duplicate Snapshots found?")
        user_purgeOrphans = JCheckBox("(will only delete Orphans matching your ^^Curr/Sec^^ filters above)", False)
        user_purgeOrphans.setEnabled( orphanSnaps>0 )
        user_purgeOrphans.setName("user_purgeOrphans")
        user_purgeOrphans.setEnabled(False)

        labelPurgeBase = JLabel("While Purging/Thinning, also delete all Snapshots found on Base Currency?")
        user_purgeBase = JCheckBox("(will delete all Base Currency snapshots)", False)
        user_purgeBase.setEnabled(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0 )
        user_purgeBase.setName("user_purgeBase")
        user_purgeBase.setEnabled(False)

        labelSaveTrunk = JLabel("Consolidate into new Trunk File after mass thin/purge process?")
        user_SaveTrunk = JCheckBox("(compacts/rewrites Dataset (trunk file) & clears *.mdtxn files)", False)
        user_SaveTrunk.setName("user_SaveTrunk")
        user_SaveTrunk.setEnabled(False)

        labelVERBOSE = JLabel("VERBOSE mode = Extra logfile output on all steps?")
        user_VERBOSE = JCheckBox("", False)
        user_VERBOSE.setName("user_VERBOSE")
        user_VERBOSE.setEnabled(False)

        labelSTATUS = JLabel("")
        labelSTATUS2 = JLabel("")

        userFilters = JPanel(GridLayout(0, 2))

        class PanelAction(AbstractAction):

            def __init__(self, thePanel, iOrphs):
                self.thePanel=thePanel
                self.iOrphs=iOrphs

            def actionPerformed(self, event):                                                                   # noqa
                global debug
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)

                the_simulate = None
                the_purgeOrThinMode = None
                the_age_limit_days = None
                the_max_days_between_thinned = None
                the_includeCurrencies = None
                the_includeSecurities = None
                the_purgeOrphans = None
                the_purgeBase = None
                the_SaveTrunk = None
                the_VERBOSE = None
                saveDropDownStateToo = None

                _components = self.thePanel.getComponents()
                for _theComponent in _components:

                    if isinstance(_theComponent, (JComboBox, JTextField, JCheckBox, JButton)):
                        if event.getSource().getName() == _theComponent.getName():
                            if _theComponent.getName() == "user_purgeOrThinMode": the_purgeOrThinMode  = _theComponent

                        if _theComponent.getName() == "user_purgeOrThinMode": saveDropDownStateToo  = _theComponent
                        if _theComponent.getName() == "user_simulate": the_simulate  = _theComponent
                        if _theComponent.getName() == "user_includeCurrencies": the_includeCurrencies  = _theComponent
                        if _theComponent.getName() == "user_includeSecurities": the_includeSecurities  = _theComponent
                        if _theComponent.getName() == "user_purgeOrphans": the_purgeOrphans  = _theComponent
                        if _theComponent.getName() == "user_purgeBase": the_purgeBase  = _theComponent
                        if _theComponent.getName() == "user_age_limit_days": the_age_limit_days  = _theComponent
                        if _theComponent.getName() == "user_max_days_between_thinned": the_max_days_between_thinned  = _theComponent
                        if _theComponent.getName() == "user_SaveTrunk": the_SaveTrunk  = _theComponent
                        if _theComponent.getName() == "user_VERBOSE": the_VERBOSE  = _theComponent

                if the_simulate:
                    if not the_simulate.isSelected():
                        if saveDropDownStateToo.getSelectedIndex() > 0:
                            the_SaveTrunk.setEnabled(True)
                        else:
                            the_SaveTrunk.setEnabled(False)
                            the_SaveTrunk.setSelected(False)
                    else:
                        the_SaveTrunk.setEnabled(False)
                        the_SaveTrunk.setSelected(False)

                # noinspection PyUnresolvedReferences
                if the_purgeOrThinMode:
                    if the_purgeOrThinMode.getSelectedItem().lower().startswith("<DO NOTHING>".lower()):        # noqa
                        the_age_limit_days.setEnabled(False)
                        the_max_days_between_thinned.setEnabled(False)
                        the_includeCurrencies.setEnabled(False)
                        the_includeSecurities.setEnabled(False)
                        the_purgeOrphans.setEnabled(False)
                        the_purgeBase.setEnabled(False)
                        the_SaveTrunk.setEnabled(False)
                        the_VERBOSE.setEnabled(False)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Thin Mode".lower()):         # noqa
                        the_age_limit_days.setEnabled(True)
                        the_age_limit_days.setText("90")
                        the_max_days_between_thinned.setEnabled(True)
                        the_max_days_between_thinned.setText("7")
                        the_includeCurrencies.setEnabled(True)
                        the_includeSecurities.setEnabled(True)
                        the_purgeOrphans.setEnabled(self.iOrphs>0)
                        the_purgeBase.setEnabled(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0)
                        the_SaveTrunk.setEnabled(True)
                        the_VERBOSE.setEnabled(True)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Purge Mode".lower()):        # noqa
                        the_age_limit_days.setEnabled(True)
                        the_age_limit_days.setText("730")
                        the_max_days_between_thinned.setText("")
                        the_max_days_between_thinned.setEnabled(False)
                        the_includeCurrencies.setEnabled(True)
                        the_includeSecurities.setEnabled(True)
                        the_purgeOrphans.setEnabled(self.iOrphs>0)
                        the_purgeBase.setEnabled(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0)
                        the_SaveTrunk.setEnabled(True)
                        the_VERBOSE.setEnabled(True)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Only Delete Orphans".lower()):  # noqa
                        if self.iOrphs>0:
                            the_age_limit_days.setEnabled(False)
                            the_age_limit_days.setText("")
                            the_max_days_between_thinned.setText("")
                            the_max_days_between_thinned.setEnabled(False)
                            the_includeCurrencies.setEnabled(True)
                            the_includeCurrencies.setSelectedIndex(1)
                            the_includeSecurities.setEnabled(True)
                            the_includeSecurities.setSelectedIndex(1)
                            the_purgeOrphans.setEnabled(False)
                            the_purgeOrphans.setSelected(False)
                            the_purgeBase.setEnabled(False)
                            the_purgeBase.setSelected(False)
                            the_VERBOSE.setEnabled(True)
                            if not(the_simulate.isSelected()):
                                the_SaveTrunk.setEnabled(True)
                        else:
                            the_purgeOrThinMode.setSelectedIndex(0)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Only Delete Base Records".lower()):  # noqa
                        if MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0:
                            the_age_limit_days.setEnabled(False)
                            the_age_limit_days.setText("")
                            the_max_days_between_thinned.setText("")
                            the_max_days_between_thinned.setEnabled(False)
                            the_includeCurrencies.setEnabled(False)
                            the_includeCurrencies.setSelectedIndex(1)
                            the_includeSecurities.setEnabled(False)
                            the_includeSecurities.setSelectedIndex(1)
                            the_purgeOrphans.setEnabled(False)
                            the_purgeOrphans.setSelected(False)
                            the_purgeBase.setEnabled(False)
                            the_purgeBase.setSelected(False)
                            the_VERBOSE.setEnabled(True)
                            if not(the_simulate.isSelected()):
                                the_SaveTrunk.setEnabled(True)
                        else:
                            the_purgeOrThinMode.setSelectedIndex(0)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        userFilters.add(label_simulate)
        userFilters.add(user_simulate)
        userFilters.add(labelPurgeOrThinMode)
        userFilters.add(user_purgeOrThinMode)
        userFilters.add(label_age_limit_days)
        userFilters.add(user_age_limit_days)
        userFilters.add(label_max_days_between_thinned)
        userFilters.add(user_max_days_between_thinned)
        userFilters.add(label_includeCurrencies)
        userFilters.add(user_includeCurrencies)
        userFilters.add(label_includeSecurities)
        userFilters.add(user_includeSecurities)
        userFilters.add(labelPurgeOrphans)
        userFilters.add(user_purgeOrphans)
        userFilters.add(labelPurgeBase)
        userFilters.add(user_purgeBase)
        userFilters.add(labelSaveTrunk)
        userFilters.add(user_SaveTrunk)
        userFilters.add(labelVERBOSE)
        userFilters.add(user_VERBOSE)
        userFilters.add(labelSTATUS)
        userFilters.add(labelSTATUS2)

        components = userFilters.getComponents()
        for theComponent in components:
            if isinstance(theComponent, (JComboBox,JTextField,JCheckBox)):
                theComponent.addActionListener(PanelAction( userFilters, orphanSnaps))

        while True:
            options = ["EXIT", "PROCEED"]
            userAction = (JOptionPane.showOptionDialog(jif,
                                                       userFilters,
                                                       "THIN PRICE HISTORY",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       options, options[0]))
            if userAction != 1:
                txt = "THIN PRICE HISTORY - No changes made....."
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            lDoNOTHING = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 0
            lThinMode = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 1
            lPurgeMode = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 2
            purgeOrphansONLY = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 3
            purgeBaseONLY = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 4

            simulate = user_simulate.isSelected()
            age_limit_days = user_age_limit_days.getText()
            max_days_between_thinned = user_max_days_between_thinned.getText()
            purgeOrphans = user_purgeOrphans.isSelected()
            purgeBase = user_purgeBase.isSelected()
            confirmedSaveTrunk = user_SaveTrunk.isSelected()
            VERBOSE = user_VERBOSE.isSelected()

            if isinstance(user_includeCurrencies.getSelectedItem(),(str,unicode)):
                if str(user_includeCurrencies.getSelectedItem()).startswith("<ALL"):
                    includeCurrencies=True
                elif str(user_includeCurrencies.getSelectedItem()).startswith("<EXCL"):
                    includeCurrencies=False
                else:
                    raise(Exception("THIN PRICE HISTORY INCLUDE CURRENCIES PARAMETER ERROR"))
            elif isinstance(user_includeCurrencies.getSelectedItem(),(CurrencyType)):
                includeCurrencies = user_includeCurrencies.getSelectedItem()
            else:
                raise(Exception("THIN PRICE HISTORY INCLUDE CURRENCIES PARAMETER ERROR2"))

            if isinstance(user_includeSecurities.getSelectedItem(),(str,unicode)):
                if str(user_includeSecurities.getSelectedItem()).startswith("<ALL"):
                    includeSecurities=True
                elif str(user_includeSecurities.getSelectedItem()).startswith("<EXCL"):
                    includeSecurities=False
                else:
                    raise(Exception("THIN PRICE HISTORY INCLUDE SECURITIES PARAMETER ERROR"))
            elif isinstance(user_includeSecurities.getSelectedItem(),(CurrencyType)):
                includeSecurities = user_includeSecurities.getSelectedItem()
            else:
                raise(Exception("THIN PRICE HISTORY INCLUDE SECURITIES PARAMETER ERROR2"))

            paramError=False
            labelSTATUS.setText("")
            labelSTATUS.setForeground(getColorRed())

            if lDoNOTHING:
                labelSTATUS.setText("ERROR: I CANNOT DO NOTHING? PLEASE CHOOSE AN OPTION!")
                continue

            if lThinMode or lPurgeMode:
                # noinspection PyChainedComparsons
                if not StringUtils.isInteger(age_limit_days) or not (int(age_limit_days) >0 and int(age_limit_days) <= (365*5)):        # noqa
                    user_age_limit_days.setForeground(getColorRed())
                    labelSTATUS.setText("ERROR: age limit days parameter must be between 0 and 1825 (5 years)")
                    paramError=True
                else:
                    age_limit_days=int(age_limit_days)
                    user_age_limit_days.setForeground(saveColor)
            else:
                age_limit_days=0

            if lThinMode:
                # noinspection PyChainedComparsons
                if not StringUtils.isInteger(max_days_between_thinned) or not (int(max_days_between_thinned) >0 and int(max_days_between_thinned) <= (31)):   # noqa
                    user_max_days_between_thinned.setForeground(getColorRed())
                    labelSTATUS.setText("ERROR: max days between dates parameter must be between 0 and 31")
                    paramError=True
                else:
                    max_days_between_thinned=int(max_days_between_thinned)
                    user_max_days_between_thinned.setForeground(saveColor)
            else:
                max_days_between_thinned = 0

            if purgeOrphans and purgeOrphansONLY:
                user_purgeOrphans.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: you cannot select both purge Orphans and purge ONLY orphans")
                paramError=True
            else:
                user_purgeOrphans.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if (purgeOrphans or purgeOrphansONLY) and orphanSnaps < 1:
                user_purgeOrphans.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: You have no Orphan records to purge - please deselect these options")
                paramError=True
            else:
                user_purgeOrphans.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if purgeBase and purgeBaseONLY:
                user_purgeBase.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: you cannot select both delete Base records and delete ONLY base records")
                paramError=True
            else:
                user_purgeBase.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if (purgeBase or purgeBaseONLY) and MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size() < 1:
                user_purgeBase.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: You have no Base Currency snapshot records to delete - please deselect these options")
                paramError=True
            else:
                user_purgeBase.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if not includeCurrencies and not includeSecurities and (lThinMode or lPurgeMode or purgeOrphansONLY):
                user_includeSecurities.setForeground(getColorRed())
                user_includeCurrencies.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: Please select Security(s) / Currency(s) to process/filter...")
                paramError = True
            else:
                user_includeSecurities.setForeground(saveColor)
                user_includeCurrencies.setForeground(saveColor)

            if (includeCurrencies or includeSecurities) and (purgeBaseONLY):
                user_includeSecurities.setForeground(getColorRed())
                user_includeCurrencies.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: Delete Base Currency records IGNORES filters. Please Deselect Security(s) / Currency(s) filter(s)...")
                paramError = True
            else:
                user_includeSecurities.setForeground(saveColor)
                user_includeCurrencies.setForeground(saveColor)

            if paramError: continue

            break

        components = userFilters.getComponents()
        for theComponent in components:
            if isinstance(theComponent, (JComboBox,JTextField, JCheckBox)):
                for al in theComponent.getActionListeners():
                    theComponent.removeActionListener(al)
        del userFilters

        if lDoNOTHING: raise Exception("ERROR: Why is lDoNOTHING set?")

        if not simulate:
            if not confirm_backup_confirm_disclaimer(jif, "THIN PRICE HISTORY", "Thin Price History?"):
                return

        jif.dispose()       # already within the EDT

        myPrint("B","THIN PRICE HISTORY - User choose parameters: "
                    "Simulate: %s "
                    "Thin Mode: %s "
                    "Purge Mode: %s "
                    "age_limit_days: %s "
                    "max_days_between_thinned: %s "
                    "includeCurrencies: %s "
                    "includeSecurities: %s "
                    "purgeOrphans: %s "
                    "purgeOrphansONLY: %s "
                    "purgeBase: %s"
                    "purgeBaseONLY: %s"
                    "SaveTrunk: %s"
                    "verbose: %s"
                %(simulate, lThinMode, lPurgeMode, age_limit_days, max_days_between_thinned, includeCurrencies, includeSecurities, purgeOrphans, purgeOrphansONLY, purgeBase, purgeBaseONLY, confirmedSaveTrunk,  VERBOSE))

        del orphanSnaps

        def prune_snapshots(_curr, THINMODE, age_limit_days, max_days_between_thinned, lDelete=False, lVerbose=False):        # noqa

            if THINMODE: ThnTxt="THIN"
            else: ThnTxt="PURGE"

            age_limit_date = DateUtil.incrementDate(DateUtil.getStrippedDateInt(), 0, 0, -(age_limit_days))
            text = "\n>%s: %s'ing snapshots older than %s\n" %(_curr, ThnTxt, age_limit_date)
            text += "  %s BEFORE %s (snapshots: %s, splits: %s)\n"%(_curr, ThnTxt, _curr.getSnapshots().size(), _curr.getSplits().size())
            _snapshots = _curr.getSnapshots()
            old_snapshots = []
            countChanges  = 0
            saveFirstSnapPreserved = None
            for snapshot in _snapshots:
                if snapshot.getDateInt() < age_limit_date:
                    if len(old_snapshots)+1 >= len(_snapshots):
                        text += "  > NOTE: Preserving the newest and last Price History record (so you always have 1): %s\n" %snapshot
                        saveFirstSnapPreserved = snapshot.getDateInt()
                    else:
                        old_snapshots.append(snapshot)
                else:
                    if saveFirstSnapPreserved is None:
                        saveFirstSnapPreserved = snapshot.getDateInt()

            if saveFirstSnapPreserved is None:
                myPrint("B","@@ LOGIC ERROR why saveFirstSnapPreserved == None?")
                saveFirstSnapPreserved = age_limit_date

            last_date = 0
            text += "  %s snapshot(s) are older than cutoff date and eligible to be %s'd'..\n" %(len(old_snapshots),ThnTxt)
            num_thinned = 0
            # This presumes the data is presented oldest, to newest, which the inbuilt comparator/sort seems to do...

            # for snapshot in old_snapshots:
            for _i in range(0, len(old_snapshots)):
                snapshot = old_snapshots[_i]
                snap_date = snapshot.getDateInt()

                if _i+1 < len(old_snapshots):                        # not at end of the records
                    safetyDate = old_snapshots[_i+1].getDateInt()    # take a peek at the next record..
                else:
                    safetyDate = saveFirstSnapPreserved

                if (not THINMODE) \
                        or (THINMODE and DateUtil.calculateDaysBetween(last_date, snap_date) < max_days_between_thinned
                            and DateUtil.calculateDaysBetween(last_date, safetyDate) < max_days_between_thinned+1):  # This ensures there's no huge leap to the next date......
                    if lVerbose:
                        text += "    *** delete snapshot dated %s\n"%(snap_date)
                    num_thinned += 1
                    if lDelete:
                        if lVerbose:
                            myPrint("B","%s PRICE HISTORY: Deleting snapshot: %s" %(ThnTxt,repr(snapshot)))
                        countChanges+=1
                        snapshot.deleteItem()
                else:
                    # don't thin this snapshot, and set the last seen date to it
                    if  lVerbose:
                        text += "    > Not deleting snapshot dated %s (preserving 1 per interval specified)\n"%(snap_date)
                    last_date = snap_date
                _i+=1

            if len(old_snapshots):
                text += "  >> %s'd %s of %s eligible (old) snapshots (%s percent) from %s\n"%(ThnTxt, num_thinned, len(old_snapshots), 100*num_thinned/len(old_snapshots), _curr.getName())
                text += "  >> %s'd %s of %s total snapshots          (%s percent) from %s\n"%(ThnTxt, num_thinned, len(_snapshots), 100*num_thinned/len(_snapshots), _curr.getName())
            else:
                text += "  >> No old snapshots %s'd from %s\n" %(ThnTxt, _curr.getName())

            return text, countChanges

        def prune_all_snapshots(THIN_MODE, age_limit_days, max_days_between_thinned, incCurrencies, incSecurities, lVerbose=False, lDelete=False):       # noqa
            countTheChanges = 0
            _currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            lastC = None
            text = ""

            if THIN_MODE: Thn_Txt="THIN"
            else: Thn_Txt="PURGE"

            theList = []
            if incCurrencies: theList.append(CurrencyType.Type.CURRENCY)                                        # noqa
            if incSecurities: theList.append(CurrencyType.Type.SECURITY)                                        # noqa

            for theCType in theList:

                for _curr in _currs:

                    if _curr.getCurrencyType() != theCType: continue

                    if (_curr.getCurrencyType() == CurrencyType.Type.CURRENCY                                                  # noqa
                            and incCurrencies and isinstance(incCurrencies,(CurrencyType)) and _curr != incCurrencies):
                        continue
                    if (_curr.getCurrencyType() == CurrencyType.Type.SECURITY                                                   # noqa
                            and incSecurities and isinstance(incSecurities,(CurrencyType)) and _curr != incSecurities):
                        continue

                    if lastC != _curr.getCurrencyType():
                        text+="\n%s:\n" %_curr.getCurrencyType()
                        lastC = _curr.getCurrencyType()

                    _snaps = _curr.getSnapshots()
                    if _snaps.size() >= 1:
                        _txt, _i = prune_snapshots(_curr, THIN_MODE, age_limit_days, max_days_between_thinned, lDelete, lVerbose)
                        text += _txt
                        countTheChanges += _i
                        _snaps = _curr.getSnapshots()
                        text += "  %s AFTER %s (snapshots: %s, splits: %s)\n"%(_curr, Thn_Txt, _snaps.size(), _curr.getSplits().size())
            return text, countTheChanges

        def prune_orphans(_orphans, incCurrencies, incSecurities, lVerbose=False, lDelete=False):

            iPurgeCount=0

            _orphanSnaps = len(_orphans)
            text = "\nReviewing 'orphan' (or duplicates/stranded) snaps...:\n"

            theList = []                                                                                                # noqa
            theList.append(None)
            if incCurrencies: theList.append(CurrencyType.Type.CURRENCY)                                                # noqa
            if incSecurities: theList.append(CurrencyType.Type.SECURITY)                                                # noqa

            filteredOrphanList=[]
            for theCType in theList:
                for _o in _orphans:
                    theCurr = _o.getCurrencyParameter(None, "curr", None)

                    if theCType is None:
                        if theCurr is not None: continue
                    else:
                        if theCurr.getCurrencyType() != theCType: continue

                    if theCurr:
                        if (theCurr.getCurrencyType() == CurrencyType.Type.CURRENCY                                                  # noqa
                                and incCurrencies and isinstance(incCurrencies,(CurrencyType)) and theCurr != incCurrencies):
                            continue
                        if (theCurr.getCurrencyType() == CurrencyType.Type.SECURITY                                                   # noqa
                                and incSecurities and isinstance(incSecurities,(CurrencyType)) and theCurr != incSecurities):
                            continue
                    filteredOrphanList.append(_o)

            del _orphans

            if len(filteredOrphanList)<1:
                text += "\nNo *filtered* currency or security snapshots were 'orphans' (duplicates/stranded)\n\n"
            else:
                text += "\n%s *filtered* currency or security snapshots were 'orphans' (duplicates/stranded)\n\n"%(len(filteredOrphanList))
                if lDelete:
                    myPrint("B","Logging 'orphan' snaps for deletion....")
                    text += "Logging 'orphan' snaps for deletion....\n"
                    if lVerbose:
                        for _o in filteredOrphanList:
                            text += "Logging 'Orphan' to delete: %s\n" %(repr(_o))
                            myPrint("B","Logging 'Orphan' to delete: %s" %(repr(_o)))
                    MD_REF.getCurrentAccount().getBook().logRemovedItems(filteredOrphanList)
                    iPurgeCount+=len(filteredOrphanList)
                else:
                    if lVerbose:
                        for _o in filteredOrphanList: text += "  'Orphan' found: %s\n" %(_o)
                    text += "\nSimulation so no 'orphan' snaps will be deleted....\n"
            del filteredOrphanList

            return text, iPurgeCount

        if lThinMode: ThnPurgeTxt="THIN"
        elif lPurgeMode: ThnPurgeTxt="PURGE"
        elif purgeOrphansONLY: ThnPurgeTxt="PURGE ORPHANS"
        elif purgeBaseONLY: ThnPurgeTxt="PURGE BASE CURRENCY RECORDS"
        else: ThnPurgeTxt="THIN/PURGE"

        if simulate: x="SIMULATE"
        else: x="DATABASE UPDATE"

        purgingMsg = MyPopUpDialogBox(toolbox_frame_,"Please wait: Processing your %s request (%s).." %(ThnPurgeTxt,x),
                                      theTitle="FIX - Thin/Purge",
                                      theWidth=100, lModal=False,OKButtonText="WAIT")
        purgingMsg.go()

        diagDisplay += "\n\n *** EXECUTING %s PRICE HISTORY ***\n" %(ThnPurgeTxt)
        diagDisplay += "\nUser choose parameters:\n" \
                       " >> Simulate:                 %s\n" \
                       " >> Purge Mode:               %s\n" \
                       " >> Thin Mode:                %s\n" \
                       " >> age_limit_days:           %s (%s)\n" \
                       " >> max_days_between_thinned: %s\n" \
                       " >> includeCurrencies:        %s\n" \
                       " >> includeSecurities:        %s\n" \
                       " >> purgeOrphans:             %s\n" \
                       " >> purgeOrphansONLY:         %s\n" \
                       " >> purgeBase:                %s\n" \
                       " >> purgeBaseONLY:            %s\n" \
                       " >> confirmedSaveTrunk:       %s\n" \
                       " >> VERBOSE:                  %s\n" \
                       %(simulate, lPurgeMode, lThinMode, age_limit_days, DateUtil.incrementDate(DateUtil.getStrippedDateInt(), 0, 0, -(age_limit_days)),max_days_between_thinned, includeCurrencies, includeSecurities, purgeOrphans, purgeOrphansONLY, purgeBase, purgeBaseONLY, confirmedSaveTrunk, VERBOSE)

        diagDisplay+="\n%s PRICE HISTORY\n" \
                     " =================\n" %(ThnPurgeTxt)

        if not simulate:
            MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

        if simulate:
            diagDisplay += "\n ** SIMULATION MODE - NO CHANGES MADE ** \n"
        else:
            diagDisplay += "\n ** %s MODE - CHANGES BEING MADE! ** \n" %(ThnPurgeTxt)

        if purgeOrphans or purgeOrphansONLY:
            x,i = prune_orphans(orphans_to_delete, includeCurrencies, includeSecurities, lVerbose=VERBOSE, lDelete=(not simulate))
            diagDisplay += x
            totalChangesMade += i

        if purgeBase or purgeBaseONLY:
            x,i = does_base_has_snaps(lDelete=(not simulate), lVerbose=VERBOSE)
            diagDisplay += x
            totalChangesMade += i

        if lPurgeMode or lThinMode:  # Mutually exclusive!
            txt, i = prune_all_snapshots(lThinMode, age_limit_days, max_days_between_thinned, includeCurrencies, includeSecurities, lVerbose=VERBOSE, lDelete=(not simulate))
            diagDisplay += txt
            totalChangesMade += i

        if not simulate:
            MD_REF.getUI().getMain().saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        if confirmedSaveTrunk:
            if not simulate:
                if totalChangesMade > 0:
                    myPrint("B","%s PRICE HISTORY: Calling saveTrunkFile()...." %(ThnPurgeTxt))
                    diagDisplay += "\n\n ======\nSaving Trunk File.....\n ======\n\n"
                    MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                else:
                    myPrint("B","%s PRICE HISTORY: No changes made - so NOT Calling saveTrunkFile()...." %(ThnPurgeTxt))
                    diagDisplay += "No changes made, so **NOT** Saving Trunk File.....\n"
            else:
                diagDisplay += "Simulation mode >> (Not) Saving Trunk File.....\n"

        purgingMsg.kill()

        diagDisplay+="\n\n ANALYSIS AFTER %s:\n" %(ThnPurgeTxt)
        diagDisplay+=" ==============================\n"

        diagDisplay += objects_by_type()

        diagDisplay += snaps_by_currency()

        diagDisplay+="\n"

        if simulate:
            x="SIMULATION MODE ONLY"
        else:
            x="UPDATE/%s MODE" %(ThnPurgeTxt)

        if totalChangesMade > 0:
            lMustRestartAfterSnapChanges = True
            diagDisplay += ("\n\n *** %s changes were made! ***\n\n" %(totalChangesMade)).upper()
        else:
            diagDisplay += "\n\n *** no changes were made! ***\n\n".upper()

        diagDisplay+="\n%s PRICE HISTORY in %s COMPLETED!\n" %(ThnPurgeTxt,x)
        diagDisplay+="\n<END>"

        txt = "%s PRICE HISTORY - %s >> Successfully executed (%s changes made)" %(ThnPurgeTxt,x,totalChangesMade)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)

        jif = QuickJFrame("Price History Analysis", diagDisplay,copyToClipboard=lCopyAllToClipBoard_TB,
                          lQuitMDAfterClose=(not simulate and lMustRestartAfterSnapChanges)).show_the_frame()
        if simulate:
            MyPopUpDialogBox(jif, "%s PRICE HISTORY - %s >> Successfully executed" %(ThnPurgeTxt,x),"",200,"THIN/PRUNE PRICE HISTORY").go()
        else:
            if totalChangesMade > 0:
                play_the_money_sound()
                MyPopUpDialogBox(jif, "%s PRICE HISTORY - %s >> Successfully executed %s changes - RESTART OF MONEYDANCE REQUIRED - MD WILL QUIT AFTER VIEWING THIS OUTPUT" %(ThnPurgeTxt,x,totalChangesMade),"",200,"THIN/PRUNE PRICE HISTORY").go()
            else:
                MyPopUpDialogBox(jif, "%s PRICE HISTORY - %s >> Successfully executed - NO CHANGES NECESSARY / MADE" %(ThnPurgeTxt,x),"",200,"THIN/PRUNE PRICE HISTORY").go()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def extract_attachments():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "EXTRACT ATTACHMENTS"

        ask=MyPopUpDialogBox(toolbox_frame_,"EXTRACT ATTACHMENTS - For Your Information",
                             "This will extract all your attachments to a directory....\n"
                             "There is also an extension which will extract attachments alongside your Investment or Bank Account Registers\n"
                             ">> Extension: 'Extract Data' available from MD menu >> Manage Extensions\n"
                             "Please select a directory to extract attachments to...\n"
                             "I will create a sub-directory called 'EXTRACT_MD_ATTACHMENTS-x' (I will append a unique number)",
                             theWidth=225,
                             theTitle=_THIS_METHOD_NAME,
                             OKButtonText="PROCEED", lCancelButton=True)
        if not ask.go():
            return

        while True:
            lExit = False

            _theTitle = "Select location to Extract Attachments to... (CANCEL=ABORT)"
            theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                                get_home_dir(),         # Starting path
                                                None,                   # Default Filename
                                                _theTitle,              # Title
                                                False,                  # Multi-file selection mode
                                                True,                   # True for Open/Load, False for Save
                                                False,                  # True = Files, else Dirs
                                                "EXTRACT ATTACHMENTS",  # Load/Save button text, None for defaults
                                                None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=False,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

            if theDir is None or theDir == "":
                _txt = "%s: User did not select Extract Directory to put attachments... Aborting" %(_THIS_METHOD_NAME)
                myPrint("P", _txt); myPopupInformationBox(None, _txt)
                lExit = True
                break

            if not os.path.exists(theDir):
                myPopupInformationBox(None, "ERROR - the folder does not exist?", _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
                continue

            theDir = os.path.join(theDir,"EXTRACT_MD_ATTACHMENTS-%s" %(UUID.randomUUID().toString()))
            if os.path.exists(theDir):
                myPopupInformationBox(None, "SORRY - the folder %s already exists... I need to create it myself...", _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
                continue

            break

        iSkip=0
        iCountAttachments = 0
        textLog = "\n%s:\n" \
                  " ===================\n\n" %(_THIS_METHOD_NAME)

        textLog += "Base extract folder: %s%s\n\n" %(theDir,os.path.sep)
        textRecords = []

        if not lExit and theDir is not None:
            exportFolder = theDir

            txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()

            File(exportFolder).mkdirs()

            myPrint("B", "Will export all attachments to %s"%(exportFolder))

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: extracting attachments..",
                                          theTitle=_THIS_METHOD_NAME,
                                          theWidth=100,
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            for txn in txnSet.iterableTxns():
                for attachKey in txn.getAttachmentKeys():
                    iCountAttachments+=1
                    attachTag = txn.getAttachmentTag(attachKey)
                    txnDate = txn.getDateInt()
                    attachFile = File(attachTag).getName()
                    attachFolder = os.path.join(exportFolder,"ACCT-TYPE-%s"%(txn.getAccount().getAccountType()),"ACCT-%s" %(txn.getAccount().getAccountName()))
                    File(attachFolder).mkdirs()
                    outputPath = os.path.join(attachFolder, "{:04d}-{:02d}-{:02d}-{}-{}".format(txnDate/10000, (txnDate/100)%100,  txnDate%100, str(iCountAttachments).zfill(5), attachFile))
                    if os.path.exists(outputPath):
                        iSkip+=1
                        myPrint("B", "Error - path: %s already exists... SKIPPING THIS ONE!" %outputPath)
                        textLog+=("Error - path: %s already exists... SKIPPING THIS ONE!\n" %outputPath)
                    else:
                        myPrint("P", "Exporting attachment [%s]" %(os.path.basename(outputPath)))
                        try:
                            outStream = FileOutputStream(File(outputPath))
                            inStream = MD_REF.getCurrentAccount().getBook().getLocalStorage().openFileForReading(attachTag)
                            IOUtils.copyStream(inStream, outStream)
                            outStream.close()
                            inStream.close()
                            textRecords.append([txn.getAccount().getAccountType(), txn.getAccount().getAccountName(), txn.getDateInt(),
                                                "%s %s %s %s %s .%s\n"
                                                %(pad(str(txn.getAccount().getAccountType()),15),pad(txn.getAccount().getAccountName(),30),txn.getDateInt(),rpad(txn.getValue()/100.0,10),pad(txn.getDescription(),20),outputPath[len(exportFolder):])])
                        except:
                            myPrint("B","Error extracting file - will SKIP : %s" %(outputPath))
                            textLog+=("Error extracting file - will SKIP : %s\n" %(outputPath))
                            iSkip+=1

            textRecords=sorted(textRecords, key=lambda _sort: (_sort[0],_sort[1],_sort[2]))
            for r in textRecords:
                textLog+=r[3]

            if iSkip: textLog+="\nERRORS/SKIPPED: %s (review console log for details)\n" %(iSkip)

            textLog+="\n<END>"

            try:
                log = open(os.path.join(exportFolder,"Extract_Attachments_LOG.txt"), "w")
                log.write(textLog)
                log.close()
            except: pass

            pleaseWait.kill()

            txt = "%s: FINISHED: %s attachments extracted (%s skipped)..." %(_THIS_METHOD_NAME,iCountAttachments,iSkip)
            myPrint("B", txt); setDisplayStatus(txt, "B")
            play_the_money_sound()

            if iSkip < 1:
                myPopupInformationBox(toolbox_frame_,"%s attachments extracted.." %(iCountAttachments), theTitle=_THIS_METHOD_NAME)
            else:
                myPopupInformationBox(toolbox_frame_,"%s attachments extracted.. AND YOU HAD %s Missing/Errors?" %(iCountAttachments,iSkip),theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

            try:
                helper = MD_REF.getPlatformHelper()
                helper.openDirectory(File(exportFolder))
            except: pass

        else:
            txt = "%s: NO ATTACHMENTS EXTRACTED!" %(_THIS_METHOD_NAME)
            myPrint("B", txt); setDisplayStatus(txt, "R")

        return

    def diagnose_attachments(lFix=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if lFix:
            MyPopUpDialogBox(toolbox_frame_,
                             "NOTE: You already have Syncing disabled - Good!\n"
                             "There is a flaw in Moneydance Syncing as regards attachments when Syncing is ON\n"
                             "Deleted attachments will keep re-appearing as they Syncronise from Sync/Dropbox/Secondary machines\n"
                             "You have to disable Sync, manually delete your sync Folder/Data, then delete the Orphans (using this tool)\n"
                             "Then re-enable Sync, Wait for Sync to complete, then re-enable Sync on secondary devices...\n"
                             "<GOOD LUCK!>",
                             theTitle="ATTACHMENT ANALYSIS & DELETION OF ORPHANS",
                             theWidth=100, lModal=True,OKButtonText="ACKNOWLEDGE")

        scanningMsg = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching Database and filesystem for attachments..",
                                       theTitle="ATTACHMENT(S) SEARCH",
                                       theWidth=100, lModal=False,OKButtonText="WAIT")
        scanningMsg.go()

        myPrint("P", "Scanning database for attachment data..")
        book = MD_REF.getCurrentAccount().getBook()

        attachmentList={}
        attachmentLocations={}

        iObjectsScanned=0
        iTxnsScanned=0

        iTxnsWithAttachments = 0
        iAttachmentsFound = 0
        iAttachmentsNotInLS = 0
        iDuplicateKeys = 0
        attachmentsNotInLS=[]

        diagDisplay="ANALYSIS OF ATTACHMENTS\n\n"

        attachmentFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe", MD_REF.getCurrentAccountBook().getAttachmentsFolder())

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()

        txnSet = book.getTransactionSet()
        for _mdItem in txnSet.iterableTxns():

            iObjectsScanned+=1

            iTxnsScanned+=1

            if not (_mdItem.hasAttachments() or len(_mdItem.getAttachmentKeys())>0): continue

            iTxnsWithAttachments+=1
            x="Found Record with %s Attachment(s): %s" %(len(_mdItem.getAttachmentKeys()),_mdItem)
            myPrint("D",x)
            if debug: diagDisplay+=(x+"\n")

            if attachmentList.get(_mdItem.getUUID()):
                iDuplicateKeys += 1
                x="@@ Error %s already exists in my attachment list...!?" %_mdItem.getUUID()
                myPrint("DB", x)
                if debug: diagDisplay+=(x+"\n")

            attachmentList[_mdItem.getUUID()] = [
                _mdItem.getUUID(),
                _mdItem.getAccount().getAccountName(),
                _mdItem.getAccount().getAccountType(),
                _mdItem.getDateInt(),
                _mdItem.getValue(),
                _mdItem.getAttachmentKeys()
            ]
            x="Attachment keys: %s" %_mdItem.getAttachmentKeys()
            myPrint("D",x)
            if debug: diagDisplay+=(x+"\n")

            for _key in _mdItem.getAttachmentKeys():
                iAttachmentsFound+=1
                if attachmentLocations.get(_mdItem.getAttachmentTag(_key)):
                    iDuplicateKeys += 1
                    x="@@ Error %s already exists in my attachment location list...!?" %_mdItem.getUUID()
                    myPrint("B", )
                    if debug: diagDisplay+=(x+"\n")

                attachmentLocations[_mdItem.getAttachmentTag(_key)] = [
                    _mdItem.getAttachmentTag(_key),
                    _key,
                    _mdItem.getUUID(),
                    LS.exists(_mdItem.getAttachmentTag(_key))
                ]
                if not LS.exists(_mdItem.getAttachmentTag(_key)):
                    iAttachmentsNotInLS+=1
                    attachmentsNotInLS.append([
                        _mdItem.getUUID(),
                        _mdItem.getAccount().getAccountName(),
                        _mdItem.getAccount().getAccountType(),
                        _mdItem.getDateInt(),
                        _mdItem.getValue(),
                        _mdItem.getAttachmentKeys()
                    ])

                    x="@@ Error - Attachment for Txn DOES NOT EXIST! - Attachment tag: %s" %_mdItem.getAttachmentTag(_key)
                    myPrint("B",x)
                    diagDisplay+=(x+"\n")
                else:
                    x="Attachment tag: %s" %_mdItem.getAttachmentTag(_key)
                    myPrint("D", x)
                    if debug: diagDisplay+=(x+"\n")


        # Now scan the file system for attachments
        myPrint("P", "Now scanning attachment directory(s) and files...:")

        attachmentsRawListFound = []

        typesFound={}

        for root, dirs, files in os.walk(attachmentFullPath):

            for name in files:
                theFile = os.path.join(root,name)[len(attachmentFullPath)-len(MD_REF.getCurrentAccountBook().getAttachmentsFolder()):]
                byteSize = os.path.getsize(os.path.join(root,name))
                modified = datetime.datetime.fromtimestamp(os.path.getmtime(os.path.join(root,name))).strftime('%Y-%m-%d %H:%M:%S')
                attachmentsRawListFound.append([theFile, byteSize, modified, os.path.join(root,name)])
                theExtension = os.path.splitext(theFile)[1].lower()

                iCountExtensions = 0
                iBytes = 0
                if typesFound.get(theExtension):
                    iCountExtensions = typesFound.get(theExtension)[1]
                    iBytes = typesFound.get(theExtension)[2]
                typesFound[theExtension] = [theExtension, iCountExtensions+1, iBytes+byteSize ]

                x="Found Attachment File: %s" %theFile
                myPrint("D", x)
                if debug: diagDisplay+=(x+"\n")

        # Now match file system to the list from the database
        iOrphans=0
        iOrphanBytes=0

        orphanList=[]

        for fileDetails in attachmentsRawListFound:
            deriveTheKey = fileDetails[0]
            deriveTheBytes = fileDetails[1]
            deriveTheModified = fileDetails[2]
            deriveRawPath = fileDetails[3]
            if attachmentLocations.get(deriveTheKey.replace(os.path.sep,"/")):
                x="Attachment file system link found in Moneydance database"
                myPrint("D", x)
                if debug: diagDisplay+=(x+"\n")
            else:
                x="Error: Attachment filesystem link missing in Moneydance database: %s" %deriveTheKey
                myPrint("DB", x)
                if debug: diagDisplay+=(x+"\n")
                iOrphans+=1
                iOrphanBytes+=deriveTheBytes
                if lFix:
                    orphanList.append([deriveTheKey, deriveTheBytes, deriveTheModified, deriveRawPath])
                else:
                    orphanList.append([deriveTheKey, deriveTheBytes, deriveTheModified])

        msgStr=""

        myPrint("P","\n"*5)

        x="----------------------------------"
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")

        x = "Objects scanned: %s" %iObjectsScanned
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")

        x="Transactions scanned: %s" %iTxnsScanned
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Transactions with attachments: %s" %iTxnsWithAttachments
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Total Attachments referenced in Moneydance database (a txn may have multi-attachments): %s" %iAttachmentsFound
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Attachments missing from Local Storage: %s" %iAttachmentsNotInLS
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Total Attachments found in file system: %s (difference %s)" %(len(attachmentsRawListFound),len(attachmentsRawListFound)-iAttachmentsFound)
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")

        myPrint("P","\n"*1)

        x="Attachment extensions found: %s" %len(typesFound)
        myPrint("B", x)
        diagDisplay+=("\n"+x+"\n")

        iTotalBytes = 0
        sortedExtensions = sorted(typesFound.values(), key=lambda _x: (_x[2]), reverse=True)

        for x in sortedExtensions:
            iTotalBytes+=x[2]

            x="Extension: %s Number: %s Size: %sMB" %(pad(x[0],6),rpad(x[1],12),rpad(round(x[2]/(1000.0 * 1000.0),2),12))
            myPrint("B", x)
            diagDisplay+=(x+"\n")

        x="Attachments on disk are taking: %sMB" %(round(iTotalBytes/(1000.0 * 1000.0),2))
        myPrint("B", x)
        diagDisplay+=(x+"\n")
        msgStr+=(x+"\n")
        x="----------------------------------"
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n\n")

        lErrors=False
        if iAttachmentsNotInLS:
            x = "@@ ERROR: You have %s missing attachment(s) referenced on Moneydance Txns!" %(iAttachmentsNotInLS)
            msgStr+=x+"\n"
            diagDisplay+=(x+"\n\n")
            myPrint("P","")
            myPrint("B",x)
            setDisplayStatus(x.upper(),"R")
            lErrors=True
            attachmentsNotInLS=sorted(attachmentsNotInLS, key=lambda _x: (_x[3]), reverse=False)
            for theOrphanRecord in attachmentsNotInLS:
                x="Attachment is missing from this Txn: AcctType: %s Account: %s Date: %s Value: %s AttachKey: %s" %(theOrphanRecord[1],
                                                                                                                     theOrphanRecord[2],
                                                                                                                     theOrphanRecord[3],
                                                                                                                     theOrphanRecord[4],
                                                                                                                     theOrphanRecord[5])
                myPrint("B", x)
                diagDisplay+=(x+"\n")
            diagDisplay+="\n"

        if iOrphans:
            x = "@@ ERROR: %s Orphan attachment(s) found, taking up %sMBs" %(iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2))
            msgStr+=x+"\n"
            diagDisplay+=(x+"\n\n")
            myPrint("P","")
            setDisplayStatus(x.upper(),"R")

            myPrint("B",x)
            x="Base Attachment Directory is: %s" %os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe","")
            myPrint("B",x)
            diagDisplay+=(x+"\n")
            lErrors=True
            orphanList=sorted(orphanList, key=lambda _x: (_x[2]), reverse=False)

            for theOrphanRecord in orphanList:

                try:
                    x="Orphaned Attachment >> Txn Size: %sKB Modified %s for file: %s" %(rpad(round(theOrphanRecord[1]/(1000.0),1),6),
                                                                                         pad(theOrphanRecord[2],19),
                                                                                         theOrphanRecord[0])
                    diagDisplay+=(x+"\n")
                    myPrint("B", x)

                except:
                    diagDisplay += dump_sys_error_to_md_console_and_errorlog(True)
                    diagDisplay += "REVIEW MD MENU>HELP>CONSOLE WINDOW FOR DETAILS\n\n"
                    myPrint("B", "@@ record causing issue was.....:")
                    myPrint("B", theOrphanRecord)
                    myPrint("B", "... will continue.....")

        if not lErrors:
            x = "Congratulations! - No orphan attachments detected!".upper()
            myPrint("B",x)
            diagDisplay+=(x+"\n")
            setDisplayStatus(x.upper(),"B")

        if iAttachmentsFound:
            diagDisplay+="\n\nLISTING VALID ATTACHMENTS FOR REFERENCE\n"
            diagDisplay+=" ======================================\n"
            x="\nBase Attachment Directory is: %s" %os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe","")
            diagDisplay+=(x+"\n-----------\n")

            for validLocation in attachmentLocations:
                locationRecord = attachmentLocations[validLocation]
                record = attachmentList[locationRecord[2]]
                try:
                    diagDisplay+="AT: %s ACT: %s DT: %s Val: %s FILE: %s\n" \
                                 %(pad(repr(record[2]),12),
                                   pad(safeStr(record[1]),20),       # Avoid utf-8 issue!
                                   record[3],
                                   rpad(record[4]/100.0,10),
                                   validLocation)

                except:
                    diagDisplay += dump_sys_error_to_md_console_and_errorlog(True)
                    diagDisplay += "REVIEW MD MENU>HELP>CONSOLE WINDOW FOR DETAILS\n\n"
                    myPrint("B", "@@ record causing issue was.....:")
                    myPrint("B", locationRecord)
                    myPrint("B", record)
                    myPrint("B", "... will continue.....")

        if not lFix or not iOrphans: diagDisplay+='\n<END>'

        scanningMsg.kill()

        jif = QuickJFrame("ATTACHMENT ANALYSIS",diagDisplay,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        if iOrphans:
            if lFix:
                theMsg = MyPopUpDialogBox(jif,
                                       "You have %s Orphan attachment(s) found, taking up %sMBs" % (iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2)),
                                          msgStr,
                                          200,"ORPHANED ATTACHMENTS",
                                          lCancelButton=False,
                                          OKButtonText="OK",
                                          lAlertLevel=1)
            else:
                theMsg = MyPopUpDialogBox(jif,
                                       "You have %s Orphan attachment(s) found, taking up %sMBs" % (iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2)),
                                          msgStr +"CLICK TO VIEW ORPHANS, or CANCEL TO EXIT",
                                          200,"ORPHANED ATTACHMENTS",
                                          lCancelButton=True,
                                          OKButtonText="CLICK TO VIEW",
                                          lAlertLevel=1)
        elif iAttachmentsNotInLS:
            theMsg = MyPopUpDialogBox(jif,
                                   "You have %s missing attachment(s) referenced on Moneydance Txns!" % (iAttachmentsNotInLS),
                                      msgStr,
                                      200,"MISSING ATTACHMENTS",
                                      lCancelButton=False,
                                      OKButtonText="OK",
                                      lAlertLevel=1)

        if lErrors:
            pass
        else:
            theMsg = MyPopUpDialogBox(jif,
                                      x,
                                      msgStr,
                                      200,"ATTACHMENTS STATUS",
                                      lCancelButton=False,
                                      OKButtonText="OK",
                                      lAlertLevel=0)

        myPrint("P","\n"*2)

        if iOrphans and not lFix:
            if theMsg.go():                                                                                             # noqa
                while True:
                    selectedOrphan = JOptionPane.showInputDialog(jif,
                                                                 "Select an Orphan to View",
                                                                 "VIEW ORPHAN (Escape or Cancel to exit)",
                                                                 JOptionPane.WARNING_MESSAGE,
                                                                 None,
                                                                 orphanList,
                                                                 None)
                    if not selectedOrphan:
                        break

                    try:
                        tmpDir = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), "tmp")
                        tmpDir.mkdirs()
                        attachFileName = (File(tmpDir, selectedOrphan[0])).getName()                                    # noqa
                        tmpFile = File.createTempFile(str(System.currentTimeMillis() % 10000L), attachFileName, tmpDir)
                        tmpFile.deleteOnExit()
                        fout = FileOutputStream(tmpFile)
                        LS.readFile(selectedOrphan[0], fout)                                                            # noqa
                        fout.close()
                        Desktop.getDesktop().open(tmpFile)

                    except:
                        myPrint("B","Sorry, could not open attachment file....: %s" %selectedOrphan[0])                 # noqa

        else:
            theMsg.go()                                                                                                 # noqa

        if lFix and not iOrphans:

            myPopupInformationBox(jif, "YOU HAVE NO ORPHANS TO DELETE - NO ACTION TAKEN!")

        elif lFix:

            if confirm_backup_confirm_disclaimer(jif, "ATTACHMENTS - DELETE ORPHANS",
                                                     "Delete %s Orphan attachments from Disk?" %(iOrphans)):

                myPrint("B", "USER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH DELETION OF %s Orphan attachments from disk." %(iOrphans))

                jif.dispose()

                diagDisplay += ("\n\n"
                                "DELETING ORPHANS FROM DISK\n"
                                " =========================\n")

                for theOrphanRecord in orphanList:

                    try:
                        os.remove(theOrphanRecord[3])
                        x="DELETED ORPHAN: %s" %(theOrphanRecord[3])
                        myPrint("B",x)
                        diagDisplay+=(x+"\n")
                    except:
                        x="@@ FAILED TO DELETE ORPHAN: %s" %(theOrphanRecord[3])
                        myPrint("B",x)
                        diagDisplay+=(x+"\n")

                diagDisplay += ("Now removing empty attachment folder structures from disk......")
                if removeEmptyDirs(attachmentFullPath):
                    diagDisplay += ("Success")
                else:
                    diagDisplay += ("Hit an error (review console log)")

                diagDisplay+=("\n\n<END>\n")
                jif = QuickJFrame("ATTACHMENT ANALYSIS & ORPHAN DELETION",diagDisplay,lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False,lJumpToEnd=True).show_the_frame()
                txt = "%s Orphan Attachments deleted from disk" %(iOrphans)
                myPrint("B", txt)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(jif, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            else:
                jif.dispose()
                txt = "User declined disclaimer - no orphans deleted!"
                myPrint("B",txt)
                diagDisplay+=("\n"+txt+"\n"+"<END>\n")
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("ATTACHMENT ANALYSIS & ORPHAN DELETION",diagDisplay,lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False,lJumpToEnd=True).show_the_frame()
                myPopupInformationBox(jif, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)

        del orphanList
        del attachmentList
        del attachmentLocations
        del typesFound
        del attachmentsRawListFound
        del attachmentsNotInLS

        toolbox_frame_.toFront()
        jif.toFront()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def isQuoteLoader_or_QER_Running():

        QLID = "securityquoteload"
        QERID = "yahooqt"

        foundBuild = 0
        foundExtn = False

        try:
            fms = MD_REF.getLoadedModules()
            for fm in fms:
                if fm.getIDStr().lower() == QLID.lower() or fm.getIDStr().lower() == QERID.lower():
                    foundExtn = True
                    foundBuild = fm.getBuild()
                    break
            if foundExtn:
                myPrint("DB","QuoteLoader or Q&ER extension (build %s) is loaded..." %(foundBuild))
            else:
                myPrint("DB","Did not find QuoteLoader or Q&ER extension running...")
        except:
            myPrint("B","ERROR, crashed whilst detecting QuoteLoader / Q&ER extension?")

        return foundExtn


    def perform_quote_loader_check(_frame, _txt):

        if isQuoteLoader_or_QER_Running():

            saveYES = UIManager.get("OptionPane.yesButtonText"); saveNO = UIManager.get("OptionPane.noButtonText")
            UIManager.put("OptionPane.yesButtonText", "OK - CONTINUE"); UIManager.put("OptionPane.noButtonText", "STOP - I NEED TO CHECK")
            ask = myPopupAskQuestion(_frame,"QUOTELOADER / Q&ER IS RUNNING","QuoteLoader / Q&ER is loaded. Confirm that it's not updating before running '%s'?" %(_txt))
            UIManager.put("OptionPane.yesButtonText", saveYES); UIManager.put("OptionPane.noButtonText", saveNO)

            if not ask:
                txt = "QuoteLoader / Q&ER running. Please verify it's not updating before running '%s' - no changes made" %(_txt)
                setDisplayStatus(txt, "R")
                return False

        return True

    # noinspection PyUnresolvedReferences
    def detect_fix_nonlinked_investment_security_records():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        nonLinkedSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(24))

        if len(nonLinkedSecurityAccounts) < 1:
            txt = "Congratulations - No Investment Security Accounts not properly linked to a Security Master were detected - No changes made!"
            setDisplayStatus(txt, "B")
            myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        for badLink in nonLinkedSecurityAccounts:
            myPrint("B","Improperly linked Security (Sub Account): %s" %(badLink))

        selectedSecSubAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Security that's not properly linked to it's master'",
                                                      "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      None,
                                                      nonLinkedSecurityAccounts,
                                                      None)

        if not selectedSecSubAcct:
            txt = "User did not select any of the %s improperly linked Security(s) to fix - no changes made" %(len(nonLinkedSecurityAccounts))
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        securities = []
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for currSec in currencies:
            if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                        # noqa
            securities.append(currSec)
        securities = sorted(securities, key=lambda sort_x: (sort_x.getName().upper()))

        if len(securities) < 1:
            txt = "ERROR - You seem to have no Security Master records to link to - Create one first (Tools>Securities) - No changes made!"
            setDisplayStatus(txt, "B")
            myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        targetSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                    "Select the target Security to link to this record",
                                                    "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                    JOptionPane.INFORMATION_MESSAGE,
                                                    None,
                                                    securities,
                                                    None)

        if not targetSecurity:
            txt = "User did not select a target Security - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                 "Reassign Security '%s' to Security Master: '%s'?" %(selectedSecSubAcct, targetSecurity)):
            return

        myPrint("B", "USER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH Reassign Security '%s' to Security Master '%s'?" %(selectedSecSubAcct, targetSecurity))

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        selectedSecSubAcct.setEditingMode()
        selectedSecSubAcct.setCurrencyType(targetSecurity)
        selectedSecSubAcct.syncItem()

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "Fix/reassign Security (Sub Account) completed. Now reports '%s'. Please Check results" %(selectedSecSubAcct)
        myPrint("B", txt)
        setDisplayStatus(txt, "DG")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def edit_security_decimal_places():

        _THIS_METHOD_NAME = "Edit a Security's Decimal Places setting"

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_security_dpc"
        PARAMETER_KEY_DATA = ".old_data"
        PARAMETER_KEY_COST_BASIS = ".old_cost_basis"

        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX - Non Hierarchical Security Account Txns (cross-linked securities)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output = "%s:\n" \
                 " ========================================\n\n" \
                 "The Decimal Places setting on a security relates only to the qty of shares on transactions, the stock holding qty balance, and related LOT Control records.\n" \
                 "...the (max) decimal precision is set by the user when a Security is first created. It is subsequently hidden and not editable in standard MD.\n" \
                 "...This function allows you to change it. Related records will be properly updated.\n\n" \
                 "NOTE: The decimal places setting was used to store the price/rate prior to MD2019 (as a factor compared to the base currency dpc)\n" \
                 "      So, if you are using MD2019 or later, then this is not issue for you\n" \
                 "      If you want to revert back to MD2017 or earlier, then please do not use this utility to change a security dpc setting.\n" \
                 "      (Also note, that if you revert to MD2017 you will probably have to check the rates/prices anyway, due to an unrelated MD bug.....)\n\n" \
                 "" %(_THIS_METHOD_NAME)

        myPrint("B", "%s: Analysing..." %(_THIS_METHOD_NAME))

        try:

            if not perform_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

            class StoreSecurity:
                def __init__(self, _obj):
                    self.obj = _obj

                def getSecurity(self):  return self.obj

                def __str__(self):  return "Decimal Places: %s >> %s" %(rpad(self.obj.getDecimalPlaces(),2),self.obj)

                def __repr__(self): return self.__str__()


            # Sweep One - gather the potential targets by duplicate Ticker Symbol....
            allSecurities = []
            currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            for currSec in currencies:
                if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue
                allSecurities.append(StoreSecurity(currSec))
            del currencies
            allSecurities = sorted(allSecurities, key=lambda x: (x.getSecurity().getName().upper()))

            securityToEdit = JOptionPane.showInputDialog(toolbox_frame_,
                                                        "Select Security to edit Decimal Places",
                                                        _THIS_METHOD_NAME.upper(),
                                                        JOptionPane.WARNING_MESSAGE,
                                                        None,
                                                         allSecurities,
                                                        None)                                                           # type: StoreSecurity

            if not securityToEdit:
                txt = "%s: No Security selected.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            securityToEdit = securityToEdit.getSecurity()
            output += "\n" \
                      "Security: %s was selected to edit.\n" \
                      "Current Decimal Places set to: %s\n" %(securityToEdit, securityToEdit.getDecimalPlaces())

            while True:

                newDecimal = myPopupAskForInput(toolbox_frame_,
                                                _THIS_METHOD_NAME,
                                                "New Decimal Places:",
                                                "Enter the new Decimal Places setting (currently %s)" %(securityToEdit.getDecimalPlaces()),
                                                defaultValue=securityToEdit.getDecimalPlaces())

                if newDecimal is not None and not StringUtils.isInteger(newDecimal):
                    continue

                if newDecimal is None or int(newDecimal) == securityToEdit.getDecimalPlaces():
                    txt = "%s: No new decimal places selected.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if int(newDecimal) >= 0 and int(newDecimal) <= 8:
                    newDecimal = int(newDecimal)
                    break

                continue

            # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
            allInvestmentSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(22))


            iTotalTxns = 0
            iTotalBalance = 0
            lUsingLotControl = False
            securitySubAccountsNeedChanging = []
            output += "\nSearching for related Investment Account Security holdings, transactions, balances etc...:\n"

            lAnyCostBasisErrorsFound = [False]

            for secAcct in allInvestmentSecurityAccounts:
                if secAcct.getCurrencyType() == securityToEdit:
                    securitySubAccountsNeedChanging.append(secAcct)

                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

                    lFoundCostBasisTags = False
                    for txn in txns:
                        if txn.getParameter("cost_basis", None) is not None:
                            lFoundCostBasisTags = lUsingLotControl = True
                            break

                    if lFoundCostBasisTags:
                        output += "... WARNING: LOT CONTROLLED RECORDS using Cost Basis Tags found ***\n"

                    if not InvestUtil.isCostBasisValid(secAcct):
                        lAnyCostBasisErrorsFound[0] = True
                        output += "... WARNING: INVALID COST BASIS / LOT CONTROL DETECTED! ***\n"

                    iTotalTxns += txns.getSize()
                    bal = securityToEdit.getDoubleValue(secAcct.getBalance())
                    iTotalBalance += bal
                    output += "... %s Txns: %s Balance: %s\n" %(pad(secAcct.getFullAccountName(),50),rpad(txns.getSize(),12),rpad(bal,12))
                    if secAcct.getStartBalance() != 0:
                        txt = "*** ERROR: %s has a starting balance of %s - SHOULD BE ZERO - Will abort! ***" %(secAcct, secAcct.getStartBalance())
                        myPrint("B", txt); output += "\n%s\n\n" %(txt)
                        raise Exception(txt)
                    del txns

            del allInvestmentSecurityAccounts

            output += "\n" \
                      "Investment Account Security records found: %s\n" \
                      "Related Transactions found: %s\n" \
                      "Total security balance: %s\n\n" \
                      %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance)

            if lUsingLotControl:
                output += "\n*** WARNING: LOT CONTROLLED RECORDS using Cost Basis Tags found ***\n\n"

            if lAnyCostBasisErrorsFound[0]:
                output += "\n*** WARNING: INVALID LOT CONTROL / COST BASIS RECORDS BEFORE ANY CHANGES WERE DETECTED ***\n\n"
            else:
                output += "\nNOTE: No Invalid Lot Control/Cost Basis records were detected before any changes made....\n\n"

            jif = QuickJFrame(("%s: Accounts, Txns, Balance Analysis" %(_THIS_METHOD_NAME)).upper(),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if (iTotalBalance + iTotalTxns + len(securitySubAccountsNeedChanging)) == 0:
                txt = "NOTE - No related accounts, txns, balances were found for this security!"
                output += "\n*** %s ***\n" %(txt)
                myPopupInformationBox(jif, txt, _THIS_METHOD_NAME)

            elif lAnyCostBasisErrorsFound[0]:
                myPopupInformationBox(jif,
                                      "%s Accounts, %s Txns, Balance %s found ** NOTE: INVALID LOT CONTROL / COST BASIS RECORDS DETECTED! **"
                                      %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance),
                                      _THIS_METHOD_NAME)
            else:
                myPopupInformationBox(jif,
                                      "NOTE: %s Accounts, %s Txns, Balance %s found" %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance),
                                      _THIS_METHOD_NAME)


            if not myPopupAskQuestion(jif,
                                  _THIS_METHOD_NAME.upper(),
                                  "CONFIRM you want to change Decimals from %s to %s?" %(securityToEdit.getDecimalPlaces(),newDecimal)):
                txt = "%s: User aborted.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            jif.dispose()

            txt = "New Decimal Places %s for %s selected (currently: %s) " %(newDecimal, securityToEdit, securityToEdit.getDecimalPlaces())
            myPrint("B", txt); output += "\n%s\n" %(txt)

            decimalAdjustmentMethod = "expand"
            jif = QuickJFrame(("%s: Decimal Strategy" %(_THIS_METHOD_NAME)).upper(),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if newDecimal < securityToEdit.getDecimalPlaces():

                options = ["Round lost fractional balances up/down (round)",
                           "Truncate / lose / chop lost fractional balances (floor)",
                           "Always round up lost fractional balances (ceiling)"]


                selectedDecimalStrategy = JOptionPane.showInputDialog(jif,
                                                                   "Select the Decimal REDUCTION Strategy?",
                                                                   _THIS_METHOD_NAME.upper(),
                                                                   JOptionPane.WARNING_MESSAGE,
                                                                   None,
                                                                   options,
                                                                   None)

                if not selectedDecimalStrategy:
                    txt = "%s: User did not select a Decimal Reduction Strategy for the edit - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return


                if options.index(selectedDecimalStrategy) == 0:    decimalAdjustmentMethod = "round"
                elif options.index(selectedDecimalStrategy) == 1:  decimalAdjustmentMethod = "floor"
                else:                                              decimalAdjustmentMethod = "ceiling"
                del options

                output += "\n** Decimal Reduction Strategy selected: '%s' (Fractional balances might be affected) **\n\n" %(decimalAdjustmentMethod)

                if lUsingLotControl:

                    ask = MyPopUpDialogBox(jif,
                                           "%s: WARNING. Lot Controlled Records in use, and reduction of dpc requested!" %(_THIS_METHOD_NAME),
                                           "You are using LOT Controlled Records (with cost basis tags) that link sells to buys\n"
                                           "You have also requested to reduce decimal precision\n"
                                           "This will probably lose fractional share balances\n"
                                           "This utility can apply the same maths to the Lot Controlled allocations, but it may be fractionally wrong\n"
                                           "You can/may review and fix these later.... Your choice....",
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           lCancelButton=True,
                                           OKButtonText="PROCEED")
                    if not ask.go():
                        txt = "%s: User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                        myPrint("B",txt)
                        setDisplayStatus(txt, "R")
                        jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                        return

                    txt = "** User agreed to reduce decimal precision and accept that LOT Controlled records might be fractionally wrong.... **"
                    myPrint("B",txt); output += "\n\n%s\n\n" %(txt)

            else:
                output += "\nDecimal Strategy selected: %s (Increased so no loss of values)\n\n" %(decimalAdjustmentMethod)
                txt = "DECIMAL INCREASE STRATEGY: You are increasing the number of decimal places; so no values will be lost.."
                output += "\n%s\n" %(txt)
                myPopupInformationBox(jif, txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

                if lUsingLotControl:
                    output += "\n\n *** NOTE: LOT CONTROLLED RECORDS using Cost Basis Tags found - As you are increasing the decimal precision, no fractional losses should occur ***\n\n"

            jif.dispose()


            ask = MyPopUpDialogBox(toolbox_frame_,
                                   "%s: REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE DECIMAL EDIT" %(_THIS_METHOD_NAME),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s... User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                myPrint("B",txt)
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE %s DECIMAL PLACE EDIT FROM %s to %s?" %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)):
                return

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH DECIMAL PLACE EDIT of %s FROM %s to %s.....\n\n" %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)

            output += "\n"

        except:
            txt = ("MINOR ERROR - %s: crashed before any merge actions. Please review output and console" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing %s right now.." %(_THIS_METHOD_NAME),
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          theWidth=100,
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the merge..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            # Do this first, so that the 'internal' MD maths on the txn edits work with the new dpc settings.....
            txt = "** Updating %s Security Master to new Decimal Places (was %s >> to %s) setting..." %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)
            myPrint("B", txt); output += "\n%s\n\n" %(txt)

            oldDecimal = securityToEdit.getDecimalPlaces()

            def calculateNewShares(oldValue):

                if newDecimal > oldDecimal:
                    _newShares = oldValue * Math.pow(10.0, (newDecimal - oldDecimal))
                else:

                    if oldValue < 0.0:
                        neg = True
                    else:
                        neg = False

                    if decimalAdjustmentMethod == "round":
                        _newShares = Math.round(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    elif decimalAdjustmentMethod == "floor":
                        _newShares = Math.floor(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    elif decimalAdjustmentMethod == "ceiling":
                        _newShares = Math.ceil(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    else:
                        raise Exception("ERROR: Bad Decimal Strategy detected '%s'?!" %(decimalAdjustmentMethod))

                    if neg: _newShares *= -1.0

                _newShares = int(_newShares)
                return _newShares


            securityToEdit.setEditingMode()
            securityToEdit.setDecimalPlaces(newDecimal)
            securityToEdit.setParameter(PARAMETER_KEY,True)
            securityToEdit.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_decimal_places:%s}" %(oldDecimal))
            securityToEdit.syncItem()

            # Now for Txns..    .
            if len(securitySubAccountsNeedChanging) > 0:
                txt = "Now editing all relevant txns change decimal precision ....:"
                myPrint("B", txt); output += "\n\n%s\n\n" %(txt)

                for secAcct in securitySubAccountsNeedChanging:
                    txt = "Updating %s..." %(secAcct)
                    myPrint("B",txt); output += "%s\n" %(txt)

                    parentAccount = secAcct.getParentAccount()

                    secAcct.setParameter(PARAMETER_KEY,True)
                    secAcct.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_decimal_places:%s}" %(oldDecimal))

                    secAcct.syncItem()

                    txnsToEdit = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

                    if txnsToEdit.getSize() < 1:
                        txt = ".... has no transactions to update..."
                        output += "%s\n" %(txt)
                    else:
                        txt = ".... Updating %s transactions: %s" %(secAcct, txnsToEdit.getSize())
                        myPrint("B",txt); output += "%s\n" %(txt)

                        txnsToEdit = sorted(txnsToEdit, key=lambda _x: (_x.getDateInt()))

                        for txn in txnsToEdit:

                            if not isinstance(txn, SplitTxn):       # Should never happen..... ;->
                                raise Exception("Error: found a non-split: %s" %(txn))

                            pTxn = txn.getParentTxn()

                            lEditingMode = False

                            # Look for and fix any Lot Control records at the same time.... Risky business!
                            if txn.getParameter("cost_basis", None) is not None:
                                cbTags = TxnUtil.parseCostBasisTag(txn)
                                if cbTags is not None:
                                    lAnyTagChanges = False
                                    totalOldSharesBUYS = totalNewSharesBUYS =0
                                    for txnID in cbTags:
                                        oldShareValue = cbTags[txnID]
                                        if oldShareValue == 0: continue
                                        totalOldSharesBUYS += oldShareValue
                                        newShares = calculateNewShares(oldShareValue)
                                        totalNewSharesBUYS += newShares
                                        cbTags[txnID] = newShares
                                        lAnyTagChanges = True

                                    if lAnyTagChanges:
                                        newTag = ""
                                        for txnID in cbTags:
                                            newTag += "{}:{};".format(txnID,cbTags[txnID])
                                        pTxn.setEditingMode()
                                        lEditingMode = True

                                        if debug:
                                            txn.setParameter(PARAMETER_KEY+PARAMETER_KEY_COST_BASIS,txn.getParameter("cost_basis", None))

                                        txn.setParameter("cost_basis", newTag)
                                        output += ".. %s %s ** Updated Lot Control: (Old BUYS: %s New BUYS: %s)**\n" %(
                                                                                                    convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                                                                    pad(pTxn.getInvestTxnType().getIDString(),12),
                                                                                                    totalOldSharesBUYS,
                                                                                                    totalNewSharesBUYS)

                            # get the current raw data
                            splitShares = txn.getValue()
                            splitParentShareValue = txn.getAmount() * -1
                            old_samt = txn.getParameter("samt", None)
                            old_pamt = txn.getParameter("pamt", None)

                            if splitShares == 0:
                                output += ".. %s %s %s Val: %s - Skipping as ZERO shares...\n" %(
                                                               convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                               pad(pTxn.getInvestTxnType().getIDString(),12),
                                                               pad(pTxn.getDescription()+pTxn.getMemo(),40),
                                                               rpad(parentAccount.getCurrencyType().formatFancy(-splitParentShareValue,MD_decimal),12))

                                if lEditingMode:
                                    pTxn.syncItem()  # Left over from the cost basis change above....

                                continue

                            newShares = calculateNewShares(splitShares)

                            if splitParentShareValue == 0:
                                price = 0.0
                            else:
                                price = (1.0 * splitParentShareValue) / (1.0 * splitShares)     # force floating point conversion

                                # Taken from MD code.....
                                price = CurrencyTable.getRawRate(secAcct.getCurrencyType(), parentAccount.getCurrencyType(), 1.0 / price)

                            pTxn.setEditingMode()
                            txn.setParameter(PARAMETER_KEY,True)

                            if debug:
                                txn.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_samt:%s,old_pamt:%s}" %(old_samt, old_pamt))

                            # newShares = adjusted, long. Price = recalculated, double, splitParentShareValue = unchanged, long
                            txn.setAmount(newShares, price, splitParentShareValue)
                            # txn.setParameter("samt", newShares)
                            pTxn.syncItem()

                            output += ".. %s %s %s Val: %s Old Raw Shrs: %s New Raw Shrs: %s New Shrs: %s\n" %(
                                                           convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                           pad(pTxn.getInvestTxnType().getIDString(),12),
                                                           pad(pTxn.getDescription()+pTxn.getMemo(),40),
                                                           rpad(parentAccount.getCurrencyType().formatFancy(-splitParentShareValue,MD_decimal),12),
                                                           rpad(splitShares,12),
                                                           rpad(newShares,12),
                                                           rpad(secAcct.getCurrencyType().formatFancy(txn.getValue(),MD_decimal),25))

                            # Fail safe...!
                            if txn.getParameter("pamt", "ERROR") != old_pamt:
                                raise Exception("ERROR: Txn's new pamt(%s) != old pamt(%s) - review console..." %(txn.getParameter("pamt", "ERROR"),old_pamt))

                            continue

                    output += "----\n"
                    del txnsToEdit

                output += "\n>> Txn decimal places update completed.....\n\n"

            output += "\n>> Update of decimal places completed..\n\n"

        except:

            txt = ("MAJOR ERROR - %s crashed. Please review output, console, and RESTORE YOUR DATASET!"%(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset after %s changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es).." %(_THIS_METHOD_NAME))
            MD_REF.getUI().getMain().saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # OK - Main update is done....

            lAnyCostBasisErrorsFound = [False]

            if len(securitySubAccountsNeedChanging) > 0:
                output += "\n\nSTATISTICS AFTER EDIT DECIMAL ACTIONS COMPLETED...\n\n"

                for secAcct in securitySubAccountsNeedChanging:
                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct).getSize()
                    bal = securityToEdit.getDoubleValue(secAcct.getBalance())
                    output += "... %s Txns: %s Balance: %s\n" %(pad(secAcct.getFullAccountName(),50),rpad(txns,12),rpad(bal,12))

                    if not InvestUtil.isCostBasisValid(secAcct):
                        lAnyCostBasisErrorsFound[0] = True
                        output += "   ... WARNING: INVALID COST BASIS / LOT CONTROL DETECTED AFTER UPDATE ***\n"

            if lAnyCostBasisErrorsFound[0]:
                output += "\n\n*** WARNING: INVALID COST BASIS / LOT CONTROL RECORDS WERE DETECTED AFTER UPDATE ***\n"
            else:
                output += "\nNOTE: No Invalid Lot Control/Cost Basis records were detected after the changes were made....\n\n"

            del securitySubAccountsNeedChanging

            output += "\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and %s) back to disk....." %(_THIS_METHOD_NAME),
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              theWidth=100,
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                pleaseWait.kill()

            if newDecimal < oldDecimal and lUsingLotControl:
                output += "\n\n *** WARNING - PLEASE REVIEW YOUR LOT CONTROL ALLOCATIONS BUYS to SELLS as fractional losses / mismatches may have occurred! ***\n\n"
                txt = "%s Completed with WARNINGS - review log, check the results & LOT Controlled BUY/SELL Allocations, then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.WARNING_MESSAGE; optionColor = "R"
            elif lAnyCostBasisErrorsFound[0]:
                output += "\n\n *** WARNING - PLEASE REVIEW YOUR LOT CONTROL ALLOCATIONS BUYS to SELLS as LOT CONTROL/COST BASIS ERRORS WERE DETECTED! ***\n\n"
                txt = "%s Completed with WARNINGS - review log, check the results & LOT Controlled BUY/SELL Allocations (Errors Detected), then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.WARNING_MESSAGE; optionColor = "R"
            else:
                txt = "%s successfully completed - please review log, check the results, then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.INFORMATION_MESSAGE; optionColor = "DG"

            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES & THEN RESTART MONEYDANCE ***\n\n"
            output += "\n<END>"

        except:
            txt = ("ERROR - %s crashed after the edit actions. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
        setDisplayStatus(txt, optionColor)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionMessage)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def merge_duplicate_securities():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "Merge 'Duplicate' Securities (by 'ticker')"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_security_merge"
        PARAM_CURRID = "curr_id."

        today = Calendar.getInstance()                                                                                  # noqa
        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX - Non Hierarchical Security Account Txns (cross-linked securities)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output = "%s:\n" \
                 " ============================================================\n\n" %(_THIS_METHOD_NAME)

        myPrint("B", "%s: Analysing..." %(_THIS_METHOD_NAME))

        try:

            base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

            # Sweep One - gather the potential targets by duplicate Ticker Symbol....
            dup_securities = OrderedDict()
            securities = []
            currencies = sorted(MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies(),
                                key=lambda x: (x.getCurrencyType(), x.getName().upper(), x.getTickerSymbol(), x.getIDString()))

            for currSec in currencies:
                if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                    # noqa
                securities.append(currSec)
                theTicker = currSec.getTickerSymbol().strip().upper()
                if theTicker is None or theTicker == "" or len(theTicker) < 1: continue
                getDup = dup_securities.get(theTicker)
                if getDup is not None:
                    getDup[0] += 1
                    getDup[1].append(currSec)
                else:
                    getDup = [1, [currSec]]
                dup_securities[theTicker] = getDup
            del currencies

            def compareSplits(splitsOne, splitsTwo):
                if len(splitsOne) < 1 and len(splitsTwo) < 1:   return True
                if len(splitsOne) != len(splitsTwo):            return False
                splitsOne = sorted(splitsOne, key=lambda sort_x: (sort_x.getDateInt()))
                splitsTwo = sorted(splitsTwo, key=lambda sort_x: (sort_x.getDateInt()))

                for i in range(0,len(splitsOne)):
                    s1 = splitsOne[i]
                    s2 = splitsTwo[i]
                    if s1.getDateInt() != s2.getDateInt():        return False
                    if s1.getSplitRatio() != s2.getSplitRatio():  return False
                    if s1.getNewShares() != s2.getNewShares():    return False
                    if s1.getOldShares() != s2.getOldShares():    return False

                return True

            myPrint("DB","%s: Initial candidates found %s %s" %(_THIS_METHOD_NAME, len(dup_securities),dup_securities))

            # Sweep Two - start validating the data found
            lShowOutput = False
            removeList = []

            output +=   "Performing analysis and validation of potential 'duplicate' Securities.\n\n" \
                        "The following data can be edited in MD Menu > Tools>Securities (** except 'Decimal Places' where you will need to use Toolbox to edit)\n\n" \
                        "The check / validation rules are:\n" \
                        "- Find potential 'duplicates' where Securities' 'Ticker' Symbols are the same; then Duplicate Security's...:\n" \
                        "... ID must be short and DIFFERENT (so you can identify them in this process). Examples: use '^APPL1', '^APPL2', '^APPL3'.. to merge 3 Apple Stocks\n" \
                        "....(^^Close this window and use Tools>Securities>EDIT and change the Security ID for each duplicate and then re-run this function again)\n" \
                        "...'Currency' must match\n" \
                        "...'Current Price' must match\n" \
                        "...'Prefix' & 'Suffix' must match\n" \
                        "...'Splits' data must match\n" \
                        "... hidden 'Decimal Places' setting must match **\n" \
                        "- NOTE: Security Name is not matched, but you can select the Security to become the 'master', that has right details, as part of the process\n" \
                        "\n" \
                        "--------------------------------------------------------------------------------------------------------------------------------------------------\n\n"

            def getSecurityNameAndID(theSec, theLen=None):

                theName = theSec.getName()
                if theLen: theName = theName[:theLen]+".."
                return "%s(ID: %s)" %(theName,theSec.getIDString())


            class StoreSecurity:
                def __init__(self, _obj):
                    self.obj = _obj                         # type: CurrencyType

                def getSecurity(self): return self.obj      # type: CurrencyType

                def getDisplayString(self, _security, _short=False):

                    if _short:
                        return ("%s:ID %s:rate %s:dpc %s:%s:%s:(%s price recs)"
                                % (_security.getName()[:35]+"..",
                                   _security.getIDString(),
                                   safeInvertRate(_security.getRelativeRate()),
                                   _security.getDecimalPlaces(),
                                   _security.getPrefix(),
                                   _security.getSuffix(),
                                   _security.getSnapshots().size()))

                    return ("%s:Ticker %s:ID %s:rate %s:dpc %s:%s:%s:(%s price history recs)"
                            % (_security.getName(),
                               _security.getTickerSymbol(),
                               _security.getIDString(),
                               safeInvertRate(_security.getRelativeRate()),
                               _security.getDecimalPlaces(),
                               _security.getPrefix(),
                               _security.getSuffix(),
                               _security.getSnapshots().size()))

                def shortDisplay(self):
                    return (self.getDisplayString(self.getSecurity(),True))

                def __str__(self): return (self.getDisplayString(self.getSecurity()))[:200]

                def __repr__(self): return self.__str__()

            for dup in dup_securities:
                getDup = dup_securities.get(dup)
                if getDup[0] < 2:
                    removeList.append(dup)
                    continue

                highestSnapCount = 0
                primaryCurr = getDup[1][0]
                for scanDup in getDup[1]:
                    getSnaps = scanDup.getSnapshots()
                    if getSnaps.size() > highestSnapCount:
                        highestSnapCount = getSnaps.size()
                        primaryCurr = scanDup

                getDup[1].remove(primaryCurr)
                getDup[1].insert(0, primaryCurr)

                foundIDs = [primaryCurr.getIDString().strip().lower()]

                lFailChecks = False
                primarySplits = primaryCurr.getSplits()
                output += "Verifying potential 'duplicates': %s(Ticker: %s Master ID: %s) (has %s price history records)\n"\
                          %(primaryCurr.getName(),dup,primaryCurr.getIDString(),highestSnapCount)

                for scanDup in getDup[1]:

                    if scanDup == primaryCurr: continue     # You can't check against yourself...!

                    _tempSec = StoreSecurity(scanDup)
                    _len = 95

                    getDupID = scanDup.getIDString().strip().lower()
                    txt = " --- (Validating ID: %s)\n" \
                          "... '%s' NOTE: has %s price history records" %(scanDup.getIDString(), pad(_tempSec.shortDisplay(),_len), scanDup.getSnapshots().size())
                    output += "%s\n" %(txt)

                    if getDupID in foundIDs:
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as using identical ID                   %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getIDString(),primaryCurr.getIDString())
                        myPrint("DB",txt); output += "%s\n" %(txt)
                    else:
                        foundIDs.append(getDupID)

                    if scanDup.getRelativeCurrency() != primaryCurr.getRelativeCurrency():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not using the same relative currency %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getRelativeCurrency().getName(),primaryCurr.getRelativeCurrency().getName())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getDecimalPlaces() != primaryCurr.getDecimalPlaces():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same decimal places          %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getDecimalPlaces(),primaryCurr.getDecimalPlaces())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getRelativeRate() != primaryCurr.getRelativeRate():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same 'Current Prices'        %s vs %s" %(pad(_tempSec.shortDisplay(),_len),safeInvertRate(scanDup.getRelativeRate()),safeInvertRate(primaryCurr.getRelativeRate()))
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getPrefix()+scanDup.getSuffix() != primaryCurr.getPrefix()+primaryCurr.getSuffix():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same prefix/suffix           %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getPrefix()+":"+scanDup.getSuffix(),primaryCurr.getPrefix()+":"+primaryCurr.getSuffix())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    thisSplits = scanDup.getSplits()
                    if not compareSplits(primarySplits, thisSplits):
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not all have the same splits..." %(pad(_tempSec.shortDisplay(),_len))
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    output += "\n"
                    del _tempSec

                if lFailChecks:
                    txt = "... *** Failed checks - removing candidate....."
                    myPrint("DB",txt); output += "%s\n" %(txt)
                    removeList.append(dup)
                else:
                    txt = "... *** PASSED checks - will include as candidate for merging....."
                    myPrint("DB",txt); output += "%s\n" %(txt)

                output += "\n"

            for remove_ticker in removeList:
                del dup_securities[remove_ticker]
            del removeList

            myPrint("DB","%s: After validation, found %s %s" %(_THIS_METHOD_NAME, len(dup_securities),dup_securities))

            if len(securities) < 2 or len(dup_securities) < 1:
                output += "\n" \
                          "Use MD Menu > Tools>Securities to make changes necessary for Securities to 'qualify' for merging....\n" \
                          "Ensure you use a DIFFERENT ID for each duplicate - e.g. ^APPL1, ^APPL2, ^APPL3 for Apple (for example)...\n" \
                          "** except for decimal places differences. Use Toolbox 'MENU: Currency & Security tools > FIX: Edit a Security's (hidden) Decimal Place setting'\n" \
                          "\n"
                if lShowOutput:
                    txt = "%s: Not enough Securities / no valid duplicate Tickers found (refer report on screen for details) - NO CHANGES MADE" %(_THIS_METHOD_NAME)
                else:
                    txt = "%s: Not enough Securities / no duplicate Tickers found - NO CHANGES MADE" %(_THIS_METHOD_NAME)
                myPrint("B",txt); output += "\n%s\n" %(txt)
                setDisplayStatus(txt, "R")
                output += "\n<END>"
                if lShowOutput:
                    jif=QuickJFrame(txt, output, lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                    myPopupInformationBox(jif,txt)
                else:
                    myPopupInformationBox(toolbox_frame_,txt)
                return
            del lShowOutput


            txt = _THIS_METHOD_NAME
            if not perform_quote_loader_check(toolbox_frame_, txt): return


            class StoreTickerData:
                def __init__(self, _theTicker, numberCandidates, listSecurityCandidates):
                    self.theTicker = _theTicker
                    self.numberCandidates = numberCandidates
                    self.listSecurityCandidates = listSecurityCandidates        # type: [CurrencyType]
                    self.primarySecurity = self.listSecurityCandidates[0]

                def getTicker(self):
                    return (self.theTicker)

                def getName(self):
                    return (self.primarySecurity.getName())

                def getSecurityList(self):
                    return (self.listSecurityCandidates)

                def getSecurityListWithoutPrimary(self):
                    listAccts = []
                    for acct in self.listSecurityCandidates:
                        if acct == self.getPrimarySecurity(): continue
                        listAccts.append(acct)
                    return (listAccts)

                def getPrimarySecurity(self):
                    return (self.primarySecurity)

                def setPrimarySecurity(self, theSecurity):
                    self.primarySecurity = theSecurity

                def getDisplayString(self, _security):
                    return ("%s:Ticker %s:ID %s:rate %s:dpc %s:%s:%s:(%s price history recs)"
                            % (_security.getName(),
                               self.theTicker,
                               _security.getIDString(),
                               safeInvertRate(_security.getRelativeRate()),
                               _security.getDecimalPlaces(),
                               _security.getPrefix(),
                               _security.getSuffix(),
                               _security.getSnapshots().size()))

                def __str__(self): return (self.getDisplayString(self.getPrimarySecurity()))[:200]

                def __repr__(self): return self.__str__()

            listDuplicateTickers = []
            output += "\nFinal list of 'duplicate' candidates...:\n"

            for dup in dup_securities:
                theDupDetails = dup_securities[dup]
                listDuplicateTickers.append(StoreTickerData(dup,theDupDetails[0],theDupDetails[1]))
                txt = ".. %s found for Ticker: '%s'" %(theDupDetails[0],dup)
                myPrint("DB",txt); output += "%s\n" %(txt)
                for theDups in theDupDetails[1]:
                    txt = "         - Name: %s ID: %s Rate: %s Dpc: %s Prx:Sfx: %s (Price History records: %s)"\
                          %(pad(theDups.getName(),30),
                            pad(theDups.getIDString(),20),
                            rpad(safeInvertRate(theDups.getRelativeRate()),12),
                            rpad(theDups.getDecimalPlaces(),2),
                            pad(theDups.getPrefix()+":"+theDups.getSuffix(),20),
                            rpad(theDups.getSnapshots().size(),12))
                    myPrint("DB",txt); output += "%s\n" %(txt)
                output += "\n"
            del dup_securities

            output += "\n"

            jif = QuickJFrame("%s: Candidates" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            tickerToMerge = JOptionPane.showInputDialog(jif,
                                                         "Select Ticker / Security set to merge (sorted by Name, Ticker, ID)",
                                                        _THIS_METHOD_NAME.upper(),
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         None,
                                                         listDuplicateTickers,
                                                         None)                                                              # type: StoreTickerData
            del listDuplicateTickers

            if not tickerToMerge:
                txt = "%s: User did not select a Ticker / Security set to merge - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            quickSecurityDropdownList = []
            for secDropdown in tickerToMerge.getSecurityList():
                quickSecurityDropdownList.append(StoreSecurity(secDropdown))

            selectedSecurity = JOptionPane.showInputDialog(jif,
                                                           "Select the Security that will be the final master (sorted by Name, Ticker, ID)",
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           None,
                                                           quickSecurityDropdownList,
                                                           None)  # type: StoreSecurity

            if not selectedSecurity:
                txt = "%s: User did not select a Security as the master for the merge - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            selectedSecurity = selectedSecurity.getSecurity()

            jif.dispose()

            if selectedSecurity != tickerToMerge.getPrimarySecurity():
                txt = "Master security switched from %s to %s (ID: %s)"\
                      %(tickerToMerge.getPrimarySecurity(), selectedSecurity, selectedSecurity.getIDString())
                myPrint("DB",txt); output += "%s\n" %(txt)
                tickerToMerge.setPrimarySecurity(selectedSecurity)

            output += "\n\n" \
                      "Selected Ticker / Security: '%s'\n" %(tickerToMerge.getTicker())

            output += "Selected Security to use as the master for the merge: %s\n\n" %(tickerToMerge.getDisplayString(selectedSecurity))
            del selectedSecurity

            # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
            allInvestmentAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(23))

            output += "\nAnalysis of Securities to Merge - Ticker '%s' - %s:\n\n" %(tickerToMerge.getTicker(),tickerToMerge.getName())

            lAnyCostBasisErrorsFound = [False]

            # Prepare before totals...
            _WHAT = 0
            _QTY = 1
            _COSTBASIS = 2
            _VALUE = 3
            _CBFLAG = 4

            # noinspection PyUnresolvedReferences
            def create_totals(theCount, theAccount, theTable):
                _acctRelCurr = theAccount.getCurrencyType()
                theTable.append(["Txn Count",    theCount, "", "", ""])
                theTable.append(["Account Starting Balance", "","",_acctRelCurr.formatSemiFancy(theAccount.getStartBalance(),MD_decimal), ""])
                theTable.append(["Cash Balance", "", "", _acctRelCurr.formatSemiFancy(theAccount.getBalance(),MD_decimal), ""])
                _totals = [0.0, 0.0, _acctRelCurr.getDoubleValue(theAccount.getBalance()), False]
                lDetectCBError = False
                for acct in theAccount.getSubAccounts():
                    if acct.getAccountType() == Account.AccountType.SECURITY:

                        if not InvestUtil.isCostBasisValid(acct):
                            lDetectCBError = True
                            lAnyCostBasisErrorsFound[0] = True

                        _subAcctRelCurr = acct.getCurrencyType()
                        subAcctBal = acct.getBalance()
                        subAcctCostBasis = InvestUtil.getCostBasis(acct)
                        # price = (1.0 / _subAcctRelCurr.adjustRateForSplitsInt(DateUtil.convertCalToInt(today), _subAcctRelCurr.getRelativeRate()))                        # noqa
                        price = CurrencyTable.getUserRate(_subAcctRelCurr, _acctRelCurr)                                # noqa

                        _totals[0] += _subAcctRelCurr.getDoubleValue(subAcctBal)
                        _totals[1] += _acctRelCurr.getDoubleValue(subAcctCostBasis)
                        _totals[2] +=  round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())
                        if lDetectCBError: _totals[3] = True
                        theTable.append([getSecurityNameAndID(acct.getCurrencyType()),
                                         _subAcctRelCurr.formatSemiFancy(subAcctBal,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(subAcctCostBasis,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())),MD_decimal),
                                         lDetectCBError])
                theTable.append(["**TOTALS:",
                                 _totals[0],
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[1]),MD_decimal),
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[2]),MD_decimal),
                                 _totals[3]])


            def output_stats(theText, theAccount, theTable):

                if theAccount.getCurrencyType() == base or theAccount.getCurrencyType() is None:
                    relText = ""
                else:
                    relText = " relative to %s" %(theAccount.getCurrencyType().getRelativeCurrency())

                local_output = "%s: %s (Currency: %s%s)\n" %(theText, theAccount, theAccount.getCurrencyType(), relText)
                iRow = 1
                posInc = 0
                for data in theTable:
                    if iRow == 2:
                        posInc += 14
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("Qty Shares",12), rpad("Cost Basis",15), rpad("Current Value",15))
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    if iRow == 4:
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("",12), rpad("",15), rpad("-------------",15))

                    if data[_WHAT].upper() == "**TOTALS:".upper():
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    cbMsg = ""
                    if data[_CBFLAG]: cbMsg = " * Cost Basis Error detected"
                    local_output += "   %s %s %s %s %s\n" %(pad(data[_WHAT],60+posInc),rpad(data[_QTY],12), rpad(data[_COSTBASIS],15), rpad(data[_VALUE],15),cbMsg)
                    iRow += 1
                return local_output


            def isSecurityHeldWithinInvestmentAccount(_theSecurity, _theInvestmentAccount):

                _subAccts = _theInvestmentAccount.getSubAccounts()
                for _subAcct in _subAccts:
                    # noinspection PyUnresolvedReferences
                    if _subAcct.getAccountType() != Account.AccountType.SECURITY: continue
                    _subAcctCurr = _subAcct.getCurrencyType()
                    if _subAcctCurr is None: continue
                    if _subAcctCurr == _theSecurity:
                        return _subAcct

                return None


            def isSecurityHeldWithinAnyInvestmentAccount(_theSecurity):

                # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
                _subAccts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(22))

                for _subAcct in _subAccts:
                    # noinspection PyUnresolvedReferences
                    if _subAcct.getAccountType() != Account.AccountType.SECURITY: continue
                    _subAcctCurr = _subAcct.getCurrencyType()
                    if _subAcctCurr is None: continue
                    if _subAcctCurr == _theSecurity:
                        return _subAcct

                return None


            def isAnySecurityHeldWithinInvestmentAccount(_theSecurityList, _theInvestmentAccount):

                for _theSecurity in _theSecurityList:
                    _result = isSecurityHeldWithinInvestmentAccount(_theSecurity,_theInvestmentAccount)
                    if _result is not None: return True

                return False


            for security in tickerToMerge.getSecurityList():
                output += "%s Price History Records: %s\n" %(pad(getSecurityNameAndID(security),80),rpad(security.getSnapshots().size(),10))
            output += "\n"


            # OK, now scan existing investment accounts... More validation.....
            investmentAccountsInvolvedInMerge = {}
            investmentAccountsNeedingPrimaryCreated = {}
            investmentAccountsNeedingSecondaryMerge = {}

            lFailValidation = False
            iFoundAnyInvestmentAccounts = 0
            iPrimarySecuritiesToCreate = 0
            iSecuritiesMergedDeleted = 0
            output += "Investment Accounts:\n"
            for investAccount in allInvestmentAccounts:
                if not isAnySecurityHeldWithinInvestmentAccount(tickerToMerge.getSecurityList(), investAccount): continue
                failStartingBalanceMustBeZero = False
                failUsesAverageCostValidation = False
                validateUsesAvgCost = None
                iFoundAnyInvestmentAccounts += 1
                output += "** %s\n" %(investAccount.getAccountName())
                foundPrimary = isSecurityHeldWithinInvestmentAccount(tickerToMerge.getPrimarySecurity(), investAccount)
                if not foundPrimary:
                    iPrimarySecuritiesToCreate += 1
                    output += "   <NEW MASTER SECURITY NOT FOUND IN THIS INVESTMENT ACCOUNT - WILL BE ADDED>\n"
                foundSecondary = False
                for security in tickerToMerge.getSecurityList():
                    foundSecurity = isSecurityHeldWithinInvestmentAccount(security, investAccount)
                    if foundSecurity is not None:
                        if security != tickerToMerge.getPrimarySecurity():
                            foundSecondary = True
                            iSecuritiesMergedDeleted += 1
                        txnsUsed = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(foundSecurity)
                        _relCurr = foundSecurity.getCurrencyType()
                        output += "   %s Uses Avg Cost: %s Shares Held: %s Txns: %s" \
                                  %(pad("'%s':%s" %(foundSecurity.getParentAccount().getAccountName()[:30], getSecurityNameAndID(foundSecurity.getCurrencyType(),theLen=35)),85),
                                    pad(str(foundSecurity.getUsesAverageCost()),6),
                                    rpad(_relCurr.formatSemiFancy(foundSecurity.getBalance(),MD_decimal),18),
                                    rpad(txnsUsed.getSize(),15))
                        if security == tickerToMerge.getPrimarySecurity():
                            output += "   <MASTER - KEEP>\n"
                        else:
                            output += "   ** will be merged/removed **\n"

                        if foundSecurity.getStartBalance() != 0:
                            failStartingBalanceMustBeZero = lFailValidation = True
                            output += "   *** <ERROR - StartingBalance() reports %s - SHOULD ALWAYS BE ZERO! CANNOT MERGE>\n" %(foundSecurity.getStartBalance())

                        if validateUsesAvgCost is None:
                            validateUsesAvgCost = foundSecurity.getUsesAverageCost()
                        elif validateUsesAvgCost != foundSecurity.getUsesAverageCost():
                            output += "   *** <ERROR - UsesAverageCost() differs between Investment Accounts for this same Security! CANNOT MERGE>\n"
                            failUsesAverageCostValidation = lFailValidation = True

                investmentAccountsInvolvedInMerge[investAccount] = True

                if failUsesAverageCostValidation or failStartingBalanceMustBeZero:
                    output += "   <Above Investment account FAILED VALIDATION. Function will ABORT WITHOUT CHANGES>\n"
                elif foundSecondary:
                    investmentAccountsNeedingSecondaryMerge[investAccount] = True
                    output += "   <Above Investment account will be included in Security merge>\n"
                    if not foundPrimary:
                        investmentAccountsNeedingPrimaryCreated[investAccount] = True
                else:
                    output += "   <Above Investment account will NOT be touched, no 'duplicate' securities to merge>\n"

                output += "   ----\n"
            del allInvestmentAccounts

            if not iFoundAnyInvestmentAccounts:
                output += "<NONE FOUND>\n\n"
            else:
                output += "%s Investment Accounts are involved in the merge...\n" %(iFoundAnyInvestmentAccounts)
                output += "... Will add the master security to %s investment accounts\n" %(iPrimarySecuritiesToCreate)
                output += "... Will merge/remove %s duplicate securities from investment accounts\n" %(iSecuritiesMergedDeleted)
                output += "----\n"


            if lFailValidation:
                txt = "\n\n INVESTMENT ACCOUNT: SECURITY HOLDING VALIDATION FAILED - CANNOT PROCEED! Review the report on screen for details.\n"
                myPrint("DB", txt); output += "\n\n%s\n" %(txt)
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            output += "\n"

            ############################################################################################################
            # OK - Snapshot validation etc
            primarySnaps = 0
            allOtherSnaps = 0
            for security in tickerToMerge.getSecurityList():
                if security == tickerToMerge.getPrimarySecurity():
                    primarySnaps = security.getSnapshots().size()
                else:
                    allOtherSnaps += security.getSnapshots().size()

            lSnapshotActionRequired = False
            lSnapsDeleteAll = lSnapsMergeAll = lSnapsKeepMasterOnly = lSnapsDumpMaster = False
            if (primarySnaps+allOtherSnaps) < 1:
                output += "No Price History Exists - No action required....\n"
            elif primarySnaps > 0 and allOtherSnaps < 1:
                output += "Only the Primary Security has Price History records - No action required....\n"
            else:
                lSnapshotActionRequired = True
                output += "Master Security has %s Price History records, the others have %s - STRATEGY REQUIRED...\n" %(primarySnaps, allOtherSnaps)

            if lSnapshotActionRequired:
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()

                options = ["Keep Master's %s Price History Records Only (dump the other's %s records)"  %(primarySnaps, allOtherSnaps),
                           "Merge all other %s history records into master's (currently holds %s)"      %(allOtherSnaps, primarySnaps),
                           "Dump Master's %s Price History records, merge %s others into master"        %(primarySnaps, allOtherSnaps),
                           "DELETE ALL %s PRICE HISTORY RECORDS"                                        %(primarySnaps+allOtherSnaps)]

                selectedSnapStrategy = JOptionPane.showInputDialog(jif,
                                                               "Select the Price History Strategy?",
                                                               "%s - PRICE HISTORY" %(_THIS_METHOD_NAME.upper()),
                                                               JOptionPane.INFORMATION_MESSAGE,
                                                               None,
                                                               options,
                                                               None)

                if not selectedSnapStrategy:
                    txt = "%s: User did not select a Price History Strategy for the merge - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                jif.dispose()

                if options.index(selectedSnapStrategy) == 0:    lSnapsKeepMasterOnly = True
                elif options.index(selectedSnapStrategy) == 1:  lSnapsMergeAll = True
                elif options.index(selectedSnapStrategy) == 2:  lSnapsDumpMaster = True
                else:                                           lSnapsDeleteAll = True

                output += "** Price History Strategy selected: %s\n\n" %(selectedSnapStrategy)


            ############################################################################################################
            # OK - hidden CUSIP validation etc


            def countCUSIPs(_theSec):
                iCUSIPs = 0
                for key in _theSec.getParameterKeys():
                    if key.startswith(PARAM_CURRID):
                        iCUSIPs += 1
                return iCUSIPs


            def getAllUniqueCUSIPs(_theSecList):
                _allUniqueCUSIPs = {}
                returnUniqueCUSIPs = []
                for _theSec in _theSecList:
                    for key in _theSec.getParameterKeys():
                        if key.startswith(PARAM_CURRID):
                            _theScheme = key[len(PARAM_CURRID):]
                            _theCUSIP = _theSec.getIDForScheme(_theScheme)
                            if _allUniqueCUSIPs.get(_theScheme+"."+_theCUSIP) is None:
                                _allUniqueCUSIPs[_theScheme+"."+_theCUSIP] = True
                                returnUniqueCUSIPs.append([_theScheme, _theCUSIP])
                return returnUniqueCUSIPs


            primaryCUSIPs = 0
            allOtherCUSIPs = 0
            for security in tickerToMerge.getSecurityList():
                if security == tickerToMerge.getPrimarySecurity():
                    primaryCUSIPs = countCUSIPs(security)
                else:
                    allOtherCUSIPs += countCUSIPs(security)

            allUniqueCUSIPs = getAllUniqueCUSIPs(tickerToMerge.getSecurityList())
            if len(allUniqueCUSIPs) > 0:
                output += "Hidden CUSIP data found (used for linking Investment Downloaded Securities to MD Securities)...:\n"
                for theScheme, theCUSIP in allUniqueCUSIPs:
                    output += "Scheme: %s, ID: %s\n" %(theScheme, theCUSIP)
                output += "\n"

            lCUSIPActionRequired = False
            if len(allUniqueCUSIPs) < 1:
                output += "No hidden CUSIP data exists - This is OK and No action required....\n"
            elif primaryCUSIPs > 0 and allOtherCUSIPs < 1:
                output += "Only the Master Security has hidden CUSIP data - This is OK and No action required....\n"
            else:
                lCUSIPActionRequired = True
                output += "Hidden CUSIP data - STRATEGY REQUIRED...\n"

            selectedCUSIP = None
            if lCUSIPActionRequired:
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()

                class StoreCUSIP:
                    def __init__(self, _objScheme, _objCUSIP):
                        self._objScheme = _objScheme
                        self._objCUSIP = _objCUSIP

                    def getScheme(self): return self._objScheme

                    def getCUSIP(self): return self._objCUSIP

                    def __str__(self):
                        if self.getScheme() is None: return ("<NONE> (No hidden CUSIP data)")
                        return ("Scheme: %s, ID: %s" % (self.getScheme(), self.getCUSIP()))

                    def __repr__(self): return self.__str__()


                allUniqueCUSIPsPicklist = []                                                                            # noqa
                allUniqueCUSIPsPicklist.append(StoreCUSIP(None,None))
                for theScheme, theCUSIP in allUniqueCUSIPs:
                    allUniqueCUSIPsPicklist.append(StoreCUSIP(theScheme, theCUSIP))

                selectedCUSIP = JOptionPane.showInputDialog(jif,
                                                            "Select the hidden CUSIP to keep/use in the new Master Security?",
                                                            "%s - HIDDEN CUSIP DATA" % (_THIS_METHOD_NAME.upper()),
                                                            JOptionPane.INFORMATION_MESSAGE,
                                                            None,
                                                            allUniqueCUSIPsPicklist,
                                                            None)

                del allUniqueCUSIPsPicklist

                if not selectedCUSIP:
                    txt = "%s: User did not select a hidden CUSIP record for the merge - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                jif.dispose()

                output += "** Hidden CUSIP Strategy: - CUSIP data selected: %s\n\n" %(selectedCUSIP)
            del allUniqueCUSIPs


            ############################################################################################################
            output += "\n------\n"
            output += "Investment Accounts included in merge:                  %s\n" %(len(investmentAccountsInvolvedInMerge))
            output += "Investment new Master securities to be added:           %s\n" %(len(investmentAccountsNeedingPrimaryCreated))
            output += "Investment 'duplicate' securities to be merged/removed: %s\n" %(len(investmentAccountsNeedingSecondaryMerge))
            output += "\n------\n"


            jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            ask = MyPopUpDialogBox(jif,
                                   "%s: REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE SECURITY MERGE" %(_THIS_METHOD_NAME.upper()),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s: User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                myPrint("B",txt)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE MERGE OF SECURITY %s / %s?" %(tickerToMerge.getTicker(),tickerToMerge.getPrimarySecurity())):
                return

            jif.dispose()

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH SECURITY MERGE of %s / %s.....\n\n" %(tickerToMerge.getTicker(),getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))

            if len(investmentAccountsInvolvedInMerge) > 0:
                output += "\nSTATISTICS BEFORE START...\n\n"
                for reportAccount in investmentAccountsInvolvedInMerge:
                    getTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(reportAccount)
                    countTxns = getTxns.getSize()
                    valuesTable = []
                    create_totals(countTxns, reportAccount, valuesTable)
                    output += output_stats("Before:", reportAccount, valuesTable)
                    output += "\n----\n"
                    del getTxns, valuesTable

                if lAnyCostBasisErrorsFound[0]:
                    output += "\n\n** WARNING: Lot Control / Cost Basis errors detected before changes started - review output....\n\n"
                else:
                    output += "\nLot Control / Cost Basis reports OK before changes....\n"

            output += "\n"

        except:
            txt = ("MINOR ERROR - %s: crashed before any merge actions. Please review output and console" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing 'duplicate' security merge right now..",
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          theWidth=100,
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the merge..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            ############################################################################################################
            # Start with snapshot merge...
            if not lSnapshotActionRequired:
                txt = "Skipping Price History actions...."
                myPrint("B", txt); output += "%s\n\n" %(txt)
            else:
                primary = tickerToMerge.getPrimarySecurity()
                if lSnapsDumpMaster or lSnapsDeleteAll:
                    getSnaps = primary.getSnapshots()
                    txt = "Deleting %s price history records from %s" %(getSnaps.size(), getSecurityNameAndID(primary))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    for snap in getSnaps: snap.deleteItem()

                if lSnapsMergeAll or lSnapsDumpMaster:
                    for security in tickerToMerge.getSecurityListWithoutPrimary():
                        rCurr = primary.getRelativeCurrency()
                        getSnaps = security.getSnapshots()
                        txt = "Merging %s potential price history records from %s into %s" %(getSnaps.size(), getSecurityNameAndID(security), getSecurityNameAndID(primary))
                        myPrint("B",txt); output += "%s\n" %(txt)
                        for snap in getSnaps:
                            foundSnap = primary.getSnapshotForDate(snap.getDateInt())
                            if foundSnap is not None and foundSnap.getDateInt() == snap.getDateInt():
                                # Found a match - skip
                                pass
                            else:
                                newSnap = primary.addSnapshotInt(snap.getDateInt(), snap.getRate(), rCurr)
                                newSnap.setEditingMode()
                                newSnap.setDailyVolume(snap.getDailyVolume())
                                newSnap.setUserDailyLow(snap.getDailyLow())
                                newSnap.setUserDailyHigh(snap.getDailyHigh())
                                newSnap.syncItem()

                if lSnapsKeepMasterOnly: pass

                for security in tickerToMerge.getSecurityListWithoutPrimary():
                    getSnaps = security.getSnapshots()
                    txt = "Now Deleting %s price history records from %s (post any merge actions)" %(getSnaps.size(), getSecurityNameAndID(security))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    for snap in getSnaps: snap.deleteItem()

                output += "----\n"
                output += "Master %s now contains: %s Price History records...\n" %(getSecurityNameAndID(primary), primary.getSnapshots().size())
                for security in tickerToMerge.getSecurityListWithoutPrimary():
                    output += "Duplicate %s now contains: %s Price History records...\n" %(getSecurityNameAndID(security), security.getSnapshots().size())
                output += "----\n"

            ############################################################################################################
            # Now CUSIP merge...

            def deleteCUSIPs(_theSec):
                _deleteList = []
                for key in _theSec.getParameterKeys():
                    if key.startswith(PARAM_CURRID):
                        _theScheme = key[len(PARAM_CURRID):]
                        _deleteList.append(_theScheme)
                for _delSchemeCUSIP in _deleteList:
                    _theSec.setIDForScheme(_delSchemeCUSIP, None)


            if not lCUSIPActionRequired:
                txt = "Skipping hidden CUSIP data actions...."
                myPrint("B", txt); output += "%s\n\n" %(txt)

            else:

                txt = "Removing any hidden CUSIP data from %s" %(getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))
                myPrint("B",txt); output += "%s\n" %(txt)

                tickerToMerge.getPrimarySecurity().setEditingMode()
                deleteCUSIPs(tickerToMerge.getPrimarySecurity())

                if selectedCUSIP.getScheme():
                    txt = "Adding CUSIP data - Scheme: %s ID: %s to %s" %(selectedCUSIP.getScheme(), selectedCUSIP.getCUSIP(), getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    tickerToMerge.getPrimarySecurity().setIDForScheme(selectedCUSIP.getScheme(),selectedCUSIP.getCUSIP())

                tickerToMerge.getPrimarySecurity().setParameter(PARAMETER_KEY,True)
                tickerToMerge.getPrimarySecurity().syncItem()

                output += "----\n"
                output += "Master %s now contains: hidden CUSIP record: Scheme: %s, ID: %s\n" %(getSecurityNameAndID(tickerToMerge.getPrimarySecurity()), selectedCUSIP.getScheme(),selectedCUSIP.getCUSIP())
                output += "----\n"


            ############################################################################################################
            # Now create any missing Primary security sub account(s)...

            if len(investmentAccountsNeedingPrimaryCreated) > 0:
                txt = "Adding the new master Security to %s Investment accounts:" %(len(investmentAccountsNeedingPrimaryCreated))
                myPrint("B", txt); output += "%s\n" %(txt)

                primary = tickerToMerge.getPrimarySecurity()
                for createAccount in investmentAccountsNeedingPrimaryCreated:
                    # Copy the first one we find... Yup - there could be more, but tough!
                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,createAccount)

                        if copyAcct is None: continue

                        txt = "... Adding: %s to %s" %(getSecurityNameAndID(primary), createAccount)
                        myPrint("B", txt); output += "%s\n" %(txt)

                        newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(),
                                                              Account.AccountType.SECURITY,
                                                              createAccount)
                        newSecurityAcct.setEditingMode()
                        newSecurityAcct.getUUID()
                        newSecurityAcct.setAccountName(primary.getName())
                        newSecurityAcct.setCurrencyType(primary)
                        newSecurityAcct.setStartBalance(0)

                        newSecurityAcct.setUsesAverageCost(copyAcct.getUsesAverageCost())
                        newSecurityAcct.setBroker(copyAcct.getBroker())
                        newSecurityAcct.setBrokerPhone(copyAcct.getBrokerPhone())
                        newSecurityAcct.setAPR(copyAcct.getAPR())
                        newSecurityAcct.setBondType(copyAcct.getBondType())
                        newSecurityAcct.setComment(copyAcct.getComment())
                        newSecurityAcct.setCompounding(copyAcct.getCompounding())
                        newSecurityAcct.setFaceValue(copyAcct.getFaceValue())
                        newSecurityAcct.setFaceValue(copyAcct.getFaceValue())
                        newSecurityAcct.setMaturity(copyAcct.getMaturity())
                        newSecurityAcct.setMonth(copyAcct.getMonth())
                        newSecurityAcct.setNumYears(copyAcct.getNumYears())
                        newSecurityAcct.setPut(copyAcct.getPut())
                        newSecurityAcct.setOptionPrice(copyAcct.getOptionPrice())
                        newSecurityAcct.setDividend(copyAcct.getDividend())
                        newSecurityAcct.setExchange(copyAcct.getExchange())
                        newSecurityAcct.setSecurityType(copyAcct.getSecurityType())
                        newSecurityAcct.setSecuritySubType(copyAcct.getSecuritySubType())
                        newSecurityAcct.setStrikePrice(copyAcct.getStrikePrice())

                        for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                            newSecurityAcct.setParameter(param, copyAcct.getParameter(param))

                        newSecurityAcct.setParameter(PARAMETER_KEY,True)
                        newSecurityAcct.syncItem()

                        break

            lErrorDeletingSecuritySubAccounts = False
            if len(investmentAccountsNeedingSecondaryMerge) > 0:
                txt = "Now reassigning relevant txns to the new/merged master security....:"
                myPrint("B", txt); output += "\n\n%s\n" %(txt)

                # now for the merge/reassignment of relevant transactions...
                for reassignAcct in investmentAccountsNeedingSecondaryMerge:

                    primaryAcct = isSecurityHeldWithinInvestmentAccount(tickerToMerge.getPrimarySecurity(),reassignAcct)

                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,reassignAcct)
                        if copyAcct is None: continue

                        reassignTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(copyAcct)
                        reassignTxns = sorted(reassignTxns, key=lambda _x: (_x.getDateInt()))

                        # Note sorted loses x.getSize() >> use len(x)
                        output += "... retrieved %s txns from duplicate security %s within investment account '%s' - reassigning.....\n" %(len(reassignTxns), getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount())

                        for srcTxn in reassignTxns:

                            if not isinstance(srcTxn, SplitTxn):       # Should never happen..... ;->
                                raise Exception("Error: found a non-split: %s" %(srcTxn))

                            pTxn = srcTxn.getParentTxn()
                            pTxn.setEditingMode()
                            srcTxn.setAccount(primaryAcct)
                            srcTxn.setParameter(PARAMETER_KEY,True)
                            pTxn.syncItem()
                            output += ".. %s %s %s %s\n" %(convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                           pad(pTxn.getInvestTxnType().getIDString(),12),
                                                           pad(pTxn.getDescription()+pTxn.getMemo(),60),
                                                           rpad(copyAcct.getCurrencyType().formatFancy(srcTxn.getValue(),MD_decimal),18))
                            continue

                        output += "\n"
                        del reassignTxns

                output += "\n>> Txn reassignment completed.....\n\n"

                txt = "Now removing duplicate securities from Investment account(s)...."
                myPrint("B", txt); output += "\n%s\n" %(txt)

                ############################################################################################################
                # now delete the empty sub accounts.....
                for reassignAcct in investmentAccountsNeedingSecondaryMerge:

                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,reassignAcct)
                        if copyAcct is None: continue

                        remainingTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(copyAcct)
                        output += "... %s txns left in %s for duplicate security %s ..." %(remainingTxns.getSize(), copyAcct.getParentAccount(), getSecurityNameAndID(copyAcct.getCurrencyType()))

                        if remainingTxns.getSize() < 1:
                            txt = "... Removing: security %s (empty) from Account: %s" %(getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount())
                            myPrint("B", txt); output += "%s\n" %(txt)
                            copyAcct.deleteItem()
                        else:
                            lErrorDeletingSecuritySubAccounts = True
                            txt = "... *** ERROR - Cannot remove security %s from %s as it still contains %s txns! ***" %(getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount(), remainingTxns.getSize())
                            myPrint("B", txt); output += "%s\n" %(txt)

                output += "\n>> Removal of duplicate Securities from Investment Account(s) completed.....\n\n"

            # Now delete the (empty) and now unused old duplicate Securities
            txt = "Now deleting the redundant duplicate security(s) (that have been merged into the new master) from Tools>Securities..:"
            myPrint("B", txt); output += "\n%s\n\n" %(txt)

            lErrorDeletingSecurities = False
            for securityToDelete in tickerToMerge.getSecurityListWithoutPrimary():
                findSecurityAcct = isSecurityHeldWithinAnyInvestmentAccount(securityToDelete)
                if findSecurityAcct is None:
                    output += ".. Verified %s is not being used...... DELETING REDUNDANT SECURITY FROM TOOLS>SECURITIES....\n" %(getSecurityNameAndID(securityToDelete))
                    securityToDelete.deleteItem()
                else:
                    lErrorDeletingSecurities = True
                    output += ".. ERROR %s is still being used in %s ...... ** NOT DELETING REDUNDANT SECURITY FROM TOOLS>SECURITIES **\n" %(getSecurityNameAndID(securityToDelete), findSecurityAcct)

            output += "\n>> Merge 'duplicate' Securities completed..\n\n"

            del tickerToMerge

        except:

            txt = ("MAJOR ERROR - %s: crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset merge 'duplicate' security changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es)..")
            MD_REF.getUI().getMain().saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # OK - Main update is done....

            lAnyCostBasisErrorsFound[0] = False
            if len(investmentAccountsInvolvedInMerge) > 0:
                output += "\n\nSTATISTICS AFTER MERGE ACTIONS COMPLETED...\n\n"
                for reportAccount in investmentAccountsInvolvedInMerge:
                    getTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(reportAccount)
                    countTxns = getTxns.getSize()
                    valuesTable = []
                    create_totals(countTxns, reportAccount, valuesTable)
                    output += output_stats("After:", reportAccount, valuesTable)
                    output += "\n----\n"
                    del getTxns, valuesTable

                if lAnyCostBasisErrorsFound[0]:
                    output += "\n\n** WARNING: Lot Control / Cost Basis errors detected after changes completed - review output....\n\n"
                else:
                    output += "\nLot Control / Cost Basis reports OK after changes....\n"

            del investmentAccountsInvolvedInMerge, investmentAccountsNeedingSecondaryMerge, investmentAccountsNeedingPrimaryCreated

            output += "\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and merge actions) back to disk.....",
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              theWidth=100,
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                pleaseWait.kill()

            if lErrorDeletingSecuritySubAccounts or lErrorDeletingSecurities:
                txt = "%s: completed ** WITH ERRORS ** Please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.ERROR_MESSAGE
                optionColor = "R"
            elif lAnyCostBasisErrorsFound[0]:
                txt = "%s: completed ** NOTE: You have Lot Control errors >> please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.ERROR_MESSAGE
                optionColor = "R"
            else:
                txt = "%s: successfully completed - please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.INFORMATION_MESSAGE
                optionColor = "DG"
            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES ***\n\n"
            output += "\n<END>"

        except:
            txt = ("ERROR - %s: crashed after the merge actions. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        setDisplayStatus(txt, optionColor)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionMessage)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def move_merge_investment_txns():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "Move/Merge Investment Accounts"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_txn_merge"
        today = Calendar.getInstance()                                                                                  # noqa

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX - Non Hierarchical Security Account Txns (cross-linked securities)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        allInvestmentAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(23))
        toListAccount = list(allInvestmentAccounts)

        if len(allInvestmentAccounts) < 2:
            txt = "%s: You do not have enough accounts to do this - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        txt = "%s" %(_THIS_METHOD_NAME)
        if not perform_quote_loader_check(toolbox_frame_, txt): return

        sourceAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the 'from' source Account",
                                                      _THIS_METHOD_NAME.upper(),
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      None,
                                                      allInvestmentAccounts,
                                                      None)

        if not sourceAccount:
            txt = "%s: User did not select a source Account to move txns from - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        toListAccount.remove(sourceAccount)

        targetAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                    "Select the target Account to move/merge txns into",
                                                    _THIS_METHOD_NAME.upper(),
                                                    JOptionPane.INFORMATION_MESSAGE,
                                                    None,
                                                    toListAccount,
                                                    None)

        if not targetAccount:
            txt = "%s: User did not select a target Account to move txns into - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        sourceTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(sourceAccount)
        if sourceTxns.getSize() < 1:
            txt = "%s: Source Account has no transactions - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B", "%s: Analysing Investment accounts %s into %s...." %(_THIS_METHOD_NAME, sourceAccount, targetAccount))

        output = "%s: from one account into another:\n" \
                 " ============================================================\n\n" %(_THIS_METHOD_NAME)

        try:

            base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

            if isQuoteLoader_or_QER_Running():
                output += "QuoteLoader / Q&ER extension is loaded. User confirmed that it's not auto-updating and to proceed....\n\n"

            output += "Pre move/merge analysis....\n"
            output += "Source Account: %s\n" %(sourceAccount.getFullAccountName())
            output += "Target Account: %s\n\n" %(targetAccount.getFullAccountName())

            MD_decimal = MD_REF.getPreferences().getDecimalChar()

            # noinspection PyUnresolvedReferences
            def getSubSecAccts(fromWhere, lSource):
                secs = []
                _output = ""
                _txtSource = "Source"
                if not lSource: _txtSource = "Target"
                for acct in fromWhere.getSubAccounts():
                    if acct.getAccountType() == Account.AccountType.SECURITY and acct.getStartBalance() == 0:
                        secs.append(acct)
                        _relCurr = acct.getCurrencyType()
                        _output += "..%s: %s contains Security: %s (%s shares)\n" %(_txtSource, fromWhere, acct, _relCurr.formatSemiFancy(acct.getBalance(),MD_decimal))
                    elif acct.getAccountType() == Account.AccountType.SECURITY:
                        _txt = "Error: %s found SECURITY (sub account) %s with starting balance of %s - should always be ZERO? - Aborting" %(_txtSource, acct, acct.getStartBalance())
                        myPrint("DB",_txt)
                        setDisplayStatus(txt, "R")
                        myPopupInformationBox(toolbox_frame_,_txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                        return None, None
                    else:
                        _txt = "Error: %s found non SECURITY account %s within %s? - Aborting" %(_txtSource, acct,fromWhere)
                        myPrint("DB",_txt)
                        setDisplayStatus(txt, "R")
                        myPopupInformationBox(toolbox_frame_,_txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                        return None, None
                return secs, _output

            response = getSubSecAccts(sourceAccount, lSource=True)
            if response[0] is None: return
            sourceSecurities = response[0]
            output += response[1]
            output += "\n"

            response = getSubSecAccts(targetAccount, lSource=False)
            if response[0] is None: return
            targetSecurities = response[0]
            output += response[1]
            output += "\n"

            def find_src_sec_in_target(findSecCurr):
                for _trgSec in targetSecurities:
                    if _trgSec.getCurrencyType() == findSecCurr:
                        return _trgSec
                return None

            securities_to_create = []
            for srcSec in sourceSecurities:
                trgSec = find_src_sec_in_target(srcSec.getCurrencyType())
                if trgSec:
                    if trgSec.getUsesAverageCost() != srcSec.getUsesAverageCost():
                        txt = "Error: Security %s Source & Target UsesAverageCost does NOT match (%s vs %s) - Aborting" %(srcSec,srcSec.getUsesAverageCost(),trgSec.getUsesAverageCost())
                        myPrint("DB",txt)
                        setDisplayStatus(txt, "R")
                        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                        return
                    output += "Matched: %s to %s >> UsesAverageCost=%s\n" %(srcSec, trgSec, srcSec.getUsesAverageCost())
                else:
                    securities_to_create.append(srcSec)

            targetTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(targetAccount)

            if sourceAccount.getCurrencyType() != targetAccount.getCurrencyType():
                txt = "Error: Sorry the source acct's currency %s does not match target's %s" %(sourceAccount.getCurrencyType(), targetAccount.getCurrencyType())
                myPrint("DB",txt)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            output += "\nConfirmed that source and target accounts use the same currency: %s\n" %(sourceAccount.getCurrencyType())

            countSourceBefore = sourceTxns.getSize()
            countTargetBefore = targetTxns.getSize()

            output += "\n"
            output += "Source Account contains: {:>10} transactions\n".format(countSourceBefore)
            output += "Target Account contains: {:>10} transactions\n".format(countTargetBefore)
            del targetTxns

            # Validate against a loop where the source contains a txf to/from the target
            iCountLoops = 0
            output += "\nValidating against an account 'loop' where the source contains a txf to/from the target\n"

            sourceTxns = sorted(sourceTxns, key=lambda _x: (_x.getDateInt()))       # Sort for the log output of txns with loops

            for srcTxn in sourceTxns:

                if isinstance(srcTxn,SplitTxn):
                    if srcTxn.getParentTxn().getAccount() == targetAccount:
                        pass
                    else:
                        continue

                elif isinstance(srcTxn,ParentTxn):
                    # secTxn = TxnUtil.getSecurityPart(srcTxn)
                    xfrTxn = TxnUtil.getXfrPart(srcTxn)
                    feeTxn = TxnUtil.getCommissionPart(srcTxn)
                    incTxn = TxnUtil.getIncomePart(srcTxn)
                    expTxn = TxnUtil.getExpensePart(srcTxn)

                    if ((xfrTxn and xfrTxn.getAccount() == targetAccount)
                            or (feeTxn and feeTxn.getAccount() == targetAccount)
                            or (incTxn and incTxn.getAccount() == targetAccount)
                            or (expTxn and expTxn.getAccount() == targetAccount)):
                        pass
                    else:
                        continue

                else:
                    # Should never happen!!
                    txt = "Error: found a non-Parent / non-Split Txn - Cannot continue...:\n%s\nDate: %s\n" %(srcTxn.getSyncInfo().toMultilineHumanReadableString(), convertStrippedIntDateFormattedText(srcTxn.getDateInt()))
                    myPrint("B",txt)
                    txt2 = "%s: ERROR: Found a non-Parent / non-Split Txn - Cannot continue..." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt2, "R")
                    MyPopUpDialogBox(toolbox_frame_,txt2,txt,OKButtonText="ABORT",lAlertLevel=2).go()
                    return

                # OK - we have a loop - list them out for the user to find....
                pTxn = srcTxn.getParentTxn()
                iCountLoops += 1

                output += ".. *** LOOP DETECTED %s %s %s %s ***\n" %(convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                               pad(pTxn.getInvestTxnType().getIDString(),12),
                                               pad(pTxn.getDescription()+pTxn.getMemo(),60),
                                               rpad(sourceAccount.getCurrencyType().formatFancy(srcTxn.getValue(),MD_decimal),18))

            if iCountLoops < 1:
                output += "... to/from accounts validated... No account 'loops' should be created...\n"
            else:
                output += "... to/from accounts checked... %s account 'loops' could exist if we proceed with move/merge...\n" %(iCountLoops)
                jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
                if not MyPopUpDialogBox(jif,
                                       "Move/merge: Would create %s account loop(s) - Proceed or Cancel?" %(iCountLoops),
                                       ">>The txns that would cause an account 'loop' are shown on screen....\n"
                                       "%s source txns already refer to the new target account\n"
                                       "If you proceed, then these txns would refer to them themselves once move/merged\n"
                                       "This is illogical, and your cash balances might be 'incorrect'\n"
                                       "You can proceed and fix yourself later, or cancel to fix first before you proceed?!" %(iCountLoops),
                                       theTitle=_THIS_METHOD_NAME.upper(),
                                       OKButtonText="PROCEED",
                                       lCancelButton=True,
                                       lAlertLevel=1).go():
                    txt = "ERROR: %s Txns to move/merge includes the target account - would cause account 'loop(s)' - no changes made" %(iCountLoops)
                    myPrint("B", txt)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                    return

                else:
                    jif.dispose()
                    output += "\n*** to/from accounts failed validation. The move/merge will create %s txns with account 'loops' that refer to self. PLEASE FIX YOURSELF LATER ***\n" %(iCountLoops)

            sourceRCurr = sourceAccount.getCurrencyType()
            sourceStartBal = sourceAccount.getStartBalance()

            targetRCurr = targetAccount.getCurrencyType()
            targetStartBal = targetAccount.getStartBalance()

            if sourceStartBal == 0 and targetStartBal == 0:
                output += "\nSource & Target have starting cash balances of zero...\n"
            else:
                output += "\nSource starting cash balance: %s\n" %(sourceRCurr.formatSemiFancy(sourceStartBal,MD_decimal))
                output += "\nTarget starting cash balance: %s\n" %(targetRCurr.formatSemiFancy(targetStartBal,MD_decimal))

            ask = MyPopUpDialogBox(toolbox_frame_,
                                   "%s: from selected Investment account into another.. REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE MERGE" %(_THIS_METHOD_NAME),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s: - User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                myPrint("B",txt)
                setDisplayStatus(txt, "R")
                jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE MOVE FROM %s to %s?" %(sourceAccount,targetAccount)):
                return

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH MOVE/MERGE FROM %s to %s.....\n\n" %(sourceAccount, targetAccount)

            lAddCashBalances = False
            if sourceStartBal != 0:
                if myPopupAskQuestion(toolbox_frame_,"%s: - CASH BALANCES" %(_THIS_METHOD_NAME.upper()),"Do you want me to add source acct's starting cash balance of %s into target's?" %(sourceRCurr.formatSemiFancy(sourceStartBal,MD_decimal))):
                    lAddCashBalances = True
                    output += "User requested to add source acct's starting cash balance into target's...\n\n"
                else:
                    output += "User DECLINED to add source acct's starting cash balance into target's... It will therefore be left behind...\n\n"

            lDeleteEmptyAccount = False
            if sourceStartBal != 0 and not lAddCashBalances:
                txt = "NOTE: Source account cannot be auto-deleted post merge as it will be left with a cash starting balance..."
                myPopupInformationBox(toolbox_frame_,txt,"%s: - STARTING CASH BALANCE(S)" %(_THIS_METHOD_NAME.upper()))
                output += "%s\n\n" %(txt)

            elif JOptionPane.showOptionDialog(toolbox_frame_,
                                              "Do you want me to delete the resulting empty source account?",
                                              "%s: - CLEANUP?" %(_THIS_METHOD_NAME.upper()),
                                              JOptionPane.YES_NO_OPTION,
                                              JOptionPane.WARNING_MESSAGE,
                                              None,
                                              ["NO", "YES"], "NO") == 1:    # == 1 will == "YES"
                lDeleteEmptyAccount = True
                output += "User requested to delete the resulting source account: %s\n\n" %(sourceAccount)

            ################
            # LET'S DO IT! #
            ################

            # Prepare before totals...
            _WHAT = 0
            _QTY = 1
            _COSTBASIS = 2
            _VALUE = 3
            _CBFLAG = 4

            sourceValuesBefore = []
            targetValuesBefore = []

            lAnyCostBasisErrorsFound = [False]

            # noinspection PyUnresolvedReferences
            def create_totals(theCount, theAccount, theTable):
                _acctRelCurr = theAccount.getCurrencyType()
                theTable.append(["Txn Count",    theCount, "", "", ""])
                theTable.append(["Account Starting Balance", "","",_acctRelCurr.formatSemiFancy(theAccount.getStartBalance(),MD_decimal), ""])
                theTable.append(["Cash Balance", "", "", _acctRelCurr.formatSemiFancy(theAccount.getBalance(),MD_decimal), ""])
                _totals = [0.0, 0.0, _acctRelCurr.getDoubleValue(theAccount.getBalance()), False]
                lDetectCBError = False
                for acct in theAccount.getSubAccounts():
                    if acct.getAccountType() == Account.AccountType.SECURITY:

                        if not InvestUtil.isCostBasisValid(acct):
                            lDetectCBError = True
                            lAnyCostBasisErrorsFound[0] = True

                        _subAcctRelCurr = acct.getCurrencyType()
                        subAcctBal = acct.getBalance()
                        subAcctCostBasis = InvestUtil.getCostBasis(acct)
                        # price = (1.0 / _subAcctRelCurr.adjustRateForSplitsInt(DateUtil.convertCalToInt(today), _subAcctRelCurr.getRelativeRate()))                        # noqa
                        price = CurrencyTable.getUserRate(_subAcctRelCurr, _acctRelCurr)                                # noqa

                        _totals[0] += _subAcctRelCurr.getDoubleValue(subAcctBal)
                        _totals[1] += _acctRelCurr.getDoubleValue(subAcctCostBasis)
                        _totals[2] +=  round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())
                        if lDetectCBError: _totals[3] = True
                        theTable.append([acct.getAccountName(),
                                         _subAcctRelCurr.formatSemiFancy(subAcctBal,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(subAcctCostBasis,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())),MD_decimal),
                                         lDetectCBError])
                theTable.append(["**TOTALS:",
                                 _totals[0],
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[1]),MD_decimal),
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[2]),MD_decimal),
                                _totals[3]])

            create_totals(countSourceBefore, sourceAccount, sourceValuesBefore)
            create_totals(countTargetBefore, targetAccount, targetValuesBefore)

            if lAnyCostBasisErrorsFound[0]:
                output += "\n\n** WARNING: Lot Control / Cost Basis errors detected before changes started - review output....\n\n"
            else:
                output += "\nLot Control / Cost Basis reports OK before changes....\n"

            output += "\n"

        except:
            txt = "MINOR ERROR - Move/merge crashed before any move/merge. Please review output and console".upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame("MINOR ERROR - %s:" %(_THIS_METHOD_NAME.upper()),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing move/merge right now..",
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          theWidth=100,
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-move/merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the move/merge..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            # Start by adding any Account Starting Cash Balances....
            if lAddCashBalances:
                txt = "Adding source starting cash balance: %s to target's: %s = %s"\
                      %(sourceRCurr.formatSemiFancy(sourceStartBal,MD_decimal),
                        targetRCurr.formatSemiFancy(targetStartBal,MD_decimal),
                        targetRCurr.formatSemiFancy(sourceStartBal+targetStartBal,MD_decimal))

                myPrint("B", txt); output += "%s\n" %(txt)

                targetAccount.setEditingMode()
                targetAccount.setStartBalance(sourceStartBal+targetStartBal)
                targetAccount.setParameter(PARAMETER_KEY,True)
                targetAccount.syncItem()

                sourceAccount.setEditingMode()
                sourceAccount.setStartBalance(0)
                sourceAccount.setParameter(PARAMETER_KEY,True)
                sourceAccount.syncItem()


            # Now create any missing security sub account(s)...
            if len(securities_to_create) > 0:
                txt = "Adding %s missing security(s) to target Investment Account:" %(len(securities_to_create))
                myPrint("B", txt); output += "%s\n" %(txt)

                for sec_to_create in securities_to_create:
                    txt = "... Creating: %s" %(sec_to_create.getAccountName())
                    myPrint("B", txt); output += "%s\n" %(txt)

                    newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(),
                                                          Account.AccountType.SECURITY,
                                                          targetAccount)
                    newSecurityAcct.setEditingMode()
                    newSecurityAcct.getUUID()
                    newSecurityAcct.setAccountName(sec_to_create.getAccountName())
                    newSecurityAcct.setCurrencyType(sec_to_create.getCurrencyType())
                    newSecurityAcct.setStartBalance(0)

                    newSecurityAcct.setUsesAverageCost(sec_to_create.getUsesAverageCost())
                    newSecurityAcct.setBroker(sec_to_create.getBroker())
                    newSecurityAcct.setBrokerPhone(sec_to_create.getBrokerPhone())
                    newSecurityAcct.setAPR(sec_to_create.getAPR())
                    newSecurityAcct.setBondType(sec_to_create.getBondType())
                    newSecurityAcct.setComment(sec_to_create.getComment())
                    newSecurityAcct.setCompounding(sec_to_create.getCompounding())
                    newSecurityAcct.setFaceValue(sec_to_create.getFaceValue())
                    newSecurityAcct.setFaceValue(sec_to_create.getFaceValue())
                    newSecurityAcct.setMaturity(sec_to_create.getMaturity())
                    newSecurityAcct.setMonth(sec_to_create.getMonth())
                    newSecurityAcct.setNumYears(sec_to_create.getNumYears())
                    newSecurityAcct.setPut(sec_to_create.getPut())
                    newSecurityAcct.setOptionPrice(sec_to_create.getOptionPrice())
                    newSecurityAcct.setDividend(sec_to_create.getDividend())
                    newSecurityAcct.setExchange(sec_to_create.getExchange())
                    newSecurityAcct.setSecurityType(sec_to_create.getSecurityType())
                    newSecurityAcct.setSecuritySubType(sec_to_create.getSecuritySubType())
                    newSecurityAcct.setStrikePrice(sec_to_create.getStrikePrice())

                    for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                        newSecurityAcct.setParameter(param, sec_to_create.getParameter(param))

                    newSecurityAcct.setParameter(PARAMETER_KEY,True)
                    newSecurityAcct.syncItem()
                    targetSecurities.append(newSecurityAcct)


            copyTxns = sourceTxns
            del sourceTxns

            txt = "Now Moving/Merging transactions...:"
            myPrint("B", txt); output += "\n\n%s\n" %(txt)

            # now for the merge/move of the transactions...
            for srcTxn in copyTxns:

                if isinstance(srcTxn, SplitTxn):      # This is a cash transfer
                    pTxn = srcTxn.getParentTxn()
                    pTxn.setEditingMode()
                    srcTxn.setAccount(targetAccount)
                    srcTxn.setParameter(PARAMETER_KEY,True)
                    pTxn.syncItem()
                    output += ".. %s %s %s %s\n" %(convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                   pad(pTxn.getInvestTxnType().getIDString(),12),
                                                   pad(pTxn.getDescription()+pTxn.getMemo(),60),
                                                   rpad(sourceAccount.getCurrencyType().formatFancy(srcTxn.getValue(),MD_decimal),18))
                    continue

                # Thus, we are on a parent...
                if not isinstance(srcTxn, ParentTxn): raise Exception("Error: found a non-parent: %s" %(srcTxn))
                srcTxn.setEditingMode()
                for iSplit in range(0, srcTxn.getSplitCount()):
                    theSplit = srcTxn.getSplit(iSplit)
                    theSrcSplitAcct = theSplit.getAccount()
                    if theSrcSplitAcct.getAccountType() == Account.AccountType.SECURITY:
                        trgSec = find_src_sec_in_target(theSrcSplitAcct.getCurrencyType())
                        theSplit.setAccount(trgSec)
                srcTxn.setParameter(PARAMETER_KEY,True)
                srcTxn.setAccount(targetAccount)
                srcTxn.syncItem()
                output += ".. %s %s %s %s\n" %(convertStrippedIntDateFormattedText(srcTxn.getDateInt()),
                                               pad(srcTxn.getInvestTxnType().getIDString(),12),
                                               pad(srcTxn.getDescription()+srcTxn.getMemo(),60),
                                               rpad(sourceAccount.getCurrencyType().formatFancy(srcTxn.getValue(),MD_decimal),18))

            del copyTxns

            output += "\n>> Move/merge completed..\n\n"

        except:

            txt = ("MAJOR ERROR - %s: crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame("MAJOR ERROR - %s:" %(_THIS_METHOD_NAME.upper()),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset move/merge changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es)..")
            MD_REF.getUI().getMain().saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # Confirm that there are no txns left in the source account...
            sourceTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(sourceAccount)
            targetTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(targetAccount)
            countSourceAfter = sourceTxns.getSize()
            countTargetAfter = targetTxns.getSize()
            output += "Source Account now contains: {:>10} transactions\n".format(countSourceAfter)
            output += "Target Account now contains: {:>10} transactions\n".format(countTargetAfter)

            del sourceTxns, targetTxns

            if countSourceAfter == 0:
                output += "\nVerified that source account now contains ZERO txns...\n"
            else:
                txt = "ERROR: source account %s still seems to have %s transactions" %(sourceAccount, countSourceAfter)
                myPrint("B", txt); output += "\n%s\n" %(txt)
                jif = QuickJFrame(_THIS_METHOD_NAME.upper(),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                setDisplayStatus(txt, "R")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if countTargetAfter == (countSourceBefore + countTargetBefore):
                output += "Verified that ending target txn count of %s is equal to original source %s + target %s\n"\
                          %(countTargetAfter, countSourceBefore, countTargetBefore)
            else:
                txt = "ERROR: target account txn count of %s is NOT equal to original source %s + target %s!"\
                      %(countTargetAfter, countSourceBefore, countTargetBefore)
                myPrint("B", txt); output += "\n%s\n" %(txt)
                jif = QuickJFrame(_THIS_METHOD_NAME.upper(),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                setDisplayStatus(txt, "R")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            # Total up the Accounts after the merge...
            sourceValuesAfter = []
            targetValuesAfter = []

            lAnyCostBasisErrorsFound[0] = False
            create_totals(countSourceAfter, sourceAccount, sourceValuesAfter)
            create_totals(countTargetAfter, targetAccount, targetValuesAfter)

            # Delete the empty Account(s) if requested...
            # Don't forget we block this earlier on if source has a starting balance and user did not request to add into target
            if lDeleteEmptyAccount:
                MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
                MD_REF.getUI().setSuspendRefresh(True)

                txt = "Now deleting the empty source account after removing associated Securities..:"
                myPrint("B", txt); output += "%s\n\n" %(txt)

                for subAcct in sourceAccount.getSubAccounts():
                    subAcct.deleteItem()
                sourceAccount.deleteItem()

                MD_REF.getUI().getMain().saveCurrentAccount()
                MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
                MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            # OK - Main update is done....

            output += "\n\n ***\n\n" \
                      "STATISTICS OF ACCOUNTS BEFORE AND AFTER...\n"\
                     " =========================================\n\n"
            output += "BEFORE:\n"\
                      "-----------------------------------------------------\n"

            def output_stats(theText, theAccount, theTable):

                if theAccount.getCurrencyType() == base or theAccount.getCurrencyType() is None:
                    relText = ""
                else:
                    relText = " relative to %s" %(theAccount.getCurrencyType().getRelativeCurrency())

                local_output = "%s: %s (Currency: %s%s)\n" %(theText, theAccount, theAccount.getCurrencyType(), relText)
                iRow = 1
                posInc = 0
                for data in theTable:
                    if iRow == 2:
                        posInc += 14
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("Qty Shares",12), rpad("Cost Basis",15), rpad("Current Value",15))
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    if iRow == 4:
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("",12), rpad("",15), rpad("-------------",15))

                    if data[_WHAT].upper() == "**TOTALS:".upper():
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    cbMsg = ""
                    if data[_CBFLAG]: cbMsg = " * Cost Basis Error detected"
                    local_output += "   %s %s %s %s %s\n" %(pad(data[_WHAT],60+posInc),rpad(data[_QTY],12), rpad(data[_COSTBASIS],15), rpad(data[_VALUE],15),cbMsg)
                    iRow += 1
                return local_output

            output += output_stats("Source", sourceAccount, sourceValuesBefore)
            output += "\n"
            output += output_stats("Target", targetAccount, targetValuesBefore)

            output += "\n\n"
            output += "AFTER:\n" \
                      "-------------------------------------------------------\n"

            output += output_stats("Source", sourceAccount, sourceValuesAfter)
            output += "\n"
            output += output_stats("Target", targetAccount, targetValuesAfter)

            if lAnyCostBasisErrorsFound[0]:
                output += "\n\n** WARNING: Lot Control / Cost Basis errors detected after changes completed - review output....\n\n"
            else:
                output += "\nLot Control / Cost Basis reports OK after changes....\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and these move/merge txns) back to disk.....",
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              theWidth=100,
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                pleaseWait.kill()

            if lAnyCostBasisErrorsFound[0]:
                txt = "%s: from %s to %s completed. NOTE: You have Lot Control errors >> please review log and check the results..." %(_THIS_METHOD_NAME, sourceAccount, targetAccount)
                optionColor = "R"
                optionFlag = JOptionPane.WARNING_MESSAGE
            else:
                txt = "%s: from %s to %s successfully completed - please review log and check the results..." %(_THIS_METHOD_NAME, sourceAccount, targetAccount)
                optionColor = "DG"
                optionFlag = JOptionPane.INFORMATION_MESSAGE

            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES ***\n\n"
            output += "\n<END>"

        except:
            txt = ("ERROR - %s crashed after the move/merge. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame("ERROR - %s:" %(_THIS_METHOD_NAME.upper()),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame("%s COMPLETED:" %(_THIS_METHOD_NAME.upper()),output,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
        setDisplayStatus(txt, optionColor)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionFlag)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_non_hier_sec_acct_txns():

        _THIS_METHOD_NAME = "FIX: Non-Hierarchical Security Acct Txn".upper()

        PARAMETER_KEY = "toolbox_fix_non_hier_sec_acct_txns"

        # fix_non-hierarchical_security_account_txns.py
        # (replaces fix_investment_txns_to_wrong_security.py)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("B", "Diagnosing Investment Transactions where Security's Account is not linked properly to the Parent Txn's Acct")
        myPrint("P", "-----------------------------------------------------------------------------------------------------------")

        output = "FIX Investment Transactions where Security's Account is not linked properly to the Parent Txn's Acct:\n" \
                 " =====================================================================================================\n\n"

        try:
            txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
            txns = txnSet.iterableTxns()
            fields = InvestFields()

            iOrphans = 0
            txt = "Scanning for Security Orphans...:"
            output += "\n%s\n" %(txt); myPrint("B",txt)
            for _txn in txns:
                if not isinstance(_txn, ParentTxn): continue   # only work with parent transactions
                _acct = _txn.getAccount()
                if _acct.getAccountType() != Account.AccountType.INVESTMENT: continue                                   # noqa
                fields.setFieldStatus(_txn)

                if fields.hasSecurity and fields.security is None:
                    iOrphans += 1
                    txt = "ERROR: Txn for 'Orphaned' Security %s found within Investment Account %s! (Have you force removed a Security with linked TXNs?\n" \
                          "txn:\n%s\n" %(fields.security, _acct, _txn.getSyncInfo().toMultilineHumanReadableString())
                    output += "\n%s\n" %(txt); myPrint("B",txt)

            if iOrphans:
                txt = "ERROR: %s investment txn(s) with 'Orphaned'securities detected (probably User Force Removal of Security from Investment Account)" %(iOrphans)
                output += "\n%s\n" %(txt); myPrint("B",txt)
                output += "\n<ABORTED>"
                setDisplayStatus(txt, "R")
                jif = QuickJFrame(_THIS_METHOD_NAME,output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
                MyPopUpDialogBox(jif,txt,
                                 "It's highly likely that you have clicked 'Actions' > 'Remove Security' from an Investment Account..\n"
                                 ".. and that this Security had linked Transactions... You would have been warned and asked to respond 'yes'\n"
                                 ".. this will have deleted Buy/Sell TXNs and partially removed the Security from other TXNs like buy/Sell/Xfr etc\n"
                                 ".. these are now illogical and damaged records.... The data is lost and not recoverable. Toolbox CANNOT REPAIR!\n"
                                 ">> You will need to restore, and or manually edit and repair the TXNs with your own knowledge of what was lost...",
                                 theTitle=_THIS_METHOD_NAME,OKButtonText="ACKNOWLEDGED",lAlertLevel=1).go()
                return

            else:
                txt = ">> No investment txn(s) with Orphaned securities were detected - phew!"
                output += "\n%s\n" %(txt); myPrint("B",txt)

            output += "\n\n"

            def review_security_accounts(_txns, FIX_MODE=False):

                count_the_errors = 0
                count_unfixable_yet = 0
                errors_fixed = 0
                text = ""
                for txn in _txns:
                    if txn.getParentTxn() != txn: continue   # only work with parent transactions

                    acct = txn.getAccount()
                    # noinspection PyUnresolvedReferences
                    if acct.getAccountType() != Account.AccountType.INVESTMENT: continue

                    # at this point we are only dealing with investment parent txns
                    fields.setFieldStatus(txn)

                    if fields.hasSecurity and not acct.isAncestorOf(fields.security):
                        count_the_errors += 1
                        txnTxt = txn.toMultilineString().replace(";",";\n")
                        text+=("Must fix txn %s\n"
                               "%s\n"
                               " > in %s with sec acct %s\n" %(fields.txnType, txnTxt, acct, fields.security.getFullAccountName()))
                        # This fix assumes that the split / security bit should sit within the txn's parent account. It seeks for the same
                        # security in this account and reattaches it.

                        # Alternatively you could txn.setAccount() to be the split security's parent account
                        # e.g. txn.setAccount(fields.security.getParentAccount())

                        secCurr = fields.security.getCurrencyType()
                        correctSecAcct = None
                        for subacct in AccountUtil.getAccountIterator(acct):
                            if subacct.getCurrencyType() == secCurr:
                                correctSecAcct = subacct
                                break

                        if not correctSecAcct:
                            if FIX_MODE:
                                _txt = ".. Security sub-acct '%s' not found within this Investment account '%s' - so manually creating/adding..." %(secCurr.getName(), acct)
                                text += "%s\n" %(_txt); myPrint("B",_txt)

                                # need to create the Security sub-account in this Investment Account....
                                newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(), Account.AccountType.SECURITY, acct)   # noqa
                                newSecurityAcct.setEditingMode()
                                newSecurityAcct.getUUID()
                                newSecurityAcct.setAccountName(fields.security.getAccountName())
                                newSecurityAcct.setCurrencyType(fields.security.getCurrencyType())
                                newSecurityAcct.setStartBalance(0)

                                newSecurityAcct.setUsesAverageCost(fields.security.getUsesAverageCost())
                                newSecurityAcct.setBroker(fields.security.getBroker())
                                newSecurityAcct.setBrokerPhone(fields.security.getBrokerPhone())
                                newSecurityAcct.setAPR(fields.security.getAPR())
                                newSecurityAcct.setBondType(fields.security.getBondType())
                                newSecurityAcct.setComment(fields.security.getComment())
                                newSecurityAcct.setCompounding(fields.security.getCompounding())
                                newSecurityAcct.setFaceValue(fields.security.getFaceValue())
                                newSecurityAcct.setMaturity(fields.security.getMaturity())
                                newSecurityAcct.setMonth(fields.security.getMonth())
                                newSecurityAcct.setNumYears(fields.security.getNumYears())
                                newSecurityAcct.setPut(fields.security.getPut())
                                newSecurityAcct.setOptionPrice(fields.security.getOptionPrice())
                                newSecurityAcct.setDividend(fields.security.getDividend())
                                newSecurityAcct.setExchange(fields.security.getExchange())
                                newSecurityAcct.setSecurityType(fields.security.getSecurityType())
                                newSecurityAcct.setSecuritySubType(fields.security.getSecuritySubType())
                                newSecurityAcct.setStrikePrice(fields.security.getStrikePrice())

                                for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                                    newSecurityAcct.setParameter(param, fields.security.getParameter(param))

                                newSecurityAcct.setParameter(PARAMETER_KEY,True)
                                newSecurityAcct.syncItem()

                                correctSecAcct = newSecurityAcct
                            else:
                                text+=(" -> will need to auto-create/add Security and then assign txn to %s\n" %(acct))

                        if correctSecAcct:
                            if FIX_MODE:
                                errors_fixed += 1
                                text+=(" -> ASSIGNING txn to %s\n" %(correctSecAcct.getFullAccountName()))
                                fields.security = correctSecAcct
                                fields.storeFields(txn)
                                txn.syncItem()
                            else:
                                text+=(" -> need to assign txn to %s\n" %(correctSecAcct.getFullAccountName()))

                del _txns
                return text, count_the_errors, count_unfixable_yet, errors_fixed

            x, iCountErrors, iCountUnfixable, iErrorsFixed = review_security_accounts(txns, FIX_MODE=False)
            output += x

            output += "\n\nYou have %s errors, with %s needing manual fixes first... I have fixed %s\n\n" %(iCountErrors, iCountUnfixable, iErrorsFixed)

            if iCountErrors<1:
                txt = "%s: CONGRATULATIONS - I found no Invalid txns......." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt)
                return

            myPrint("B","%s: found %s errors... with %s needing manual fixes" %(_THIS_METHOD_NAME, iCountErrors, iCountUnfixable))

            jif = QuickJFrame("VIEW Investment Security Txns with Invalid Parent Accounts".upper(), output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if iCountUnfixable>0:
                txt = "%s: You have %s errors to manually first first!" %(_THIS_METHOD_NAME, iCountUnfixable)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,"You have %s errors to manually first first!" %(iCountUnfixable), _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME,"FIX %s Security Txns with Invalid Parent Accts?" %(iCountErrors)):
                return

            jif.dispose()       # already within the EDT
            myPrint("B", "User accepted disclaimer to FIX Investment Security Txns with Invalid Parent Accounts. Proceeding.....")

            output += "\n\nRUNNING FIX ON SECURITY TXNS TO RE-LINK PARENT ACCOUNTS\n" \
                      "------------------------------------------------------------\n\n"

            MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the move/changes..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            x, iCountErrors, iCountUnfixable, iErrorsFixed = review_security_accounts(txns, FIX_MODE=True)
            del txns, txnSet

            MD_REF.getUI().getMain().saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            output += x
            output += "\n\nYou had %s errors, with %s needing manual fixes first... I HAVE FIXED %s\n\n" %(iCountErrors, iCountUnfixable, iErrorsFixed)
            output += "\n<END>"

            play_the_money_sound()
            txt = "FIXED %s Investment Security Txns with Invalid Parent Accounts" %(iErrorsFixed)
            setDisplayStatus(txt, "DG"); myPrint("B", txt)
            jif = QuickJFrame(_THIS_METHOD_NAME, output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)

        except:
            output += dump_sys_error_to_md_console_and_errorlog(True)
            txt = "%s: ERROR - Script has crashed. Review screen and console!" %(_THIS_METHOD_NAME)
            output += txt + "\n"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif = QuickJFrame(_THIS_METHOD_NAME, output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt, _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def detect_non_hier_sec_acct_or_orphan_txns():

        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        txns = txnSet.iterableTxns()
        fields = InvestFields()

        count_the_errors = 0

        for txn in txns:

            if not isinstance(txn, ParentTxn): continue   # only work with parent transactions

            acct = txn.getAccount()

            # noinspection PyUnresolvedReferences
            if acct.getAccountType() != Account.AccountType.INVESTMENT: continue

            # at this point we are only dealing with investment parent txns
            fields.setFieldStatus(txn)

            if fields.hasSecurity and not acct.isAncestorOf(fields.security):
                count_the_errors += 1
                myPrint("B", "ERROR: Txn for Security %s found within Investment Account %s that is cross linked to another account (or Security is orphaned)!\n"
                             "txn:\n%s\n" %(fields.security, acct, txn.getSyncInfo().toMultilineHumanReadableString()))
        del txnSet, txns

        if count_the_errors:
            myPrint("B", "ERROR: %s investment txn(s) with cross-linked securities detected" %(count_the_errors))
        else:
            myPrint("DB", "NOTE: No investment txn(s) with cross-linked securities were detected - phew!")

        return count_the_errors


    def fix_delete_one_sided_txns():

        # delete_invalid_txns.py
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("B", "Script running to analyse whether you have any one sided transactions - usually from Quicken Imports....")
        myPrint("P", "--------------------------------------------------------------------------------------------------------")

        book = MD_REF.getCurrentAccountBook()
        txnSet = book.getTransactionSet()
        txns = txnSet.iterableTxns()

        output = ""
        toDelete = []

        output +="\nLIST OF ONE SIDED TRANSACTIONS (usually from Quicken Imports)\n"
        output +="-------------------------------------------------------------\n"

        for txn in txns:
            if txn.getOtherTxnCount() == 0:
                output += pad(str(txn.getUUID()),50)+" "
                output += "Date: "+pad(str(txn.getDateInt()),15)+" "
                output += pad(str(txn.getAccount()),25)+" "
                output += pad(str(txn.getAccount().getAccountType()),25)+" "
                output += pad(str(txn.getTransferType()),15)+" "
                output += rpad(str(txn.getValue()),12)+" "
                output += "\n"

                toDelete.append(txn)

        if not len(toDelete)>0:

            txt = "You have no one-sided transactions to delete!!"
            setDisplayStatus(txt, "B")
            myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE ONE-SIDE TXNS", JOptionPane.INFORMATION_MESSAGE)
            return

        output += "\n<END>"

        jif=QuickJFrame("LIST OF ONE SIDED TRANSACTIONS (usually from Quicken Imports)", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        myPrint("J","You have %s one-sided transactions that can be deleted!!"%len(toDelete))
        myPopupInformationBox(jif, "You have %s one-sided transactions that can de deleted!!"%len(toDelete), "DELETE ONE-SIDE TXNS", JOptionPane.WARNING_MESSAGE)

        if not confirm_backup_confirm_disclaimer(jif, "DELETE ONE-SIDED TRANSACTIONS", "delete %s one-sided transactions?" %(len(toDelete))):
            return

        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for t in toDelete:
            myPrint("J", "Item %s deleted" %t.getUUID())
            t.deleteItem()

        MD_REF.getUI().getMain().saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        play_the_money_sound()
        txt = "%s Invalid One-Sided Transactions DELETED!" %(len(toDelete))
        setDisplayStatus(txt, "DG")
        myPrint("B", txt)
        myPopupInformationBox(jif,txt, "DELETE ONE-SIDE TXNS", JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def convert_stock_avg_cst_control():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX - Non Hierarchical Security Account Txns (cross-linked securities)' >> no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,"CONVERT ACCT/STOCK TO Avg Cst Ctrl","Do you want to convert a stock to Average Cost Control and reset/wipe any LOT data?",theMessageType=JOptionPane.WARNING_MESSAGE):
            myPopupInformationBox(toolbox_frame_,"NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        accountsList = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(14))
        accountsList = sorted(accountsList, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        accountSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                 "Select a LOT Controlled Acct/Stock to convert to Avg Cost Control",
                                                 "CONVERT ACCT/STOCK TO Avg Cst Ctrl",
                                                 JOptionPane.INFORMATION_MESSAGE,
                                                 MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                 accountsList,
                                                 None)

        if not accountSec:
            txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl - No Account/Security was selected - no changes made.."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        class SecurityObj:
            def __init__(self,Obj,Book):                                                                                # noqa
                self.Obj = Obj
                self.Acct = Obj.getParentAccount()
                self.TxnSet = Book.getTransactionSet().getTransactionsForAccount(Obj)
                self.Name = Obj.getAccountName()
                self.Num = Obj.getAccountNum()
                self.Type = "SECURITY"
                self.AvgCost = Obj.getUsesAverageCost()
                self.Txns = []
                for _Txn in self.TxnSet: self.Txns.append(TxnObj(_Txn))

        class TxnObj:
            def __init__(self,Txn):                                                                                     # noqa
                self.Obj = Txn
                self.Parent = Txn.getParentTxn()
                self.ID = Txn.getUUID()
                self.DateInt = Txn.getDateInt()
                self.Type = self.Parent.getInvestTxnType().getIDString()
                self.saveCostBasisState = self.Obj.getParameter("cost_basis",None)

        Book = MD_REF.getCurrentAccountBook()

        # We are forcing just the one selected Security into the List (the original script allowed user to hard code several)
        Securities = [SecurityObj(accountSec,Book)]

        iErrors=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    iErrors+=1

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "CONVERT ACCT/STOCK TO Avg Cst Ctrl","Convert %s to Avg Cst Control and wipe %s LOT records?" %(accountSec,iErrors)):
            return

        listWiped=""
        for Security in Securities:
            myPrint("B","@@ User requested to convert Acct/Security %s to Average Lot Control and wipe %s LOT records... EXECUTING NOW" %(Security.Obj, iErrors))
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    listWiped+=" %s Wiped LOT tag on record (was: %s)\n" %(Security.Obj, Txn.Obj.getParameter("cost_basis", None))
                    myPrint("B","@@ Security %s Wiping LOT record on %s" %(Security.Obj, Txn.Obj))
                    Txn.Obj.setParameter("cost_basis", None)
                    Txn.Obj.syncItem()

            Security.Obj.setUsesAverageCost(True)
            Security.AvgCost = True
            Security.Obj.syncItem()

        txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl - Security %s Changed to Average Cost Control (and %s LOT records wiped)"%(accountSec,iErrors)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        MyPopUpDialogBox(toolbox_frame_,
                         theStatus="Security %s converted to Average Cost Control (I wiped %s LOT records - shown below)" %(accountSec,iErrors),
                         theMessage="%s" %(listWiped),
                         theWidth=200,
                         theTitle="CONVERT ACCT/STOCK TO Avg Cst Ctrl",
                         lAlertLevel=1).go()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def convert_stock_lot_FIFO():
        # MakeFifoCost.py (author unknown)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "CONVERT ACCT/STOCK TO LOT/FIFO: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX - Non Hierarchical Security Account Txns (cross-linked securities)' >> no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,"CONVERT ACCT/STOCK TO LOT/FIFO","Do you want to attempt to convert a stock to LOT Controlled and match Sells to Buys using FiFo?",theMessageType=JOptionPane.WARNING_MESSAGE):
            myPopupInformationBox(toolbox_frame_,"NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        accountsList = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(13))
        accountsList = sorted(accountsList, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        accountSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                 "Select an Avg Cost Controlled Acct/Stock to convert to LOT/FiFo",
                                                 "CONVERT STOCK FIFO",
                                                 JOptionPane.INFORMATION_MESSAGE,
                                                 MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                 accountsList,
                                                 None)

        if not accountSec:
            txt = "CONVERT STOCK FIFO - No Account/Security was selected - no changes made.."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # noinspection PyUnresolvedReferences
        if len(accountSec.getCurrencyType().getSplits()) >0:
            # noinspection PyUnresolvedReferences
            txt = "CONVERT STOCK FIFO - SORRY - You have %s split(s) on this security %s. I have not been programmed to deal with these - contact author...." %(len(accountSec.getCurrencyType().getSplits()),accountSec)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, "CONVERT STOCK FIFO", theMessageType=JOptionPane.ERROR_MESSAGE)
            return


        MyPopUpDialogBox(toolbox_frame_,
                         theStatus="Information before you proceed: %s" %(accountSec),
                         theMessage="This function updates the Acct/Security records as it progresses to generate the report\n"
                                    "There is no pre-report for you to validate/confirm\n"
                                    "1. It will ask you to confirm I can wipe any existing LOT tags incorrectly set first (I will save these)\n"
                                    "2. The report will run, Convert to LOT Control, update the LOT records, and show you the results\n"
                                    "3. If you are not happy, I can reset the Security back to Avg Cost Control (removing/resetting LOT tags)\n"
                                    "4. I will restore wiped (incorrect) LOT tags back to the saved data from step 1.\n"
                                    "** You will be asked to confirm and perform a backup then proceed in the next step....",
                         theWidth=200,
                         theTitle="CONVERT STOCK FIFO",
                         OKButtonText="I HAVE READ THIS",
                         lAlertLevel=1).go()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "CONVERT STOCK FIFO","Convert %s to LOT control and assign FiFio?" %(accountSec)):
            return

        class SecurityObj:
            def __init__(self,Obj,Book):                                                                                # noqa
                self.Obj = Obj
                self.Acct = Obj.getParentAccount()
                self.TxnSet = Book.getTransactionSet().getTransactionsForAccount(Obj)
                self.Name = Obj.getAccountName()
                self.Num = Obj.getAccountNum()
                self.Type = "SECURITY"
                self.Balance = Obj.getBalance()
                self.CurTyp = Obj.getCurrencyType()
                self.AvgCost = Obj.getUsesAverageCost()
                self.Txns = []
                for _Txn in self.TxnSet:
                    self.Txns.append(TxnObj(_Txn))
                self.Txns.sort(key=lambda l: l.Date)

        class TxnObj:
            def __init__(self,Txn):                                                                                     # noqa
                self.Obj = Txn
                self.Parent = Txn.getParentTxn()
                self.ID = Txn.getUUID()
                self.DateInt = Txn.getDateInt()
                self.Type = self.Parent.getInvestTxnType().getIDString()
                # noinspection PyUnresolvedReferences
                self.Date = datetime.datetime.fromtimestamp(DateUtil.convertIntDateToLong(Txn.getDateInt()).time/1e3)
                self.LngShrs = Txn.getValue()
                securityAcct = Txn.getAccount()
                securityCurr = securityAcct.getCurrencyType()
                self.Shares = securityCurr.getDoubleValue(Txn.getValue())
                self.saveCostBasisState = self.Obj.getParameter("cost_basis",None)

        def MakeCostsFifo(Security,Book, INCLUDE_THE_ZEROS):                                                            # noqa
            WrngCnt = 0                                                                                                 # noqa

            textLog = ""

            if not Security.AvgCost:
                _txt = "CONVERT STOCK FIFO - ERROR - Security is already using LOT control - LOGIC ERROR - ABORTING!"
                setDisplayStatus(_txt, "R")
                return
            else:
                textLog+=("Setting the Security '{}:{}' to FIFO lot matching.\n\n".format(Security.Acct.getAccountName(),Security.Name))

                # If you don't do this here, then InvestUtil.getRemainingLots() returns None
                Security.Obj.setUsesAverageCost(False)
                Security.AvgCost = False
                Security.Obj.syncItem()

                for Txn in Security.Txns:                                                                               # noqa
                    if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                            and (Txn.LngShrs != 0 or INCLUDE_THE_ZEROS)):
                        RLots = InvestUtil.getRemainingLots(Book,Security.Obj,Txn.Obj.getDateInt())
                        ShrsLeft = -(Txn.LngShrs)
                        Buys = ""
                        prettyBuys = ""
                        for Txn2 in Security.Txns:
                            if Txn2.LngShrs > 0 and Txn2.ID in RLots:
                                RInfo = RLots.get(Txn2.ID)
                                # noinspection PyUnresolvedReferences
                                RShrs = RInfo.getAvailableShares()
                                if RShrs >= ShrsLeft:
                                    Buys += "{}:{};".format(Txn2.ID,ShrsLeft)
                                    prettyBuys += "BUY-{}:{};".format(Txn2.DateInt,Txn.Obj.getAccount().getCurrencyType().getDoubleValue(ShrsLeft))
                                    ShrsLeft = 0
                                    break
                                elif RShrs > 0:
                                    Buys += "{}:{};".format(Txn2.ID,RShrs)
                                    prettyBuys += "BUY-{}:{};".format(Txn2.DateInt,Txn.Obj.getAccount().getCurrencyType().getDoubleValue(RShrs))
                                    ShrsLeft -= RShrs
                        if ShrsLeft > 0:
                            textLog+=("@@ WARNING! Came up short %s shares for ID='%s' on date=%s!\n" %(rpad(Txn.Obj.getAccount().getCurrencyType().getDoubleValue(ShrsLeft),12),Txn.ID,Txn.Date.strftime("%Y/%m/%d")))
                            WrngCnt += 1
                        if len(Buys) > 0:
                            Txn.Obj.setParameter("cost_basis",Buys)
                            Txn.Obj.syncItem()
                            Txn.Obj.getParentTxn().syncItem()
                            textLog+=("cost_basis for the sale dated: %s of %s shares on %s set to '%s'\n" %(Txn.DateInt,rpad(Txn.Shares,12),Txn.Date.strftime("%Y/%m/%d"),prettyBuys))
                    else:
                        if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())):
                            textLog+=("skipped ZERO sale dated: %s of %s shares...'\n" %(Txn.DateInt,rpad(Txn.Shares,12)))

            return WrngCnt, textLog

        output = "CONVERT STOCK FIFO (Convert Accounts/Security using Avg Cost Control to LOT control & assign FiFo)\n" \
                 " =================================================================================================\n\n"

        WrngCnt = 0
        Book = MD_REF.getCurrentAccountBook()

        # We are forcing just the one selected Security into the List (the original script allowed user to hard code several)
        Securities = [SecurityObj(accountSec,Book)]

        iErrors=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    iErrors+=1
        if iErrors>0:
            if not myPopupAskQuestion(toolbox_frame_,"CONVERT STOCK FIFO",
                                      "WARNING: I found %s LOTS already set on account/security. Do you want to proceed (and overwrite) these?" %(iErrors),
                                      theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "CONVERT STOCK FIFO - ABORTED - as Acct/Security %s already had %s LOT records!!??" %(accountSec, iErrors)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            myPrint("B", "CONVERT STOCK FIFO - RESETTING %s LOT TAGS on Acct/Security %s!!"%(iErrors, accountSec))
            output+=("\nRESETTING %s LOT TAGS on Acct/Security %s!!\n"%(iErrors, accountSec))

            for Security in Securities:
                for Txn in Security.Txns:
                    if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                            and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                        output+=" > Found LOT tag on Sale record, when it should be None... Resetting to None (was SELL %s Shrs Dated:%s: %s)\n" %(rpad(Txn.Shares,12),Txn.DateInt,Txn.Obj.getParameter("cost_basis", None))
                        Txn.Obj.setParameter("cost_basis", None)
                        Txn.Obj.syncItem()

        iSellZeros=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType()) and Txn.LngShrs == 0):
                    iSellZeros+=1

        lIncludeSellZeros=False
        if iSellZeros>0:
            if myPopupAskQuestion(toolbox_frame_,"CONVERT STOCK FIFO",
                                  "WARNING: I found %s Sale Txns for ZERO shares. YES = INCLUDE and match these to Zero Buys; NO = SKIP/IGNORE them?" %(iSellZeros),
                                  theMessageType=JOptionPane.WARNING_MESSAGE):
                myPrint("B", "CONVERT STOCK FIFO: Acct/Security %s - Will match %s ZERO sales too..."%(accountSec, iSellZeros))
                lIncludeSellZeros = True

        for Security in Securities:
            count, text = MakeCostsFifo(Security,Book, lIncludeSellZeros)
            WrngCnt += count
            output += text

        if iSellZeros>0:
            if lIncludeSellZeros:
                output+="\n\n @@ ALERT - I have matched Sales for ZERO shares to BUYS... @@\n\n"
            else:
                output+="\n\n @@ ALERT - The MD LOT Window will pop up wanting you to match the Zero Sells, which you can't.. You can just press Cancel on this (or re-run and Include them) @@\n\n"

        output+=("\nFinished. Processed {} securities producing {} warnings.\n".format(len(Securities),WrngCnt))

        _secAcctRelCurr = accountSec.getCurrencyType()                                                                  # noqa
        _secAcctCostBasis = InvestUtil.getCostBasis(accountSec)
        _secAcctCostBasisDbl = _secAcctRelCurr.getDoubleValue(_secAcctCostBasis)

        output += "\nMD Reports the cost basis for '%s' is now %s\n" %(accountSec, _secAcctCostBasisDbl)

        if not InvestUtil.isCostBasisValid(accountSec):
            cbMessageValidIndicator = "** INVALID ** (you can edit these manually later in MD)"
            txt = "CONVERT STOCK FIFO: WARNING - MD reports the cost basis for '%s' is **INVALID** after the update.." %(accountSec)
        else:
            cbMessageValidIndicator = "VALID"
            txt = "CONVERT STOCK FIFO: NOTE: MD is reporting that the cost basis for '%s' is VALID after the update.." %(accountSec)
        myPrint("B", txt); output += "\n%s\n" %(txt)

        jif=QuickJFrame("CONVERT STOCK FIFO - REVIEW RESULTS", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        ask=MyPopUpDialogBox(jif,
                             theStatus="Please review results on security: %s" %(accountSec),
                             theMessage="These changes have already been made to your dataset\n"
                                        "FYI - MD is reporting that the updated Cost Basis / Lot control status is %s\n"
                                        "To reset the security back to Avg Cost Control and reset/remove these altered LOT records select CANCEL\n"
                                        "(NOTE: I will put the LOT records back to the same state before this script ran)"
                                        "[OK KEEP RESULTS] will accept these changes" %(cbMessageValidIndicator),
                             theWidth=200,
                             theTitle="CONVERT STOCK FIFO",
                             OKButtonText="OK KEEP RESULTS",
                             lCancelButton=True,
                             lAlertLevel=1)
        if not ask.go():
            jif.dispose()       # already within the EDT
            myPrint("B", "\nREVERTING CHANGES - RESETTING ACCOUNT/SECURITY %s BACK TO AVERAGE COST CONTROL!!\n"%(accountSec))
            myPrint("B", "CONVERT STOCK FIFO - RESETTING LOT TAGS on Acct/Security %s!!"%(accountSec))

            output+=("\nREVERTING CHANGES - RESETTING ACCOUNT/SECURITY %s BACK TO AVERAGE COST CONTROL!!\n"%(accountSec))
            output+=("\nRESETTING LOT TAGS on Acct/Security %s!!\n"%(accountSec))

            for Security in Securities:

                myPrint("B","CONVERT STOCK FIFO - Reverting Security %s back to Average Cost Control" %(accountSec))
                output+=("@@ CONVERT STOCK FIFO - Reverting Security %s back to Average Cost Control@@\n" %(accountSec))

                for Txn in Security.Txns:
                    if InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType()):
                        if Txn.Obj.getParameter("cost_basis", None) != Txn.saveCostBasisState:
                            output+="  >> Reverting LOT record to: %s\n" %(Txn.saveCostBasisState)
                            Txn.Obj.setParameter("cost_basis", Txn.saveCostBasisState)
                            Txn.Obj.syncItem()
                output+=" > Reverting to Average Cost Control...\n"
                Security.Obj.setUsesAverageCost(True)
                Security.AvgCost = True
                Security.Obj.syncItem()
                output+="\n<END>"
                txt = "CONVERT STOCK FIFO - Changes to Security %s REJECTED and REVERSED - review report" %(accountSec)
                setDisplayStatus(txt, "R")
        else:
            jif.dispose()       # already within the EDT
            output+="\nCHANGES ACCEPTED and RETAINED...\n" \
                    "\n<END>"
            txt = "CONVERT STOCK FIFO - Changes to Security %s Accepted and retained - review report" %(accountSec)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)


        jif=QuickJFrame("CONVERT STOCK FIFO - REVIEW RESULTS", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        play_the_money_sound()
        myPopupInformationBox(jif, "REVIEW REPORT", "CONVERT STOCK FIFO", JOptionPane.WARNING_MESSAGE)


        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def show_open_share_lots():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        class LotInfo:
            def __init__(self, _date, _buyPrice, _availableShares, _costBasis, _currentPrice, _currentValue):
                self.date = _date
                self.buyPrice = _buyPrice
                self.availableShares = _availableShares
                self.costBasis = _costBasis
                self.currentPrice = _currentPrice
                self.currentValue = _currentValue

        book = MD_REF.getCurrentAccountBook()
        date = datetime.datetime.today()

        # diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: Scanning investments....",theTitle="SEARCH", theWidth=100, lModal=False,OKButtonText="WAIT")
        # diag.go()
        #
        output="\n\nANALYSING SHARES/SECURITIES WITH OPEN (Unconsumed LOTS)\n" \
               " ======================================================\n\n"

        output+='Outstanding Tax Lots as of %s\n\n'%(date.strftime("%m/%d/%y"))
        output+=("%s %s %s %s %s %s\n"
                 %(pad("Buy Date",10),
                   rpad("Buy Price",12),
                   rpad("Avail. Shares",12),
                   rpad("Cost Basis",12),
                   rpad("Current Price",12),
                   rpad("Current Value",14)))

        iFound=0
        for acct in AccountUtil.getAccountIterator(book):
            if acct.getAccountType() ==  acct.AccountType.SECURITY:
                if  not acct.getUsesAverageCost():
                    if InvestUtil.getCostBasis(acct)  > 0:
                        output+="\n%s\n\n" %(acct.getFullAccountName())
                        totalCostBasis = float(0)
                        totalAvailableShares = float(0)
                        currentPrice = float(1)/float(acct.getCurrencyType().getRelativeRate())
                        lotList = []
                        lots = InvestUtil.getRemainingLots(book, acct, DateUtil.getStrippedDateInt())

                        # noinspection PyUnresolvedReferences
                        for transaction, availSharesTracker in lots.items():
                            availableShares = float(availSharesTracker.getAvailableShares())/10000
                            if availableShares > 0:
                                t = book.getTransactionSet().getTxnByID(transaction)
                                # noinspection PyUnresolvedReferences
                                date = datetime.datetime.fromtimestamp(DateUtil.convertIntDateToLong(t.getDateInt()).time/1e3)
                                adjustedBuyPrice = float(1)/acct.getCurrencyType().adjustRateForSplitsInt(t.getDateInt(), t.getRate())*100
                                costBasis = availableShares*adjustedBuyPrice
                                currentValue = currentPrice*availableShares
                                totalCostBasis += costBasis
                                totalAvailableShares += availableShares
                                lotList.append(LotInfo(date, adjustedBuyPrice, availableShares, costBasis, currentPrice, currentValue))
                        lotList.sort(key=lambda sort_l: sort_l.date)
                        lotCount = 0
                        for _lot in lotList:
                            lotCount += 1
                            output+=("%s %s %s %s %s %s\n"
                                     %(pad(_lot.date.strftime("%m/%d/%y"),10),
                                       rpad(_lot.buyPrice,12),
                                       rpad(_lot.availableShares,12),
                                       rpad(_lot.costBasis,12),
                                       rpad(_lot.currentPrice,12),
                                       rpad(_lot.currentValue,14)))
                            iFound+=1
                        if lotCount > 1:
                            output+=("%s %s %s %s %s %s\n"
                                     %(pad("",10),
                                       rpad("",12),
                                       rpad("----------",12),
                                       rpad("----------",12),
                                       rpad("",12),
                                       rpad("----------",14)))
                            output+=("%s %s %s %s %s %s\n"
                                     %(pad("",10),
                                       rpad("",12),
                                       rpad(totalAvailableShares,12),
                                       rpad(totalCostBasis,12),
                                       rpad("",12),
                                       rpad(totalAvailableShares*currentPrice,14)))
                        output+="\n"
        output+="\n<END>"

        # diag.kill()
        #
        if iFound<1:
            txt = "VIEW OPEN LOTS - You have no open / unconsumed LOTs to display!"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,"VIEW OPEN LOTS")
        else:
            toolbox_frame_.toFront()
            txt = "VIEW OPEN LOTS - Displaying %s open LOTS!" %(iFound)
            setDisplayStatus(txt, "B")
            jif = QuickJFrame("VIEW OPEN LOTS",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class OpenFolderButtonAction(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            helper = MD_REF.getPlatformHelper()

            grabProgramDir = find_the_program_install_dir()
            if not os.path.exists((grabProgramDir)): grabProgramDir = None

            grabSyncFolder = get_sync_folder()

            locations = [
                "Show Preferences (config.dict) Folder",
                "Show Custom themes Folder",
                "Show Console (error) log Folder",
                "Show Contents of your current Dataset Folder",
                "Show Extensions Folder",
                "Show Auto Backup Folder",
                "Show Last used (Manual) Backup Folder"]

            # noinspection PyUnresolvedReferences
            locationsDirs = [
                Common.getPreferencesFile(),
                ThemeInfo.customThemeFile,
                MD_REF.getLogFile(),
                MD_REF.getCurrentAccount().getBook().getRootFolder(),
                Common.getFeatureModulesDirectory(),
                FileUtils.getBackupDir(MD_REF.getPreferences()),
                File(MD_REF.getUI().getPreferences().getSetting("backup.last_saved", ""))]

            if grabSyncFolder:
                locations.append("Open Sync Folder")
                locationsDirs.append(File(grabSyncFolder))

            if grabProgramDir:
                locations.append("Open Program's Install Directory")
                locationsDirs.append(File(grabProgramDir))

            selectedFolder = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "Select the Folder you would like to open",
                                                         "Select Folder",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                         locations,
                                                         None)
            if not selectedFolder:
                txt = "No folder was selected to open.."
                setDisplayStatus(txt, "R")
                return

            try:
                Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(str(locationsDirs[locations.index(selectedFolder)])),None)
            except:
                pass

            if not os.path.exists(str(locationsDirs[locations.index(selectedFolder)])):
                txt = "Sorry - File/Folder does not exist! (path copied to clipboard)"
                setDisplayStatus(txt, "R")
                return

            thePathString = locationsDirs[locations.index(selectedFolder)].getCanonicalPath()   # type: str

            if (Platform.isOSX() and grabSyncFolder and
                    ("iCloud~com~infinitekind~moneydancesync" in thePathString or "dropbox" in thePathString.lower())):
                # Bypass system security preventing access to certain folders....
                openResponse = subprocess.check_output('open "%s"' %(thePathString), shell=True)                        # noqa
                txt = "Sync Folder location: %s (copied to clipboard) & opened" %(thePathString)
                setDisplayStatus(txt, "B")
            else:
                helper.openDirectory(locationsDirs[locations.index(selectedFolder)])
                txt = "Folder %s opened..: %s  (path copied to clipboard)" %(selectedFolder, locationsDirs[locations.index(selectedFolder)])
                setDisplayStatus(txt, "B")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    def display_passwords():
        global toolbox_frame_, debug

        myPrint(u"D", u"In ", inspect.currentframe().f_code.co_name, u"()")

        MD_enc = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
        MD_hnt = MD_REF.getUI().getCurrentAccounts().getEncryptionHint()
        MD_sync_pwd = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()

        theMsg = u"'Master' Encryption Passphrase ('password'): "
        displayMsg = u"'Master' Encryption Passphrase ('password'): "

        if MD_enc is not None and MD_enc != u"":
            theMsg += u"%s" %(MD_enc)
            displayMsg += u"%s" %(MD_enc)
            if MD_hnt is not None and MD_hnt != u"":
                theMsg += u"  >> Encryption Passphrase Hint: %s" %(MD_hnt)
                displayMsg += u"  >> Encryption Passphrase Hint: %s" %(MD_hnt)
            else:
                theMsg += u"  >> Encryption Passphrase Hint: (NOT SET)"
                displayMsg += u"  >> Encryption Passphrase Hint: (NOT SET)"

            theMsg += u"\n"
            displayMsg += u"  -  "
        else:
            theMsg += u"(NOT SET - this means a default 'internal' encryption passphrase is being used)\n"
            displayMsg += u"(NOT SET - this means a default 'internal' encryption passphrase is being used)  -  "

        theMsg += u"Sync Passphrase: "
        displayMsg += u"Sync Passphrase: "

        if MD_sync_pwd is not None and MD_sync_pwd != u"":
            theMsg += u"%s" %(MD_sync_pwd)
            displayMsg += u"%s" %(MD_sync_pwd)
        else:
            theMsg += u"(NOT SET)"
            displayMsg += u"(NOT SET)"

        myPrint(u"B",u"Displaying Moneydance Encryption & Sync Passphrase(s) ....!")

        txt = u"Moneydance Encryption Passphrases: %s" %(displayMsg)
        setDisplayStatus(txt, "B")

        MyPopUpDialogBox(toolbox_frame_,u"Moneydance Encryption Passphrases:",theMsg,theTitle=u"PASSWORDS",lAlertLevel=1).go()

        myPrint(u"D", u"Exiting ", inspect.currentframe().f_code.co_name, u"()")
        return theMsg, displayMsg

    def change_fonts():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if float(MD_REF.getBuild()) < 3030:
            txt = "Error - must be on Moneydance build 3030+ to change fonts! NO CHANGES MADE!"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User requested to change Moneydance Default Fonts!")

        if not backup_config_dict():
            txt = "Error backing up config.dict preferences file before deletion - NO CHANGES MADE!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        prefs=MD_REF.getUI().getPreferences()

        systemFonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames()
        for installedFont in systemFonts: myPrint("DB","System OS Font %s is installed in your system..:" %installedFont)

        # These are taken from MD Code - build 3034 - watch out they may change...!
        Mac_fonts_main =     ["SF Pro Display", "SF Display", "Helvetica Neue", "Helvetica", "Lucida Grande", "Dialog"]
        Mac_fonts_mono =     ["Gill Sans", "Menlo", "Monaco", "Monospaced"]

        Windows_fonts_main = ["Dialog"]
        Windows_fonts_mono = ["Calibri","Monospaced"]

        Linux_fonts_main =   ["Dialog"]
        Linux_fonts_mono =   ["Monospaced"]

        all_fonts_code =   ["Hack", "Monospaced"]
        all_fonts_print =   ["Helvetica", "Dialog"]

        lExit=False
        lAnyFontChanges=False

        for checkFont in ["main_font","mono_font","code_font","print.font_name"]:
            x = prefs.getSetting(checkFont, None)
            if x is not None and x == "null":
                lAnyFontChanges=True
                prefs.setSetting(checkFont,None)
                myPrint("B","@@ Font setting %s in config.dict was set to 'null'. I have corrected this and deleted the setting.." %checkFont)

        if lAnyFontChanges: MD_REF.savePreferences()

        while True:
            if lExit: break

            mainF = prefs.getSetting("main_font", None)
            monoF = prefs.getSetting("mono_font", None)
            codeF = prefs.getSetting("code_font", None)
            printF = prefs.getSetting("print.font_name", None)

            myPrint("DB",'@@ MONEYDANCE: Config.dict: "main_font" currently set to %s' %mainF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "mono_font" currently set to %s' %monoF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "code_font" currently set to %s' %codeF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "print.font_name" currently set to %s' %printF)

            display_main="None(Moneydance defaults)"
            display_mono="None(Moneydance defaults)"
            display_code="None(Moneydance defaults)"
            display_print="None(Moneydance defaults)"
            if mainF and mainF != "null": display_main = mainF
            if monoF and monoF != "null": display_mono = monoF
            if codeF and codeF != "null": display_code = codeF
            if printF and printF != "null": display_print = printF

            MyPopUpDialogBox(toolbox_frame_,"Config.dict - CURRENT FONTS:",
                             '"main_font" currently set to %s\n'
                             '"mono_font" currently set to %s  (Used for mainly numbers)\n'
                             '"code_font" currently set to %s  (the Moneybot / Python Font >> IMPACTS OUTPUT COLUMN ALIGNMENT <<)\n'
                             '"print.font_name" currently set to %s' %(display_main,display_mono,display_code,display_print),
                             150,"FONTS",OKButtonText="CONTINUE").go()

            _options=["MAIN: CHANGE SETTING",
                      "MAIN: DELETE SETTING",
                      "MONO: CHANGE SETTING",
                      "MONO: DELETE SETTING",
                      "CODE: CHANGE SETTING",
                      "CODE: DELETE SETTING",
                      "PRINT: CHANGE SETTING",
                      "PRINT: DELETE SETTING"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "What type of change do you want to make?",
                                                         "ALTER FONTS",
                                                         JOptionPane.WARNING_MESSAGE,
                                                         None,
                                                         _options,
                                                         None)

            if not selectedOption: break

            lMain = (_options.index(selectedOption) == 0 or _options.index(selectedOption) == 1)
            lMono = (_options.index(selectedOption) == 2 or _options.index(selectedOption) == 3)
            lCode = (_options.index(selectedOption) == 4 or _options.index(selectedOption) == 5)
            lPrint = (_options.index(selectedOption) == 6 or _options.index(selectedOption) == 7)

            lDelete = (_options.index(selectedOption) == 1 or _options.index(selectedOption) == 3 or _options.index(selectedOption) == 5 or _options.index(selectedOption) == 7)
            lChange = (_options.index(selectedOption) == 0 or _options.index(selectedOption) == 2 or _options.index(selectedOption) == 4 or _options.index(selectedOption) == 6)

            if lMain:
                theKey = "main_font"
            elif lMono:
                theKey = "mono_font"
            elif lCode:
                theKey = "code_font"
            elif lPrint:
                theKey = "print.font_name"
            else:
                raise(Exception("error"))

            if lDelete:
                if myPopupAskQuestion(toolbox_frame_,"DELETE FONT KEY","Are you sure you want to delete key: %s?" %theKey,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE):
                    prefs.setSetting(theKey,None)
                    MD_REF.savePreferences()
                    lAnyFontChanges=True
                    myPrint("B", "Config.dict: key: %s DELETED - RESTART MD" %theKey)
                    myPopupInformationBox(toolbox_frame_, "Config.dict: key: %s DELETED - RESTART MD" %theKey, "FONTS", JOptionPane.WARNING_MESSAGE)
                    continue
                else:
                    continue

            elif lChange:

                theFonts = None                                                                                         # noqa
                if Platform.isOSX():
                    if lMain:
                        theFonts = Mac_fonts_main
                    elif lMono:
                        theFonts = Mac_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))
                elif Platform.isWindows():
                    if lMain:
                        theFonts = Windows_fonts_main
                    elif lMono:
                        theFonts = Windows_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))
                else:
                    if lMain:
                        theFonts = Linux_fonts_main
                    elif lMono:
                        theFonts = Linux_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))

                for x in theFonts: myPrint("DB","Possible internal default fonts for your Platform...: %s" %x)

                _options=["CHOOSE FROM MD INTERNAL LIST", "CHOOSE FROM YOUR OS' SYSTEM INSTALLED"]
                selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "New Font Selection options for: %s?" %theKey,
                                                             "ALTER FONTS",
                                                             JOptionPane.WARNING_MESSAGE,
                                                             None,
                                                             _options,
                                                             None)

                if not selectedOption:
                    continue

                if _options.index(selectedOption) == 0 or _options.index(selectedOption) == 1:

                    if _options.index(selectedOption) == 1: theFonts = systemFonts
                    selectedFont = JOptionPane.showInputDialog(toolbox_frame_,
                                                               "Select new Font to set for %s" %theKey,
                                                               "ALTER FONTS",
                                                               JOptionPane.WARNING_MESSAGE,
                                                               None,
                                                               theFonts,
                                                               None)
                    if not selectedFont:
                        continue
                    else:
                        prefs.setSetting(theKey,selectedFont)
                        MD_REF.savePreferences()
                        lAnyFontChanges=True
                        myPrint("B", 'Config.dict: key: %s CHANGED to "%s" - RESTART MD' %(theKey,selectedFont))
                        myPopupInformationBox(toolbox_frame_, 'Config.dict: key: %s CHANGED to "%s"\nRESTART MD' %(theKey,selectedFont), "FONTS", JOptionPane.WARNING_MESSAGE)
                        continue

                else: raise(Exception("error"))

            continue

        if lAnyFontChanges:

            try:
                MD_REF.getUI().getFonts().updateFonts()
                txt = "MD Font Changes made (MD Fonts were also reinitialised) - YOU MIGHT NEED TO RESTART MONEYDANCE ANYWAY (config.dict was also backed up)...."
            except:
                txt = "MD Font Changes made (failed to reinitialise MD Fonts) - PLEASE RESTART MONEYDANCE (config.dict was also backed up)...."

            myPrint("DB", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
        else:
            txt = "NO FONT ACTIONS TAKEN! - NO CHANGES MADE...."
            myPrint("D", txt)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def delete_theme_file():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("DB", "User requested to delete custom theme file!")

        # noinspection PyUnresolvedReferences
        customThemeFile = str(ThemeInfo.customThemeFile)
        if not os.path.exists(customThemeFile):
            txt = "Custom Theme file does not exist to delete!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,
                                  "DELETE MD custom Theme file?",
                                  "Are you sure you want to delete custom Theme file?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.ERROR_MESSAGE):

            txt = "User declined to delete custom Theme file!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        disclaimer = myPopupAskForInput(toolbox_frame_,
                                        "DELETE MD custom Theme file",
                                        "DISCLAIMER:",
                                        "Type 'IAGREE' to DELETE custom theme file",
                                        "NO",
                                        False,
                                        JOptionPane.ERROR_MESSAGE)
        if disclaimer != "IAGREE":
            txt = "User declined to agree to disclaimer >> custom Theme file!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User confirmed to delete custom Theme file...")

        try:
            if not backup_custom_theme_file():
                txt = "Error backing up custom theme file prior to deletion - no changes made!"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            os.remove(customThemeFile)
            txt = "DELETED CUSTOM THEME FILE: %s" %(customThemeFile)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE CUSTOM THEME FILE", JOptionPane.WARNING_MESSAGE)

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR DELETING CUSTOM THEME FILE: %s" %(customThemeFile)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE CUSTOM THEME FILE", JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def find_IOS_sync_data():
        global toolbox_frame_, debug, i_am_an_extension_so_run_headless

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not(Platform.isOSX() or Platform.isWindows()):
            txt = "FindIOSSyncDataButtonAction() called, but not OSx or Windows!?"
            setDisplayStatus(txt, "R")
            myPrint("B",txt)
            return

        instructions = """
INSTRUCTIONS TO ATTEMPT TO RETRIEVE YOUR MONEYDANCE SYNC ENCRYPTION KEY FROM iPHONE/iPAD

NOTE: As of 15th January 2021, there is a new iOS app in Beta Test, this allows you to view your encryption passphrase
... I understand an Android version is also coming... Ideally use these first if you have access to your mobile

OTHERWISE:
STEP 1. Ensure you have the Moneydance iOS App working & Syncing on an iphone/iPad.
STEP 2. Perform an iPhone/iPad backup to your computer Using iTunes (or Finder on Mac Big Sur). Instructions below....
STEP 3. RETURN HERE and let Toolbox attempt search; or search manually yourself (instructions below)

-----------------------------------------------------------------------------------------------------------------------------        
NOTE: If on a Mac, and you want Toolbox to search in step 3, then you must change these Mac Settings first...        
>>The system prevents programmatic access to the backups.. 
>> Go to Mac / Settings / Security & Privacy. Privacy Tab
- Click the padlock to unlock the settings
- Scroll down left side to Full Disk Access
- On the right, find Moneydance and tick it (or click the + to add and tick it) to Grant Access
- Exit and restart Moneydance, then run this Toolbox option again (if you don't do this, it will not find your backups!)..
>> Change this setting back afterwards.....
-----------------------------------------------------------------------------------------------------------------------------        

NOTE: DO NOT EDIT THE FILE MENTIONED BELOW. ALWAYS QUIT WITHOUT SAVING.
IF YOU COPY THE FILE TO YOUR DESKTOP, MAKE SURE YOU COPY (and not move)...
(Normally you hold down the CTRL, or OPTION/ALT key whilst dragging so the icon changes to a plus and copy)


================================
Mac (easiest option if possible) 
================================
Please review these instructions:
https://support.apple.com/en-gb/guide/iphone/iph3ecf67d29/ios
- Essentially install iTunes (not needed on Mac Big Sur - which uses finder)
- Go to the iPhone/iPad tab, General options
- Perform a local backup (NOT ENCRYPTED)

>> Come back here after backup completed and then run this Toolbox option to search backups........ <<

OR MANUAL INSTRUCTIONS BELOW

This link has details on the backup location: https://support.apple.com/en-gb/HT204215

>> Locate your backup(s) in Finder: 
- Open Finder. Menu GO 
- Go To Folder 
- Copy and paste this:

~/Library/Application Support/MobileSync/Backup/ 
Press Return.

You will see a list of backups. (e.g. 00008030-000E31343A02802E) 
Right click this folder (the most recent) 
Select "New terminal at folder". Then terminal will open at this folder. 

Copy / paste this command below and press enter...

grep -rl tik_dropbox_md *

...wait...

It will find something like this: 
c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c 
This is the file you need, stay in Terminal

plutil -p c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c 
(and you will see the information on the screen next to "tik_dropbox_md_sync_key" =>

or do this: 
open -a TextEdit c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

And you will see text and gibberish..... but also your key... Your key should be visible... See example. My was after the text 'last_account_used2V'

(of course, now you know the file, you can find it, copy it to desktop, open with other text viewers....)


================================
WINDOWS 
================================
Download and install iTunes, plug in iPhone. Select the iPhone icon and you should see  (General) options
(Help here: https://support.apple.com/en-gb/guide/iphone/iph3ecf67d29/ios)

Perform a local backup, DESELECT Encrypt local backup. Select Backup NOW 

...wait...

>> Come back here after backup completed and then run this Toolbox option to search backups........ <<

OR MANUAL INSTRUCTIONS BELOW

When finished, locate your backup - help here: https://support.apple.com/en-gb/HT204215

In the taskbar search box, type command (no enter) and when there is a popup select run as administrator 
type 
cd %userprofile% (Or a different folder if in a different place) 
cd apple 
cd mobilesync 
cd backup 
dir 
Your backups will be listed. If only one, skip this next step, else find the latest. Select/copy the name 
cd <the selected name>

So you will now be at something like...: 
C:\\Users\\<username>\\Apple\\MobileSync\\Backup\\00008030-000E31343A02802E> 
or 
C:\\Users\\<username>>\\Apple\\MobileSync\\Backup> (if only one backup)

Now type this and enter:

findstr /S /I /M /C:"tik_dropbox_md" *.* 
... wait ...

It will show you something like this..:

00008030-000E31343A02802E\\c8\\c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

Backup name: 00008030-000E31343A02802E 
SubDir: c8 
Actual file name you want: c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

Now copy/paste the whole string (one line) and type this (paste the long name) and enter

start notepad 00008030-000E31343A02802E\\c8\\c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

Notepad is rubbish, so use the cursor and move right along the lines until you see your key... 
---

On both the above options, you can find and copy the file to your desktop. Rename the desktop copy to 'key.plist' for ease of use after you have it.

Once you have the file..: 
On windows you can download and use this tool: 
https://www.imactools.com/iphonebackupviewer/download/win 
Run the program, select the 3 line menu button top right, Tools, Property List View, then open the key.plist file you saved to your desktop..

On Mac, in terminal 
cd /Users/<yourname>/Desktop 
type and enter 
plutil -convert xml1 key.plist 
Now you will have a text readable version of the file you can open in a text editor..

<END>            
"""

        jif = QuickJFrame("View Instructions:", instructions,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        jif.setLocationRelativeTo(toolbox_frame_)

        if not myPopupAskQuestion(jif,
                                  "SEARCH COMPUTER iOS BACKUP(s)",
                                  "This may be time consuming...Do you want to continue with the search for Encryption Sync Passphrases now?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.WARNING_MESSAGE):

            txt = "User Aborted iOS backup(s) search..."
            setDisplayStatus(txt, "R")
            return

        jif.dispose()       # already within the EDT

        if Platform.isOSX():
            searchList = ["Library/Application Support/MobileSync/Backup"]
        else:
            searchList = ["Apple\\MobileSync\\Backup",
                          "Apple Computer\\MobileSync\\Backup",
                          "AppData\\Roaming\\Apple\\MobileSync\\Backup",
                          "AppData\\Roaming\\Apple Computer\\MobileSync\\Backup"]


        miniText=""
        pathList = []
        for x in (searchList):
            fullPath = os.path.join(get_home_dir(), x)
            miniText += "%s\n" %fullPath
            if os.path.exists(fullPath) and os.path.isdir(fullPath):
                pathList.append(fullPath)

        if len(pathList)<1:
            txt = "Sorry - could not find your IOS Backup directory(s)..."
            setDisplayStatus(txt, "R")
            myPrint("B", "Sorry - could not find your IOS Backup directory(s) in %s ....:" %get_home_dir())
            myPrint("B", searchList)
            MyPopUpDialogBox(toolbox_frame_,"Search for iOS Backup(s) - could not find your directory(s):",
                             miniText,theTitle="RECOVER IOS SYNC KEY",OKButtonText="ABORT").go()
            return

        theIKReference = "c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c"  # WARNING, this may change? Might have to switch to finding the key..!
        diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching iOS Backup(s)..",theTitle="SEARCH", theWidth=100, lModal=False,OKButtonText="WAIT")
        diag.go()

        def findIOSBackup(pattern, path):
            iFound=0                                                                                                    # noqa
            result = []
            dotCounter = 0

            lContinueToEnd=False

            if not i_am_an_extension_so_run_headless:
                print "Searching for your iOS Backups (might be time consuming):.....",

            for root, dirs, files in os.walk(path):

                if dotCounter % 1000 <1:
                    if not i_am_an_extension_so_run_headless: print ".",

                if not dotCounter or (dotCounter % 10000 <1 and not lContinueToEnd):

                    options=["STOP HERE","SEARCH TO END", "KEEP ASKING"]
                    response = JOptionPane.showOptionDialog(toolbox_frame_,
                                                            "Are you OK to continue (%s found so far)?"%iFound,
                                                            "SEARCH COMPUTER FOR iOS BACKUP(s)",
                                                            0,
                                                            JOptionPane.QUESTION_MESSAGE,
                                                            None,
                                                            options,
                                                            options[2])
                    if response == 0:
                        _txt = "User Aborted iOS Backup(s) search..."
                        setDisplayStatus(_txt, "R")
                        return result, iFound

                    elif response == 1:
                        lContinueToEnd = True

                dotCounter+=1

                if debug: myPrint("DB","Searching: %s" %(root))

                for name in files:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp):
                        myPrint("DB", "found file link! %s - will skip" %fp)
                        continue
                    if fnmatch.fnmatch(name, pattern):
                        iFound+=1
                        result.append(fp)

                for name in dirs:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp):
                        myPrint("DB", "found dir link! %s - will skip" %fp)
                        continue
                    if fnmatch.fnmatch(name, pattern):
                        iFound+=1
                        result.append(fp)

            return result, iFound

        iFound = 0
        fileList=[]

        for theDir in pathList:
            myPrint("P","Searching from Directory: %s" %theDir)

            holdFileList, holdFound = findIOSBackup(theIKReference, theDir)
            fileList += holdFileList
            iFound += holdFound

        diag.kill()

        print
        myPrint("B","Completed search for iOS Backup(s): %s found (called: %s)" %(iFound, theIKReference))

        if iFound < 1:
            txt = "Sorry - could not find the Moneydance Sync file(s) (%s) in iOS backup(s)..." %(theIKReference)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPrint("B", fileList)
            x=""
            if Platform.isOSX():
                x="PLEASE CHECK YOU GRANTED FULL DISK ACCESS (READ INSTRUCTIONS)\n\n"
            MyPopUpDialogBox(toolbox_frame_,"Search for iOS Backups - SORRY >> COULD NOT FIND the Moneydance App Sync File (%s) in these directories:"%theIKReference,
                             x+miniText,theTitle="RECOVER IOS SYNC KEY",OKButtonText="CLOSE").go()
            return


        # ###############################################################################################
        # https://github.com/provegard/binaryplist/
        # Copyright (c) 2011, Per Rovegard <per@rovegard.se>
        # Licensed under the 3-clause BSD license.
        from struct import unpack
        from datetime import tzinfo, timedelta

        # noinspection PyDeprecation
        def dump_plist(obj, _format):
            if 'plist' == (_format or 'plist'):
                from plistlib import writePlist
                writePlist(obj, sys.stdout)
            elif 'json' == _format:
                import json
                s = json.dumps(obj, indent=2)
                print(s)

        def decode_plist(_filename, _format="plist", _search="ALL"):   # Can be "plist" or "json"
            with open(_filename, 'rb') as fd:
                try:
                    plist_root = read_binary_plist(fd)

                    if _search == "ALL":
                        dump_plist(plist_root, _format)
                    else:
                        if _search in plist_root:
                            return plist_root[_search]
                        else:
                            return "NOT FOUND"

                except PListFormatError as e:
                    myPrint("B","Format error: %s" % (e.message))
                    return "ERROR"
                except PListUnhandledError as e:
                    myPrint("B","Unhandled: %s" % (e.message))
                    return "ERROR"

        # HEADER
        #         magic number ("bplist")
        #         file format version
        #
        # OBJECT TABLE
        #         variable-sized objects
        #
        #         Object Formats (marker byte followed by additional info in some cases)
        #         null    0000 0000
        #         bool    0000 1000                       // false
        #         bool    0000 1001                       // true
        #         fill    0000 1111                       // fill byte
        #         int     0001 nnnn       ...             // # of bytes is 2^nnnn, big-endian bytes
        #         real    0010 nnnn       ...             // # of bytes is 2^nnnn, big-endian bytes
        #         date    0011 0011       ...             // 8 byte float follows, big-endian bytes
        #         data    0100 nnnn       [int]   ...     // nnnn is number of bytes unless 1111 then int count follows, followed by bytes
        #         string  0101 nnnn       [int]   ...     // ASCII string, nnnn is # of chars, else 1111 then int count, then bytes
        #         string  0110 nnnn       [int]   ...     // Unicode string, nnnn is # of chars, else 1111 then int count, then big-endian 2-byte uint16_t
        #                 0111 xxxx                       // unused
        #         uid     1000 nnnn       ...             // nnnn+1 is # of bytes
        #                 1001 xxxx                       // unused
        #         array   1010 nnnn       [int]   objref* // nnnn is count, unless '1111', then int count follows
        #                 1011 xxxx                       // unused
        #         set     1100 nnnn       [int]   objref* // nnnn is count, unless '1111', then int count follows
        #         dict    1101 nnnn       [int]   keyref* objref* // nnnn is count, unless '1111', then int count follows
        #                 1110 xxxx                       // unused
        #                 1111 xxxx                       // unused
        #
        # OFFSET TABLE
        #         list of ints, byte size of which is given in trailer
        #         -- these are the byte offsets into the file
        #         -- number of these is in the trailer
        #
        # TRAILER
        #         byte size of offset ints in offset table
        #         byte size of object refs in arrays and dicts
        #         number of offsets in offset table (also is number of objects)
        #         element # in offset table which is top level object
        #         offset table offset


        try:
            unichr(8364)                                                                                                # noqa
        except NameError:
            # Python 3
            def unichr(x):                                                                                              # noqa
                return chr(x)

        # From CFDate Reference: "Absolute time is measured in seconds relative to the
        # absolute reference date of Jan 1 2001 00:00:00 GMT".
        SECS_EPOCH_TO_2001 = 978307200

        MARKER_NULL = 0X00
        MARKER_FALSE = 0X08
        MARKER_TRUE = 0X09
        MARKER_FILL = 0X0F                                                                                              # noqa
        MARKER_INT = 0X10
        MARKER_REAL = 0X20
        MARKER_DATE = 0X33
        MARKER_DATA = 0X40
        MARKER_ASCIISTRING = 0X50
        MARKER_UNICODE16STRING = 0X60
        MARKER_UID = 0X80
        MARKER_ARRAY = 0XA0
        MARKER_SET = 0XC0
        MARKER_DICT = 0XD0


        def read_binary_plist(fd):
            """Read an object from a binary plist.
            The binary plist format is described in CFBinaryPList.c at
            http://opensource.apple.com/source/CF/CF-550/CFBinaryPList.c. Only the top
            level object is returned.
            Raise a PListFormatError or a PListUnhandledError if the input data cannot
            be fully understood.
            Arguments:
            fd -- a file-like object that is seekable
            """
            r = BinaryPListReader(fd)
            return r.read()


        class PListFormatError(Exception):
            """Represent a binary plist format error."""
            pass


        class PListUnhandledError(Exception):
            """Represent a binary plist error due to an unhandled feature."""
            pass


        class ObjectRef(object):
            def __init__(self, index):
                self.index = index

            def resolve(self, lst):
                return lst[self.index]


        class BinaryPListReader(object):

            def __init__(self, fd):
                self._fd = fd
                self._offsets = None
                self.objectRefSize = None

            def read(self):
                fd = self._fd

                # start from the beginning to check the signature
                fd.seek(0, 0)
                buf = fd.read(7)

                # verify the signature; the first version digit is always 0
                if buf != b"bplist0":
                    raise PListFormatError("Invalid signature: %s" % (buf, ))

                # seek to and read the trailer (validation omitted for now)
                fd.seek(-32, 2)
                buf = fd.read(32)

                _, offsetIntSize, self.objectRefSize, numObjects, topObject, offsetTableOffset = unpack(">5x3B3Q", buf)

                # read the object offsets
                fd.seek(offsetTableOffset, 0)
                self._offsets = [self._read_sized_int(offsetIntSize) for _ in range(0, numObjects)]

                # read the actual objects
                objects = [self._read_object(offs) for offs in self._offsets]

                # resolve lazy values (references to the object list)
                self._resolve_objects(objects)

                return objects[topObject]

            def _resolve_objects(self, objects):
                # all resolutions are in-place, to avoid breaking references to
                # the outer objects!
                for obj in objects:
                    if isinstance(obj, list):
                        for i in range(0, len(obj)):
                            obj[i] = obj[i].resolve(objects)
                    if isinstance(obj, set):
                        temp = [item.resolve(objects) for item in obj]
                        obj.clear()
                        obj.update(temp)
                    if isinstance(obj, dict):
                        temp = {k.resolve(objects): v.resolve(objects) for k, v in list(obj.items())}
                        obj.clear()
                        obj.update(temp)

            def _read_object(self, offset=-1):
                if offset >= 0:
                    self._fd.seek(offset)
                else:
                    offset = self._fd.tell()  # for the error message
                marker = ord(self._fd.read(1))
                nb1 = marker & 0xf0
                nb2 = marker & 0x0f

                obj = None
                if nb1 == MARKER_NULL:
                    if marker == MARKER_NULL:
                        obj = None
                    elif marker == MARKER_FALSE:
                        obj = False
                    elif marker == MARKER_TRUE:
                        obj = True
                    # TO DO: Fill byte, skip over
                elif nb1 == MARKER_INT:
                    count = 1 << nb2
                    obj = self._read_sized_int(count)
                elif nb1 == MARKER_REAL:
                    obj = self._read_sized_float(nb2)
                elif marker == MARKER_DATE:  # marker!
                    secs = self._read_sized_float(3)
                    secs += SECS_EPOCH_TO_2001
                    obj = datetime.datetime.fromtimestamp(secs, UTC())
                elif nb1 == MARKER_DATA:
                    # Binary data
                    count = self._read_count(nb2)
                    obj = self._fd.read(count)
                elif nb1 == MARKER_ASCIISTRING:
                    # ASCII string
                    count = self._read_count(nb2)
                    obj = self._fd.read(count).decode("ascii")
                elif nb1 == MARKER_UNICODE16STRING:
                    # UTF-16 string
                    count = self._read_count(nb2)
                    data = self._fd.read(count * 2)
                    chars = unpack(">%dH" % (count, ), data)
                    s = u''
                    for ch in chars:
                        s += unichr(ch)
                    obj = s
                elif nb1 == MARKER_UID:
                    count = 1 + nb2
                    obj = self._read_sized_int(count)
                elif nb1 == MARKER_ARRAY:
                    count = self._read_count(nb2)
                    # we store lazy references to the object list
                    obj = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
                elif nb1 == MARKER_SET:
                    count = self._read_count(nb2)
                    # we store lazy references to the object list
                    obj = set([ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)])
                elif nb1 == MARKER_DICT:
                    count = self._read_count(nb2)
                    # first N keys, then N values
                    # we store lazy references to the object list
                    keys = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
                    values = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
                    obj = dict(list(zip(keys, values)))

                try:
                    return obj
                except NameError:
                    raise PListFormatError("Unknown marker at position %d: %d" %
                                           (offset, marker))

            def _read_count(self, nb2):
                count = nb2
                if count == 0xf:
                    count = self._read_object()
                return count

            def _read_sized_float(self, log2count):
                if log2count == 2:
                    # 32 bits
                    ret, = unpack(">f", self._fd.read(4))
                elif log2count == 3:
                    # 64 bits
                    ret, = unpack(">d", self._fd.read(8))
                else:
                    raise PListUnhandledError("Unhandled real size: %d" %
                                              (1 << log2count, ))
                return ret

            def _read_sized_int(self, count):
                # in format version '00', 1, 2, and 4-byte integers have to be
                # interpreted as unsigned, whereas 8-byte integers are signed
                # (and 16-byte when available). negative 1, 2, 4-byte integers
                # are always emitted as 8 bytes in format '00'
                buf = self._fd.read(count)
                if count == 1:
                    ret = ord(buf)
                elif count == 2:
                    ret, = unpack(">H", buf)
                elif count == 4:
                    ret, = unpack(">I", buf)
                elif count == 8:
                    ret, = unpack(">q", buf)
                else:
                    raise PListUnhandledError("Unhandled int size: %d" %
                                              (count, ))
                return ret


        class UTC(tzinfo):

            def utcoffset(self, dt):
                return timedelta(0)

            def tzname(self, dt):
                return "UTC"

            def dst(self, dt):
                return timedelta(0)

        # typedef struct {
        #    uint8_t  _unused[5];
        #    uint8_t  _sortVersion;
        #    uint8_t  _offsetIntSize;
        #    uint8_t  _objectRefSize;
        #    uint64_t _numObjects;
        #    uint64_t _topObject;
        #    uint64_t _offsetTableOffset;
        # } CFBinaryPlistTrailer;

        syncPassphrases=[]
        for foundFile in fileList:
            try:
                theSyncKey = decode_plist(foundFile,_format="plist",_search="tik_dropbox_md_sync_key")
                syncPassphrases.append(theSyncKey)
            except:
                syncPassphrases.append("Sorry - caught an error decoding the file")

        niceFileList="\n SEARCH FOR MONEYDANCE (%s) iOS Backup(s)\n"%theIKReference
        niceFileList+="Search for these Directories:\n"
        niceFileList+=miniText
        niceFileList+="\nFound these Directories:\n"

        for x in pathList:
            niceFileList+="%s\n" %x
        niceFileList+="\n"

        if not iFound:
            niceFileList+="\n<NONE FOUND>\n"

        for x in fileList:
            myPrint("B","Found: %s" %x)
            niceFileList+=x+"\n"

        niceFileList+="\nPOSSIBLE SYNC ENCRYPTION PASSPHRASES:\n"
        if len(syncPassphrases) < 1:
            niceFileList+="\n<NONE FOUND>\n"

        for encryptionKey in syncPassphrases:
            niceFileList+="%s\n" %encryptionKey

        niceFileList+="\n\n<END>"
        txt = "Find my iOS Backup(s) found %s files, with %s possible Sync Encryption keys" %(iFound,len(syncPassphrases))
        setDisplayStatus(txt, "DG")

        jif=QuickJFrame("LIST OF MONEYDANCE iOS Backups and Sync Encryption keys FOUND".upper(), niceFileList, lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        myPopupInformationBox(jif, "%s Sync Encryption keys found...." %(len(syncPassphrases)), "iOS BACKUP SEARCH", JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def import_QIF():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "IMPORT QIF"

        theTitle = "Select QIF file for import"
        QIFfilename = getFileFromFileChooser(toolbox_frame_,         # Parent frame or None
                                            get_home_dir(),          # Starting path
                                            "select_your_file.qif",  # Default Filename
                                            theTitle,                # Title
                                            False,                   # Multi-file selection mode
                                            True,                    # True for Open/Load, False for Save
                                            True,                    # True = Files, else Dirs
                                            None,                    # Load/Save button text, None for defaults
                                            "qif",                   # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if QIFfilename is None or QIFfilename == "":
            txt = "%s: User chose to cancel or no file selected >>  So no Import will be performed... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not os.path.exists(QIFfilename) or not os.path.isfile(QIFfilename):
            txt = "%s: Sorry, file selected to import either does not exist or is not a file" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        dropdownAccts=AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(5))
        dropdownAccts=sorted(dropdownAccts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))  # type: [Account]
        dropdownAccts.insert(0,"<NONE: USE QIF SPECIFIED>")

        label_QIF = JLabel("%s" %(os.path.basename(QIFfilename)))

        label_accounts = JLabel("Select Default Account if none specified in QIF:")
        user_accounts = JComboBox(dropdownAccts)

        # QIF_FORMATS = ["QIF_FORMAT_AUTO", "QIF_FORMAT_MMDDYY", "QIF_FORMAT_DDMMYY", "QIF_FORMAT_YYMMDD"]
        QIF_FORMATS = ["QIF_FORMAT_AUTO", "QIF_FORMAT_MMDDYY", "QIF_FORMAT_DDMMYY", "QIF_FORMAT_YYMMDD"]
        label_qif_format = JLabel("Select QIF Format")
        user_QIF_format = JComboBox(QIF_FORMATS)

        decimalStrings = [".",","]
        label_decimal = JLabel("Select your decimal point character")
        user_selectDecimal = JComboBox(decimalStrings)
        user_selectDecimal.setSelectedIndex(0)

        dropdownCurrs=[]
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() != CurrencyType.Type.CURRENCY: continue                                           # noqa
            dropdownCurrs.append(curr)
        dropdownCurrs=sorted(dropdownCurrs, key=lambda sort_x: (sort_x.getName().upper()))
        label_currency = JLabel("Select Default Currency for any Accounts created:")
        user_currency = JComboBox(dropdownCurrs)
        user_currency.setSelectedItem(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType())

        IMPORT_TYPE = ["QIF_MODE_TRANSFER", "QIF_MODE_DOWNLOAD"]
        # label_import_type = JLabel("Select Import Type")
        # user_import_type = JComboBox(IMPORT_TYPE)
        #

        label_import_type_transfer = JLabel("TRANSFER MODE?")
        user_import_type_transfer = JRadioButton("(transfer)", True)
        label_import_type_download = JLabel("DOWNLOAD (from bank) MODE?")
        user_import_type_download = JRadioButton("(disabled - use newer function)",False)
        user_import_type_download.setEnabled(False)
        bg2 = ButtonGroup()
        bg2.add(user_import_type_transfer)
        bg2.add(user_import_type_download)

        label_importStructure = JLabel("Import Structure only (no data)?")
        user_importStructureOnly = JRadioButton("(structure only)", False)
        label_importAllData = JLabel("Import all data?")
        user_importAllData = JRadioButton("(all data)", False)
        bg = ButtonGroup()
        bg.add(user_importStructureOnly)
        bg.add(user_importAllData)

        userFilters = JPanel(GridLayout(0, 2))
        userFilters.add(JLabel("IMPORT FILE:"))
        userFilters.add(label_QIF)
        userFilters.add(label_qif_format)
        userFilters.add(user_QIF_format)
        userFilters.add(label_decimal)
        userFilters.add(user_selectDecimal)
        userFilters.add(label_currency)
        userFilters.add(user_currency)
        userFilters.add(label_accounts)
        userFilters.add(user_accounts)
        userFilters.add(JLabel(""))
        userFilters.add(JLabel("---"))
        # userFilters.add(label_import_type)
        # userFilters.add(user_import_type)
        userFilters.add(label_import_type_transfer)
        userFilters.add(user_import_type_transfer)
        userFilters.add(label_import_type_download)
        userFilters.add(user_import_type_download)
        userFilters.add(JLabel(""))
        userFilters.add(JLabel("---"))
        userFilters.add(label_importStructure)
        userFilters.add(user_importStructureOnly)
        userFilters.add(label_importAllData)
        userFilters.add(user_importAllData)


        while True:
            options = ["EXIT", "IMPORT"]
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       userFilters,
                                                       "IMPORT QIF (Older MD Function)",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                       options, options[0]))
            if userAction != 1:
                txt = "%s: - User aborted - No changes made....." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not user_importStructureOnly.isSelected() and not user_importAllData.isSelected():
                user_importStructureOnly.setForeground(getColorRed())
                user_importAllData.setForeground(getColorRed())
                continue

            if not user_import_type_transfer.isSelected() and not user_import_type_download.isSelected():
                user_import_type_transfer.setForeground(getColorRed())
                user_import_type_download.setForeground(getColorRed())
                continue

            break

        if user_QIF_format.getSelectedItem() == "QIF_FORMAT_AUTO":
            theQIFFormat = Common.QIF_FORMAT_AUTO
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_MMDDYY":
            theQIFFormat = Common.QIF_FORMAT_MMDDYY
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_DDMMYY":
            theQIFFormat = Common.QIF_FORMAT_DDMMYY
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_YYMMDD":
            theQIFFormat = Common.QIF_FORMAT_YYMMDD
        else:
            txt = "%s: Error - QIF Format %s unknown / unsupported by Moneydance now....?!" %(_THIS_METHOD_NAME, user_QIF_format.getSelectedItem())
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if user_import_type_transfer.isSelected():
            theImportType = Common.QIF_MODE_TRANSFER
        elif user_import_type_download.isSelected():
            theImportType = Common.QIF_MODE_DOWNLOAD
        else:
            txt = "%s: Error - QIF MODE unknown / unsupported by Moneydance now....?!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # if user_import_type.getSelectedItem() == "QIF_MODE_TRANSFER":
        #     theImportType = Common.QIF_MODE_TRANSFER
        # elif user_import_type.getSelectedItem() == "QIF_MODE_DOWNLOAD":
        #     theImportType = Common.QIF_MODE_DOWNLOAD
        # else:
        #     txt = "QIF IMPORT: Error - QIF MODE %s unknown / unsupported by Moneydance now....?!" %(user_import_type.getSelectedItem())
        #     setDisplayStatus(txt, "R")
        #     myPopupInformationBox(toolbox_frame_,txt,"QIF IMPORT" %(user_import_type.getSelectedItem()), theMessageType=JOptionPane.WARNING_MESSAGE)
        #     return

        theAcct = None
        if isinstance(user_accounts.getSelectedItem(), Account):
            theAcct = user_accounts.getSelectedItem()

        theMsg =  "File name:        %s\n"         %(QIFfilename)
        theMsg += "QIF Format:       %s (%s)\n"    %(user_QIF_format.getSelectedItem(),theQIFFormat)
        theMsg += "Decimal Char:     %s\n"         %(user_selectDecimal.getSelectedItem())
        theMsg += "Default Currency: %s\n"         %(user_currency.getSelectedItem())
        theMsg += "Default Account:  %s\n"         %(user_accounts.getSelectedItem())
        theMsg += "Import Type:      %s (%s)\n"    %(IMPORT_TYPE[theImportType],theImportType)
        theMsg += "Structure Only:   %s\n"         %(user_importStructureOnly.isSelected())

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Please confirm parameters:",
                             theMessage=theMsg,
                             theWidth=225,
                             theTitle="QIF IMPORT",
                             OKButtonText="PROCEED",
                             lCancelButton=True)
        if (not ask.go() or not myPopupAskBackup(toolbox_frame_,"Do you want to make a Backup before your QIF Import?")):
            txt = "%s: User aborted - NO CHANGES MADE" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B","User has requested a QIF import with these following parameters:\n")
        myPrint("B",theMsg)
        myPrint("J",">>EXECUTING IMPORT................\n")

        MD_REF.importQIFIntoAccount(    MD_REF.getCurrentAccount().getBook(),
                                            File(QIFfilename),
                                            theQIFFormat,                           # one of Common.QIF_FORMAT_MMDDYY, QIF_FORMAT_YYMMDD, QIF_FORMAT_DDMMYY, QIF_FORMAT_AUTO
                                            user_selectDecimal.getSelectedItem(),   # your decimal place character.
                                            user_currency.getSelectedItem(),        # the default currency to use for any new accounts that are created
                                            theAcct,                                # the default account to import into (though the QIF file may also specify multiple accounts with names)
                                            theImportType,                          # Common.QIF_MODE_DOWNLOAD or Common.QIF_MODE_TRANSFER
                                            user_importStructureOnly.isSelected())  # if true, only import the account and category structure

        myPrint("J",">>FINISHED IMPORT................\n")

        txt = "%s: File %s imported (review console log for any messages)" %(_THIS_METHOD_NAME, os.path.basename(QIFfilename))
        setDisplayStatus(txt, "B")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

        ConsoleWindow.showConsoleWindow(MD_REF.getUI())

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def convert_timestamp_readable_date():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        getTimeStamp = myPopupAskForInput(toolbox_frame_,"CONVERT TIMESTAMP","TimeStamp:","Enter the TimeStamp (Milliseconds) to see the readable date")

        setDisplayStatus(" ", "DG")

        if getTimeStamp is None or getTimeStamp == "" or not StringUtils.isInteger(getTimeStamp) or int(getTimeStamp) < 1: return
        readableStamp = get_time_stamp_as_nice_text(int(getTimeStamp))

        txt = "Convert Timestamp (%s): %s" %(getTimeStamp,readableStamp)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"CONVERT TIMESTAMP")

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def force_remove_extension():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("DB", "User requested to delete all references to orphaned/outdated Extensions from config.dict and *.mxt files...")

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            txt = "No orphaned Extension preferences or files detected - nothing to do!"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        displayData="\nLISTING EXTENSIONS ORPHANED IN CONFIG.DICT OR FILES (*.MXT)\n\n"

        for x in orphan_prefs.keys():
            displayData+="%s Extension: %s is %s\n" %(pad("config.dict:",40),pad(x,40),pad(orphan_prefs[x],40))

        displayData+="\n"

        for x in orphan_confirmed_extn_keys.keys():
            _theVersion = MD_REF.getUI().getPreferences().getSetting(orphan_confirmed_extn_keys[x][1],None)
            displayData+="%s Extension: %s Key: %s (build: %s) is %s\n" %(pad("config.dict: ",40),pad(x,40),pad(orphan_confirmed_extn_keys[x][1],40),_theVersion,pad(orphan_confirmed_extn_keys[x][0],40))

        displayData+="\n"

        for x in orphan_files.keys():
            displayData+="%s Extension: %s is %s\n" %(pad("File: "+orphan_files[x][1],40),pad(x,40),pad(orphan_files[x][0],40))

        displayData+="\n<END>"
        jif = QuickJFrame("ORPHANED EXTENSIONS", displayData,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if not confirm_backup_confirm_disclaimer(jif, "DELETE ORPHANED EXTENSIONS", "delete the Extension Orphans?"):
            return

        extensionDir = Common.getFeatureModulesDirectory()
        if not extensionDir:
            txt = "DELETE ORPHANED EXTENSIONS - Error getting Extensions directory - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not backup_config_dict():
            txt = "DELETE ORPHANED EXTENSIONS - Error backing up config.dict preferences file - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # reload latest preferences
        extension_prefs = MD_REF.getUI().getPreferences().getTableSetting("gen.fmodules",None)
        if not extension_prefs:
            txt = "DELETE ORPHANED EXTENSIONS - Error getting gen.fmodules setting - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # OK - let's go....!! Delete away!!!
        for x in orphan_prefs.keys():
            extension_prefs.put(x,None)
            myPrint("B","Orphaned extension %s removed from config.dict!" %x)

        MD_REF.getUI().getPreferences().setSetting("gen.fmodules",extension_prefs)
        myPrint("B","config.dict gen.fmodules setting re-saved....")

        for x in orphan_confirmed_extn_keys:
            MD_REF.getUI().getPreferences().setSetting(orphan_confirmed_extn_keys[x][1],None)
            myPrint("B","Orphaned extension key %s removed from config.dict!" %orphan_confirmed_extn_keys[x][1])

        MD_REF.savePreferences()

        lError=False
        # extensionDir = Common.getFeatureModulesDirectory()
        for x in orphan_files.keys():
            # noinspection PyTypeChecker
            fileToDelete = os.path.join(extensionDir.getAbsolutePath(),orphan_files[x][1])
            if not os.path.exists(fileToDelete):
                lError=True
                myPrint("B","ERROR orphaned extension file %s MISSING" %fileToDelete)
            else:
                try:
                    os.remove(fileToDelete)
                    myPrint("B","Orphaned extension file %s deleted" %fileToDelete)
                except:
                    lError=True
                    myPrint("B","ERROR deleting orphaned extension file %s deleted" %fileToDelete)
                    dump_sys_error_to_md_console_and_errorlog()

        play_the_money_sound()

        if lError:
            myPrint("B", "Orphaned Extensions have been deleted - WITH ERRORS - from config.dict and the .MXT files from the Extensions folder....")
            txt = "ORPHANED EXTENSIONS HAVE BEEN DELETED - WITH ERRORS - REVIEW CONSOLE ERROR LOG!"
        else:
            myPrint("B", "SUCCESS - Your Orphaned Extensions have been deleted from config.dict and the .MXT files from the Extensions folder....")
            txt = "SUCCESS - YOUR ORPHANED EXTENSIONS HAVE BEEN DELETED - RESTART MONEYDANCE!"

        setDisplayStatus(txt, "R")
        myPopupInformationBox(jif, txt, "DELETE ORPHANED EXTENSIONS", JOptionPane.ERROR_MESSAGE)
        return

    def reset_window_positions():
        global toolbox_frame_, debug
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _RESETWINLOC    = 0
        _RESETREGFILT   = 1
        _RESETREGVIEW   = 2
        _RESETALL       = 3

        what = [
            "RESET - Only Window Locations on their own (Excludes Filters & Views)",
            "RESET - Only Transaction Register Filters",
            "RESET - Only Transaction Register Initial / Current View screen",
            "RESET - Window display settings (Sizes, Locations, Sorts, Widths etc) - Everything EXCEPT Filters & Views"
        ]

        resetWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                "Select the Window display setting(s) to RESET",
                                                "RESET WINDOW DISPLAY SETTINGS",
                                                JOptionPane.WARNING_MESSAGE,
                                                None,
                                                what,
                                                None)
        if not resetWhat:
            txt = "No RESET WINDOW DISPLAY SETTINGS TYPE option was chosen - no changes made!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User requested to %s settings from config.dict, LocalStorage() ./safe/settings , and by account!" %resetWhat)

        lAll = lWinLocations = lRegFilters = lRegViews = False

        if resetWhat == what[_RESETALL]:        lAll            = True
        if resetWhat == what[_RESETWINLOC]:     lWinLocations   = True
        if resetWhat == what[_RESETREGFILT]:    lRegFilters     = True
        if resetWhat == what[_RESETREGVIEW]:    lRegViews       = True

        def get_set_config(st, tk, lReset, lResetAll, lResetWinLoc, lResetRegFilters, lResetRegViews ):                 # noqa
            # As of 2021.2010   Window locations are only in config.dict.
            #                   Register Filters and Initial Register Views are only in LocalStorage()
            #                   column width, sort orders, etc are everywhere......

            configData = []

            if not lReset:
                configData.append("\nDATA STORED WITHIN CONFIG.DICT (effectively defaults where not specifically set by Account):")
                configData.append("--------------------------------------------------------------------------------------------")

            lastKey = None
            for theKey in tk:
                # Skip config settings we don't want to reset

                # Main safety filter here
                value = st.get(theKey)
                if not check_for_window_display_data(theKey, value): continue

                if lResetAll:
                    pass
                elif lResetWinLoc:
                    if not check_for_just_locations_window_display_data(theKey, value): continue
                elif lResetRegFilters:
                    if not check_for_just_register_filters_window_display_data(theKey, None): continue
                elif lResetRegViews:
                    if not check_for_just_initial_view_filters_window_display_data(theKey, None): continue
                else:
                    myPrint("B", "@@@ ERROR in get_set_config(): unexpected parameter!?")
                    raise(Exception("@@@ ERROR in get_set_config(): unexpected parameter!?"))

                test = "col_widths."
                if theKey.startswith(test):
                    if lReset:
                        MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("COLUMN WIDTHS:")

                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                test = "ext_mgmt_win"
                if theKey.startswith(test):
                    if lReset:
                        MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nEXTENSIONS WINDOW:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                test = "moneybot_py_divider"
                if theKey.startswith(test):
                    if lReset:
                        MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nMONEYBOT:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                test = "mbot."
                if theKey.startswith(test):
                    if lReset:
                        MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nMONEYBOT:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                test = "gui."
                if theKey.startswith(test):
                    if lReset:
                        MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nGUI.:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                myPrint("B","@@ RESET WINDOW DATA - ERROR >> What is this key: %s ? @@" %theKey)
                raise(Exception("ERROR - caught an un-coded key: " + str(theKey)))

            # END OF config.dict search
            ########################################################################################################

            if lResetAll or lResetRegFilters or lResetRegViews:
                # Now get the same data for each account
                accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(6))

                if not lReset:
                    configData.append("\nDATA STORED INTERNALLY BY ACCOUNT (not config.dict):")
                    configData.append("-----------------------------------------------------")

                dataPrefKey = "col_widths."
                dataPrefKeys_legacy = [  "gui.col_widths",
                                         "rec_reg.credit",
                                         "rec_reg.debit" ]

                keyIterator=[]
                if lResetRegFilters:    keyIterator.append("sel_reg_filter")
                if lResetRegFilters:    keyIterator.append("sel_invreg_filter")
                if lResetRegViews:      keyIterator.append("sel_inv_view")

                for acct in accounts:

                    last = None

                    if lResetAll:
                        for x in _COLWIDTHS:
                            xx = acct.getPreference(dataPrefKey+x, None)

                            if xx:
                                if lReset:
                                    # NOTE: This really sets the preference in LocalStorage() with the acct's UUII+"." prepended as the key!!!! (Sneaky eh!!??)
                                    acct.setPreference(dataPrefKey+x, None)
                                    # acct.syncItem() # Not entirely sure about this.... If Preference goes to LocalStorage() then Acct shouldn't be affected..
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Key: %s Value: %s" %(pad(dataPrefKey+x+":",30),str(xx).strip()))

                    if lResetRegFilters or lResetRegViews:
                        for x in keyIterator:
                            xx = acct.getPreference(x, None)

                            if xx:
                                if lReset:
                                    # NOTE: This really sets the preference in LocalStorage() with the acct's UUII+"." prepended as the key!!!! (Sneaky eh!!??)
                                    acct.setPreference(x, None)
                                    # acct.syncItem() # Not entirely sure about this.... If Preference goes to LocalStorage() then Acct shouldn't be affected..
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Key: %s Value: %s" %(pad(x+":",30),str(xx).strip()))

                    lNeedsSync = False

                    if lResetAll:
                        for theLegacyKey in dataPrefKeys_legacy:

                            # Look for legacy keys actually on the account..!
                            yy = acct.getParameter(theLegacyKey, None)

                            if yy:  # Should be a legacy setting
                                if lReset:
                                    acct.setEditingMode()
                                    acct.setParameter(theLegacyKey, None)
                                    lNeedsSync = True
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Legacy Key: %s Value: %s" %(pad(theLegacyKey+":",30-7),str(yy).strip()))

                    if lResetRegFilters or lResetRegViews:
                        for theLegacyKey in keyIterator:

                            # Look for legacy keys actually on the account..!
                            yy = acct.getParameter(theLegacyKey, None)

                            if yy:  # Should be a legacy setting
                                if lReset:
                                    acct.setEditingMode()
                                    acct.setParameter(theLegacyKey, None)
                                    lNeedsSync = True
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Legacy Key: %s Value: %s" %(pad(theLegacyKey+":",30-7),str(yy).strip()))

                    if lReset and lNeedsSync:
                        acct.syncItem()

                # END OF Accounts search
                ########################################################################################################

                if not lReset:
                    configData.append("\nDATA STORED INTERNALLY WITHIN LOCAL STORAGE (not config.dict):")
                    configData.append("----------------------------------------------------------------")

                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                keys=sorted(LS.keys())

                if lResetAll:

                    last = None

                    for theKey in keys:
                        value = LS.get(theKey)

                        for theTypeToCheck in dataPrefKeys_legacy:

                            if theKey.endswith("."+theTypeToCheck):

                                if lReset:
                                    LS.put(theKey, None)
                                else:
                                    splitKey = theKey.split('.')
                                    if splitKey[0] != last:
                                        last = splitKey[0]
                                        lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])
                                        if lookupAcct:
                                            configData.append("\n>>Account: %s" %(lookupAcct.getAccountName()))
                                        else:
                                            configData.append("\n>>Account: <NOT FOUND> ???")

                                    configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                        # Now look for keys not linked to Accounts... Perhaps deleted ones?
                        for theTypeToCheck in _COLWIDTHS:

                            if theKey.endswith(".col_widths."+theTypeToCheck):

                                splitKey = theKey.split('.')
                                lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])

                                if lookupAcct: continue     # Found one, probably caught above, so skip

                                if lReset:
                                    LS.put(theKey, None)
                                else:
                                    if splitKey[0] != last:
                                        last = splitKey[0]
                                        configData.append("\n>>Account: <NOT FOUND> ??? (probably a deleted account)")

                                    configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                if lResetRegFilters or lResetRegViews:

                    last = None

                    for theKey in keys:
                        value = LS.get(theKey)

                        if lResetRegFilters:
                            if not check_for_just_register_filters_window_display_data(theKey, None):
                                continue
                        elif lResetRegViews:
                            if not check_for_just_initial_view_filters_window_display_data(theKey, None):
                                continue
                        else:
                            myPrint("B", "@@ ERROR: RESET WINDOW DISPLAY SETTINGS - Unexpected filter!?")
                            raise(Exception("@@ ERROR: RESET WINDOW DISPLAY SETTINGS - Unexpected filter!?"))

                        if lReset:
                            LS.put(theKey, None)
                        else:
                            splitKey = theKey.split('.')
                            if splitKey[0] != last:
                                last = splitKey[0]
                                lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])
                                if lookupAcct:
                                    configData.append("\n>>Account: %s" %(lookupAcct.getAccountName()))
                                else:
                                    configData.append("\n>>Account: <NOT FOUND>???")

                            configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                # END OF LocalStorage() search
                ########################################################################################################

            configData.append("\n <END>")

            for i in range(0, len(configData)):
                configData[i] = configData[i] + "\n"

            configData = "".join(configData)

            if not lReset:
                jif = QuickJFrame("View the relevant RESET WINDOW DISPLAY SETTINGS that will be reset if you select OK to proceed", configData,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                return jif

            return

        st,tk = read_preferences_file(lSaveFirst=False)

        if not st:
            txt = "ERROR: RESET WINDOW DISPLAY SETTINGS >> reading and sorting the data file - no changes made!..."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(None,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("D", "\nDisplaying the relevant RESET WINDOW DISPLAY SETTINGS (in various places) that I can reset.....:\n")

        theNewViewFrame = get_set_config(st, tk, False, lAll, lWinLocations, lRegFilters, lRegViews)

        if not myPopupAskQuestion(theNewViewFrame,
                                  "RESET WINDOW DISPLAY SETTINGS",
                                  "WARNING: Have you closed all Account Register windows and made sure only the Main Home Screen / Summary page is visible first??",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.WARNING_MESSAGE):
            txt = "WARNING: Close all Account Register Windows and make sure only the Main Home Screen Summary/Dashboard is visible before running the Reset Windows Sizes!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(theNewViewFrame,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(theNewViewFrame, "RESET WINDOW DISPLAY SETTINGS", "%s data?" %(resetWhat)):
            return

        if not backup_config_dict():
            txt = "RESET WINDOW DISPLAY SETTINGS: ERROR making backup of config.dict - no changes made!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(theNewViewFrame,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not backup_local_storage_settings():
            txt = "RESET WINDOW DISPLAY SETTINGS: ERROR making backup of LocalStorage() ./safe/settings - no changes made!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(theNewViewFrame,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # DO THE RESET HERE
        get_set_config(st, tk, True, lAll, lWinLocations, lRegFilters, lRegViews)

        MD_REF.savePreferences()                # save config.dict
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()    # Flush local storage to safe/settings

        play_the_money_sound()
        myPrint("B", "SUCCESS - %s data reset in config.dict config file, internally by Account & Local Storage...." %(resetWhat))
        txt = "OK - %s settings forgotten.... RESTART MD!" %(resetWhat)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(theNewViewFrame, "SUCCESS - %s - RESTART MONEYDANCE" %(resetWhat), "RESET WINDOW DISPLAY SETTINGS", JOptionPane.WARNING_MESSAGE)

        return

    def hacker_mode_suppress_dropbox_warning():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        ask=MyPopUpDialogBox(toolbox_frame_,theStatus="You can suppress the 'Your file seems to be in a shared folder' Warning..",
                             theMessage="Moneydance support states that you should NEVER store your dataset in Dropbox.\n"
                                        "... and that you should store your dataset locally and use Moneydance's built-in syncing instead to share across computers and devices.\n"
                                        "THEREFORE YOU PROCEED AT ENTIRELY YOUR OWN RISK AND ACCEPT THAT STORING IN DROPBOX MIGHT DAMAGE YOUR DATA!",
                             theWidth=200,
                             theTitle="SUPPRESS DROPBOX WARNING",
                             lCancelButton=True,
                             OKButtonText="ACCEPT RISK",
                             lAlertLevel=3)

        if not ask.go():
            txt = "'SUPPRESS DROPBOX WARNING' - User chose to exit  - no changes made"
            setDisplayStatus(txt, "R")
            return

        if confirm_backup_confirm_disclaimer(toolbox_frame_, "SUPPRESS DROPBOX WARNING", "Suppress 'Your data is stored in a shared folder' (Dropbox) message?"):
            suppressFile = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "suppress_file_in_dropbox_restriction.txt")
            if not os.path.exists(suppressFile):
                try:
                    x=open(suppressFile, "w")
                    x.write("DISCLAIMER - YOU SUPPRESS THE 'Your file is stored in a shared folder' (Dropbox) WARNING AT YOUR OWN RISK\n"
                            "STORING YOUR MD DATASET IN DROPBOX CAN DAMAGE YOUR DATASET\n\n"
                            "(Warning courtesy of Toolbox)")

                    x.close()
                    myPrint("B","HACKER MODE: 'SUPPRESS DROPBOX WARNING': User requested to suppress the 'Your file is stored in a shared folder' (dropbox) warning....")
                    myPrint("B", "@@User accepted warnings and disclaimer about dataset damage and instructed Toolbox to create %s - EXECUTED" %(suppressFile))
                    play_the_money_sound()
                    txt = "'SUPPRESS DROPBOX WARNING' - Suppressed >> 'Your file is stored in a shared folder' (dropbox) warning. MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,"'SUPPRESS DROPBOX WARNING'",JOptionPane.ERROR_MESSAGE)
                    MD_REF.getUI().exit()
                except:
                    myPrint("B","'SUPPRESS DROPBOX WARNING' - Error creating %s" %(suppressFile))
                    dump_sys_error_to_md_console_and_errorlog()

            txt = "'SUPPRESS DROPBOX WARNING' - ERROR - either the file already exists, or I failed to create the file..(review console log)?"
            setDisplayStatus(txt, "R")

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def hacker_mode_save_trunk_file():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "HACK: SAVE TRUNK FILE"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME,"Execute Save Trunk File function?"):
            return

        myPrint("B","%s: Calling saveTrunkFile() now at user request...." %(_THIS_METHOD_NAME))
        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..
        MD_REF.getCurrentAccount().getBook().saveTrunkFile()
        play_the_money_sound()

        txt = "%s: Save Trunk Executed!" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hacker_mode_sync_push_pull(_push_pull):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "HACK: FORCE SYNC PUSH/PULL"

        PUSH_RESYNC = "tiksync/force_push_resync"                                                                       # noqa
        PULL_RESYNC = "tiksync/force_pull_resync"                                                                       # noqa

        lSyncPush = lSyncPull = False
        if _push_pull.upper() == "PUSH": lSyncPush = True
        if _push_pull.upper() == "PULL": lSyncPull = True
        if not lSyncPush and not lSyncPull: raise Exception("%s: Invalid parameter supplied" %(_THIS_METHOD_NAME))

        if lSyncPull: raise Exception("%s: Sorry - PULL function is disabled" %(_THIS_METHOD_NAME))

        if lSyncPull: _THIS_METHOD_NAME = "HACK: FORCE SYNC PULL"
        if lSyncPush: _THIS_METHOD_NAME = "HACK: FORCE SYNC PUSH"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()                                                      # noqa

        if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = "%s: Sorry - can only push from a Primary Sync Dataset...(Toolbox can promote to Primary if required)" %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)

        syncFolder = None                                                                                               # noqa
        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
        except:
            syncFolder = False                                                                                          # noqa
            dump_sys_error_to_md_console_and_errorlog()
            txt = "Sorry - cannot proceed as error getting Sync status (review console for details)"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if syncFolder is None:
            txt = "%s: Cannot proceed as you don't appear to be using Sync" %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        txt = None
        if lSyncPull:
            txt = "THIS WILL FORCE SYNC TO PULL REMOTE DATASET, OVERWRITING YOUR LOCAL COPY"
            myPopupInformationBox(toolbox_frame_, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            txt = "%s: Execute Sync Force Pull (of remote Sync Data, overwrite local data)?" %(_THIS_METHOD_NAME)
        if lSyncPush:
            txt = "THIS WILL FORCE SYNC TO PUSH LOCAL DATASET, OVERWRITING REMOTE COPIES"
            myPopupInformationBox(toolbox_frame_, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            txt = "%s: Execute Sync Force Push (of local Sync Data to remotes)?" %(_THIS_METHOD_NAME)

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME,txt): return

        myPrint("B", "User accepted disclaimer - now executing: %s" %(txt))
        MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..

        if lSyncPush:
            MD_REF.getCurrentAccount().getBook().getSyncer().forceResyncFromLocal()
            myPrint("B", "@@ Called .getSyncer().forceResyncFromLocal() to Force Push (Re)Sync to remotes...")
            # storage.writeToFileAtomically(PyByteArray(), PUSH_RESYNC)
            # myPrint("B", "@@ Created: %s" %(PUSH_RESYNC))

        if lSyncPull:
            MD_REF.getUI().getCurrentAccounts().setNeedsResetFromSyncFolder()
            myPrint("B", "@@ Called .getCurrentAccounts().setNeedsResetFromSyncFolder() to Force Pull (Re)Sync from remotes...")

            # MD_REF.getCurrentAccount().getBook().getSyncer().resetSyncingAndWaitForRemoteData()
            # myPrint("B", "@@ Called .getSyncer().resetSyncingAndWaitForRemoteData() to Force Pull (Re)Sync from remotes...")

            # storage.writeToFileAtomically(PyByteArray(), PULL_RESYNC)
            # myPrint("B", "@@ Created: %s" %(PULL_RESYNC))

        MD_REF.getUI().getMain().saveCurrentAccount()
        play_the_money_sound()

        txt = "%s: Force Sync Push/Pull requested." %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")

        ConsoleWindow.showConsoleWindow(MD_REF.getUI())
        MyPopUpDialogBox(toolbox_frame_,
                         "%s" %(txt),
                         "Check the Help>Console Window...\n"
                         "Wait (up to) a few minutes and look for the following entries in the console log....:\n"
                         "...'Toolbox.... @@ Called .getSyncer().forceResyncFromLocal() to Force Push (Re)Sync to remotes...'\n"
                         "...'uploading new trunk file v3/trunk-nnnnnnnnnnnn.mdtxn to syncFolder'\n"
                         "...'deleting stale sync log file: v3/nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.mdtxn'\n"
                         "(the above line may repeat several times)...\n"
                         "... and then 'checking for txn logs...'....\n"
                         "When it's finished, hopefully with no errors, then RESTART MD. <GOOD LUCK!>",
                         theTitle=_THIS_METHOD_NAME,
                         theWidth=160, lModal=True,OKButtonText="ACKNOWLEDGE").go()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hacker_mode_set_check_days():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        key = "moneydance.checknum_series_threshold"
        props_lookback_days = System.getProperty(key, "180")

        ask = MyPopUpDialogBox(toolbox_frame_,"Next Check Number Algorithm look-back Threshold:",
                               'System.getProperty("%s") currently set to: %s\n'%(key,props_lookback_days),
                               200,"NEXT CHEQUE NUMBER ALGORITHM",
                               lCancelButton=True,OKButtonText="CHANGE")
        if not ask.go():
            txt = "HACKER MODE: NO CHANGES MADE TO NEXT CHECK NUMBER LOOK-BACK THRESHOLD"
            setDisplayStatus(txt, "B")
            return

        lDidIChangeDays=False

        while True:
            days_response = myPopupAskForInput(toolbox_frame_,"CHANGE NEXT CHECK NUMBER LOOK-BACK THRESHOLD","Days:",
                                               "Enter new number of days (1 to 365):",props_lookback_days)

            if days_response is None:
                days_response = 0
                break
            elif days_response == props_lookback_days:
                break
            elif not StringUtils.isInteger(days_response):
                continue
            elif int(days_response)>0 and int(days_response)<365:                                                       # noqa
                lDidIChangeDays = True
                break

        if lDidIChangeDays:
            System.setProperty(key,str(days_response))
            myPrint("B","HACKER MODE: System Property '%s' set to %s" %(key,days_response))
        else:
            txt = "HACKER MODE: NO CHANGES MADE TO NEXT CHECK NUMBER LOOK-BACK THRESHOLD"
            setDisplayStatus(txt, "B")
            return

        txt = "HACKER MODE: Next Check Number Algorithm look-back Threshold set to %s (days)" %(days_response)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"NEXT CHEQUE NUMBER ALGORITHM",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def hacker_mode_edit_parameter_keys():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if not myPopupAskQuestion(toolbox_frame_,"HACKER: EDIT OBJ'S MODE","DANGER - ARE YOU SURE YOU WANT TO VISIT THIS FUNCTION?",
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
            txt = "Hacker Edit Obj Mode - User declined to proceed - aborting.."
            setDisplayStatus(txt, "R")
            return

        objSelecter = GeekOutModeButtonAction(lOFX=False, EDIT_MODE=True)
        theObject = objSelecter.actionPerformed("")  # type: list
        del objSelecter

        if theObject is None or len(theObject)!=1:
            # txt = "Hacker Edit Obj Mode - No Object selected/found - aborting.."
            # setDisplayStatus(txt, "R")
            return

        theObject = theObject[0]            # type: MoneydanceSyncableItem

        _HACK_KEYADD          = 0
        _HACK_KEYCHG          = 1
        _HACK_KEYDEL          = 2
        _HACK_RECORDDELETE    = 3

        what = [
            "HACK: Object ADD    Parameter Key (and data)",
            "HACK: Object CHANGE Parameter Key's Data",
            "HACK: Object DELETE Parameter Key (and it's data)",
            "HACK: DELETE OBJECT - NOT RECOMMENDED!"
        ]

        while True:

            lAdd = lChg = lDel = lDeleteRecord = False

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the option for the HACK (on %s)?" %(theObject),
                                                       "HACKER",
                                                       JOptionPane.WARNING_MESSAGE,
                                                       None,
                                                       what,
                                                       None)

            if not selectedWhat:
                txt = "Thank you for using HACKER MODE!.. Exiting"
                setDisplayStatus(txt, "B")
                return

            if selectedWhat == what[_HACK_KEYADD]:          lAdd = True
            if selectedWhat == what[_HACK_KEYCHG]:          lChg = True
            if selectedWhat == what[_HACK_KEYDEL]:          lDel = True
            if selectedWhat == what[_HACK_RECORDDELETE]:    lDeleteRecord = True

            text = ""
            if lChg:            text = "ADD"
            if lChg:            text = "CHANGE"
            if lDel:            text = "DELETE"
            if lDeleteRecord:   text = "DELETE OBJECT"

            if lAdd:
                addKey = myPopupAskForInput(toolbox_frame_,
                                            "HACKER: ADD PARAMETER TO %s" % (theObject),
                                            "PARAMETER:",
                                            "Carefully enter the name of the Parameter you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                            "",
                                            False,
                                            JOptionPane.WARNING_MESSAGE)

                if not addKey or len(addKey.strip()) < 1: continue
                addKey = addKey.strip()

                if not check_if_key_string_valid(addKey):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter %s is NOT valid!" % addKey, "HACKER: ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to Hacker menu

                testKeyExists = theObject.getParameter(addKey,None)                                                     # noqa

                if testKeyExists:
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter %s already exists - cannot add - aborting..!" %(addKey), "HACKER: ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to Hacker menu

                addValue = myPopupAskForInput(toolbox_frame_,
                                              "HACKER: ADD PARAMETER VALUE TO %s" %(theObject),
                                              "VALUE:",
                                              "Carefully enter the value you want to add (STRINGS ONLY! CaSE MattERS):",
                                              "",
                                              False,
                                              JOptionPane.WARNING_MESSAGE)

                if not addValue or len(addValue.strip()) <1: continue
                addValue = addValue.strip()

                if not check_if_key_data_string_valid(addValue):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter value %s is NOT valid!" %(addValue), "HACKER: ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to Hacker menu

                if confirm_backup_confirm_disclaimer(toolbox_frame_, "HACKER MODE","ADD PARAMETER VALUE TO %s" %(theObject)):

                    theObject.setParameter(addKey,addValue)                                                             # noqa
                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.syncItem()                                                                            # noqa
                    play_the_money_sound()
                    txt = "@@ HACKERMODE: Parameter: %s Value: %s added to %s @@" %(addKey,addValue,theObject)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_,
                                          "SUCCESS: Key %s added to %s!" % (addKey,theObject),
                                          "HACKER: ADD TO %s" %(theObject),
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                continue

            # DELETE OBJECT  :-<
            if lDeleteRecord:

                output =  "%s PLEASE REVIEW PARAMETER & VALUE BEFORE DELETING OBJECT\n" %(theObject)
                output += "---------------------------------------------------------\n\n"

                if isinstance(theObject, SplitTxn):
                    txt = theObject.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                else:
                    txt = theObject.getSyncInfo().toMultilineHumanReadableString()

                output += "\n%s\n" %(txt)

                output += "\n<END>"
                if isinstance(theObject, SplitTxn):
                    jif = QuickJFrame("REVIEW THE SPLIT TXN's DATA BEFORE DELETION (OF THE SPLIT)", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                elif isinstance(theObject, ParentTxn):
                    jif = QuickJFrame("REVIEW THE PARENT'S TXN DATA BEFORE DELETION (OF THE WHOLE PARENT TXN)", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                else:
                    jif = QuickJFrame("REVIEW THE OBJECT's DATA BEFORE DELETION", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

                if confirm_backup_confirm_disclaimer(jif, "HACKER: DELETE OBJECT","DELETE OBJECT %s" %(theObject)):

                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        # This will delete the split only; thus we also must sync the parent
                        theObject.deleteItem()                                                                          # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.deleteItem()                                                                          # noqa

                    play_the_money_sound()
                    txt = "@@ HACKERMODE: OBJECT %s DELETED @@" %(theObject)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)

                    myPopupInformationBox(jif,
                                          "SUCCESS: OBJECT %s DELETED" %(theObject),
                                          "HACKER: DELETE OBJECT",
                                          JOptionPane.ERROR_MESSAGE)
                    return

                continue

            # OK, so we are changing or deleting
            if lChg or lDel:

                paramKeys = sorted(theObject.getParameterKeys())                                                        # noqa
                selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                          "Select the %s Parameter you want to %s" % (theObject,text),
                                                          "HACKER",
                                                          JOptionPane.WARNING_MESSAGE,
                                                          None,
                                                          paramKeys,
                                                          None)
                if not selectedKey: continue

                value = theObject.getParameter(selectedKey, None)                                                       # noqa

                output =  "%s PLEASE REVIEW PARAMETER & VALUE BEFORE MAKING CHANGES\n" %(theObject)
                output += "------------------------------------------------\n\n"

                output += "\n@@ This '%s' key can be changed/deleted by this script @@\n" % selectedKey

                output += "\n%s %s\n" %(pad("%s PARAMETER:"%(theObject),25),selectedKey)
                output += "\n%s %s\n" %(pad("Type:",25), type(value))
                output += "\n%s %s\n" %(pad("Value:",25), value)

                output += "\n<END>"
                jif = QuickJFrame("REVIEW THE KEY BEFORE CHANGES to %s" %(theObject), output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

                chgValue = None

                if lChg:
                    chgValue = myPopupAskForInput(jif,
                                                  "HACKER: CHANGE PARAMETER VALUE IN %s" %(theObject),
                                                  "VALUE:",
                                                  "Carefully enter the new value (STRINGS ONLY! CaSE MattERS):",
                                                  value,
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                    chgValue = chgValue.strip()

                    if not check_if_key_data_string_valid(chgValue):
                        myPopupInformationBox(jif,"ERROR: value %s is NOT valid!" %chgValue,"HACKER: CHANGE IN %s" %(theObject),JOptionPane.ERROR_MESSAGE)
                        continue    # back to Hacker menu

                confAction = ""
                if lDel:
                    confAction = "%s key: %s (with old value: %s)" %(text,selectedKey,value)
                if lChg:
                    confAction = "%s key: %s to new value: %s" %(text,selectedKey,chgValue)

                if confirm_backup_confirm_disclaimer(jif, "HACKER: %s VALUE IN %s" %(text,theObject),confAction):

                    if lDel:
                        theObject.setParameter(selectedKey,None)                                                        # noqa

                    if lChg:
                        theObject.setParameter(selectedKey,chgValue)                                                    # noqa

                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.syncItem()                                                                            # noqa

                    MD_REF.savePreferences()            # Flush all in memory settings to config.dict file on disk
                    play_the_money_sound()

                    if lDel:
                        myPrint("B","@@ HACKERMODE: Parameter: %s DELETED from %s (old value: %s) @@" %(selectedKey,theObject,value))
                        myPopupInformationBox(jif,
                                              "SUCCESS: Parameter: %s DELETED from %s (old value: %s)" %(selectedKey,theObject,value),
                                              "HACKER: DELETE IN %s" %theObject,
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        myPrint("B","@@ HACKERMODE: Parameter: %s CHANGED to %s in %s @@" %(selectedKey,chgValue, theObject))
                        myPopupInformationBox(jif,
                                              "SUCCESS: Parameter: %s CHANGED to %s in %s" %(selectedKey,chgValue, theObject),
                                              "HACKER: CHANGE IN %s" %theObject,
                                              JOptionPane.WARNING_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                jif.dispose()       # already within the EDT
                continue

        # ENDWHILE

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def hacker_remove_int_external_files_settings():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        options = ["Remove 'External' entries from File>Open menu [and optionally DELETE dataset from disk too]",
                   "DELETE 'Internal' / Default location dataset(s) from Disk (which will also remove entry from File>Open)"]

        selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                     "Select the option you require",
                                                     "HACKER: DELETE INT/EXT DATASET",
                                                     JOptionPane.WARNING_MESSAGE,
                                                     MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                     options,
                                                     None)

        if not selectedOption or options.index(selectedOption) > 1:
            txt = "No option selected.. No changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        theText = ""
        lInternal = lExternal = False
        if options.index(selectedOption) == 0:
            lExternal = True
            theText = ( "This allows you to REMOVE references to Datasets stored in the non-default/External locations\n"
                        "This removes the entries from the MD File>Open Menu.\n"
                        "(These may not actually exist on disk any more)\n"
                        "I will offer you each Dataset name one-by-one\n"
                        "You will not be offered, or allowed, to delete the current open dataset\n"
                        "OPTIONALLY - You can choose to also DELETE these dataset(s) FROM DISK (after your confirmation)\n"
                        "There will not be any backup prompts - please do this yourself first!\n"
                        "(RESTART MD AFTER USING TO REFRESH THE File>Open list)\n\n"
                        "THIS IS THE DISCLAIMER UP FRONT - CLICK I AGREE TO PROCEED" )
        elif options.index(selectedOption) == 1:
            lInternal = True
            theText = ( "This allows you to DELETE Datasets from the MD Internal/Default location\n"
                        "I will offer you each Dataset name one-by-one\n"
                        "You will not be offered, or allowed, to delete the current open dataset\n"
                        "Each one you select will be DELETED FROM DISK (after your confirmation)\n"
                        "(This will therefore remove the entry from the MD File>Open Menu)\n"
                        "There will not be any backup prompts - please do this yourself first!\n"
                        "(RESTART MD AFTER USING TO REFRESH THE File>Open list)\n\n"
                        "THIS IS THE DISCLAIMER UP FRONT - CLICK I AGREE TO PROCEED" )

        ask=MyPopUpDialogBox(toolbox_frame_,
                             "For Your Information",
                             theText,
                             theWidth=225,
                             theTitle="HACK: REMOVE ENTRIES/DATASETS",
                             OKButtonText="I AGREE - PROCEED", lCancelButton=True,
                             lAlertLevel=2)
        if not ask.go():
            txt = "No agreement to proceed.. No changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if lInternal:
            hackerRemoveInternalFilesSettings()

        elif lExternal:
            hackerRemoveExternalFilesSettings()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def hacker_mode():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _HACKCONFIGADD          = 0
        _HACKCONFIGCHG          = 1
        _HACKCONFIGDEL          = 2
        _HACKLOCALSTORAGEADD    = 3
        _HACKLOCALSTORAGECHG    = 4
        _HACKLOCALSTORAGEDEL    = 5

        what = [
            "HACK: config.dict ADD setting",
            "HACK: config.dict CHANGE setting",
            "HACK: config.dict DELETE setting",
            "HACK Local Storage Setting ADD setting",
            "HACK Local Storage Setting CHANGE setting",
            "HACK Local Storage Setting DELETE setting"
        ]

        while True:

            lAdd = lChg = lDel = False
            lConfigDict = lLocalStorage = False

            # noinspection PyUnusedLocal
            LS = st = tk = prefs = fileType = None

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Key data / option for the Hack",
                                                       "HACKER",
                                                       JOptionPane.WARNING_MESSAGE,
                                                       None,
                                                       what,
                                                       None)

            if not selectedWhat:
                txt = "Thank you for using HACKER MODE!.."
                setDisplayStatus(txt, "B")
                return

            if selectedWhat == what[_HACKCONFIGADD]: lAdd = True
            if selectedWhat == what[_HACKCONFIGCHG]: lChg = True
            if selectedWhat == what[_HACKCONFIGDEL]: lDel = True
            if selectedWhat == what[_HACKLOCALSTORAGEADD]: lAdd = True
            if selectedWhat == what[_HACKLOCALSTORAGECHG]: lChg = True
            if selectedWhat == what[_HACKLOCALSTORAGEDEL]: lDel = True

            if selectedWhat == what[_HACKCONFIGADD]: lConfigDict = True
            if selectedWhat == what[_HACKCONFIGCHG]: lConfigDict = True
            if selectedWhat == what[_HACKCONFIGDEL]: lConfigDict = True
            if selectedWhat == what[_HACKLOCALSTORAGEADD]: lLocalStorage = True
            if selectedWhat == what[_HACKLOCALSTORAGECHG]: lLocalStorage = True
            if selectedWhat == what[_HACKLOCALSTORAGEDEL]: lLocalStorage = True

            LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

            if lConfigDict:
                fileType = "config.dict"
                st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
                prefs=sorted(tk)
            elif lLocalStorage:
                fileType = "LocalStorage() ./safe/settings"
                ls_keys = LS.keys()
                prefs=sorted(ls_keys)
            else:
                raise(Exception("ERROR - Unknown type!"))

            text = ""
            if lChg: text = "CHANGE"
            if lDel: text = "DELETE"

            if lAdd:
                addKey = myPopupAskForInput(toolbox_frame_,
                                            "HACKER: ADD KEY TO %s" % fileType,
                                            "KEY NAME:",
                                            "Carefully enter the name of the key you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                            "",
                                            False,
                                            JOptionPane.WARNING_MESSAGE)

                if not addKey or len(addKey.strip()) < 1: continue
                addKey = addKey.strip()

                if not check_if_key_string_valid(addKey):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key %s is NOT valid!" % addKey, "HACKER: ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to Hacker menu

                testKeyExists = True
                if lConfigDict:     testKeyExists = MD_REF.getUI().getPreferences().getSetting(addKey,None)
                if lLocalStorage:   testKeyExists = LS.get(addKey)

                if testKeyExists:
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key %s already exists - cannot add - aborting..!" % addKey, "HACKER: ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to Hacker menu

                addValue = myPopupAskForInput(toolbox_frame_,
                                              "HACKER: ADD KEY VALUE TO %s" % fileType,
                                              "KEY VALUE:",
                                              "Carefully enter the key value you want to add (STRINGS ONLY!):",
                                              "",
                                              False,
                                              JOptionPane.WARNING_MESSAGE)

                if not addValue or len(addValue.strip()) <1: continue
                addValue = addValue.strip()

                if not check_if_key_data_string_valid(addValue):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key value %s is NOT valid!" % addValue, "HACKER: ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to Hacker menu

                disclaimer = myPopupAskForInput(toolbox_frame_,
                                                "HACKER: ADD KEY VALUE TO %s" % fileType,
                                                "DISCLAIMER:",
                                                "Type 'IAGREE' to add key: %s with value: %s" % (addKey,addValue),
                                                "NO",
                                                False,
                                                JOptionPane.ERROR_MESSAGE)
                if disclaimer == "IAGREE":
                    if lConfigDict:
                        MD_REF.getUI().getPreferences().setSetting(addKey,addValue)
                        MD_REF.savePreferences()                # Flush all in memory settings to config.dict file on disk
                    if lLocalStorage:
                        LS.put(addKey,addValue)
                        LS.save()    # Flush local storage to safe/settings

                    play_the_money_sound()
                    myPrint("B","@@ HACKERMODE: key: %s value: %s added to %s @@" %(addKey,addValue,fileType))
                    myPopupInformationBox(toolbox_frame_,
                                          "SUCCESS: Key %s added to %s!" % (addKey,fileType),
                                          "HACKER: ADD TO %s" % fileType,
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                myPopupInformationBox(toolbox_frame_, "NO CHANGES MADE!", "HACKER", JOptionPane.INFORMATION_MESSAGE)
                continue

            # OK, so we are changing or deleting
            if lChg or lDel:
                selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                          "Select the %s key/setting you want to %s" % (fileType,text),
                                                          "HACKER",
                                                          JOptionPane.WARNING_MESSAGE,
                                                          None,
                                                          prefs,
                                                          None)
                if not selectedKey: continue

                lOK_to_Change = False
                value = None
                if lConfigDict:
                    # value = MD_REF.getUI().getPreferences().getSetting(selectedKey)
                    value = st.get(selectedKey)   # Have to use the backdoor to maintain the real instance type

                if lLocalStorage:
                    value = LS.get(selectedKey)
                    valueTest = LS.getString(selectedKey, "")

                    try:
                        # Is it a StreamTable?
                        valueTest_st = StreamTable()
                        valueTest_st.readFrom(valueTest)
                        value = valueTest_st
                    except:
                        # Is it a StreamVector?
                        valueTest_sv = StreamVector()
                        try:
                            valueTest_sv.readFrom(valueTest)
                            value = valueTest_sv
                        except:
                            pass

                output =  "%s PLEASE REVIEW KEY & VALUE BEFORE MAKING CHANGES\n" %fileType
                output += "%s------------------------------------------------\n\n" %("-"*len(fileType))

                if isinstance(value,(StreamTable,StreamVector)) and lChg:
                    output += "\n@@ Sorry: StreamTable & StreamVector keys cannot be changed by this script (only deleted) @@\n"
                elif not isinstance(value, (str, unicode)) and lChg:
                    output += "\n@@ Sorry: %s keys cannot be changed by this script (only deleted) @@\n" % type(value)
                else:
                    lOK_to_Change = True
                    output += "\n@@ This '%s' key can be changed/deleted by this script @@\n" % selectedKey

                output += "\n%s %s\n" %(pad("%s KEY:"%fileType,25),selectedKey)
                output += "\n%s %s\n" %(pad("Type:",25), type(value))

                if isinstance(value,(StreamTable,StreamVector)):
                    output += "\n%s\n%s\n" %("Value:", value)
                else:
                    output += "\n%s %s\n" %(pad("Value:",25), value)

                output += "\n<END>"
                jif = QuickJFrame("REVIEW THE KEY BEFORE CHANGES to %s" %fileType, output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

                if lChg and not lOK_to_Change:
                    myPopupInformationBox(jif,
                                          "SORRY: I cannot change the key %s in %s" %(selectedKey,fileType),
                                          "HACKER: CHANGE KEY IN %s" %fileType,
                                          JOptionPane.ERROR_MESSAGE)
                    continue

                chgValue = None

                if lChg:
                    chgValue = myPopupAskForInput(jif,
                                                  "HACKER: CHANGE KEY VALUE IN %s" %(fileType),
                                                  "KEY VALUE:",
                                                  "Carefully enter the new key value (STRINGS ONLY!):",
                                                  value,
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                    chgValue = chgValue.strip()

                    if not check_if_key_data_string_valid(chgValue):
                        myPopupInformationBox(jif,"ERROR: Key value %s is NOT valid!" %chgValue,"HACKER: CHANGE IN %s" %fileType,JOptionPane.ERROR_MESSAGE)
                        continue    # back to Hacker menu

                disclaimer = None
                if lDel:
                    disclaimer = myPopupAskForInput(jif,
                                                    "HACKER: %s KEY VALUE IN %s" %(text,fileType),
                                                    "DISCLAIMER:",
                                                    "Type 'IAGREE' to %s key: %s (with old value: %s)" %(text,selectedKey,value),
                                                    "NO",
                                                    False,
                                                    JOptionPane.ERROR_MESSAGE)
                if lChg:
                    disclaimer = myPopupAskForInput(jif,
                                                    "HACKER: %s KEY VALUE IN %s" %(text,fileType),
                                                    "DISCLAIMER:",
                                                    "Type 'IAGREE' to %s key: %s to new value: %s" %(text,selectedKey,chgValue),
                                                    "NO",
                                                    False,
                                                    JOptionPane.ERROR_MESSAGE)

                if disclaimer == "IAGREE":
                    if lConfigDict:
                        if lDel:
                            MD_REF.getUI().getPreferences().setSetting(selectedKey,None)
                        if lChg:
                            MD_REF.getUI().getPreferences().setSetting(selectedKey,chgValue)
                        MD_REF.savePreferences()            # Flush all in memory settings to config.dict file on disk
                    if lLocalStorage:
                        if lDel:
                            LS.put(selectedKey,None)
                        if lChg:
                            LS.put(selectedKey,chgValue)
                        LS.save()                               # Flush local storage to safe/settings

                    play_the_money_sound()

                    if lDel:
                        myPrint("B","@@ HACKERMODE: key: %s DELETED from %s (old value: %s) @@" %(selectedKey,fileType,value))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s DELETED from %s (old value: %s)" %(selectedKey,fileType,value),
                                              "HACKER: DELETE IN %s" %fileType,
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        myPrint("B","@@ HACKERMODE: key: %s CHANGED to %s in %s @@" %(selectedKey,chgValue, fileType))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s CHANGED to %s in %s" %(selectedKey,chgValue, fileType),
                                              "HACKER: CHANGE IN %s" %fileType,
                                              JOptionPane.WARNING_MESSAGE)
                    continue

                myPopupInformationBox(jif,"NO CHANGES MADE!", "HACKER", JOptionPane.INFORMATION_MESSAGE)
                continue

        # ENDWHILE

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def getModifiedDatesFomZip(_storage, _archiveFile):
        """Interrogates a zip archive, then processes all entries, and determines the oldest and newest modified dates"""

        zip_in = ZipInputStream(_storage.openFileForReading(_archiveFile))  # type: ZipInputStream
        oldestMInt = newestMInt = 0
        try:
            while True:
                entry = zip_in.getNextEntry()       # type: ZipEntry
                if entry is None: break
                if not entry.isDirectory():
                    name = entry.getName()                                                                              # noqa
                    modifiedDate = entry.getTime()
                    if modifiedDate > 0:
                        modifiedDateInt = DateUtil.convertLongDateToInt(modifiedDate)
                        oldestMInt = (modifiedDateInt if oldestMInt < 1 else min(oldestMInt, modifiedDateInt))
                        newestMInt = (modifiedDateInt if newestMInt < 1 else max(newestMInt, modifiedDateInt))
                zip_in.closeEntry()
        except: pass

        finally:
            try: zip_in.closeEntry()
            except: pass

            try: zip_in.close()
            except: pass

        return (oldestMInt, newestMInt)

    def hacker_mode_shrink_dataset():
        """Attempts to reduce dataset size by 'purging' txn log files - relies on processed.dct as failsafe for dates"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        SIMULATE = False

        _THIS_METHOD_NAME = "HACKER: SHRINK DATASET SIZE"

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, " "*len(_THIS_METHOD_NAME))

        if SIMULATE: output += "*** SIMULATION MODE *** No changes really being made!!\n"*3; output += "\n"

        DAYS_TO_KEEP = 30

        SAVE_TRUNK = False

        # Copied from com.infinitekind.tiksync.Syncer
        OUTGOING_PATH = "tiksync/out"
        INCOMING_PATH = "tiksync/in"
        TXN_FILE_EXTENSION = ".txn"
        TXN_FILE_EXTENSION_TMP = ".txn-tmp"
        OUTGOING_TXN_FILE_EXTENSION = ".mdtxn"
        ARCHIVE_PATH = "archive"
        ARCHIVE_EXTENSION = ".mdtxnarchive"
        PROCESSED_FILES = "tiksync/processed.dct"
        UPLOADBUFFER = "tiksync/uploadbuf"

        if isQuoteLoader_or_QER_Running():
            output += "QuoteLoader / Q&ER extension is loaded. User confirmed that it's not auto-updating and to proceed....\n\n"

        safeFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe")

        fp = os.path.join(safeFullPath, PROCESSED_FILES)
        if not os.path.exists(fp):
            myPrint("B", "ERROR - cannot proceed as file does not exist: %s" %(os.path.join(safeFullPath, PROCESSED_FILES)))
            txt = "Sorry - cannot proceed as %s does not exist?! (review console for details)" %(PROCESSED_FILES)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output += "Base 'safe' folder is: %s\n\n" %(safeFullPath)

        output += "Verified and found: %s\n" %(PROCESSED_FILES)

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        # Grab processed files here - freeze at this point....
        lError = False
        processedIn = None
        processedTxnFiles = StreamTable()  # type: StreamTable
        try:
            if storage.exists(PROCESSED_FILES):
                processedIn = storage.openFileForReading(PROCESSED_FILES)
                output += "Read %s data into memory\n" %(PROCESSED_FILES)
            else:
                lError = True                                                                                           # noqa
                raise Exception("Error: %s does not appear to exist?" %(PROCESSED_FILES))
            if processedIn is not None: processedTxnFiles.readFrom(processedIn)
        except:
            lError = True
            dump_sys_error_to_md_console_and_errorlog()
        finally:
            if processedIn is not None:
                try:
                    processedIn.close()
                except IOException:
                    lError = True
                    dump_sys_error_to_md_console_and_errorlog()

        oldestP = newestP = 0
        for pFileName in processedTxnFiles:
            pDate = processedTxnFiles.getLong(pFileName, 0)
            if pDate > 0:
                oldestP = (pDate if oldestP < 1 else min(oldestP, pDate))
                newestP = (pDate if newestP < 1 else max(newestP, pDate))

        output += ("Loaded %s (contains: %s entries, size: %sMBs). Oldest: %s, Newest: %s\n"
                  %(PROCESSED_FILES, len(processedTxnFiles), convertBytesMBs(os.path.getsize(fp)),
                    DateUtil.convertLongDateToInt(oldestP), DateUtil.convertLongDateToInt(newestP)))

        if lError or len(processedTxnFiles) < 1:
            if lError:
                txt = "Sorry - cannot proceed as error processing %s (review console for details)" %(PROCESSED_FILES)
            elif len(processedTxnFiles) < 1:
                txt = "Sorry - cannot proceed as %s contains no records?" %(PROCESSED_FILES)
            myPrint("B", txt)                                                                                           # noqa
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        syncFolder = None                                                                                               # noqa
        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
        except:
            syncFolder = False                                                                                          # noqa
            dump_sys_error_to_md_console_and_errorlog()
            txt = "Sorry - cannot proceed as error getting Sync status (review console for details)"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        fileSize, fileCount = calculateMoneydanceDatasetSize(True)

        output += "\nDataset is currently %sMBs containing %s files\n" %(fileSize, fileCount)

        MyPopUpDialogBox(toolbox_frame_,
                         "%sThis function attempts to shrink your dataset size (currently %sMBs, %s files)." %(("SIMULATION MODE: " if SIMULATE else ""),fileSize, fileCount),
                         "It does NOT change your actual database of records (known as 'trunk')\n"
                         "MD keeps log files for every change you (have ever) made. Typically these are .txn and .mdtxn files\n"
                         "Whilst in theory they could be used to rebuild your database from an older start point, this has never been done to my knowledge.\n"
                         "These files accumulate over time, and can be safely deleted. Toolbox can do this for you. It will purge log files older than %s days\n"
                         "It validates against the log of known processed dates, and also peeks inside archived zip files that MD creates\n"
                         "NOTE: You will need to repeat this process on other Sync copies too...\n"
                         "PRIOR TO RUNNING THIS, IDEALLY RESTART MD, & ENSURE THAT QUOTE LOADER/Q&ER EXTNS, IMPORTS & BANK DOWNLOADS ARE **NOT** RUNNING\n"
                         "<GOOD LUCK>" %(DAYS_TO_KEEP),
                         theTitle=_THIS_METHOD_NAME,
                         theWidth=160, lModal=True,OKButtonText="ACKNOWLEDGE").go()

        lPurgeOutDir = False
        if syncFolder is None:
            output += "\nSyncing appears disabled....\n"
            theMsg = MyPopUpDialogBox(toolbox_frame_,
                                        "It appears that you have Syncing disabled (is this correct?).",
                                        "If you really are NOT using Sync, I can purge the 'out' directory too?\n"
                                        "Only Click 'PURGE-OUT' if you are NOT using Sync on this dataset.\n"
                                        "(i.e. if you have temporarily disabled Sync, click Cancel)\n"
                                        "If you click 'PURGE-OUT', you can still enable a NEW Sync relationship at a later date....\n"
                                        "(clicking 'Cancel' means Do NOT purge 'out' directory...)",
                                        theTitle=_THIS_METHOD_NAME, theWidth=150, lCancelButton=True, OKButtonText="PURGE-OUT")
            if theMsg.go():
                output += "User confirmed that Sync is not being used and to proceed with purge of '%s'..\n" %(OUTGOING_PATH)
                lPurgeOutDir = True
            else:
                output += "User requested NOT to purge '%s'..\n" %(OUTGOING_PATH)
        else:
            output += "\nSync is ENABLED and as such, '%s' will NOT be purged. (SyncDir: %s)\n" %(OUTGOING_PATH, syncFolder)

        while True:

            newDaysToKeep = myPopupAskForInput(toolbox_frame_,
                                            _THIS_METHOD_NAME,
                                            "Days to Keep:",
                                            "Enter the new Days to Keep setting (currently %s) - min 1" %(DAYS_TO_KEEP),
                                            defaultValue=str(DAYS_TO_KEEP))

            if newDaysToKeep is not None and not StringUtils.isInteger(newDaysToKeep):
                continue

            if newDaysToKeep is None or int(newDaysToKeep) < 1 or int(newDaysToKeep) > (365*5):
                txt = "%s: No valid days to keep entered.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            DAYS_TO_KEEP = int(newDaysToKeep)
            myPrint("DB", "Days to Keep set to %s" %DAYS_TO_KEEP)
            break

        todayDateInt = DateUtil.getStrippedDateInt()
        lookBackDateInt = DateUtil.incrementDate(todayDateInt, 0, 0, -(DAYS_TO_KEEP))

        output += "\nDays to keep setting set as: %s. Today: %s. Purge up to Date: %s\n" %(DAYS_TO_KEEP, todayDateInt, lookBackDateInt)

        output += "\n\n" \
                  "LISTING POTENTIAL PURGE TARGET FILES\n" \
                  " ===================================\n"

        class StoreFileReference:

            def __init__(self, _safePath, _filename, _fullPath, _theDateInt=0, _oldestProcessedInt=0, _newestProcessedInt=0):
                self.safePath = _safePath
                self.filename = _filename
                self.fullPath = _fullPath
                self.theDateInt = _theDateInt
                self.oldestProcessedInt = _oldestProcessedInt
                self.newestProcessedInt = _newestProcessedInt
                self.fileSize = os.path.getsize(_fullPath)

        output += "\n%s targets...:\n" %(OUTGOING_PATH)
        # Scan 'out' files... (awaiting Sync)
        targetOutFilesForDeletion = []
        if lPurgeOutDir:
            for filename in storage.listFiles(OUTGOING_PATH):
                fp = os.path.join(safeFullPath, OUTGOING_PATH, filename)
                if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

                if (filename.endswith(TXN_FILE_EXTENSION_TMP)) and is_file_older_than_x_days(fp, DAYS_TO_KEEP):
                    # These are normally 'broken' sync txn files..... get rid of them....
                    targetOutFilesForDeletion.append(StoreFileReference(OUTGOING_PATH, filename, fp))
                    output += "%s\n" %(filename)
                    continue

                if not filename.endswith(TXN_FILE_EXTENSION):   continue
                if not processedTxnFiles.containsKey(filename): continue                                                # noqa

                txnFileTimestamp = processedTxnFiles.getLong(filename, 0)
                txnFileDate = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
                if txnFileDate != 0 and txnFileDate <= lookBackDateInt:
                    # Confirmed that the processed file database has logged this file as processed into trunk!
                    targetOutFilesForDeletion.append(StoreFileReference(OUTGOING_PATH, filename, fp, txnFileDate))
        if len(targetOutFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetOutFilesForDeletion = sorted(targetOutFilesForDeletion, key=lambda sort_x: (sort_x.theDateInt))
            for target in targetOutFilesForDeletion:
                output += "%s (processed: %s, modified: %s)\n" %(target.filename, target.theDateInt, getHumanReadableModifiedDateTimeFromFile(target.fullPath))

        output += "\n%s targets...:\n" %(UPLOADBUFFER)
        targetUploadBufferForDeletion = []
        fp = os.path.join(safeFullPath, UPLOADBUFFER)
        if (os.path.exists(fp) and is_file_older_than_x_days(fp, DAYS_TO_KEEP)):
            # Should be an 'old' file... delete it.....
            targetUploadBufferForDeletion.append(StoreFileReference(UPLOADBUFFER, UPLOADBUFFER, fp))
            output += "%s (modified: %s)\n" %(UPLOADBUFFER, getHumanReadableModifiedDateTimeFromFile(fp))
        del fp
        if len(targetUploadBufferForDeletion) < 1: output += "<NONE>\n"

        # Scan 'in' files (in theory all processed into Sync locally)
        output += "\n%s targets...:\n" %(INCOMING_PATH)
        targetInFilesForDeletion = []
        for filename in storage.listFiles(INCOMING_PATH):
            fp = os.path.join(safeFullPath, INCOMING_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if not filename.endswith(OUTGOING_TXN_FILE_EXTENSION):  continue
            if not processedTxnFiles.containsKey(filename):         continue                                            # noqa

            txnFileTimestamp = processedTxnFiles.getLong(filename, 0)
            txnFileDate = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
            if txnFileDate != 0 and txnFileDate <= lookBackDateInt:
                # Confirmed that the processed file database has logged this file as processed into trunk!
                targetInFilesForDeletion.append(StoreFileReference(INCOMING_PATH, filename, fp, txnFileDate))
            del fp
        if len(targetInFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetInFilesForDeletion = sorted(targetInFilesForDeletion, key=lambda sort_x: (sort_x.theDateInt))
            for target in targetInFilesForDeletion:
                output += "%s (processed: %s, modified: %s)\n" %(target.filename, target.theDateInt, getHumanReadableModifiedDateTimeFromFile(target.fullPath))

        # Scan 'archive' files (these are zip files containing .mdtxn files)
        output += "\n%s targets...:\n" %(ARCHIVE_PATH)
        targetArchiveFilesForDeletion = []

        for filename in storage.listFiles(ARCHIVE_PATH):
            fp = os.path.join(safeFullPath, ARCHIVE_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if not filename.endswith(ARCHIVE_EXTENSION): continue

            oldestModInt, newestModInt = getModifiedDatesFomZip(storage, ARCHIVE_PATH+"/"+filename)
            if oldestModInt < 1 or newestModInt < 1: continue

            if newestModInt <= lookBackDateInt:
                targetArchiveFilesForDeletion.append(StoreFileReference(ARCHIVE_PATH, filename, fp, _oldestProcessedInt=oldestModInt, _newestProcessedInt=newestModInt))
            del fp
        if len(targetArchiveFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetArchiveFilesForDeletion = sorted(targetArchiveFilesForDeletion, key=lambda sort_x: (sort_x.newestProcessedInt))
            for target in targetArchiveFilesForDeletion:
                output += "%s ZIPFile (contains oldest: %s, newest: %s; ZIPfile modified: %s)\n"\
                          %(target.filename, target.oldestProcessedInt, target.newestProcessedInt, getHumanReadableModifiedDateTimeFromFile(target.fullPath))


        sizeOutDelete = sizeInDelete = sizeUploadBufferDelete = sizeArchiveFilesDelete = 0.0
        for fn in targetOutFilesForDeletion:        sizeOutDelete           += fn.fileSize
        for fn in targetInFilesForDeletion:         sizeInDelete            += fn.fileSize
        for fn in targetUploadBufferForDeletion:    sizeUploadBufferDelete  += fn.fileSize
        for fn in targetArchiveFilesForDeletion:    sizeArchiveFilesDelete  += fn.fileSize

        totalSize = sizeOutDelete + sizeInDelete + sizeUploadBufferDelete + sizeArchiveFilesDelete
        totalFiles = len(targetOutFilesForDeletion) + len(targetInFilesForDeletion) + len(targetUploadBufferForDeletion) + len(targetArchiveFilesForDeletion)

        if totalFiles < 1:
            txt = "Sorry. No files to purge found!"
            myPrint("B", "%s: %s" %(_THIS_METHOD_NAME, txt))
            setDisplayStatus("%s: %s" %(_THIS_METHOD_NAME, txt), "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        txt1 = "OK, I can purge %s files and reduce dataset size by %sMBs" %(totalFiles, convertBytesMBs(totalSize))
        txt2 = ("Syncing is currently: %s\n"
                "Purge of 'out' directory is: %s\n"
                "Days to keep is set at: %s\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs" % (
                    ("ENABLED" if syncFolder is not None else "DISABLED"), ("ENABLED" if lPurgeOutDir else "DISABLED"),
                    DAYS_TO_KEEP,
                    OUTGOING_PATH,  len(targetOutFilesForDeletion),         convertBytesMBs(sizeOutDelete),
                    INCOMING_PATH,  len(targetInFilesForDeletion),          convertBytesMBs(sizeInDelete),
                    ARCHIVE_PATH,   len(targetArchiveFilesForDeletion),     convertBytesMBs(sizeArchiveFilesDelete),
                    UPLOADBUFFER,   len(targetUploadBufferForDeletion),     convertBytesMBs(sizeUploadBufferDelete)))

        output += "\n" \
                  "%s\n" \
                  "%s\n\n" %(txt1, txt2)

        jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        MyPopUpDialogBox(jif,
                         txt1,
                         txt2,
                         theTitle=_THIS_METHOD_NAME,
                         theWidth=100, lModal=True,OKButtonText="ACKNOWLEDGE").go()


        if not confirm_backup_confirm_disclaimer(jif,
                                                 _THIS_METHOD_NAME,
                                                 "%sShrink Dataset by removing %s old change log files (older than %s days)?"
                                                 %(("SIMULATION MODE: " if SIMULATE else ""),totalFiles, DAYS_TO_KEEP)):
            return

        jif.dispose()
        output += "\nUSER CONFIRMED DISCLAIMER AND AGREED TO PROCEED WITH %s\n\n" %(_THIS_METHOD_NAME)

        # Should probably do something with com.moneydance.apps.md.controller.BackgroundOpsThread - but haven't worked that out yet

        output += "Flushing memory and saving Preferences to disk....\n"
        MD_REF.savePreferences()

        output += "Flushing memory and saving local storage settings to disk....\n"
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()

        output += "Flushing memory and saving in memory dataset changes to disk (log files)....\n"
        MD_REF.getUI().getMain().saveCurrentAccount()

        output += "Pausing the MD Syncing engine....\n"
        MD_REF.getCurrentAccountBook().pauseSyncing()

        if not SIMULATE and SAVE_TRUNK:  # Now that we check processed.dct, not strictly necessary....
            output += "Flushing dataset back to trunk file....\n"
            MD_REF.getCurrentAccount().getBook().saveTrunkFile()

        output += "\n" \
                  "DELETING LOG FILES...\n" \
                  " --------------------\n"

        for fn in targetOutFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))


        for fn in targetInFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        for fn in targetUploadBufferForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        for fn in targetArchiveFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        output += ">> Finished removing files.....\n\n"

        output += "Resuming the MD Syncing engine....\n\n"
        MD_REF.getCurrentAccountBook().resumeSyncing()

        newFileSize, newFileCount = calculateMoneydanceDatasetSize(True)
        output += "Dataset was %sMBs containing %s files\n" %(fileSize, fileCount)
        output += "Dataset now %sMBs containing %s files\n" %(newFileSize, newFileCount)
        output += "...reduced (%sMBs)          (%s files)\n" %(fileSize-newFileSize, fileCount-newFileCount)

        if SIMULATE:
            output += "\n\n" \
                      "SIMULATION OVER - NO CHANGES MADE...\n".upper()
        else:
            output += "\n\n" \
                      "I recommend you perform another backup and restart MD...\n".upper()

        output += "\n<END>"

        jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB, lJumpToEnd=True, lWrapText=False).show_the_frame()

        if SIMULATE:
            txt = "SIMULATION - Dataset (not really) reduced by %sMBs (%s files) - review log for details" %(fileSize-newFileSize, fileCount-newFileCount)
        else:
            txt = "SUCCESS - Dataset reduced by %sMBs (%s files) - review log for details" %(fileSize-newFileSize, fileCount-newFileCount)

        setDisplayStatus("%s: %s" %(_THIS_METHOD_NAME, txt), "R")
        myPrint("B","%s: %s" %(_THIS_METHOD_NAME, txt))
        myPopupInformationBox(jif,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hacker_mode_encrypt_file():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "HACKER: IMPORT/ENCRYPT INTO LOCAL STORAGE"

        myPopupInformationBox(toolbox_frame_, "Select a non-encrypted file. It will be encrypted and saved to TMP directory of current dataset (details in console log)")

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()
        startingFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath())

        theTitle = "Select file to import (encrypt) and save in the LocalStorage TMP directory"
        selectedFile = getFileFromFileChooser(  toolbox_frame_,     # Parent frame or None
                                                startingFullPath,   # Starting path
                                                None,               # Default Filename
                                                theTitle,           # Title
                                                False,              # Multi-file selection mode
                                                True,               # True for Open/Load, False for Save
                                                True,               # True = Files, else Dirs
                                                None,               # Load/Save button text, None for defaults
                                                "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=True,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

        if selectedFile is None or selectedFile == "":
            txt = "%s: No file selected to import/encrypt/save..!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not os.path.exists(selectedFile) or not os.path.isfile(selectedFile):
            txt = "%s: Sorry, file selected to import / encrypt either does not exist or is not a file" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        try:
            copyFileName = File(selectedFile).getName()
            tmpFile = "tmp" + os.path.sep + str(System.currentTimeMillis() % 10000L) +  "-" + copyFileName
            fis = FileInputStream(File(selectedFile))
            LS.writeFile(tmpFile, fis)
            fis.close()
            helper = MD_REF.getPlatformHelper()
            helper.openDirectory(File(os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe","tmp")))
        except:
            txt = "%s: SORRY - Failed to import (encrypt) file %s (view console error log)" %(_THIS_METHOD_NAME, selectedFile)
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B","%s: User requested to import (encrypt) file: %s into LocalStorage() TMP dir... SUCCESS!" %(_THIS_METHOD_NAME, selectedFile))

        txt = "%s: File %s encrypted and saved in TMP dir" %(_THIS_METHOD_NAME, selectedFile)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def file_chooser_wrapper(_methodTitle, _startingFolder, _dialogTitle, _proceedButtonText):
        # With the latest MacOSx, FileDialog causes some problems when as accessing 'system' locations.
        # ...it presents the last used non-system location - useless for this - we want this specific directory....!
        # JFileChooser has a non native LaF on Mac, but worked... But then VAQua broke it....
        # MacOS: ~/Library/Containers/com.infinitekind.MoneydanceOSX/Data/Documents is a system-location
        # User will have to manually navigate... Oh well!

        selectedFile = getFileFromFileChooser(  toolbox_frame_,         # Parent frame or None
                                                _startingFolder,        # Starting path
                                                None,                   # Default Filename
                                                _dialogTitle,           # Title
                                                False,                  # Multi-file selection mode
                                                True,                   # True for Open/Load, False for Save
                                                True,                   # True = Files, else Dirs
                                                _proceedButtonText,     # Load/Save button text, None for defaults
                                                None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lAllowTraverseApplications=True,
                                                lForceJFC=False,
                                                lForceFD=False,
                                                lAllowNewFolderButton=False,
                                                lAllowOptionsButton=False)

        if selectedFile is None or selectedFile == "":
            txt = "%s: User chose to cancel or no file selected." %(_methodTitle)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _methodTitle, theMessageType=JOptionPane.WARNING_MESSAGE)
            return None

        if not os.path.exists(selectedFile) or not os.path.isfile(selectedFile):
            txt = "%s: Sorry, file selected to extract either does not exist or is not a file?" %(_methodTitle)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _methodTitle, theMessageType=JOptionPane.WARNING_MESSAGE)
            return None

        return selectedFile

    def hacker_mode_decrypt_file():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "HACKER: EXTRACT/DECRYPT FROM LOCAL STORAGE"

        myPopupInformationBox(toolbox_frame_,"Select an internal MD encrypted file from within the 'safe'. "
                                             "I will decrypt and save it to TMP directory in this current dataset (details in console log)")

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()
        attachmentFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe")

        selectedFile = file_chooser_wrapper(_THIS_METHOD_NAME, attachmentFullPath, "Select Moneydance internal file to extract and copy to TMP directory", "EXTRACT")
        if selectedFile is None: return

        searchForSafe = selectedFile.lower().find(".moneydance"+os.path.sep+"safe"+os.path.sep)
        if searchForSafe <= 0:
            txt = "%s: file selected to extract must be within the MD Dataset 'safe'" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        truncatedPath = selectedFile[searchForSafe+len(".moneydance"+os.path.sep+"safe"+os.path.sep):]

        tmpDir = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), "tmp")
        tmpDir.mkdirs()
        copyFileName = File(selectedFile).getName()
        tmpFile = File.createTempFile(str(System.currentTimeMillis() % 10000L), "-"+copyFileName, tmpDir)
        tmpFile.deleteOnExit()
        fout = FileOutputStream(tmpFile)

        lCaughtError = False

        try:
            LS.readFile(truncatedPath, fout)

        except IOException as ioe:
            cause = ioe.getCause()
            if cause is not None and cause.getClass().getName().endswith("BadPaddingException"):                        # noqa
                myPrint("B","Caught: BadPaddingException. Class: %s, %s" %(cause.getClass(), cause.getClass().getName()))
                lCaughtError = True
            else:
                raise

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "SORRY - Failed to extract file %s (view console error log)" %(selectedFile)
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:
            if fout is not None:
                fout.close()

        if lCaughtError:
            txt = "@@ WARNING: txn file '%s' may have been corrupted. Skipping the remainder, it may be best to delete it >> ERROR(BadPaddingException)!" %(selectedFile)
            myPrint("B",txt)
            txt = "ERROR: BadPaddingException - Most of file decrypted & copied to TMP dir (CONSIDER DELETING FILE!):'%s'" %(selectedFile)
            txtColor = "R"
            msgType = JOptionPane.ERROR_MESSAGE
        else:
            myPrint("B","User requested to extract file: %s from LocalStorage()/safe and copy to TMP dir... SUCCESS!" %(selectedFile))
            txt = "HACKER MODE: File decrypted and copied to TMP dir: '%s'" %(selectedFile)
            txtColor = "B"
            msgType = JOptionPane.INFORMATION_MESSAGE

        setDisplayStatus(txt,txtColor)
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=msgType)

        MD_REF.getPlatformHelper().openDirectory(tmpDir)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hacker_mode_decrypt_file_from_sync():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "HACKER: EXTRACT/PEEK AT SYNC FILE"

        lFailTest = False
        KEY_TEST_FILE = "key_test"
        FOLDER_VER = "v3"

        passphrase = encryptedTestBytes = syncFolder = None
        try:
            passphrase = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()
            syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()

            encryptedTestBytes = IOUtils.readFully(syncFolder.readUnencrypted(KEY_TEST_FILE))
            if encryptedTestBytes is None or len(encryptedTestBytes) <= 0:
                myPrint("DB", "ERROR - The read of unencrypted data from Sync's 'key_test' returned None or zero bytes...")
                lFailTest = True
        except:
            dump_sys_error_to_md_console_and_errorlog()
            myPrint("DB", "ERROR - Failed to get your Sync Folder and read unencrypted data from 'key_test'...")
            lFailTest = True

        def canPasswordDecryptSyncData(_passphrase, the_encryptedTestBytes):
            if (the_encryptedTestBytes is None or len(the_encryptedTestBytes) <= 0): return False
            try:
                decryptedBytes = MDSyncCipher.decryptBytes(the_encryptedTestBytes, _passphrase)
                keyTestInfo = SyncRecord()
                if (not keyTestInfo.readSet(ByteArrayInputStream(decryptedBytes))): return False
                # Record starts with 12-digit random truncated UUID...
                if keyTestInfo.getString("test", "monkeys") == "Hello, how are you?":
                    myPrint("DB", "Success - I managed to decrypt your 'key_test' file from Sync Folders using your stored encryption passphrase..")
                    return True

            except BadPaddingException:
                myPrint("DB", "ERROR - BadPaddingException: I could NOT decrypt your 'key_test' file from Sync Folders using your stored encryption passphrase..!")
                return False

            myPrint("DB", "ERROR - I could NOT decrypt your 'key_test' file from Sync Folders using your stored encryption passphrase..!")
            return False

        if lFailTest or not canPasswordDecryptSyncData(passphrase, encryptedTestBytes):
            txt = "Sorry, I cannot find/test/decrypt your Sync 'key_file' (No Sync Folder, Bad Passphrase)? - Aborting!"
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return
        del passphrase

        syncFolderOnDisk = get_sync_folder()
        if not syncFolderOnDisk:
            txt = "Sorry, I cannot find your Sync folder? - Aborting!"
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        syncFolderOnDisk = os.path.join(syncFolderOnDisk, syncFolder.getSubpath())
        myPrint("DB", "Sync folder is:", syncFolderOnDisk)

        subs = syncFolder.listSubfolders(None)
        if FOLDER_VER not in subs:
            txt = "Sorry, I cannot find your '%s' Sync sub-folder? - Aborting!" %(FOLDER_VER)
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        myPopupInformationBox(toolbox_frame_, "Select a file from your Sync folder. I will decrypt it and show you the lines on screen... ")

        selectedFile = file_chooser_wrapper(_THIS_METHOD_NAME, syncFolderOnDisk, "Select Moneydance Sync encrypted file to extract / peek..", "EXTRACT/PEEK")
        if selectedFile is None: return

        if not selectedFile.startswith(syncFolderOnDisk):
            txt = "Sorry, Sync file selected to extract must be within your Sync folders'"
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        truncatedPath = selectedFile[len(syncFolderOnDisk):]
        myPrint("DB", truncatedPath)

        if "/attach/" in truncatedPath:
            txt = "Sorry, I cannot show you attachments at this time..."
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        fail = False
        readLines = None
        try:
            readLines = IOUtils.readlines(syncFolder.readFile(truncatedPath))
        except:
            fail = True
            myPrint("DB","Failed to read/decrypt.. Will try unencrypted")

        try:
            if fail:
                readLines = IOUtils.readlines(syncFolder.readUnencrypted(truncatedPath))
                fail = False
        except:
            fail = True
            myPrint("DB","Failed to read/unencrypted..")

        if fail:
            txt = "Sorry, I failed to read your file... Exiting..."
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if readLines is None or len(readLines) < 1:
            txt = "Sorry, your Sync file appears to be empty..? Exiting..."
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        len_lines = sum(len(line) for line in readLines)
        buildString = "\n".join(readLines)

        jif = QuickJFrame(_THIS_METHOD_NAME+"(%s lines, %s chars)" %(len(readLines),len_lines), buildString,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        del buildString

        txt = "HACKER MODE: File %s decrypted and shown to user" %(selectedFile)
        setDisplayStatus(txt,"B")
        myPopupInformationBox(jif, txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hacker_mode_DEBUG(lForceON=False):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        key = "moneydance.debug"
        md_debug = MD_REF.getUI().getMain().DEBUG
        props_debug = System.getProperty(key, None)

        toggleText = "ON"

        if not lForceON:
            if md_debug or (props_debug is not None and props_debug!="false"):
                toggleText = "OFF"

            ask = MyPopUpDialogBox(toolbox_frame_,"DEBUG STATUS:",
                                   "main.DEBUG                             currently set to: %s\n"
                                   'System.getProperty("%s") currently set to: %s\n'
                                   'OFXConnection.DEBUG_MESSAGES           currently set to: %s\n'
                                   'MoneybotURLStreamHandlerFactory.DEBUG  currently set to: %s\n'
                                   'OnlineTxnMerger.DEBUG                  currently set to: %s\n'
                                   'Syncer.DEBUG                           currently set to: %s\n'
                                   %(md_debug,key,props_debug,OFXConnection.DEBUG_MESSAGES,MoneybotURLStreamHandlerFactory.DEBUG,OnlineTxnMerger.DEBUG,Syncer.DEBUG),
                                   200,"TOGGLE MONEYDANCE INTERNAL DEBUG",
                                   lCancelButton=True,OKButtonText="SET ALL to %s" %toggleText)
            if not ask.go():
                txt = "HACKER MODE: NO CHANGES MADE TO DEBUG!"
                setDisplayStatus(txt,"B")
                return

            myPrint("B","HACKER MODE: User requested to change all internal DEBUG modes to %s - setting these now...!" %(toggleText))

        if toggleText == "OFF":
            MD_REF.getUI().getMain().DEBUG = False
            System.clearProperty(key)
            OFXConnection.DEBUG_MESSAGES = False
            MoneybotURLStreamHandlerFactory.DEBUG = False
            OnlineTxnMerger.DEBUG = False
            Syncer.DEBUG = False
        else:
            MD_REF.getUI().getMain().DEBUG = True
            System.setProperty(key, "true")
            OFXConnection.DEBUG_MESSAGES = True
            MoneybotURLStreamHandlerFactory.DEBUG = True
            OnlineTxnMerger.DEBUG = True
            Syncer.DEBUG = True

        if lForceON:
            myPrint("DB","Moneydance Debug turned ON (same as launching Console window)......")
            return

        txt = "All Moneydance internal debug settings turned %s" %(toggleText)
        setDisplayStatus(txt,"B")
        myPopupInformationBox(toolbox_frame_,"All Moneydance internal debug settings turned %s" %toggleText,"TOGGLE MONEYDANCE INTERNAL DEBUG",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def hacker_mode_other_DEBUG():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        debugKeys = ["com.moneydance.apps.md.view.gui.txnreg.DownloadedTxnsView.DEBUG",
                     "com.moneydance.apps.md.view.gui.OnlineUpdateTxnsWindow.DEBUG"]

        selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                  "Select the DEBUG Setting you want to view/toggle",
                                                  "HACKER: OTHER DEBUG",
                                                  JOptionPane.INFORMATION_MESSAGE,
                                                  MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                  debugKeys,
                                                  None)

        if not selectedKey or debugKeys.index(selectedKey) > 1:
            txt = "No Debug key was selected to view/toggle.."
            setDisplayStatus(txt, "R")
            return

        currentSetting = False
        if debugKeys.index(selectedKey) == 0:
            currentSetting = DownloadedTxnsView.DEBUG
        elif debugKeys.index(selectedKey) == 1:
            currentSetting = OnlineUpdateTxnsWindow.DEBUG

        ask = MyPopUpDialogBox(toolbox_frame_,"OTHER DEBUG STATUS:",
                               "%s currently set to: %s" %(selectedKey, currentSetting),
                               200,"TOGGLE THIS MONEYDANCE INTERNAL OTHER DEBUG",
                               lCancelButton=True,OKButtonText="SET to %s" %(not currentSetting))
        if not ask.go():
            txt = "HACKER MODE: NO CHANGES MADE TO OTHER DEBUG!"
            setDisplayStatus(txt, "B")
            return

        myPrint("B","HACKER MODE: User requested to change DEBUG %s to %s - setting now...!" %(selectedKey,not currentSetting))

        if debugKeys.index(selectedKey) == 0:
            DownloadedTxnsView.DEBUG = not currentSetting
        elif debugKeys.index(selectedKey) == 1:
            OnlineUpdateTxnsWindow.DEBUG = not currentSetting

        txt = "Moneydance internal debug settings %s turned %s" %(selectedKey, not currentSetting)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,"Moneydance internal debug settings %s turned %s" %(selectedKey, not currentSetting),"TOGGLE MONEYDANCE INTERNAL OTHER DEBUG",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def hacker_mode_demote_primary_to_secondary():
        # the reverse of convert_secondary_to_primary_data_set

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "HACK: MAKE this PRIMARY a SECONDARY NODE"

        if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = "Your dataset is already Secondary - no changes made.."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "DEMOTE this Primary into a Secondary Dataset?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(False)
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()        # Flush local storage to safe/settings

        play_the_money_sound()
        txt = "%s: Dataset DEMOTED to Secondary (non-Primary/Master) Node - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD" %(_THIS_METHOD_NAME)
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        MD_REF.getUI().exit()

    def hackermode_force_sync_off():
        # the reverse of convert_secondary_to_primary_data_set

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "HACK: FORCE DISABLE/TURN SYNC OFF"

        _PARAM_KEY = "netsync.sync_type"
        _NONE = "none"

        storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

        if storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE:
            txt = "Your Sync is already disabled/turned off! NO ACTION TAKEN"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Force Disable/Turn OFF Sync?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        storage.put(_PARAM_KEY, _NONE)
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()        # Flush local storage to safe/settings

        play_the_money_sound()
        txt = "Sync ('%s')has been force disabled/turned OFF - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD" %(_PARAM_KEY)
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
        MD_REF.getUI().exit()

    def hackermode_force_reset_sync_settings():
        # Resets all Sync settings, generates a new Sync ID, Turns Sync Off. You can turn it back on later....

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "HACK: FORCE RESET SYNC SETTINGS"

        storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Force reset all Sync settings, generate new SyncID & disable Sync?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # Copied from: com.moneydance.apps.md.controller.AccountBookWrapper.resetSyncInfoIfNecessary()
        storage.put("netsync.dropbox.fileid", UUID.randomUUID())
        storage.remove("netsync.sync_type")
        storage.remove("netsync.subpath")
        storage.remove("netsync.dropbox_enabled")
        storage.remove("netsync.synckey")
        storage.remove("ext.netsync.settings")
        storage.remove("netsync.guid")
        storage.remove("migrated.netsync.dropbox.fileid")

        # NOTE: as of 2022.3(4063) - this is also performed: .setIsMasterSyncNode(True)
        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(True)
        storage.save()

        root = MD_REF.getCurrentAccountBook().getRootAccount()
        if root is not None:
            root.removeParameter("netsync.dropbox.fileid")
            root.removeParameter("netsync.sync_type")
            root.removeParameter("netsync.subpath")
            root.removeParameter("netsync.dropbox_enabled")
            root.removeParameter("netsync.synckey")
            root.removeParameter("ext.netsync.settings")
            root.removeParameter("netsync.guid")
            root.removeParameter("migrated.netsync.dropbox.fileid")

        play_the_money_sound()
        txt = "ALL SYNC SETTINGS HAVE BEEN RESET - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD"
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
        MD_REF.getUI().exit()

    def restore_archive_retain_sync_settings():
        # com.moneydance.apps.md.view.gui.MoneydanceGUI.openFile(File)

        _PARAM_KEY = "netsync.sync_type"
        _NONE = "none"

        _SYNC_KEYS = [  "netsync.dropbox.fileid",
                        "netsync.sync_type",
                        "netsync.subpath",
                        "netsync.dropbox_enabled",
                        "netsync.synckey",
                        "ext.netsync.settings",
                        "netsync.guid",
                        "migrated.netsync.dropbox.fileid" ]

        _THIS_METHOD_NAME = "RESTORE ARCHIVE (RETAIN SYNC SETTINGS)"

        ask = MyPopUpDialogBox(None, "Allows you to restore a .moneydancearchive file and RETAIN Sync Settings",
                               "The normal File/Restore from Backup option will wipe out your Sync settings\n"
                               "... This means the restored dataset will not reconnect and pick up syncing where it was before\n"
                               "... You would get a brand new Sync relationship and have to reconnect devices to this new Sync\n\n"
                               "This feature allows you to retain your Sync settings, and it will then sync from the point of backup\n"
                               "... NOTE: Whilst the settings are retained, Syncing will be left turned off...\n"
                               "... So you must visit the File/Syncing menu and select the Sync option to continue...\n\n"
                               "You might use this when you have txns in the Sync 'system' from another device, that you want applied to this dataset\n",
                               250,"INSTRUCTIONS",
                               lCancelButton=True,OKButtonText="CONFIRMED", lAlertLevel=1)
        if not ask.go():
            txt = "Instructions rejected - no changes made"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        theTitle = "Select archive file to restore and retain sync settings)"
        archiveFilename = getFileFromFileChooser(toolbox_frame_,    # Parent frame or None
                                                 get_home_dir(),    # Starting path
                                                 None,              # Default Filename
                                                 theTitle,          # Title
                                                 False,             # Multi-file selection mode
                                                 True,              # True for Open/Load, False for Save
                                                 True,              # True = Files, else Dirs
                                                 None,              # Load/Save button text, None for defaults
                                                 "moneydancearchive",  # File filter (non Mac only). Example: "txt" or "qif"
                                                 lAllowTraversePackages=False,
                                                 lForceJFC=False,
                                                 lForceFD=False,
                                                 lAllowNewFolderButton=False,
                                                 lAllowOptionsButton=True)

        if archiveFilename is None or archiveFilename == "":
            txt = "%s: User chose to cancel or no file selected >>  So no Restore will be performed... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not archiveFilename.endswith(".moneydancearchive"):
            txt = "%s: ERROR - Must select a file with '.moneydancearchive' extension - No Restore will be performed... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        fileToOpen = File(archiveFilename)
        baseFilename = StringUtils.stripExtension(fileToOpen.getName())

        tmpFolder = IOUtils.createTempFolder()
        myPrint("DB","Temp folder: %s" %(tmpFolder.getCanonicalPath()))

        IOUtils.openZip(fileToOpen, tmpFolder.getAbsolutePath())
        myPrint("DB","Zip file opened....")

        class MyFilenameFilter(FilenameFilter):
            def accept(self, _dir, name): return String(name).endsWith(".moneydance")

        zipContents = tmpFolder.list(MyFilenameFilter())
        if (zipContents is None or len(zipContents) <= 0):
            txt = "%s: ERROR: Archive (zip) appears empty? So no Restore will be performed... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        tmpMDFile = File(tmpFolder, zipContents[0])
        newBookFile = AccountBook.getUnusedFileNameWithBase(AccountBookUtil.DEFAULT_FOLDER_CONTAINER, baseFilename)
        myPrint("B","Archive to restore: %s" %(fileToOpen.getCanonicalPath()))
        myPrint("B","New Name:           %s" %(newBookFile.getCanonicalPath()))

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME, "CONFIRM you want to proceed to restore archive and retain Sync settings?"):
            txt = "%s: User DECLINED TO PROCEED - no action taken" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not tmpMDFile.renameTo(newBookFile):
            try: IOUtils.copyFolder(tmpMDFile, newBookFile)
            except:
                txt = "%s: ERROR: copy/move of tmp folder failed (review console)... " %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                dump_sys_error_to_md_console_and_errorlog()
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

        archiveWrapper = AccountBookWrapper.wrapperForFolder(newBookFile)
        if archiveWrapper is None:
            try: IOUtils.deleteFolder(newBookFile)
            except: dump_sys_error_to_md_console_and_errorlog()
            txt = "%s: ERROR: Failed to set AccountBookWrapper.wrapperForFolder on restored file... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        passwordCallback = MD_REF.getUI().getSecretKeyCallback(archiveWrapper)

        iLoop = 0
        lFailed = True
        while True:
            iLoop += 1
            if iLoop > 3: break
            try:
                if archiveWrapper.loadLocalStorage(passwordCallback): lFailed = False
                break
            except MDException as mde:
                if mde.getCode() == 1004:
                    MD_REF.getUI().showErrorMessage("The password you have entered is invalid.  Please try again.")
                    continue
                else:
                    dump_sys_error_to_md_console_and_errorlog()
                    break
            except:
                dump_sys_error_to_md_console_and_errorlog()
                break

        if lFailed:
            try: IOUtils.deleteFolder(newBookFile)
            except: dump_sys_error_to_md_console_and_errorlog()
            txt = "%s: ERROR: Failed to load local storage for restored dataset... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        archiveBook = archiveWrapper.getBook()
        storage = archiveBook.getLocalStorage()
        saveSyncSetting = storage.getString(_PARAM_KEY, _NONE)

        myPrint("B", "All Sync Keys in Restored Dataset..:")
        for sKey in _SYNC_KEYS: myPrint("B", "Key %s  Value: '%s'" %(pad(sKey,40), storage.getString(sKey, "NOT SET")))
        myPrint("B", "<END OF SYNC KEYS>")

        myPrint("B", "@@@ Setting Sync in restored dataset to %s" %(_NONE))
        storage.put(_PARAM_KEY, _NONE)
        storage.put("_toolbox", "Restored & preserved Sync settings (type was: %s)...." %(saveSyncSetting))
        archiveBook.getLocalStorage().save()

        myPopupInformationBox(toolbox_frame_,"SUCCESS! ABOUT TO OPEN THE RESTORED DATASET (You need to set Sync to: '%s') - YOU MAY BE ASKED FOR YOUR PASSWORD AGAIN" %(saveSyncSetting),_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
        myPrint("B","Opening restored Dataset: %s" %(newBookFile.getCanonicalPath()))
        txt = "%s: SUCCESS: Dataset restored, open manually (and change Sync Method to: %s)" %(_THIS_METHOD_NAME, saveSyncSetting)
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        if not MD_REF.getUI().openFile(newBookFile):    # This will trigger Toolbox to close too....
            txt = "%s: ERROR: Failed to open the restored file... Please open the file manually?" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
        return

    def checkForREADONLY():

        checkDropbox = tell_me_if_dropbox_folder_exists()
        datasetPath = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

        if not os.access(datasetPath, os.W_OK) or (checkDropbox and not os.access(checkDropbox, os.W_OK)):
            myPrint("B", "@@@ ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! @@@")
            myPrint("B", "\n>> %s - Writable: %s\n"
                         ">> %s - Writable: %s\n"
                    %(checkDropbox, os.access(checkDropbox, os.W_OK), datasetPath, os.access(datasetPath, os.W_OK)))

            play_the_money_sound()
            MyPopUpDialogBox(toolbox_frame_,
                                   "ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! - YOU NEED TO EXIT MD AND FIX MANUALLY",
                                   "%s - Writable: %s\n"
                                   "%s - Writable: %s"
                                   %(checkDropbox, os.access(checkDropbox, os.W_OK), datasetPath, os.access(datasetPath, os.W_OK)),
                                   theTitle="FOLDER PROBLEM",
                                   OKButtonText="OK - I WILL EXIT",
                                   lAlertLevel=2).go()

            txt = "ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! - YOU NEED TO EXIT MD AND FIX MANUALLY"
            setDisplayStatus(txt, "R")

        return

# END OF GLOBAL CLASSES and DEFs

    # ##################################################################################################################
    # ##################################################################################################################
    # ##### MAIN DISPLAY CLASS                                                                      ####################
    # ##################################################################################################################
    # ##################################################################################################################

    def findEnvironmentPassphrases():
        theList = []
        if int(MD_REF.getBuild()) < 3088:     # MD2021.2(3088) added this capability
            return theList
        for k, v in os.environ.items():
            if k.startswith("md_passphrase"):
                theList.append([k,v])
        return theList

    class MyJPanel(JPanel):

        def __init__(self, layout, panel_name):
            self.panel_name = panel_name
            super(JPanel, self).__init__(layout)                                                                        # noqa

        def updateUI(self):
            myPrint("DB", "In %s.%s() - JPanel: '%s'" %(self, inspect.currentframe().f_code.co_name, self.panel_name))
            super(MyJPanel, self).updateUI()                                                                            # noqa
            # Here I should call .setBackground() and .setForeground() with updated MD Colors....
            # But I have not done so yet.... For now, just restart the Extension/MD to refresh after Theme change...
            # self.setBackground(NetAccountBalancesExtension.getNAB().moneydanceContext.getUI().colors.defaultBackground)
            # self.setForeground(NetAccountBalancesExtension.getNAB().moneydanceContext.getUI().colors.defaultTextForeground)

    class DiagnosticDisplay():

        def __init__(self):
            self.myScrollPane = None

        class WindowListener(WindowAdapter):

            def __init__(self, theFrame):
                self.theFrame = theFrame        # type: MyJFrame

            def windowClosing(self, WindowEvent):                                                                       # noqa
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "DiagnosticDisplay() Frame shutting down....")

                terminate_script()

            def windowClosed(self, WindowEvent):                                                                        # noqa
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))

                self.theFrame.isActiveInMoneydance = False

                myPrint("DB","applistener is %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))

                if self.theFrame.MoneydanceAppListener is not None:
                    try:
                        MD_REF.removeAppEventListener(self.theFrame.MoneydanceAppListener)
                        myPrint("DB","\n@@@ Removed my MD App Listener... %s\n" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
                        self.theFrame.MoneydanceAppListener = None
                    except:
                        myPrint("B","FAILED to remove my MD App Listener... %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
                        dump_sys_error_to_md_console_and_errorlog()

                if self.theFrame.HomePageViewObj is not None:
                    self.theFrame.HomePageViewObj.unload()
                    myPrint("DB","@@ Called HomePageView.unload() and Removed reference to HomePageView %s from MyJFrame()...@@\n" %(classPrinter("HomePageView", self.theFrame.HomePageViewObj)))
                    self.theFrame.HomePageViewObj = None

                cleanup_actions(self.theFrame)

        class CloseAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):                                                                           # noqa
                global debug, toolbox_frame_
                myPrint("DB","In CloseAction().", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "DiagnosticDisplay() Frame shutting down....")

                myPrint("DB",".. calling terminate_script()")
                terminate_script()

        class UnlockAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame
                self.saveTitle = theFrame.getTitle()

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In UnlockAction().", inspect.currentframe().f_code.co_name, "()")

                if GlobalVars.TOOLBOX_UNLOCK:
                    txt = "@@@ Toolbox is already Unlocked... ReLocking the (Tool)box! @@@"
                    sColor = "B"
                    GlobalVars.TOOLBOX_UNLOCK = False
                    self.theFrame.setTitle(self.saveTitle)
                else:
                    v = int(float(MD_REF.getVersion())); b = int(float(MD_REF.getBuild())); c = v+b
                    response = myPopupAskForInput(self.theFrame,"@@ UNLOCK TOOLBOX @@", "PASSWORD:", "Enter the password to unlock powerful features",
                                          defaultValue=None,isPassword=True,theMessageType=JOptionPane.ERROR_MESSAGE)
                    if response is not None and StringUtils.isInteger(response) and int(response) == c:
                        txt = "@@@ Toolbox UNLOCKED @@@"
                        sColor = "R"
                        GlobalVars.TOOLBOX_UNLOCK = True
                        self.theFrame.setTitle(u"Toolbox UNLOCKED (%s+I for Help) - DATASET: %s" % (MD_REF.getUI().ACCELERATOR_MASK_STR, MD_REF.getCurrentAccountBook().getName().strip()))
                    else:
                        txt = "@@@ Toolbox NOT Unlocked @@@"
                        sColor = "B"
                setDisplayStatus(txt, sColor); myPrint("B",txt)
                return

        class OnlineBankingToolsButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug
                global lAdvancedMode, lHackerMode

                # OFX BANKING MENU

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                user_UNLOCKMDPlusDiagnostic = JRadioButton("UNLOCKED - Moneydance+ Diagnostics (READONLY)", False)
                user_UNLOCKMDPlusDiagnostic.setToolTipText("When Toolbox is unlocked, will display extra MD+ Diagnostics - DO NOT SHARE WITH OTHERS!")
                user_UNLOCKMDPlusDiagnostic.setEnabled(isToolboxUnlocked() and isMDPlusEnabledBuild())
                user_UNLOCKMDPlusDiagnostic.setForeground(Color.ORANGE)

                user_searchOFXData = JRadioButton("Search for stored OFX related data", False)
                user_searchOFXData.setToolTipText("This searches for Online Banking (OFX) related setup information in most places...")

                user_viewInstalledBankProfiles = JRadioButton("View your installed Bank / Service Profiles", False)
                user_viewInstalledBankProfiles.setToolTipText("This will display all the setup data stored on your service/banking logon profile(s)")

                user_viewListALLMDServices = JRadioButton("View list of MD's Bank dynamic setup profiles (then select one)", False)
                user_viewListALLMDServices.setToolTipText("This will display Moneydance's dynamic setup profiles for all banks - pulled from Infinite Kind's website..")

                user_view_CUSIP_settings = JRadioButton("View your Security's hidden CUSIP settings (The link between your Bank's Securities & MD Securities)", False)
                user_view_CUSIP_settings.setToolTipText("This will show your Security's hidden CUSIP settings. These link your downloads on Investment Securities to MD Securities")

                user_viewOnlineTxnsPayeesPayments = JRadioButton("View your Online Txns/Payees/Payments", False)
                user_viewOnlineTxnsPayeesPayments.setToolTipText("This will show you your cached Online Txns (there should be none) and also your saved online payees and payments")

                user_viewAllLastTxnDownloadDates = JRadioButton("View all your OFX last download txn dates (for all accounts)", False)
                user_viewAllLastTxnDownloadDates.setToolTipText("View all your OFX last download txn dates (across all accounts)")

                user_toggleMDDebug = JRadioButton("Toggle Moneydance Debug (ONLY use for debugging)", False)
                user_toggleMDDebug.setToolTipText("This toggles Moneydance's internal DEBUG(s) on/off. When ON you get more messages in the Console Log (the same as opening console)")

                user_forgetOFXBankingLink = JRadioButton("Forget OFX Banking File Import Link (remove_ofx_account_bindings.py) (MD versions < MD2022)", False)
                user_forgetOFXBankingLink.setToolTipText("Force MD to forget OFX Banking Import link attributed to an Account. Moneydance will ask you to recreate the link on next import.. THIS CHANGES DATA! (remove_ofx_account_bindings.py)")
                user_forgetOFXBankingLink.setEnabled(lAdvancedMode and (not isMDPlusEnabledBuild() or isToolboxUnlocked()))
                user_forgetOFXBankingLink.setForeground(getColorRed())

                user_manageCUSIPLink = JRadioButton("Reset/Fix/Edit/Add CUSIP Banking Link (remove_ofx_security_bindings.py)", False)
                user_manageCUSIPLink.setToolTipText("Allows you to reset/add/edit/move your CUSIP banking link between security records. THIS CHANGES DATA! (remove_ofx_security_bindings.py)")
                user_manageCUSIPLink.setEnabled(lAdvancedMode)
                user_manageCUSIPLink.setForeground(getColorRed())

                user_updateOFXLastTxnUpdate = JRadioButton("Update the OFX Last Txn Update Date (Downloaded) field for an account (MD versions >= 2022 use Online menu)", False)
                user_updateOFXLastTxnUpdate.setToolTipText("Allows you to edit the last download Txn date which is used to set the start date for Txn downloads - THIS CHANGES DATA!")
                # user_updateOFXLastTxnUpdate.setEnabled(lAdvancedMode and (not isMDPlusEnabledBuild() or isToolboxUnlocked()))
                user_updateOFXLastTxnUpdate.setEnabled(lAdvancedMode)
                user_updateOFXLastTxnUpdate.setForeground(getColorRed())

                user_deleteOFXBankingLogonProfile = JRadioButton("Delete OFX Banking Service / Logon Profile (remove_one_service.py)", False)
                user_deleteOFXBankingLogonProfile.setToolTipText("This will allow you to delete an Online Banking logon / service profile (service) from Moneydance. E.g. you will have to set this up again. THIS CHANGES DATA! (remove_one_service.py)")
                user_deleteOFXBankingLogonProfile.setEnabled(lAdvancedMode)
                user_deleteOFXBankingLogonProfile.setForeground(getColorRed())

                user_cleanupMissingOnlineBankingLinks = JRadioButton("Cleanup missing Online Banking Links", False)
                user_cleanupMissingOnlineBankingLinks.setToolTipText("This Cleans up missing Online Banking Links - NOTE: Always called when 'Delete OFX Banking Service / Logon Profile' is run. THIS CHANGES DATA!")
                user_cleanupMissingOnlineBankingLinks.setEnabled(lAdvancedMode)
                user_cleanupMissingOnlineBankingLinks.setForeground(getColorRed())

                user_authenticationManagement = JRadioButton("OFX Authentication Management (various functions to manage authentication, UserIDs, ClientUIDs)", False)
                user_authenticationManagement.setToolTipText("Brings up the sub menu. Allows you to clear your authentication cache (single or all) and edit user IDs/ClientUIDs. THIS CAN CHANGE DATA!")
                user_authenticationManagement.setEnabled(lAdvancedMode)
                user_authenticationManagement.setForeground(getColorRed())

                user_deleteOnlineTxns = JRadioButton("Delete Single cached OnlineTxnList Record/Txns", False)
                user_deleteOnlineTxns.setToolTipText("Allows you to surgically remove your cached Online Txn List txns - THESE SHOULD NOT BE HERE! THIS CHANGES DATA!")
                user_deleteOnlineTxns.setEnabled(lAdvancedMode)
                user_deleteOnlineTxns.setForeground(getColorRed())

                user_deleteALLOnlineTxns = JRadioButton("Delete ALL cached OnlineTxnList Record/Txns (delete_intermediate_downloaded_transaction_caches.py)", False)
                user_deleteALLOnlineTxns.setToolTipText("Purges/cleans any/all your cached Online Txn List records / txns - THERE SHOULD BE NONE! VERY SAFE TO RUN! THIS CHANGES DATA! (delete_intermediate_downloaded_transaction_caches.py)")
                user_deleteALLOnlineTxns.setEnabled(lAdvancedMode)
                user_deleteALLOnlineTxns.setForeground(getColorRed())

                user_cookieManagement = JRadioButton("OFX Cookie Management (Hacker Mode only)", False)
                user_cookieManagement.setToolTipText("Brings up the sub menu. Allows you to manage your OFX cookies - Advanced + Hacker Mode only. THIS CAN CHANGE DATA!")
                user_cookieManagement.setEnabled(lAdvancedMode and lHackerMode)
                user_cookieManagement.setForeground(getColorRed())

                user_exportMDPlusProfile = JRadioButton("Export your Moneydance+ (Plaid) settings to a file (for 'transplant')", False)
                user_exportMDPlusProfile.setToolTipText("This will Export your stored Moneydance+ (Plaid) data/keys etc to a file (for 'transplant'). READONLY")
                user_exportMDPlusProfile.setEnabled(lAdvancedMode and lHackerMode)
                user_exportMDPlusProfile.setForeground(getColorRed())

                user_importMDPlusProfile = JRadioButton("Import ('transplant') your Moneydance+ (Plaid) settings from a file (exported by Toolbox)", False)
                user_importMDPlusProfile.setToolTipText("This will Import ('transplant') your Moneydance+ (Plaid) data/keys etc from a file exported by Toolbox. THIS CHANGES DATA!")
                user_importMDPlusProfile.setEnabled(lAdvancedMode and lHackerMode)
                user_importMDPlusProfile.setForeground(getColorRed())

                user_zapMDPlusProfile = JRadioButton("ZAP your Moneydance+ (Plaid) settings (only when status is NOT 'activated')", False)
                user_zapMDPlusProfile.setToolTipText("This will delete your stored Moneydance+ (Plaid) data/keys etc - E.g. you will have to set this up again. THIS CHANGES DATA!")
                user_zapMDPlusProfile.setEnabled((lAdvancedMode and lHackerMode) and (not isMDPlusLicenseActivated() or isToolboxUnlocked()))
                user_zapMDPlusProfile.setForeground(getColorRed())

                user_manuallyPrimeUSAARootUserIDClientIDs = JRadioButton("USAA ONLY: (NEW METHOD) Manually 'prime' / overwrite stored Root UserIDs/ClientUIDs", False)
                user_manuallyPrimeUSAARootUserIDClientIDs.setToolTipText("USAA Only: Allows you to 'prime' / overwrite stored UserIDs/ClientUIDs for USSA")
                user_manuallyPrimeUSAARootUserIDClientIDs.setEnabled(lAdvancedMode)
                user_manuallyPrimeUSAARootUserIDClientIDs.setForeground(getColorRed())

                user_createUSAAProfile = JRadioButton("USAA Only: (DEPRECATED METHOD) Executes the special script to create a working USAA OFX Profile", False)
                user_createUSAAProfile.setToolTipText("Executes: ofx_create_new_usaa_bank_custom_profile.py - THIS CHANGES DATA!")
                user_createUSAAProfile.setEnabled(lAdvancedMode)
                user_createUSAAProfile.setForeground(getColorRed())

                labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced mode **")
                labelFYI2.setForeground(getColorRed())

                labelFYI3 = JLabel("       ** to activate Exit, Select Toolbox Options, both Advanced & Hacker modes **")
                labelFYI3.setForeground(getColorRed())

                userFilters = JPanel(GridLayout(0, 1))

                bg = ButtonGroup()
                bg.add(user_forgetOFXBankingLink)
                bg.add(user_deleteOFXBankingLogonProfile)
                bg.add(user_cleanupMissingOnlineBankingLinks)
                bg.add(user_manageCUSIPLink)
                bg.add(user_searchOFXData)
                bg.add(user_UNLOCKMDPlusDiagnostic)
                bg.add(user_viewInstalledBankProfiles)
                bg.add(user_view_CUSIP_settings)
                bg.add(user_viewOnlineTxnsPayeesPayments)
                bg.add(user_viewAllLastTxnDownloadDates)
                bg.add(user_cookieManagement)
                bg.add(user_exportMDPlusProfile)
                bg.add(user_importMDPlusProfile)
                bg.add(user_zapMDPlusProfile)
                bg.add(user_authenticationManagement)
                bg.add(user_deleteOnlineTxns)
                bg.add(user_deleteALLOnlineTxns)
                bg.add(user_manuallyPrimeUSAARootUserIDClientIDs)
                bg.add(user_createUSAAProfile)
                bg.add(user_updateOFXLastTxnUpdate)
                bg.add(user_viewListALLMDServices)
                # bg.add(user_toggleOFXDebug)
                bg.add(user_toggleMDDebug)
                bg.clearSelection()

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))

                if isToolboxUnlocked():
                    userFilters.add(user_UNLOCKMDPlusDiagnostic)

                userFilters.add(user_searchOFXData)
                userFilters.add(user_viewInstalledBankProfiles)
                userFilters.add(user_viewListALLMDServices)
                userFilters.add(user_view_CUSIP_settings)
                userFilters.add(user_viewOnlineTxnsPayeesPayments)
                userFilters.add(user_viewAllLastTxnDownloadDates)
                userFilters.add(user_toggleMDDebug)
                # userFilters.add(user_toggleOFXDebug)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))
                if not lAdvancedMode:
                    userFilters.add(labelFYI2)

                userFilters.add(user_forgetOFXBankingLink)
                userFilters.add(user_manageCUSIPLink)
                userFilters.add(user_updateOFXLastTxnUpdate)
                userFilters.add(user_deleteOFXBankingLogonProfile)
                userFilters.add(user_cleanupMissingOnlineBankingLinks)
                userFilters.add(user_authenticationManagement)
                userFilters.add(user_deleteOnlineTxns)
                userFilters.add(user_deleteALLOnlineTxns)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---- ADVANCED + HACKER MODE ONLY  -----"))
                if not lAdvancedMode or not lHackerMode:
                    userFilters.add(labelFYI3)
                userFilters.add(user_cookieManagement)

                if isMDPlusEnabledBuild():
                    userFilters.add(user_exportMDPlusProfile)
                    userFilters.add(user_importMDPlusProfile)
                    userFilters.add(user_zapMDPlusProfile)

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---- USAA ONLY  -----"))
                userFilters.add(user_manuallyPrimeUSAARootUserIDClientIDs)
                userFilters.add(user_createUSAAProfile)

                while True:
                    options = ["EXIT", "PROCEED"]
                    jsp = MyJScrollPaneForJOptionPane(userFilters,750,600)
                    userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                               jsp,
                                                               "Online Banking (OFX) Tools",
                                                               JOptionPane.OK_CANCEL_OPTION,
                                                               JOptionPane.QUESTION_MESSAGE,
                                                               MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                               options, options[0]))
                    if userAction != 1:
                        txt = "Online Banking (OFX) Tools - No changes made....."
                        setDisplayStatus(txt, "B")
                        return

                    # for button in bg.getElements():
                    #     if button.isSelected(): break
                    #

                    if user_forgetOFXBankingLink.isSelected():
                        forgetOFXImportLink()

                    if user_deleteOFXBankingLogonProfile.isSelected():
                        deleteOFXService()

                    if user_cleanupMissingOnlineBankingLinks.isSelected():
                        cleanupMissingOnlineBankingLinks(lAutoPurge=False)

                    if user_manageCUSIPLink.isSelected():
                        CUSIPFix()

                    # if user_toggleOFXDebug.isSelected():
                    #     OFXDEBUGToggle()

                    if user_searchOFXData.isSelected():
                        viewer = GeekOutModeButtonAction(lOFX=True)
                        viewer.actionPerformed("")
                        del viewer
                        txt = "OFX: Your OFX Bank related settings have been searched and displayed...."
                        setDisplayStatus(txt, "B")
                        return

                    if user_toggleMDDebug.isSelected():
                        hacker_mode_DEBUG()

                    if user_UNLOCKMDPlusDiagnostic.isSelected():
                        UNLOCKMDPlusDiagnostic()
                        return

                    if user_authenticationManagement.isSelected():
                        if OFX_authentication_management(): return

                    if user_exportMDPlusProfile.isSelected():
                        export_MDPlus_Profile()

                    if user_importMDPlusProfile.isSelected():
                        if import_MDPlus_Profile(): return

                    if user_zapMDPlusProfile.isSelected():
                        if zap_MDPlus_Profile(): return

                    if user_cookieManagement.isSelected():
                        OFX_cookie_management()

                    if user_viewListALLMDServices.isSelected():
                        download_md_fiscal_setup()
                        txt = "OFX: Moneydance's Dynamic Fiscal Institution Setup profiles have been retrieved and displayed...."
                        setDisplayStatus(txt, "B")
                        return

                    if user_view_CUSIP_settings.isSelected():
                        OFX_view_CUSIP_settings()
                        txt = "OFX: Your Security's hidden CUSIP settings have been retrieved and displayed...."
                        setDisplayStatus(txt, "B")
                        return

                    if user_viewOnlineTxnsPayeesPayments.isSelected():
                        OFX_view_online_txns_payees_payments()
                        txt = "OFX: Your Online saved Txns, Payees, Payments have been retrieved and displayed...."
                        setDisplayStatus(txt, "B")
                        return

                    if user_viewAllLastTxnDownloadDates.isSelected():
                        OFX_view_all_last_txn_download_dates()
                        txt = "OFX: All your last txn download txn dates have been retrieved and displayed...."
                        setDisplayStatus(txt, "B")
                        return

                    if user_viewInstalledBankProfiles.isSelected():
                        ofx_view_service_profile_data()
                        txt = "OFX: Your installed Service / Bank logon profiles have been displayed...."
                        setDisplayStatus(txt, "B")
                        return

                    if user_deleteOnlineTxns.isSelected():
                        OFX_delete_saved_online_txns()

                    if user_deleteALLOnlineTxns.isSelected():
                        OFX_delete_ALL_saved_online_txns()
                        return

                    if user_manuallyPrimeUSAARootUserIDClientIDs.isSelected():
                        manuallyPrimeUSAARootUserIDClientIDs()

                    if user_createUSAAProfile.isSelected():
                        if createUSAAProfile(): return

                    if user_updateOFXLastTxnUpdate.isSelected():
                        OFX_update_OFXLastTxnUpdate()

                    continue

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class FixDropboxOneWaySyncButtonAction(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                # fix_dropbox_one_way_syncing.py
                # reset_sync_and_dropbox_settings.py
                theKey = "migrated.netsync.dropbox.fileid"

                titleText = "Remove legacy Dropbox Migrated Sync Key".upper()
                question  = "Remove '%s' key to fix Dropbox one-way & iCloud Sync issues?" %(theKey)

                if not confirm_backup_confirm_disclaimer(toolbox_frame_, titleText, question):
                    return

                myPrint("B","%s: Removing key '%s' from LocalStorage() at user request...." %(titleText, theKey))

                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                LS.remove(theKey)
                LS.save()

                MD_REF.getUI().getMain().saveCurrentAccount()           # Flush any current txns in memory and start a new sync record...
                play_the_money_sound()

                self.myButton.setVisible(False)
                self.myButton.setEnabled(False)

                txt = "%s: Completed. MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD" %(titleText)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,titleText,JOptionPane.WARNING_MESSAGE)
                MD_REF.getUI().exit()

        class MakeDropBoxSyncFolder(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if check_for_dropbox_folder():
                    txt = "Sorry - Fix: Create .moneydancesync folder button not available!? NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPrint("B","MakeDropBoxSyncFolder() called, but check_for_dropbox_folder() returned True - so we should not be here? FIX NOT AVAILABLE")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if not myPopupAskQuestion(toolbox_frame_,
                                          "DROPBOX",
                                          "Create missing Dropbox .moneydancesync folder?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.ERROR_MESSAGE):

                    txt = "User declined to create missing Dropbox .moneydancesync folder - NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                self.myButton.setVisible(False)
                self.myButton.setEnabled(False)

                userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
                baseFolder = File(userHomeProperty, "Dropbox")

                try:
                    if File(baseFolder, ".moneydancesync").mkdir():
                        txt = "Created Dropbox .moneydancesync folder in Dropbox"
                        setDisplayStatus(txt, "B")
                        myPrint("B", txt)
                        myPopupInformationBox(toolbox_frame_, txt, "DROPBOX", JOptionPane.WARNING_MESSAGE)
                        return

                except: dump_sys_error_to_md_console_and_errorlog()

                txt = "Error creating Dropbox .moneydancesync folder!?"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_, txt, "DROPBOX", JOptionPane.ERROR_MESSAGE)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class FindDatasetButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug, i_am_an_extension_so_run_headless

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                _THIS_METHOD_NAME = "FIND DATASET"

                if not myPopupAskQuestion(toolbox_frame_,
                                          "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)/BACKUP(s)",
                                          "This may be time consuming...Do you want to continue with search?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.WARNING_MESSAGE):

                    txt = "%s: User Aborted Dataset search..." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                whatType = ["Datasets",
                             "Backups"]


                selectedWhat = JOptionPane.showInputDialog(     toolbox_frame_,
                                                                "WHAT TYPE OF DATASET?",
                                                                "Choose Datasets or Backups",
                                                                JOptionPane.INFORMATION_MESSAGE,
                                                                MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                                whatType,
                                                                None)
                if selectedWhat is None:
                    txt = "%s: No Dataset Type was selected - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if whatType.index(selectedWhat) == 0:
                    lBackup=False
                    theExtension = "*.moneydance".lower()
                elif whatType.index(selectedWhat) == 1:
                    lBackup=True
                    theExtension = "*.moneydancearchive".lower()
                else:
                    txt = "%s: Dataset Type Error - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                myPrint("DB", "Dataset type: %s" %(theExtension))

                if Platform.isWindows():
                    theRoot = os.path.join("C:"+os.path.sep)
                else:
                    theRoot = os.path.sep

                lRootExclusions = False

                whereFrom = [ "From UserDir: %s" %get_home_dir(),
                              "From Root: %s (excluding some system locations and other volumes)" %theRoot,
                              "From Root: %s (nothing excluded - might take a long time / never finish)" %theRoot,
                              "Select your own start point"]

                selectedStart = JOptionPane.showInputDialog(toolbox_frame_,
                                                            "Select the Search start folder",
                                                            "WHERE TO SEARCH FROM",
                                                            JOptionPane.INFORMATION_MESSAGE,
                                                            MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                            whereFrom,
                                                            None)
                if selectedStart is None:
                    txt = "%s: No start point was selected - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if whereFrom.index(selectedStart) == 3:

                    theTitle = "Select location to start %s Dataset Search (CANCEL=ABORT)" %(theExtension)
                    theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                                        get_home_dir(),         # Starting path
                                                        None,                   # Default Filename
                                                        theTitle,               # Title
                                                        False,                  # Multi-file selection mode
                                                        True,                   # True for Open/Load, False for Save
                                                        False,                  # True = Files, else Dirs
                                                        "START SEARCH",         # Load/Save button text, None for defaults
                                                        None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                        lAllowTraversePackages=True,
                                                        lAllowTraverseApplications=True,
                                                        lForceJFC=False,
                                                        lForceFD=False,
                                                        lAllowNewFolderButton=False,
                                                        lAllowOptionsButton=False)

                    if theDir is None or theDir == "":
                        txt = "%s: User did not select Search Directory... Aborting" %(_THIS_METHOD_NAME)
                        setDisplayStatus(txt, "R")
                        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                        return None

                elif whereFrom.index(selectedStart) == 2:  # From ROOT with no exclusions
                    theDir = theRoot
                elif whereFrom.index(selectedStart) == 1:  # From ROOT with exclusions
                    lRootExclusions = True
                    theDir = theRoot
                elif whereFrom.index(selectedStart) == 0:  # From User Home Dir
                    theDir = get_home_dir()
                else:
                    txt = "%s: Error Selecting Search Directory... Aborting" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching..",theTitle=_THIS_METHOD_NAME, theWidth=100, lModal=False,OKButtonText="WAIT")
                diag.go()

                save_list_of_found_files=[]

                myPrint("B","DATASET Search >> Searching from Directory: %s" %theDir)

                def findDataset(pattern, path):
                    iFound=0                                                                                            # noqa
                    result = []
                    dotCounter = 0
                    thingsSearched = 0

                    lContinueToEnd=False

                    if not i_am_an_extension_so_run_headless:
                        print "Searching for your %s Datasets (might be time consuming):."%theExtension,

                    exclude_these_dirs = []

                    if lRootExclusions:
                        if Platform.isOSX():
                            exclude_these_dirs = ["/System", "/Library"]
                        elif Platform.isUnix():
                            exclude_these_dirs = ["/media", "/boot", "/cdrom", "/sys", "/proc", "/dev", "/mnt"]
                        myPrint("B","Root exclusions requested... These are: %s" %(exclude_these_dirs))

                    start_time = time.time()
                    timeOutCheckBackMinutes = 10.0
                    timeOutSeconds = 10

                    class MyTimerTask(TimerTask):

                        def __init__(self, dlg, theTimer):
                            self.dlg = dlg
                            self.theTimer = theTimer

                        def run(self):
                            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

                            myPrint("D","Timer task triggered - closing the JOption Pane....")
                            self.dlg.setVisible(False)
                            self.theTimer.cancel()

                            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                            return

                    class MyJOptionPaneListener(ComponentAdapter):

                        def __init__(self, timeout, dlg):
                            self.timeout = timeout
                            self.dlg = dlg
                            self.t = None

                        def componentShown(self, e):
                            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", e)
                            super(MyJOptionPaneListener, self).componentShown(e)                                        # noqa
                            myPrint("D","Toolbox setting up Timer Task for Search function to kill Search dialog...")
                            self.t = Timer()
                            self.t.schedule(MyTimerTask(self.dlg,self.t), self.timeout)
                            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

                        def componentHidden(self, e):
                            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", e)
                            super(MyJOptionPaneListener, self).componentHidden(e)                                       # noqa
                            myPrint("D","Killing Timer Task for Search function as dialog closed...")
                            self.t.cancel()
                            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

                    # showOptionDialog(Component parentComponent, Object message, String title, int optionType, int messageType, Icon icon, Object[] options, Object initialValue)
                    def showConfirmDialogWithTimeout(theFrame, theMessage, _theTitle, theOptionType, theMessageType, theIcon, theChoices, theInitialValue, timeout_ms, timeoutChoice):
                        theMsg = JOptionPane(theMessage, theMessageType, theOptionType, theIcon, theChoices, theInitialValue)
                        dlg = theMsg.createDialog(theFrame, _theTitle)
                        dlg.setAlwaysOnTop(True)
                        dlg.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)
                        theListener = MyJOptionPaneListener( timeout_ms, dlg )
                        dlg.addComponentListener( theListener )
                        dlg.setVisible(True)
                        selectedValue = theMsg.getValue()
                        dlg.removeComponentListener( theListener )
                        del theListener
                        if selectedValue is None or selectedValue < 0:
                            return -1
                        try:
                            return theChoices.index(selectedValue)
                        except:
                            pass    # Probably "uninitializedValue"

                        return theChoices.index(timeoutChoice)

                    options=["STOP HERE","SEARCH TO END", "KEEP ASKING"]

                    for root, dirs, files in os.walk(path, topdown=True):

                        if debug: myPrint("DB","Searching: %s" %(root))

                        if dotCounter % 1000 <1:
                            if not i_am_an_extension_so_run_headless: print ".",

                        if (not dotCounter
                                or (dotCounter % 10000 <1 and not lContinueToEnd)
                                or (time.time() - start_time > (timeOutCheckBackMinutes*60))):

                            start_time = time.time()

                            # ####
                            response = showConfirmDialogWithTimeout(toolbox_frame_,
                                                                    "Are you OK to continue (so far..: %s found / %s files/searched)?" %(iFound, thingsSearched),
                                                                    "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)",
                                                                    JOptionPane.YES_NO_OPTION,
                                                                    JOptionPane.QUESTION_MESSAGE,
                                                                    None,
                                                                    options,
                                                                    options[2],
                                                                    timeOutSeconds * 1000,
                                                                    options[2])

                            # response = JOptionPane.showOptionDialog(toolbox_frame_,
                            #                                          "Are you OK to continue (so far..: %s found / %s files/searched)?" %(iFound, thingsSearched),
                            #                                          "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)",
                            #                                          JOptionPane.YES_NO_OPTION,
                            #                                          JOptionPane.QUESTION_MESSAGE,
                            #                                          None,
                            #                                          options,
                            #                                          options[2])

                            if response < 1:
                                _txt = "%s: User Aborted Dataset search..." %(_THIS_METHOD_NAME)
                                myPrint("B", _txt); setDisplayStatus(_txt, "R")
                                return result, iFound
                            elif response == 1:
                                lContinueToEnd = True
                            elif response == 2:
                                pass

                        dotCounter+=1

                        # Remove /System dir etc on Mac/Linux....
                        if lRootExclusions:
                            for d in list(dirs):
                                for ex in exclude_these_dirs:
                                    if (root+d).startswith(ex):
                                        dirs.remove(d)

                        if lBackup:

                            for name in files:
                                fp = os.path.join(root,name)
                                if os.path.islink(fp):
                                    myPrint("DB", "found file link! %s - will skip" %fp)
                                    continue

                                thingsSearched+=1
                                if fnmatch.fnmatch(name, pattern):
                                    iFound+=1
                                    result.append("File >> Sz: %sMB Mod: %s Name: %s "
                                                  %(rpad(convertBytesMBs(os.path.getsize(os.path.join(root, name))),6),
                                                    pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime('%Y-%m-%d %H:%M:%S'),11),
                                                    os.path.join(root, name)))
                        for name in dirs:
                            fp = os.path.join(root,name)
                            if os.path.islink(fp):
                                myPrint("DB", "found dir link! %s - will skip" %fp)
                                continue

                            thingsSearched+=1
                            if fnmatch.fnmatch(name, pattern):
                                if name != ".moneydance":
                                    save_list_of_found_files.append(fp)
                                    iFound+=1
                                result.append("Dir >> Modified: %s %s"
                                              %(pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime('%Y-%m-%d %H:%M:%S'),11),
                                              os.path.join(root, name)))
                    return result, iFound

                fileList, iFound = findDataset(theExtension, theDir)

                diag.kill()

                print
                myPrint("B","Completed search for %s datafiles: %s found" %(theExtension,iFound))

                niceFileList="\n SEARCH FOR MONEYDANCE (%s) DATASETS\n" %(theExtension)
                niceFileList+="Search started from Directory: %s\n\n" %(theDir)

                if lRootExclusions:
                    niceFileList+="(NOTE: Root search exclusions of other volumes and some system locations were requested too)\n\n"

                if not iFound:
                    niceFileList+="\n<NONE FOUND>\n"

                for x in fileList:
                    myPrint("B","Found: %s" %x)
                    niceFileList+=x+"\n"

                txt = "Find my %s datasets(s) found %s possible files/directories" %(theExtension,iFound)
                setDisplayStatus(txt, "DG")

                jif = QuickJFrame("LIST OF MONEYDANCE %s DATASETS FOUND" %(theExtension),
                                  niceFileList,
                                  lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

                myPopupInformationBox(jif, "%s %s Datasets located...." %(iFound,theExtension), _THIS_METHOD_NAME, JOptionPane.INFORMATION_MESSAGE)

                if not lBackup:
                    add_to_ext_list=[]
                    internalDir = Common.getDocumentsDirectory().getCanonicalPath()

                    externalFiles = AccountBookUtil.getExternalAccountBooks()
                    externalFiles_asList = []
                    for ext in externalFiles:
                        externalFiles_asList.append(ext.getBook().getRootFolder().getCanonicalPath())

                    for filename in save_list_of_found_files:
                        if not os.path.exists(filename):
                            continue
                        if internalDir in filename:
                            continue
                        if filename in externalFiles_asList:
                            continue
                        add_to_ext_list.append(filename)

                    myPrint("DB","Found %s external files that can be added to config.dict: %s" %(len(add_to_ext_list),add_to_ext_list))

                    if (len(add_to_ext_list) > 0
                            and myPopupAskQuestion(jif, _THIS_METHOD_NAME, "%s of these datasets are not showing in your File/Open menu list(and config.dict)? WOULD YOU LIKE TO ADD ANY OF THEM?" %(len(add_to_ext_list))) ):

                        backup_config_dict(True)

                        iAdded = 0
                        externalFilesVector = MD_REF.getUI().getPreferences().getVectorSetting("external_files", StreamVector())
                        for add_this_file in add_to_ext_list:
                            if not myPopupAskQuestion(jif,"ADD FILE TO FILE/OPEN MENU","ADD: %s?" %((add_this_file))):
                                continue
                            iAdded+=1
                            myPrint("B","SEARCH FOR DATASETS - %s added to config.dict and file/open menu" %(add_this_file))
                            externalFilesVector.add(add_this_file)
                            MD_REF.getUI().getPreferences().setSetting("external_files", externalFilesVector)

                        if iAdded:
                            MD_REF.savePreferences()
                            myPopupInformationBox(jif, "SEARCH FOR DATASETS - %s files added to config.dict and file/open menu (RESTART MD REQUIRED)" %(iAdded), "DATASET SEARCH", JOptionPane.INFORMATION_MESSAGE)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class AccountsCategoriesMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug
                global lAdvancedMode, lHackerMode, fixRCurrencyCheck

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                user_view_check_number_settings = JRadioButton("View Check Number Settings", False)
                user_view_check_number_settings.setToolTipText("View the Check Number settings that will display in the Transaction Register")

                user_force_change_accounts_currency = JRadioButton("FIX: FORCE Change an Account's Currency (force_change_account_currency.py)", False)
                user_force_change_accounts_currency.setToolTipText("This allows you to FORCE change an Account's currency - USE WITH CARE!.. THIS CHANGES DATA! (force_change_account_currency.py)")
                user_force_change_accounts_currency.setEnabled(lAdvancedMode)
                user_force_change_accounts_currency.setForeground(getColorRed())

                user_force_change_all_accounts_currency = JRadioButton("FIX: FORCE Change ALL Account's Currencies (force_change_all_currencies.py)", False)
                user_force_change_all_accounts_currency.setToolTipText("This allows you to FORCE change ALL Account's Currencies - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")
                user_force_change_all_accounts_currency.setEnabled(lAdvancedMode)
                user_force_change_all_accounts_currency.setForeground(getColorRed())

                user_force_change_an_accounts_type = JRadioButton("FIX: FORCE Change an Account's Type (set_account_type.py)", False)
                user_force_change_an_accounts_type.setToolTipText("This allows you to FORCE change an Account's Type - USE WITH CARE!.. THIS CHANGES DATA! (set_account_type.py)")
                user_force_change_an_accounts_type.setEnabled(lAdvancedMode)
                user_force_change_an_accounts_type.setForeground(getColorRed())

                user_view_zero_bal_cats = JRadioButton("DIAG: Categories and Balances Report", False)
                user_view_zero_bal_cats.setToolTipText("This will list all your Categories and show which have Zero Balances - USE ADVANCED MODE TO MAKE THESE INACTIVE")

                user_inactivate_zero_bal_cats = JRadioButton("FIX: Make Zero Balance Categories Inactive", False)
                user_inactivate_zero_bal_cats.setToolTipText("This will allow you Inactivate all Categories with Zero Balances (you will see the report first). THIS CHANGES DATA!")
                user_inactivate_zero_bal_cats.setEnabled(lAdvancedMode)
                user_inactivate_zero_bal_cats.setForeground(getColorRed())

                user_view_shouldBeIncludedInNetWorth_settings = JRadioButton("DIAG: View Accounts' shouldBeIncludedInNetWorth() settings...", False)
                user_view_shouldBeIncludedInNetWorth_settings.setToolTipText("This will list all Accounts/Categories and the shouldBeIncludedInNetWorth() setting - USE ADVANCED MODE TO EDIT")

                user_edit_shouldBeIncludedInNetWorth_settings = JRadioButton("FIX: Edit an Account's shouldBeIncludedInNetWorth() setting", False)
                user_edit_shouldBeIncludedInNetWorth_settings.setToolTipText("This will allow you to edit an Account's shouldBeIncludedInNetWorth() setting. THIS CHANGES DATA!")
                user_edit_shouldBeIncludedInNetWorth_settings.setEnabled(lAdvancedMode)
                user_edit_shouldBeIncludedInNetWorth_settings.setForeground(getColorRed())

                user_fix_accounts_parent = JRadioButton("FIX: Account's Invalid Parent Account (fix_account_parent.py)", False)
                user_fix_accounts_parent.setToolTipText("This will diagnose your Parent Accounts and fix if invalid. THIS CHANGES DATA! (fix_account_parent.py)")
                user_fix_accounts_parent.setEnabled(lAdvancedMode)
                user_fix_accounts_parent.setForeground(getColorRed())

                bookName = MD_REF.getCurrentAccountBook().getName().strip()
                root = MD_REF.getCurrentAccountBook().getRootAccount()
                rootName = root.getAccountName().strip()
                user_fix_root_account_name = JRadioButton("FIX: Correct Root Account Name (Only enabled if the name is incorrect)", False)
                user_fix_root_account_name.setToolTipText("This allows you to change the (nearly) hidden Master/Parent Account Name in Moneydance (referred to as ROOT) to match the name of your Dataset (referred to as BOOK). THIS CHANGES DATA!")
                user_fix_root_account_name.setEnabled(lAdvancedMode and (rootName != bookName))
                user_fix_root_account_name.setForeground(getColorRed())

                labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced mode **")
                labelFYI2.setForeground(getColorRed())

                labelFYI_curr_fix = JLabel("       ** disabled when a serious currency/security issue has been detected **")
                labelFYI_curr_fix.setForeground(getColorRed())

                userFilters = JPanel(GridLayout(0, 1))

                bg = ButtonGroup()
                bg.add(user_view_check_number_settings)
                bg.add(user_view_zero_bal_cats)
                bg.add(user_inactivate_zero_bal_cats)
                bg.add(user_view_shouldBeIncludedInNetWorth_settings)
                bg.add(user_edit_shouldBeIncludedInNetWorth_settings)
                bg.add(user_force_change_an_accounts_type)
                bg.add(user_force_change_accounts_currency)
                bg.add(user_force_change_all_accounts_currency)
                bg.add(user_fix_accounts_parent)
                bg.add(user_fix_root_account_name)
                bg.clearSelection()

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                userFilters.add(user_view_check_number_settings)
                userFilters.add(user_view_zero_bal_cats)
                userFilters.add(user_view_shouldBeIncludedInNetWorth_settings)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                if not lAdvancedMode:
                    userFilters.add(labelFYI2)

                userFilters.add(user_inactivate_zero_bal_cats)
                userFilters.add(user_edit_shouldBeIncludedInNetWorth_settings)
                userFilters.add(user_force_change_an_accounts_type)
                userFilters.add(user_force_change_accounts_currency)
                userFilters.add(user_force_change_all_accounts_currency)
                userFilters.add(user_fix_accounts_parent)
                userFilters.add(user_fix_root_account_name)

                while True:

                    bookName = MD_REF.getCurrentAccountBook().getName().strip()
                    root = MD_REF.getCurrentAccountBook().getRootAccount()
                    rootName = root.getAccountName().strip()

                    user_fix_root_account_name.setEnabled(lAdvancedMode and (rootName != bookName))

                    bg.clearSelection()

                    options = ["EXIT", "PROCEED"]
                    jsp = MyJScrollPaneForJOptionPane(userFilters,600,300)
                    userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                               jsp,
                                                               "Accounts / Categories Diagnostics, Tools, Fixes",
                                                               JOptionPane.OK_CANCEL_OPTION,
                                                               JOptionPane.QUESTION_MESSAGE,
                                                               MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                               options, options[0]))
                    if userAction != 1:
                        return

                    selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                    if user_view_check_number_settings.isSelected():
                        x = ViewFileButtonAction("view_check_num_settings()", "Check Number Settings etc", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_view_zero_bal_cats.isSelected():
                        zero_bal_categories(False)
                        return

                    if user_inactivate_zero_bal_cats.isSelected():
                        zero_bal_categories(True)
                        return

                    if user_view_shouldBeIncludedInNetWorth_settings.isSelected():
                        view_shouldBeIncludedInNetWorth_settings()
                        return

                    if user_edit_shouldBeIncludedInNetWorth_settings.isSelected():
                        edit_shouldBeIncludedInNetWorth_settings()
                        return

                    if user_force_change_an_accounts_type.isSelected():
                        force_change_account_type()

                    if user_force_change_accounts_currency.isSelected():
                        force_change_account_currency()

                    if user_force_change_all_accounts_currency.isSelected():
                        force_change_all_accounts_currencies()

                    if user_fix_accounts_parent.isSelected():
                        fix_account_parent()
                        return

                    if user_fix_root_account_name.isSelected():
                        fix_root_account_name()

                    continue

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class CurrencySecurityMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug
                global lAdvancedMode, lHackerMode, fixRCurrencyCheck

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                lAlertPopupShown = False

                user_show_open_share_lots = JRadioButton("DIAG: Show Open Share LOTS (unconsumed) (show_open_tax_lots.py)", False)
                user_show_open_share_lots.setToolTipText("This will list all Stocks/Shares with Open/Unconsumed LOTS (when LOT Control ON) - READONLY (show_open_tax_lots.py)")

                user_convert_stock_lot_FIFO = JRadioButton("FIX: Convert Stock to LOT controlled with FIFO lot matching (MakeFifoCost.py)", False)
                user_convert_stock_lot_FIFO.setToolTipText("Convert Average Cost Controlled Stock to LOT Controlled and Allocate LOTs using FiFo method - THIS CHANGES DATA! (MakeFifoCost.py)")
                user_convert_stock_lot_FIFO.setEnabled(lAdvancedMode)
                user_convert_stock_lot_FIFO.setForeground(getColorRed())

                user_convert_stock_avg_cst_control = JRadioButton("FIX: Convert Stock to Average Cost Control", False)
                user_convert_stock_avg_cst_control.setToolTipText("Convert LOT Controlled Stock to Average Cost Control (and wipe any LOT records) - THIS CHANGES DATA!")
                user_convert_stock_avg_cst_control.setEnabled(lAdvancedMode)
                user_convert_stock_avg_cst_control.setForeground(getColorRed())

                user_thin_price_history = JRadioButton("FIX: Thin/Purge Price History (price_history_thinner.py)", False)
                user_thin_price_history.setToolTipText("This will allow you to Thin / Prune your Price History based on user parameters. THIS CHANGES DATA! (price_history_thinner.py)")
                user_thin_price_history.setEnabled(lAdvancedMode)
                user_thin_price_history.setForeground(getColorRed())

                user_fix_nonlinked_security_records = JRadioButton("FIX: Detect and fix Investment Security records not properly linked to Security Master records", False)
                user_fix_nonlinked_security_records.setToolTipText("This will scan your Investment Security record and check that it's properly linked to a security master record... Allows you to fix this too")
                user_fix_nonlinked_security_records.setEnabled(lAdvancedMode)
                user_fix_nonlinked_security_records.setForeground(getColorRed())

                user_can_i_delete_security = JRadioButton("DIAG: Can I Delete a Security?", False)
                user_can_i_delete_security.setToolTipText("This will tell you whether a Selected Security is in use and whether you can delete it in Moneydance")

                user_can_i_delete_currency = JRadioButton("DIAG: Can I Delete a Currency?", False)
                user_can_i_delete_currency.setToolTipText("This will tell you whether a Selected Currency is in use and whether you can delete it in Moneydance")

                user_list_curr_sec_dpc = JRadioButton("DIAG: List Security / Currency (hidden) decimal place settings", False)
                user_list_curr_sec_dpc.setToolTipText("This will list your Security and Currency hidden decimal place settings (and attempt to advise of setup errors)")

                user_diag_curr_sec = JRadioButton("DIAG: Diagnose currencies / securities (including relative currencies) (if errors see fix below) (based on reset_relative_currencies.py)", False)
                user_diag_curr_sec.setToolTipText("This will diagnose your Currency & Security setup, also checking relative currencies (and advise if you need to run a fix) (reset_relative_currencies.py)")

                user_diag_price_date = JRadioButton("DIAG: Diagnose currency and security's current price hidden 'price_date' field", False)
                user_diag_price_date.setToolTipText("This will diagnose your Currency & Security's current price hidden price_date field....")

                user_edit_security_decimal_places = JRadioButton("FIX: Edit a Security's (hidden) Decimal Place setting (adjusts related Investment txns & Security balances accordingly)", False)
                user_edit_security_decimal_places.setToolTipText("This allows you to edit the hidden decimal places setting stored against a security (that you determined when you set the security up)")
                user_edit_security_decimal_places.setEnabled(lAdvancedMode and int(MD_REF.getBuild()) >= 1904)  # Pre-2019.4(1904) different usage of rate/rrate/dpc
                user_edit_security_decimal_places.setForeground(getColorRed())

                user_merge_duplicate_securities = JRadioButton("FIX: Merge 'duplicate' securities (and related Investment txns) into one master security record.", False)
                user_merge_duplicate_securities.setToolTipText("Scans for 'duplicated' Securities and can merge together.. Tools>Securities>TickerSymbol is key, ID must be different... (Dpc, RelCurr, Rate, Splits must also match)")
                user_merge_duplicate_securities.setEnabled(lAdvancedMode)
                user_merge_duplicate_securities.setForeground(getColorRed())

                user_autofix_price_date = JRadioButton("FIX: Diagnose then fix your currency / security's current price hidden 'price_date' field (along with the current price/rate)", False)
                user_autofix_price_date.setToolTipText("This will diagnose then fix your Currency & Security's current price hidden price_date field (and current price/rate)....")
                user_autofix_price_date.setEnabled(lAdvancedMode)
                user_autofix_price_date.setForeground(getColorRed())

                user_fix_price_date = JRadioButton("FIX: Manually edit a currency/ security's current price hidden 'price_date' field", False)
                user_fix_price_date.setToolTipText("Allows you to manually edit a Currency / Security's current price hidden 'price_date' field....")
                user_fix_price_date.setEnabled(lAdvancedMode)
                user_fix_price_date.setForeground(getColorRed())

                user_fix_curr_sec = JRadioButton("FIX: Fix currencies / securities (including relative currencies) (based on reset_relative_currencies.py) - MUST RUN DIAGNOSE ABOVE FIRST", False)
                user_fix_curr_sec.setToolTipText("This will apply fixes to your Currency (& security) / Relative Currency setup (use after running the diagnose option first). THIS CHANGES DATA!  (reset_relative_currencies.py)")
                user_fix_curr_sec.setEnabled(lAdvancedMode and fixRCurrencyCheck is not None and fixRCurrencyCheck>1)
                user_fix_curr_sec.setForeground(getColorRed())

                user_fix_invalid_curr_sec = JRadioButton("FIX: Fix Invalid Relative Currency (& security) Rates where <= (1.0/9999999999) or >= 9999999999 (fix_invalid_currency_rates.py)", False)
                user_fix_invalid_curr_sec.setToolTipText("This will reset any relative rates back to 1.0 where <= (1.0/9999999999) or >= 9999999999. THIS CHANGES DATA!  (fix_invalid_currency_rates.py)")
                user_fix_invalid_curr_sec.setEnabled(lAdvancedMode)
                user_fix_invalid_curr_sec.setForeground(getColorRed())

                user_fix_invalid_price_history = JRadioButton("FIX: Delete invalid price history records where rate <= (1.0/9999999999) or >= 9999999999.", False)
                user_fix_invalid_price_history.setToolTipText("This will delete and invalid price history records where rate <= (1.0/9999999999) or >= 9999999999. THIS CHANGES DATA!")
                user_fix_invalid_price_history.setEnabled(lAdvancedMode)
                user_fix_invalid_price_history.setForeground(getColorRed())

                user_force_change_accounts_currency = JRadioButton("FIX: FORCE Change an Account's Currency (force_change_account_currency.py)", False)
                user_force_change_accounts_currency.setToolTipText("This allows you to FORCE change an Account's currency - USE WITH CARE!.. THIS CHANGES DATA! (force_change_account_currency.py)")
                user_force_change_accounts_currency.setEnabled(lAdvancedMode)
                user_force_change_accounts_currency.setForeground(getColorRed())


                user_force_change_all_accounts_currency = JRadioButton("FIX: FORCE Change ALL Account's Currencies (force_change_all_currencies.py)", False)
                user_force_change_all_accounts_currency.setToolTipText("This allows you to FORCE change ALL Account's Currencies - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")
                user_force_change_all_accounts_currency.setEnabled(lAdvancedMode)
                user_force_change_all_accounts_currency.setForeground(getColorRed())

                labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced mode **")
                labelFYI2.setForeground(getColorRed())

                labelFYI_curr_fix = JLabel("       ** only enabled if no serious currency/security issues detected **")
                labelFYI_curr_fix.setForeground(getColorRed())

                userFilters = JPanel(GridLayout(0, 1))

                bg = ButtonGroup()
                bg.add(user_show_open_share_lots)
                bg.add(user_convert_stock_lot_FIFO)
                bg.add(user_convert_stock_avg_cst_control)
                bg.add(user_fix_nonlinked_security_records)
                bg.add(user_thin_price_history)
                bg.add(user_can_i_delete_security)
                bg.add(user_can_i_delete_currency)
                bg.add(user_list_curr_sec_dpc)
                bg.add(user_diag_curr_sec)
                bg.add(user_diag_price_date)
                bg.add(user_edit_security_decimal_places)
                bg.add(user_merge_duplicate_securities)
                bg.add(user_autofix_price_date)
                bg.add(user_fix_price_date)
                bg.add(user_fix_curr_sec)
                bg.add(user_fix_invalid_curr_sec)
                bg.add(user_fix_invalid_price_history)
                bg.add(user_force_change_accounts_currency)
                bg.add(user_force_change_all_accounts_currency)
                bg.clearSelection()

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                userFilters.add(user_diag_curr_sec)
                userFilters.add(user_can_i_delete_security)
                userFilters.add(user_can_i_delete_currency)
                userFilters.add(user_list_curr_sec_dpc)
                userFilters.add(user_show_open_share_lots)
                userFilters.add(user_diag_price_date)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                if not lAdvancedMode:
                    userFilters.add(labelFYI2)
                else:
                    if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD:
                        userFilters.add(labelFYI_curr_fix)

                userFilters.add(user_fix_curr_sec)

                # These are new features - better supported from 2021.2 onwards
                if int(MD_REF.getBuild()) >= MD_RRATE_ISSUE_FIXED_BUILD:
                    userFilters.add(user_edit_security_decimal_places)
                    userFilters.add(user_merge_duplicate_securities)
                    userFilters.add(user_autofix_price_date)
                    userFilters.add(user_fix_price_date)

                userFilters.add(user_convert_stock_lot_FIFO)
                userFilters.add(user_convert_stock_avg_cst_control)
                userFilters.add(user_fix_nonlinked_security_records)
                userFilters.add(user_thin_price_history)
                userFilters.add(user_fix_invalid_curr_sec)
                userFilters.add(user_fix_invalid_price_history)
                userFilters.add(user_force_change_accounts_currency)
                userFilters.add(user_force_change_all_accounts_currency)

                while True:

                    user_fix_curr_sec.setEnabled(lAdvancedMode and fixRCurrencyCheck is not None and fixRCurrencyCheck>1)

                    user_edit_security_decimal_places.setEnabled(lAdvancedMode and int(MD_REF.getBuild()) >= 1904)  # Pre-2019.4(1904) different usage of rate/rrate/dpc
                    user_merge_duplicate_securities.setEnabled(lAdvancedMode)
                    user_autofix_price_date.setEnabled(lAdvancedMode)
                    user_thin_price_history.setEnabled(lAdvancedMode)
                    user_fix_invalid_curr_sec.setEnabled(lAdvancedMode)
                    user_fix_invalid_price_history.setEnabled(lAdvancedMode)

                    # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
                    if not check_all_currency_raw_rates_ok():

                        user_diag_curr_sec.setForeground(getColorBlue())

                        if lAdvancedMode and not lAlertPopupShown:

                            if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD:
                                MyPopUpDialogBox(toolbox_frame_,
                                                 "ALERT: Currency/Security data issues need resolving - some menu items are disabled...",
                                                 "You have some Currency / Security records which were created in an older version of Moneydance\n"
                                                 "These need to be updated to the latest 'format' before Toolbox can allow some options\n"
                                                 "Please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to address this issue\n"
                                                 "OR BETTER >> Upgrade to Moneydance build %s onwards (as the MD code was fixed to deal with this data issue)\n"
                                                 "Menu items will remain disabled until you do this...." %(MD_RRATE_ISSUE_FIXED_BUILD),
                                                 lModal=True, OKButtonText="Acknowledge", lAlertLevel=1).go()
                            else:
                                MyPopUpDialogBox(toolbox_frame_,
                                                 "ALERT: Currency/Security data issues need resolving - some menu items are disabled...",
                                                 "You have some Currency / Security records which have a data issue\n"
                                                 "These need to be fixed before Toolbox can allow some options\n"
                                                 "Please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to address this issue\n"
                                                 "Menu items will remain disabled until you do this....",
                                                 lModal=True, OKButtonText="Acknowledge", lAlertLevel=1).go()

                            lAlertPopupShown = True

                        user_autofix_price_date.setEnabled(False)
                        user_thin_price_history.setEnabled(False)
                        user_fix_invalid_curr_sec.setEnabled(False)
                        user_fix_invalid_price_history.setEnabled(False)

                        # Just disable if errors on Security records....
                        if not check_all_currency_raw_rates_ok(CurrencyType.Type.SECURITY):                             # noqa
                            user_edit_security_decimal_places.setEnabled(False)
                            user_merge_duplicate_securities.setEnabled(False)

                    bg.clearSelection()

                    options = ["EXIT", "PROCEED"]
                    jsp = MyJScrollPaneForJOptionPane(userFilters,1000,500)
                    userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                               jsp,
                                                               "Currency / Security Diagnostics, Tools, Fixes",
                                                               JOptionPane.OK_CANCEL_OPTION,
                                                               JOptionPane.QUESTION_MESSAGE,
                                                               MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                               options, options[0]))
                    if userAction != 1:
                        return

                    selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                    if user_can_i_delete_security.isSelected():
                        x = ViewFileButtonAction("can_I_delete_security()", "CAN I DELETE A SECURITY?", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_can_i_delete_currency.isSelected():
                        x = ViewFileButtonAction("can_I_delete_currency()", "CAN I DELETE A CURRENCY?", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_list_curr_sec_dpc.isSelected():
                        x=ViewFileButtonAction("list_security_currency_decimal_places()", "LIST SECURITY CURRENCY DECIMAL PLACES", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_diag_price_date.isSelected():
                        list_security_currency_price_date()
                        return

                    if user_autofix_price_date.isSelected():
                        list_security_currency_price_date(autofix=True)
                        return

                    if user_diag_curr_sec.isSelected():
                        diagnose_currencies(False)
                        return

                    if user_fix_curr_sec.isSelected():
                        diagnose_currencies(True)
                        return

                    if user_fix_invalid_curr_sec.isSelected():
                        fix_invalid_relative_currency_rates()
                        return

                    if user_edit_security_decimal_places.isSelected():
                        edit_security_decimal_places()
                        return

                    if user_merge_duplicate_securities.isSelected():
                        merge_duplicate_securities()
                        return

                    if user_fix_invalid_price_history.isSelected():
                        fix_invalid_price_history()
                        return

                    if user_fix_nonlinked_security_records.isSelected():
                        detect_fix_nonlinked_investment_security_records()
                        return

                    if user_thin_price_history.isSelected():
                        thin_price_history()
                        return

                    if user_show_open_share_lots.isSelected():
                        show_open_share_lots()
                        return

                    if user_convert_stock_lot_FIFO.isSelected():
                        convert_stock_lot_FIFO()
                        return

                    if user_convert_stock_avg_cst_control.isSelected():
                        convert_stock_avg_cst_control()
                        return

                    if user_force_change_accounts_currency.isSelected():
                        force_change_account_currency()

                    if user_force_change_all_accounts_currency.isSelected():
                        force_change_all_accounts_currencies()

                    if user_fix_price_date.isSelected():
                        manually_edit_price_date_field()

                    continue

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class TransactionMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug
                global lAdvancedMode, lHackerMode, fixRCurrencyCheck

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                user_view_txn_sort = JRadioButton("View Register Transactional Sort Orders", False)
                user_view_txn_sort.setToolTipText("Allows you  to view the current transaction register sort orders in operation")

                user_extract_attachments = JRadioButton("Extract Attachments to Folder", False)
                user_extract_attachments.setToolTipText("Extract all your attachments to a folder of your choosing...")

                user_diagnose_attachments = JRadioButton("DIAG: Diagnose Attachments and detect Orphans too", False)
                user_diagnose_attachments.setToolTipText("This will analise your Attachments, show you the file storage consumed, and detect Orphans/issues")

                syncFolder = None                                                                                       # noqa
                try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
                except: syncFolder = False

                user_diagnose_fix_attachments = JRadioButton("FIX: Diagnose Attachments - DELETE Orphan attachments (** Syncing must be Disabled **)", False)
                user_diagnose_fix_attachments.setToolTipText("This will analise your Attachments, detect Orphans/issues - AND ALLOW YOU TO DELETE THE ORPHAN ATTACHMENTS")
                user_diagnose_fix_attachments.setEnabled(lAdvancedMode and syncFolder is None)
                user_diagnose_fix_attachments.setForeground(getColorRed())

                user_move_invest_txns = JRadioButton("Move/Merge Investment Transactions from one account to another", False)
                user_move_invest_txns.setToolTipText("This allows you to move your investment transactions from one account into (merges with) another")
                user_move_invest_txns.setEnabled(lAdvancedMode)
                user_move_invest_txns.setForeground(getColorRed())

                user_fix_non_hier_sec_acct_txns = JRadioButton("FIX: Non-Hierarchical Security Acct Txns (& detect Orphans) (fix_non-hierarchical_security_account_txns.py)", False)
                user_fix_non_hier_sec_acct_txns.setToolTipText("This reviews your Investment Security Txns and fixes where the Account reference is cross-linked and incorrect (fix_non-hierarchical_security_account_txns.py & fix_investment_txns_to_wrong_security.py)")
                user_fix_non_hier_sec_acct_txns.setEnabled(lAdvancedMode)
                user_fix_non_hier_sec_acct_txns.setForeground(getColorRed())

                user_fix_delete_one_sided_txns = JRadioButton("FIX: Delete One-Sided Transactions (delete_invalid_txns.py)", False)
                user_fix_delete_one_sided_txns.setToolTipText("This allows you to DELETE 'invalid' one-sided transactions - usually from a bad quicken import. THIS CHANGES DATA! (delete_invalid_txns.py)")
                user_fix_delete_one_sided_txns.setEnabled(lAdvancedMode)
                user_fix_delete_one_sided_txns.setForeground(getColorRed())

                user_reverse_txn_amounts = JRadioButton("FIX: Reverse Transaction Amounts (reverse_txn_amounts.py)", False)
                user_reverse_txn_amounts.setToolTipText("This allows you to REVERSE the transaction values/amounts for an account within a date range. THIS CHANGES DATA! (reverse_txn_amounts.py)")
                user_reverse_txn_amounts.setEnabled(lAdvancedMode)
                user_reverse_txn_amounts.setForeground(getColorRed())

                user_reverse_txn_exchange_rates_by_account_and_date = JRadioButton("FIX: Reverse Transaction Exchange Rates (reverse_txn_exchange_rates_by_account_and_date)", False)
                user_reverse_txn_exchange_rates_by_account_and_date.setToolTipText("This allows you to REVERSE the transactional exchange rates for an account within a date range. THIS CHANGES DATA! (reverse_txn_exchange_rates_by_account_and_date)")
                user_reverse_txn_exchange_rates_by_account_and_date.setEnabled(lAdvancedMode)
                user_reverse_txn_exchange_rates_by_account_and_date.setForeground(getColorRed())

                labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced mode **")
                labelFYI2.setForeground(getColorRed())

                userFilters = JPanel(GridLayout(0, 1))

                bg = ButtonGroup()
                bg.add(user_view_txn_sort)
                bg.add(user_extract_attachments)
                bg.add(user_diagnose_attachments)
                bg.add(user_diagnose_fix_attachments)
                bg.add(user_move_invest_txns)
                bg.add(user_fix_non_hier_sec_acct_txns)
                bg.add(user_fix_delete_one_sided_txns)
                bg.add(user_reverse_txn_amounts)
                bg.add(user_reverse_txn_exchange_rates_by_account_and_date)
                bg.clearSelection()

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                userFilters.add(user_view_txn_sort)
                userFilters.add(user_extract_attachments)
                userFilters.add(user_diagnose_attachments)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                if not lAdvancedMode:
                    userFilters.add(labelFYI2)

                # These are new features - better supported from 2021.2 onwards
                if int(MD_REF.getBuild()) >= MD_RRATE_ISSUE_FIXED_BUILD:
                    userFilters.add(user_move_invest_txns)

                userFilters.add(user_diagnose_fix_attachments)
                userFilters.add(user_fix_non_hier_sec_acct_txns)
                userFilters.add(user_fix_delete_one_sided_txns)
                userFilters.add(user_reverse_txn_amounts)
                userFilters.add(user_reverse_txn_exchange_rates_by_account_and_date)

                while True:

                    syncFolder = None                                                                                   # noqa
                    try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
                    except: syncFolder = False
                    user_diagnose_fix_attachments.setEnabled(lAdvancedMode and syncFolder is None)

                    options = ["EXIT", "PROCEED"]
                    jsp = MyJScrollPaneForJOptionPane(userFilters,700,300)
                    userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                               jsp,
                                                               "Transaction(s) Diagnostics, Tools, Fixes",
                                                               JOptionPane.OK_CANCEL_OPTION,
                                                               JOptionPane.QUESTION_MESSAGE,
                                                               MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                               options, options[0]))
                    if userAction != 1:
                        return

                    selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                    if user_view_txn_sort.isSelected():
                        x = ViewFileButtonAction("get_register_txn_sort_orders()", "Register TXN Sort Orders etc", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_extract_attachments.isSelected():
                        extract_attachments()
                        return

                    if user_diagnose_attachments.isSelected():
                        diagnose_attachments()
                        return

                    if user_diagnose_fix_attachments.isSelected():
                        diagnose_attachments(lFix=True)
                        return

                    if user_move_invest_txns.isSelected():
                        move_merge_investment_txns()
                        return

                    if user_fix_non_hier_sec_acct_txns.isSelected():
                        fix_non_hier_sec_acct_txns()
                        return

                    if user_fix_delete_one_sided_txns.isSelected():
                        fix_delete_one_sided_txns()
                        return

                    if user_reverse_txn_amounts.isSelected():
                        reverse_txn_amounts()
                        return

                    if user_reverse_txn_exchange_rates_by_account_and_date.isSelected():
                        reverse_txn_exchange_rates_by_account_and_date()
                        return

                    continue

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class GeneralToolsMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug
                global lAdvancedMode, lHackerMode, fixRCurrencyCheck

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                user_display_passwords = JRadioButton("Display Dataset Password/Hint and Sync Passphrase", False)
                user_display_passwords.setToolTipText("Display the password/hint used to open your Encrypted Dataset, and also your Sync passphrase (if set)")

                user_view_MD_config_file = JRadioButton("View MD Config File", False)
                user_view_MD_config_file.setToolTipText("View the contents of your Moneydance configuration file")

                user_view_searchable_console_log = JRadioButton("View Searchable Console Log", False)
                user_view_searchable_console_log.setToolTipText("View the whole Console log file - searchable")

                user_view_MD_custom_theme_file = JRadioButton("View MD Custom Theme File", False)
                user_view_MD_custom_theme_file.setToolTipText("View the contents of your Moneydance custom Theme file (if you have set one up)")
                user_view_MD_custom_theme_file.setEnabled(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))    # noqa

                grabProgramDir = find_the_program_install_dir()
                user_view_java_vmoptions = JRadioButton("View Java VM Options File", False)
                user_view_java_vmoptions.setToolTipText("View the contents of the Java VM Options runtime file that Moneydance uses")
                user_view_java_vmoptions.setEnabled(grabProgramDir and os.path.exists(os.path.join(grabProgramDir,"Moneydance.vmoptions")))

                user_view_extensions_details = JRadioButton("View Extension(s) details", False)
                user_view_extensions_details.setToolTipText("View details about the Extensions installed in your Moneydance system")

                user_view_memorised_reports = JRadioButton("View Memorised Reports", False)
                user_view_memorised_reports.setToolTipText("View a list of your Memorised reports")

                user_find_sync_password_in_ios_backups = JRadioButton("Find Sync Password in iOS Backups (only on Windows and Mac)", False)
                user_find_sync_password_in_ios_backups.setToolTipText("This search for iOS backup(s) and look for your Sync Encryption password(s)")
                user_find_sync_password_in_ios_backups.setEnabled(Platform.isOSX() or Platform.isWindows())

                user_import_QIF = JRadioButton("'Older' Import QIF file and set parameters", False)
                user_import_QIF.setToolTipText("Runs the 'older' MD importQIFIntoAccount() function and allows you to set parameters (you can select create Account Structure Only) - WILL IMPORT / CHANGE DATA!")

                user_convert_timestamp = JRadioButton("Convert a TimeStamp number into a readable date/time", False)
                user_convert_timestamp.setToolTipText("Allows you to input a TimeStamp (Milliseconds) and it will display a readable date/time")

                user_change_moneydance_fonts = JRadioButton("Set/Change Default Moneydance FONTS", False)
                user_change_moneydance_fonts.setToolTipText("This will allow you to Set/Change the Default Moneydance Fonts. THIS CHANGES DATA!")
                user_change_moneydance_fonts.setEnabled(lAdvancedMode and float(MD_REF.getBuild()) >= 3030)
                user_change_moneydance_fonts.setForeground(getColorRed())

                user_delete_custom_theme_file = JRadioButton("Delete Custom Theme file", False)
                user_delete_custom_theme_file.setToolTipText("Delete your custom Theme file (if it exists). This is pretty safe. MD will create a new one if you select in Preferences. THIS DELETES A FILE!")
                user_delete_custom_theme_file.setEnabled(lAdvancedMode and os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))   # noqa
                user_delete_custom_theme_file.setForeground(getColorRed())

                user_delete_orphan_extensions = JRadioButton("FIX: Delete Orphaned Extensions", False)
                user_delete_orphan_extensions.setToolTipText("This will delete any references to orphaned / outdated Extensions (config.dict & .mxt files). THIS CHANGES DATA!")
                user_delete_orphan_extensions.setEnabled(lAdvancedMode)
                user_delete_orphan_extensions.setForeground(getColorRed())

                user_reset_window_display_settings = JRadioButton("RESET Window Display Settings", False)
                user_reset_window_display_settings.setToolTipText("This tells MD to 'forget' window display settings. CLOSE ALL REGISTER WINDOWS FIRST! The beauty is it keeps all other settings intact! THIS CHANGES DATA!")
                user_reset_window_display_settings.setEnabled(lAdvancedMode)
                user_reset_window_display_settings.setForeground(getColorRed())

                labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced mode **")
                labelFYI2.setForeground(getColorRed())

                userFilters = JPanel(GridLayout(0, 1))

                bg = ButtonGroup()
                bg.add(user_display_passwords)
                bg.add(user_view_MD_config_file)
                bg.add(user_view_searchable_console_log)
                bg.add(user_view_MD_custom_theme_file)
                bg.add(user_view_java_vmoptions)
                bg.add(user_view_extensions_details)
                bg.add(user_view_memorised_reports)
                bg.add(user_find_sync_password_in_ios_backups)
                bg.add(user_import_QIF)
                bg.add(user_convert_timestamp)
                bg.add(user_change_moneydance_fonts)
                bg.add(user_delete_custom_theme_file)
                bg.add(user_delete_orphan_extensions)
                bg.add(user_reset_window_display_settings)
                bg.clearSelection()

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                userFilters.add(user_display_passwords)
                userFilters.add(user_view_searchable_console_log)
                userFilters.add(user_view_MD_config_file)
                userFilters.add(user_view_MD_custom_theme_file)
                userFilters.add(user_view_java_vmoptions)
                userFilters.add(user_view_extensions_details)
                userFilters.add(user_view_memorised_reports)
                userFilters.add(user_find_sync_password_in_ios_backups)
                userFilters.add(user_import_QIF)
                userFilters.add(user_convert_timestamp)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                if not lAdvancedMode:
                    userFilters.add(labelFYI2)

                userFilters.add(user_change_moneydance_fonts)
                userFilters.add(user_delete_custom_theme_file)
                userFilters.add(user_delete_orphan_extensions)
                userFilters.add(user_reset_window_display_settings)

                while True:

                    grabProgramDir = find_the_program_install_dir()
                    user_view_java_vmoptions.setEnabled(grabProgramDir and os.path.exists(os.path.join(grabProgramDir,"Moneydance.vmoptions")))
                    user_view_MD_custom_theme_file.setEnabled(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))                    # noqa
                    user_delete_custom_theme_file.setEnabled(lAdvancedMode and os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))   # noqa
                    bg.clearSelection()

                    options = ["EXIT", "PROCEED"]
                    jsp = MyJScrollPaneForJOptionPane(userFilters,550,450)
                    userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                               jsp,
                                                               "General Diagnostics, Tools, Fixes",
                                                               JOptionPane.OK_CANCEL_OPTION,
                                                               JOptionPane.QUESTION_MESSAGE,
                                                               MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                               options, options[0]))
                    if userAction != 1:
                        return

                    if user_display_passwords.isSelected():
                        display_passwords()

                    if user_view_searchable_console_log.isSelected():
                        x = ViewFileButtonAction(MD_REF.getLogFile(), "MD Console Log")
                        x.actionPerformed(None)
                        return

                    if user_view_MD_config_file.isSelected():
                        x = ViewFileButtonAction(Common.getPreferencesFile(), "MD Config")
                        x.actionPerformed(None)
                        return

                    if user_view_MD_custom_theme_file.isSelected():
                        x = ViewFileButtonAction(ThemeInfo.customThemeFile, "MD Custom Theme")                          # noqa
                        x.actionPerformed(None)
                        return

                    if user_view_java_vmoptions.isSelected():
                        x = ViewFileButtonAction(File(grabProgramDir, "Moneydance.vmoptions"), "Java VM File")
                        x.actionPerformed(None)
                        return

                    if user_view_extensions_details.isSelected():
                        x = ViewFileButtonAction("view_extensions_details()", "Extension(s) details etc", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_view_memorised_reports.isSelected():
                        x = ViewFileButtonAction("get_list_memorised_reports()", "Memorized Reports and Graphs", lFile=False)
                        x.actionPerformed(None)
                        return

                    if user_find_sync_password_in_ios_backups.isSelected():
                        find_IOS_sync_data()
                        return

                    if user_import_QIF.isSelected():
                        import_QIF()

                    if user_convert_timestamp.isSelected():
                        convert_timestamp_readable_date()

                    if user_change_moneydance_fonts.isSelected():
                        change_fonts()

                    if user_delete_custom_theme_file.isSelected():
                        delete_theme_file()

                    if user_delete_orphan_extensions.isSelected():
                        force_remove_extension()
                        return

                    if user_reset_window_display_settings.isSelected():
                        reset_window_positions()
                        return

                    continue

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class HackerMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug
                global lAdvancedMode, lHackerMode, fixRCurrencyCheck

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if not lHackerMode: return

                user_hacker_mode_edit_prefs = JRadioButton("HACK: ADD/CHG/DEL System Settings/Prefs (ie config.dict / LocalStorage() settings", False)
                user_hacker_mode_edit_prefs.setToolTipText("This allows you to HACK (add/change/delete) config.dict and LocalStorage() (./safe/settings) keys..... CAN UPDATE DATA")
                user_hacker_mode_edit_prefs.setForeground(getColorRed())

                user_hacker_edit_param_keys = JRadioButton("HACK: ADD/CHG/DEL Database Object (ie Account, Currency, any object)", False)
                user_hacker_edit_param_keys.setToolTipText("This allows you to HACK (add/change/delete) an Object's Parameter keys..... CAN UPDATE DATA - ONLY USE IF YOU KNOW WHAT YOU ARE DOING")
                user_hacker_edit_param_keys.setForeground(getColorRed())

                user_hacker_delete_int_ext_files = JRadioButton("HACK: DELETE Files from Filelist and DISK", False)
                user_hacker_delete_int_ext_files.setToolTipText("This allows you to delete internal/external filenames from the list of File>Open files settings>> AND ASKS IF YOU WANT TO DELETE THE FILES TOO..... UPDATES CONFIG.DICT/CAN DELETE FILES")
                user_hacker_delete_int_ext_files.setForeground(getColorRed())

                user_hacker_toggle_DEBUG = JRadioButton("HACK: Toggle Moneydance DEBUG", False)
                user_hacker_toggle_DEBUG.setToolTipText("This will toggle Moneydance's internal DEBUG setting(s) ON/OFF.....")
                user_hacker_toggle_DEBUG.setForeground(getColorRed())

                user_hacker_toggle_other_DEBUGs = JRadioButton("HACK: Toggle Other Moneydance DEBUGs", False)
                user_hacker_toggle_other_DEBUGs.setToolTipText("This will allow you to toggle other known Moneydance internal DEBUG setting(s) ON/OFF..... (these add extra messages to Console output))")
                user_hacker_toggle_other_DEBUGs.setForeground(getColorRed())

                user_hacker_extract_from_storage = JRadioButton("HACK: Extract a File from LocalStorage", False)
                user_hacker_extract_from_storage.setToolTipText("This allows you to select & extract (decrypt) a file from inside LocalStorage (copied to TMP dir)..... FILE SELF DESTRUCTS AFTER RESTART")
                user_hacker_extract_from_storage.setForeground(getColorRed())

                user_hacker_extract_from_sync = JRadioButton("HACK: Peek at an encrypted file located in your Sync Folder...", False)
                user_hacker_extract_from_sync.setToolTipText("This allows you to select, extract (decrypt) and then peek at a file inside your Sync folder")
                user_hacker_extract_from_sync.setForeground(getColorRed())

                user_hacker_shrink_dataset = JRadioButton("HACK: Shrink Dataset size", False)
                user_hacker_shrink_dataset.setToolTipText("This function deletes MD's log files of all prior changes (not needed).. Typically these are .txn, .mdtxn files...")
                user_hacker_shrink_dataset.setForeground(getColorRed())

                user_hacker_import_to_storage = JRadioButton("HACK: Import a File back into LocalStorage", False)
                user_hacker_import_to_storage.setToolTipText("This allows you to select & import (encrypt) a file back into LocalStorage/safe/tmp dir.....")
                user_hacker_import_to_storage.setForeground(getColorRed())

                user_hacker_save_trunk = JRadioButton("HACK: Save Trunk File", False)
                user_hacker_save_trunk.setToolTipText("This allows you to call the Save Trunk File function)..... Immediately flushes all in memory changes to disk, including your dataset (rather than wait for restart). UPDATES YOUR DATASET")
                user_hacker_save_trunk.setForeground(getColorRed())

                user_hacker_sync_push = JRadioButton("HACK: Force a refresh/PUSH of your local dataset to Sync. USE WITH EXTREME CARE!", False)
                user_hacker_sync_push.setToolTipText("Push new Sync data (and rebuild remote copies). Use with extreme care! UPDATES YOUR DATASET")
                user_hacker_sync_push.setForeground(getColorRed())

                user_force_sync_off = JRadioButton("Force DISABLE/turn Sync OFF", False)
                user_force_sync_off.setToolTipText("This sets your Sync method to None - all other settings are preserved. You can turn it back on again later - UPDATES YOUR DATASET")
                user_force_sync_off.setForeground(getColorRed())

                user_force_reset_sync_settings = JRadioButton("Force RESET Sync settings (generates new SyncID and turns Sync off. You can turn it back on after MD restart)", False)
                user_force_reset_sync_settings.setToolTipText("This resets all Sync settings, changes your Sync ID, and turns Sync off. You can then re-enable it for a fresh Sync - You can turn it back on again later - UPDATES YOUR DATASET")
                user_force_reset_sync_settings.setForeground(getColorRed())

                user_restore_archive_retain_sync_settings = JRadioButton("Restore an archive file, and RETAIN Sync settings (USE WITH CARE, CAN CHANGE SYNC DATA)", False)
                user_restore_archive_retain_sync_settings.setToolTipText("Restores a .moneydancearchive file, RETAINS Sync settings (but turns Sync off - you can then manually turn it back on again")
                user_restore_archive_retain_sync_settings.setForeground(getColorRed())

                user_demote_primary_to_secondary = JRadioButton("HACK: DEMOTE Primary dataset back to a Secondary Node", False)
                user_demote_primary_to_secondary.setToolTipText("DEMOTE your Primary Sync Node/Dataset to a Secondary Node)..... UPDATES YOUR DATASET")
                user_demote_primary_to_secondary.setEnabled(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
                user_demote_primary_to_secondary.setForeground(getColorRed())

                lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
                user_hacker_suppress_dropbox_warning = JRadioButton("HACK: Suppress File in Dropbox Warning", False)
                user_hacker_suppress_dropbox_warning.setToolTipText("This allows you to suppress the 'Your file seems to be in a shared folder (Dropbox)' warning")
                user_hacker_suppress_dropbox_warning.setEnabled(lDropbox and not lSuppressed)
                user_hacker_suppress_dropbox_warning.setForeground(getColorRed())

                userFilters = JPanel(GridLayout(0, 1))

                bg = ButtonGroup()
                bg.add(user_hacker_toggle_DEBUG)
                bg.add(user_hacker_toggle_other_DEBUGs)
                bg.add(user_hacker_extract_from_storage)
                bg.add(user_hacker_extract_from_sync)
                bg.add(user_hacker_shrink_dataset)
                bg.add(user_hacker_import_to_storage)
                bg.add(user_hacker_mode_edit_prefs)
                bg.add(user_hacker_edit_param_keys)
                bg.add(user_hacker_delete_int_ext_files)
                bg.add(user_hacker_save_trunk)
                bg.add(user_hacker_sync_push)
                bg.add(user_force_sync_off)
                bg.add(user_force_reset_sync_settings)
                bg.add(user_restore_archive_retain_sync_settings)
                bg.add(user_demote_primary_to_secondary)
                bg.add(user_hacker_suppress_dropbox_warning)
                bg.clearSelection()

                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("--- READONLY / NON-UPDATE FUNCTIONS ---"))
                userFilters.add(user_hacker_toggle_DEBUG)
                userFilters.add(user_hacker_toggle_other_DEBUGs)
                userFilters.add(user_hacker_extract_from_storage)
                userFilters.add(user_hacker_extract_from_sync)
                userFilters.add(JLabel(" "))
                userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))
                userFilters.add(user_hacker_shrink_dataset)
                userFilters.add(user_hacker_import_to_storage)
                userFilters.add(user_hacker_mode_edit_prefs)
                userFilters.add(user_hacker_edit_param_keys)
                userFilters.add(user_hacker_delete_int_ext_files)
                userFilters.add(user_hacker_save_trunk)
                userFilters.add(user_force_sync_off)
                userFilters.add(user_force_reset_sync_settings)
                userFilters.add(user_restore_archive_retain_sync_settings)
                userFilters.add(user_demote_primary_to_secondary)
                userFilters.add(user_hacker_sync_push)
                userFilters.add(user_hacker_suppress_dropbox_warning)

                _NONE = "none"
                _PARAM_KEY = "netsync.sync_type"
                storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

                while True:

                    lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
                    user_hacker_suppress_dropbox_warning.setEnabled(lDropbox and not lSuppressed)
                    user_demote_primary_to_secondary.setEnabled(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
                    user_hacker_sync_push.setEnabled(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
                    user_force_sync_off.setEnabled(not (storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE))
                    user_hacker_extract_from_sync.setEnabled(MD_REF.getUI().getCurrentAccounts().getSyncFolder() is not None)

                    bg.clearSelection()

                    options = ["EXIT", "PROCEED"]
                    jsp = MyJScrollPaneForJOptionPane(userFilters,850,550)
                    userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                               jsp,
                                                               "HACKER - Diagnostics, Tools, Fixes",
                                                               JOptionPane.OK_CANCEL_OPTION,
                                                               JOptionPane.QUESTION_MESSAGE,
                                                               MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png"),
                                                               options, options[0]))
                    if userAction != 1:
                        return

                    selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                    if user_hacker_toggle_DEBUG.isSelected():
                        hacker_mode_DEBUG()

                    if user_hacker_toggle_other_DEBUGs.isSelected():
                        hacker_mode_other_DEBUG()

                    if user_hacker_extract_from_storage.isSelected():
                        hacker_mode_decrypt_file()

                    if user_hacker_extract_from_sync.isSelected():
                        hacker_mode_decrypt_file_from_sync()
                        return

                    if user_hacker_shrink_dataset.isSelected():
                        hacker_mode_shrink_dataset()
                        return

                    if user_hacker_import_to_storage.isSelected():
                        hacker_mode_encrypt_file()

                    if user_hacker_mode_edit_prefs.isSelected():
                        hacker_mode()
                        return

                    if user_hacker_edit_param_keys.isSelected():
                        hacker_mode_edit_parameter_keys()
                        return

                    if user_hacker_delete_int_ext_files.isSelected():
                        hacker_remove_int_external_files_settings()
                        return

                    if user_hacker_save_trunk.isSelected():
                        hacker_mode_save_trunk_file()

                    if user_hacker_sync_push.isSelected():
                        hacker_mode_sync_push_pull("PUSH")

                    if user_force_sync_off.isSelected():
                        hackermode_force_sync_off()

                    if user_force_reset_sync_settings.isSelected():
                        hackermode_force_reset_sync_settings()

                    if user_restore_archive_retain_sync_settings.isSelected():
                        restore_archive_retain_sync_settings()

                    if user_demote_primary_to_secondary.isSelected():
                        hacker_mode_demote_primary_to_secondary()

                    if user_hacker_suppress_dropbox_warning.isSelected():
                        hacker_mode_suppress_dropbox_warning()

                    continue

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class ConvertSecondaryButtonAction(AbstractAction):

            def __init__(self, theString):
                self.theString = theString

            def actionPerformed(self, event):
                global toolbox_frame_, debug

                # convert_secondary_to_primary_data_set

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
                    txt = "Your dataset is already Master - NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if myPopupAskQuestion(toolbox_frame_,
                                      "MAKE this SECONDARY a PRIMARY/MASTER NODE",
                                      "Are you sure you want to make this secondary dataset the Primary?",
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.ERROR_MESSAGE):

                    disclaimer = myPopupAskForInput(toolbox_frame_,
                                                    "MAKE this SECONDARY a PRIMARY/MASTER NODE",
                                                    "DISCLAIMER:",
                                                    "Are you really sure you want to change this secondary into the Primary? Type 'IAGREE' to continue..",
                                                    "NO",
                                                    False,
                                                    JOptionPane.ERROR_MESSAGE)

                    if disclaimer == 'IAGREE':

                        if not backup_local_storage_settings():
                            txt = "MAKE ME PRIMARY: ERROR making backup of LocalStorage() ./safe/settings - NO CHANGES MADE!"
                            setDisplayStatus(txt, "R")
                            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                            return

                        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(True)
                        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()        # Flush local storage to safe/settings

                        play_the_money_sound()
                        txt = "Dataset Promoted to Primary/Master Node/Dataset - MONEYDANCE WILL NOW EXIT - PLEASE RELAUNCH MD"
                        setDisplayStatus(txt, "R")
                        myPrint("B", txt)
                        myPopupInformationBox(toolbox_frame_, txt, "PRIMARY DATASET", JOptionPane.WARNING_MESSAGE)
                        MD_REF.getUI().exit()

                txt = "User did not say yes to Master Node promotion - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class AnalyseDatasetSizeButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                global toolbox_frame_, debug

                # show_object_type_quantities.py

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                output = "DATASET FILE ANALYSIS\n" \
                         " ====================\n\n"

                startDir=MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()
                output += "Dataset path: %s\n\n" %(startDir)

                attach = MD_REF.getCurrentAccountBook().getAttachmentsFolder()
                keyDir = startDir
                trunkDir = os.path.join(startDir,"safe","tiksync")
                attachDir = os.path.join(startDir,"safe", attach)
                settingsDir = os.path.join(startDir,"safe")
                archiveDir = os.path.join(startDir,"safe","archive")
                sync_outDir = os.path.join(startDir,"safe","tiksync", "out")

                sync_outCount = 0
                sync_outSize = 0

                safe_settingsSize = 0
                safe_attachmentsSize = 0
                countAttachments = 0
                safe_archiveSize = 0
                countArchiveFiles = 0
                safe_trunkSize = 0
                safe_tiksyncSize = 0
                countTIKfiles = 0
                # safe_tmpSize = 0
                keySize = 0
                countValidFiles=0
                countNonValidFiles=0
                validSize=0
                nonValidSize=0
                listNonValidFiles=[]
                listLargeFiles=[]

                total_size = 0
                start_path = startDir  # To get size of current directory
                for path, dirs, files in os.walk(start_path):
                    for f in files:
                        lValidFile = False

                        fp = os.path.join(path, f)
                        thisFileSize = os.path.getsize(fp)

                        total_size += thisFileSize

                        if os.path.basename(f) == "key" and path==keyDir and len:
                            lValidFile = True
                            keySize=thisFileSize
                        if os.path.basename(f) == "settings" and path==settingsDir:
                            lValidFile = True
                            safe_settingsSize=thisFileSize
                        if os.path.basename(f) == "trunk" and path==trunkDir:
                            lValidFile = True
                            safe_trunkSize=thisFileSize
                        if path[:len(sync_outDir)] == sync_outDir and (f.endswith(".txn") ):
                            lValidFile = True
                            sync_outSize+=thisFileSize
                            sync_outCount+=1
                        if path[:len(trunkDir)] == trunkDir and (f.endswith("trunk") or f.endswith(".mdtxn") or f.endswith("processed.dct") or f.endswith("delete_to_push_sync_info") or f.endswith(".txn") or f.endswith("force_push_resync") ):
                            lValidFile = True
                            safe_tiksyncSize+=thisFileSize
                            countTIKfiles+=1
                        if path[:len(attachDir)] == attachDir:
                            lValidFile = True
                            safe_attachmentsSize+=thisFileSize
                            countAttachments+=1
                        if path[:len(archiveDir)] == archiveDir and f.endswith(".mdtxnarchive"):
                            lValidFile = True
                            safe_archiveSize+=thisFileSize
                            countArchiveFiles+=1

                        if lValidFile:
                            countValidFiles+=1
                            validSize+=thisFileSize
                            if thisFileSize>500000:
                                listLargeFiles.append([fp,
                                                       thisFileSize,
                                                       pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime('%Y-%m-%d %H:%M:%S'),11)])
                        else:
                            countNonValidFiles+=1
                            nonValidSize+=thisFileSize
                            listNonValidFiles.append([fp,
                                                      thisFileSize,
                                                      pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime('%Y-%m-%d %H:%M:%S'),11)])

                output+=("Dataset size:               %sMB\n" %(rpad(convertBytesMBs(total_size),12)))
                output+=("- settings file size:       %sKB\n" %(rpad(convertBytesKBs(safe_settingsSize),12)))
                output+=("- key file size:            %sKB\n" %(rpad(convertBytesKBs(keySize),12)))
                output+=("- tiksync folder size:      %sMB (with %s files)\n" %(rpad(convertBytesMBs(safe_tiksyncSize),12),countTIKfiles))
                output+=("  (note trunk file size:    %sMB)\n" %(rpad(convertBytesMBs(safe_trunkSize),12)))

                if sync_outCount:
                    output+=("  (WAITING Sync 'Out' size: %sMB with %s files)\n" %(rpad(convertBytesMBs(sync_outSize),12),sync_outCount))

                output+=("- attachments size:         %sMB (in %s attachments)\n" %(rpad(convertBytesMBs(safe_attachmentsSize),12),countAttachments))
                output+=("- archive size:             %sMB (in %s files)\n" %(rpad(convertBytesMBs(safe_archiveSize),12),countArchiveFiles))
                output+=("---------------------------------------------\n")
                output+=("Valid files size:           %sMB (in %s files)\n\n" %(rpad(convertBytesMBs(validSize),12),countValidFiles))
                output+=("Non-core file(s) size:      %sMB (in %s files)\n" %(rpad(convertBytesMBs(nonValidSize),12),countNonValidFiles))
                for nonValid in listNonValidFiles:
                    output+=("   - Non-core: %sMB %s\n" %(rpad(convertBytesMBs(nonValid[1]),5),nonValid[0]))
                output+="\n\n"

                if len(listLargeFiles):
                    output+=("\nLARGE (core) file(s) > 0.5MB....:\n")
                    for largefile in listLargeFiles:
                        output+=("   - %sMB Mod: %s %s\n" %(rpad(convertBytesMBs(largefile[1]),5),largefile[2], largefile[0]))
                output+="\n\n"

                output+=(count_database_objects())

                output+=(find_other_datasets())

                output+="<END>"

                QuickJFrame("VIEW DATASET FILE ANALYSIS", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

                txt = ("Your dataset contains %s files and is %sMB. %s non-core files were found consuming %sMB"
                       %(countValidFiles,convertBytesMBs(validSize),countNonValidFiles,convertBytesMBs(nonValidSize)))
                setDisplayStatus(txt, "B")

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class DoTheMenu(AbstractAction):

            def __init__(self, displayPanel, menu, callingClass=None):
                self.displayPanel = displayPanel
                self.menu = menu
                self.callingClass = callingClass

            def actionPerformed(self, event):
                global toolbox_frame_, debug, lCopyAllToClipBoard_TB, lGeekOutModeEnabled_TB, lHackerMode, lAdvancedMode
                global lAutoPruneInternalBackups_TB

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                # ##########################################################################################################
                if event.getActionCommand() == "Page Setup":
                    pageSetup()

                # ##########################################################################################################
                if event.getActionCommand() == "Help":
                    viewHelp = ViewFileButtonAction("display_help()", "HELP DOCUMENTATION", lFile=False)
                    viewHelp.actionPerformed(None)

                # ##########################################################################################################
                if event.getActionCommand() == "About Toolbox":
                    AboutThisScript(toolbox_frame_).go()

                # ##########################################################################################################
                if event.getActionCommand() == "About Moneydance":
                    MD_REF.getUI().showAbout()

                # ##########################################################################################################
                if event.getActionCommand() == "Auto Prune Internal Backups":

                    if not lAutoPruneInternalBackups_TB:
                        if not myPopupAskQuestion(toolbox_frame_,
                                                  "AUTO PRUNE INTERNAL BACKUPS",
                                                  "Turn on Auto-Prune of internal backups of config.dict & settings (will always keep 5 days and/or 5 copies)?",
                                                  JOptionPane.YES_NO_OPTION,
                                                  JOptionPane.WARNING_MESSAGE):
                            txt = "AUTO-PRUNE INTERNAL BACKUPS DISABLED AS USER DECLINED TO PROCEED"
                            setDisplayStatus(txt, "R")

                            for i in range(0, self.menu.getItemCount()):
                                x = self.menu.getItem(i)
                                if x.getText() == "Auto Prune Internal Backups":
                                    x.setSelected(False)
                                    break

                            return
                        else:
                            myPrint("B", "@@ User asked to turn ON auto-prune of internal backups of config.dict and settings (5 days/5 copies).....")
                    else:
                        myPrint("B", "User asked to turn OFF the auto-prune of internal backups of config.dict and settings.....")

                    lAutoPruneInternalBackups_TB = not lAutoPruneInternalBackups_TB

                    if lAutoPruneInternalBackups_TB:
                        prune_internal_backups()

                # ##########################################################################################################
                if event.getActionCommand() == "Geek Out Mode":
                    lGeekOutModeEnabled_TB = not lGeekOutModeEnabled_TB
                    components = self.displayPanel.getComponents()
                    for theComponent in components:
                        if isinstance(theComponent, JButton):
                            # noinspection PyUnresolvedReferences
                            buttonText = theComponent.getLabel().strip().upper()

                            if ("GEEK" in buttonText):
                                theComponent.setVisible(not theComponent.isVisible())

                # ##########################################################################################################
                if event.getActionCommand() == "Debug":
                    if debug:
                        txt = "Script Debug mode disabled"
                        setDisplayStatus(txt, "DG")
                    else:
                        txt = "Script Debug mode enabled..."
                        setDisplayStatus(txt, "DG")
                        myPrint("B", txt)

                    debug = not debug

                # ##########################################################################################################
                if event.getActionCommand() == "Copy all Output to Clipboard":
                    if lCopyAllToClipBoard_TB:
                        txt = "Diagnostic outputs will NOT be copied to Clipboard"
                        setDisplayStatus(txt, "DG")
                    else:
                        txt = "Diagnostic outputs WILL now all be copied to the Clipboard"
                        setDisplayStatus(txt, "DG")
                        myPrint("B", txt)

                    lCopyAllToClipBoard_TB = not lCopyAllToClipBoard_TB

                # ##########################################################################################################
                if event.getActionCommand() == "Hacker Mode":

                    if not lHackerMode:
                        if not myPopupAskQuestion(toolbox_frame_,
                                              "HACKER MODE",
                                              "HACKER MODE >> DISCLAIMER: DO YOU ACCEPT THAT YOU USE THIS TOOLBOX AT YOUR OWN RISK?",
                                                  JOptionPane.YES_NO_OPTION,
                                                  JOptionPane.ERROR_MESSAGE):
                            txt = "HACKER MODE DISABLED AS USER DECLINED DISCLAIMER"
                            setDisplayStatus(txt, "R")
                            myPrint("B", txt)

                            for i in range(0, self.menu.getItemCount()):
                                x = self.menu.getItem(i)
                                if x.getText() == "Hacker Mode":
                                    x.setSelected(False)
                                    break
                            return
                        else:
                            myPrint("B", "User accepted Disclaimer and agreed to use Toolbox Hacker mode at own risk.....")

                            backup = BackupButtonAction("Would you like to create a backup before starting Hacker mode?")
                            backup.actionPerformed(None)

                            if not backup_local_storage_settings() or not backup_config_dict():
                                txt = "HACKER MODE DISABLED: SORRY - ERROR WHEN SAVING LocalStorage() ./safe/settings and config.dict to backup file!!??"
                                setDisplayStatus(txt, "R")
                                for i in range(0, self.menu.getItemCount()):
                                    x = self.menu.getItem(i)
                                    if x.getText() == "Hacker Mode":
                                        x.setSelected(False)
                                        break
                                return

                            myPrint("B","@@ HACKER MODE ENABLED. config.dict and safe/settings have been backed up...! @@")

                            txt = "HACKER MODE SELECTED - ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING - THIS CAN CHANGE DATA!"
                            setDisplayStatus(txt, "R")
                    else:
                        txt = "HACKER MODE DISABLED <PHEW!>"
                        setDisplayStatus(txt, "B")
                        myPrint("B",txt)

                    lHackerMode = not lHackerMode

                    components = self.displayPanel.getComponents()
                    for theComponent in components:
                        if isinstance(theComponent, JButton):
                            # noinspection PyUnresolvedReferences
                            buttonText = theComponent.getLabel().strip().upper()

                            if ("HACKER" in buttonText):
                                theComponent.setVisible(lHackerMode)

                # ##########################################################################################################
                if event.getActionCommand() == "Advanced Mode":
                    if myPopupAskQuestion(toolbox_frame_,
                                          "ADVANCED MODE",
                                          "ADVANCED MODE >> DISCLAIMER: DO YOU ACCEPT THAT YOU USE THIS TOOLBOX AT YOUR OWN RISK?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.ERROR_MESSAGE):

                        myPrint("B", "User accepted Disclaimer and agreed to use Toolbox Advanced mode at own risk.....")

                        backup = BackupButtonAction("Would you like to create a backup before starting Advanced mode?")
                        backup.actionPerformed(None)

                        txt = "ADVANCED MODE SELECTED - RED BUTTONS CAN CHANGE YOUR DATA - %s+I for Help" %(MD_REF.getUI().ACCELERATOR_MASK_STR)
                        setDisplayStatus(txt, "R")

                        lAdvancedMode = True

                        for i in range(0, self.menu.getItemCount()):
                            x = self.menu.getItem(i)
                            if x.getText() == "Advanced Mode":
                                x.setEnabled(False)
                            else:
                                x.setEnabled(True)

                        components = self.displayPanel.getComponents()
                        for theComponent in components:
                            if isinstance(theComponent, JButton):
                                # noinspection PyUnresolvedReferences
                                buttonText = theComponent.getLabel().strip().upper()

                                if  "HACKER" in buttonText:
                                    pass
                                elif("FIX" in buttonText
                                      or "FONTS" in buttonText
                                      or "RESET" in buttonText
                                      or "DELETE" in buttonText
                                      or "FORGET" in buttonText):
                                    theComponent.setVisible(True)

                                if "MENU:".upper() in buttonText.upper():
                                    theComponent.setForeground(getColorRed())

                    else:
                        txt = "ADVANCED MODE DISABLED AS USER DECLINED DISCLAIMER - BASIC MODE ONLY"
                        setDisplayStatus(txt, "R")
                        myPrint("B", txt)

                # ##########################################################################################################
                if event.getActionCommand() == "Basic Mode":
                    txt = "BASIC MODE SELECTED"
                    setDisplayStatus(txt, "DG")

                    lAdvancedMode = False

                    for i in range(0, self.menu.getItemCount()):
                        x = self.menu.getItem(i)
                        if x.getText() == "Basic Mode":
                            x.setEnabled(False)
                        else:
                            x.setEnabled(True)

                    components = self.displayPanel.getComponents()
                    for theComponent in components:
                        if isinstance(theComponent, JButton):
                            # noinspection PyUnresolvedReferences
                            buttonText = theComponent.getLabel().strip().upper()

                            if "DIAG" in buttonText:
                                pass
                            elif "HACKER" in buttonText:
                                pass
                            elif ("FIX" in buttonText
                                  or "FONTS" in buttonText
                                  or "RESET" in buttonText
                                  or "DELETE" in buttonText
                                  or "FORGET" in buttonText):
                                theComponent.setVisible(False)

                            if "MENU:".upper() in buttonText.upper():
                                theComponent.setForeground(Color(74,74,74))

                # Save parameters now...
                if (event.getActionCommand() == "Copy all Output to Clipboard"
                        or event.getActionCommand() == "Debug"
                        or event.getActionCommand() == "Geek Out Mode"
                        or event.getActionCommand() == "Auto Prune Internal Backups"):

                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()


                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        def openDisplay(self):
            global toolbox_frame_, lPickle_version_warning, lCopyAllToClipBoard_TB, myParameters, lIgnoreOutdatedExtensions_TB, version_build
            global lAdvancedMode, lHackerMode, lAutoPruneInternalBackups_TB, MYPYTHON_DOWNLOAD_URL

            # ConsoleWindow.showConsoleWindow(MD_REF.getUI())
            hacker_mode_DEBUG(lForceON=True)

            screenSize = Toolkit.getDefaultToolkit().getScreenSize()

            button_width = 230
            button_height = 40

            frame_width = min(screenSize.width-20, max(1024,int(round(MD_REF.getUI().firstMainFrame.getSize().width *.95,0))))
            frame_height = min(screenSize.height-20, max(768, int(round(MD_REF.getUI().firstMainFrame.getSize().height *.95,0))))

            # JFrame.setDefaultLookAndFeelDecorated(True)   # Note: Darcula Theme doesn't like this and seems to be OK without this statement...
            toolbox_frame_ = MyJFrame(u"Toolbox - Infinite Kind (co-authored by StuWareSoftSystems)... (%s+I for Help) - DATASET: %s" % (MD_REF.getUI().ACCELERATOR_MASK_STR, MD_REF.getCurrentAccountBook().getName().strip()))
            toolbox_frame_.setName(u"%s_main" %myModuleID)

            if (not Platform.isOSX()):
                MD_REF.getUI().getImages()
                toolbox_frame_.setIconImage(MDImages.getImage(MD_REF.getUI().getMain().getSourceInformation().getIconResource()))

            toolbox_frame_.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)  # The CloseAction() and WindowListener() will handle dispose() - else change back to DISPOSE_ON_CLOSE

            displayString = buildDiagText()

            GlobalVars.STATUS_LABEL = JLabel(("Infinite Kind (Moneydance) support tool >> DIAG STATUS: BASIC MODE RUNNING... - %s+I for Help (check out the Toolbox menu for more options/modes/features)"%MD_REF.getUI().ACCELERATOR_MASK_STR).ljust(800, " "), JLabel.LEFT)
            # GlobalVars.STATUS_LABEL.setBorder(BorderFactory.createLineBorder((MD_REF.getUI().getColors()).headerBorder, 2))
            GlobalVars.STATUS_LABEL.setForeground(GlobalVars.DARK_GREEN)

            try:
                if lCopyAllToClipBoard_TB:
                    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(displayString), None)
            except:
                myPrint("J","Error copying diagnostic's main screen contents to Clipboard")
                dump_sys_error_to_md_console_and_errorlog()

            shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, (shortcut | Event.SHIFT_MASK)), "unlock-window")   # So Plus on Mac...
            toolbox_frame_.getRootPane().getActionMap().put("unlock-window", self.UnlockAction(toolbox_frame_))

            # Add standard CMD-W keystrokes etc to close window
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F,  shortcut), "search-window")
            toolbox_frame_.getRootPane().getActionMap().put("close-window", self.CloseAction(toolbox_frame_))
            toolbox_frame_.addWindowListener(self.WindowListener(toolbox_frame_))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, shortcut), "display-pickle")
            toolbox_frame_.getRootPane().getActionMap().put("display-pickle", ViewFileButtonAction("display_pickle()", "StuWareSoftSystems Pickle Parameter File", lFile=False))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_I, shortcut), "display-help")
            toolbox_frame_.getRootPane().getActionMap().put("display-help", ViewFileButtonAction("display_help()", "HELP DOCUMENTATION", lFile=False))

            toolbox_frame_.setPreferredSize(Dimension(frame_width, frame_height))

            # if MD_REF.getUI().firstMainFrame.getExtendedState() != JFrame.ICONIFIED:
            #     toolbox_frame_.setExtendedState(MD_REF.getUI().firstMainFrame.getExtendedState())
            # else:
            #     toolbox_frame_.setExtendedState(JFrame.MAXIMIZED_BOTH)
            #
            toolbox_frame_.setExtendedState(JFrame.NORMAL)

            displayPanel = JPanel()
            displayPanel.setLayout(FlowLayout(FlowLayout.LEFT))

            # displayPanel.setPreferredSize(Dimension(frame_width - 30, 180))
            displayPanel.setPreferredSize(Dimension(0, 180))

            if lAutoPruneInternalBackups_TB:
                prune_internal_backups(lStartup=True)
            else:
                myPrint("J","Auto-prune of internal backups of config.dict, custom_theme.properties, ./safe/settings files is disabled... so no action")

            # START OF BUTTONS
            backup_button = JButton("<html><center><B>EXPORT BACKUP</B></center></html>")
            backup_button.setToolTipText("This will allow you to take a backup of your Moneydance Dataset")
            backup_button.setBackground(GlobalVars.DARK_GREEN)
            backup_button.setForeground(Color.WHITE)
            backup_button.addActionListener(BackupButtonAction("Confirm you want to create a backup (same as MD Menu>File>Export Backup)?"))
            displayPanel.add(backup_button)

            # These are instant fix buttons
            if (not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()):
                convertSecondary_button = JButton("<html><center><B>FIX: Make me a<BR>Primary dataset</B></center></html>")
                convertSecondary_button.setToolTipText("Promotes this Dataset a Primary / Master Dataset. Enables Sync options. (typically after restore from a synchronised secondary dataset/backup). THIS CHANGES DATA!")
                convertSecondary_button.setBackground(Color.ORANGE)
                convertSecondary_button.setForeground(Color.WHITE)
                convertSecondary_button.addActionListener(self.ConvertSecondaryButtonAction(displayString))
                convertSecondary_button.setVisible(False)
                displayPanel.add(convertSecondary_button)

            if (not check_for_dropbox_folder()):
                createMoneydanceSyncFolder_button = JButton("<html><center><B>FIX: Create Dropbox<BR>Sync Folder</B></center></html>")
                createMoneydanceSyncFolder_button.setToolTipText("This will allow you to add the missing .moneydancesync folder in Dropbox. THIS CREATES A FOLDER!")
                createMoneydanceSyncFolder_button.setBackground(Color.ORANGE)
                createMoneydanceSyncFolder_button.setForeground(Color.WHITE)
                createMoneydanceSyncFolder_button.addActionListener(self.MakeDropBoxSyncFolder(createMoneydanceSyncFolder_button))
                createMoneydanceSyncFolder_button.setVisible(False)
                displayPanel.add(createMoneydanceSyncFolder_button)

            lTabbingModeNeedsChanging = False
            if (Platform.isOSX() and Platform.isOSXVersionAtLeast("10.16")
                    and int(MD_REF.getBuild()) < 3065
                    and not DetectAndChangeMacTabbingMode(True).actionPerformed("quick check")):
                lTabbingModeNeedsChanging = True
                fixTabbingMode_button = JButton("<html><center><B>FIX: MacOS<BR>Tabbing Mode</B></center></html>")
                fixTabbingMode_button.setToolTipText("This allows you to check/fix your MacOS Tabbing Setting")
                fixTabbingMode_button.setBackground(Color.ORANGE)
                fixTabbingMode_button.setForeground(Color.WHITE)
                fixTabbingMode_button.addActionListener(DetectAndChangeMacTabbingMode(False))
                fixTabbingMode_button.setVisible(False)
                displayPanel.add(fixTabbingMode_button)

            if MD_REF.getCurrentAccount().getBook().getLocalStorage().getStr("migrated.netsync.dropbox.fileid", None):
                FixDropboxOneWaySync_button = JButton("<html><center><B>FIX: Remove Legacy Dropbox<BR>Migrated Sync Key</B></center></html>")
                FixDropboxOneWaySync_button.setToolTipText("This removes the key 'migrated.netsync.dropbox.fileid' to fix Dropbox One-way & iCloud Syncing issues (reset_sync_and_dropbox_settings.py)")
                FixDropboxOneWaySync_button.setBackground(Color.ORANGE)
                FixDropboxOneWaySync_button.setForeground(Color.WHITE)
                FixDropboxOneWaySync_button.addActionListener(self.FixDropboxOneWaySyncButtonAction(FixDropboxOneWaySync_button))
                FixDropboxOneWaySync_button.setVisible(False)
                displayPanel.add(FixDropboxOneWaySync_button)

            # end of instant fix buttons

            analiseDatasetSize_button = JButton("<html><center>Analyse Dataset<BR>Objs, Size & Files</center></html>")
            analiseDatasetSize_button.setToolTipText("This quickly analyse the contents of your dataset and show you your Object counts, file sizes, what's taking space, and non-valid files...(show_object_type_quantities.py)")
            analiseDatasetSize_button.addActionListener(self.AnalyseDatasetSizeButtonAction())
            displayPanel.add(analiseDatasetSize_button)

            findDataset_button = JButton("<html><center>Find My Dataset(s)<BR>and Backups</center></html>")
            findDataset_button.setToolTipText("This will search your hard disk for copies of your Moneydance Dataset(s) - incl Backups.... NOTE: Can be CPU & time intensive..!")
            findDataset_button.addActionListener(self.FindDatasetButtonAction())
            displayPanel.add(findDataset_button)

            generalToolsMenu_button = JButton("<html><center>MENU: General<BR>tools</center></html>")
            generalToolsMenu_button.setToolTipText("Menu containing a variety of general Diagnostics, Fixes and Tools...")
            generalToolsMenu_button.addActionListener(self.GeneralToolsMenuButtonAction())
            displayPanel.add(generalToolsMenu_button)

            onlineBankingTools_button = JButton("<html><center>MENU: Online Banking<BR>(OFX) Tools</center></html>")
            onlineBankingTools_button.setToolTipText("A selection of tools for Online Banking - SOME OPTIONS CAN CHANGE DATA!")
            onlineBankingTools_button.addActionListener(self.OnlineBankingToolsButtonAction())
            displayPanel.add(onlineBankingTools_button)

            currencySecurityMenu_button = JButton("<html><center>MENU: Currency<BR>& Security tools</center></html>")
            currencySecurityMenu_button.setToolTipText("Menu containing Currency/Security Diagnostics, Fixes and Tools...")
            currencySecurityMenu_button.addActionListener(self.CurrencySecurityMenuButtonAction())
            displayPanel.add(currencySecurityMenu_button)

            accountsCategoryMenu_button = JButton("<html><center>MENU: Accounts<BR>& Categories tools</center></html>")
            accountsCategoryMenu_button.setToolTipText("Menu containing Account and Category Diagnostics, Fixes and Tools...")
            accountsCategoryMenu_button.addActionListener(self.AccountsCategoriesMenuButtonAction())
            displayPanel.add(accountsCategoryMenu_button)

            transactionMenu_button = JButton("<html><center>MENU: Transactions<BR>tools</center></html>")
            transactionMenu_button.setToolTipText("Menu containing Transactional Diagnostics, Fixes and Tools...")
            transactionMenu_button.addActionListener(self.TransactionMenuButtonAction())
            displayPanel.add(transactionMenu_button)

            GeekOutMode_button = JButton("<html><B>Geek Out</B></html>")
            GeekOutMode_button.setToolTipText("This allows you to display very Technical Information on the Moneydance System and many key objects..... READONLY")
            GeekOutMode_button.setBackground(Color.MAGENTA)
            GeekOutMode_button.setForeground(Color.WHITE)
            GeekOutMode_button.addActionListener(GeekOutModeButtonAction())
            GeekOutMode_button.setVisible(lGeekOutModeEnabled_TB)
            displayPanel.add(GeekOutMode_button)

            hackerMenu_button = JButton("<html><center><B>HACKER MODE</B></center></html>")
            hackerMenu_button.setToolTipText("Menu containing 'Hacker' Tools...")
            hackerMenu_button.addActionListener(self.HackerMenuButtonAction())
            hackerMenu_button.setBackground(Color.RED)
            hackerMenu_button.setForeground(Color.WHITE)
            hackerMenu_button.setVisible(False)
            displayPanel.add(hackerMenu_button)

            components = displayPanel.getComponents()
            for theComponent in components:
                if isinstance(theComponent, JButton):
                    theComponent.setPreferredSize(Dimension(button_width, button_height))
                    theComponent.setBorderPainted(False)
                    theComponent.setOpaque(True)
                    if not (theComponent.getBackground() == Color.MAGENTA
                        or theComponent.getBackground() == Color.RED
                            or theComponent.getBackground() == Color.ORANGE
                                or theComponent.getBackground() == GlobalVars.DARK_GREEN):
                        theComponent.setBackground(Color.LIGHT_GRAY)

            myDiagText = JTextArea(displayString)
            myDiagText.setEditable(False)
            myDiagText.setLineWrap(True)
            myDiagText.setWrapStyleWord(True)
            myDiagText.setFont( getMonoFont() )

            mySearchAction = SearchAction(toolbox_frame_,myDiagText)
            toolbox_frame_.getRootPane().getActionMap().put("search-window", mySearchAction)

            jSep = JSeparator()
            jSep.setPreferredSize(Dimension(frame_width-30,3))
            displayPanel.add(jSep)
            displayPanel.add(GlobalVars.STATUS_LABEL)

            self.myScrollPane = JScrollPane(myDiagText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
            # self.myScrollPane.setPreferredSize(Dimension(frame_width - 30, frame_height - displayPanel.getPreferredSize().height))
            self.myScrollPane.setBorder(BorderFactory.createLineBorder((MD_REF.getUI().getColors()).mainPanelBorderColor, 1))
            self.myScrollPane.setViewportBorder(EmptyBorder(1, 5, 5, 5))
            self.myScrollPane.setOpaque(False)
            self.myScrollPane.setWheelScrollingEnabled(True)

            mainPnl = MyJPanel(BorderLayout(), "%s: MyJPanel(): Main GUI Parent JPanel" %(myModuleID))
            mainPnl.add(displayPanel, BorderLayout.NORTH)
            mainPnl.add(self.myScrollPane, BorderLayout.CENTER)

            keyToUse = shortcut

            if Platform.isWindows():
                keyToUse = InputEvent.ALT_MASK

            if Platform.isOSX():
                save_useScreenMenuBar= System.getProperty("apple.laf.useScreenMenuBar")
                if save_useScreenMenuBar is None or save_useScreenMenuBar == "":
                    save_useScreenMenuBar= System.getProperty("com.apple.macos.useScreenMenuBar")
                System.setProperty("apple.laf.useScreenMenuBar", "false")
                System.setProperty("com.apple.macos.useScreenMenuBar", "false")
            else:
                save_useScreenMenuBar = "true"

            SetupMDColors.updateUI()

            mb = JMenuBar()
            # menu1 = JMenu("<html><b>TOOLBOX Options</b></html>")
            menu1 = JMenu("TOOLBOX Options")
            menu1.setMnemonic(KeyEvent.VK_T)
            menu1.setForeground(SetupMDColors.FOREGROUND_REVERSED); menu1.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            menuItem0 = JMenuItem("Basic Mode")
            menuItem0.setMnemonic(KeyEvent.VK_B)
            menuItem0.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_B, keyToUse))
            menuItem0.setToolTipText("Switch to basic (no harm) mode")
            menuItem0.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItem0.setEnabled(False)
            menu1.add(menuItem0)

            menuItem1 = JMenuItem("Advanced Mode")
            menuItem1.setMnemonic(KeyEvent.VK_M)  # Can't think of a spare letter to use!!!!
            menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M, keyToUse))
            menuItem1.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItem1.setToolTipText("Switch to Advanced / Fix Mode (can update data)")
            menu1.add(menuItem1)

            menuItemC = JCheckBoxMenuItem("Copy all Output to Clipboard")
            menuItemC.setMnemonic(KeyEvent.VK_O)  # Can't think of a spare letter to use!!!!
            menuItemC.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, keyToUse))
            menuItemC.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItemC.setToolTipText("When selected copies the output of all displays to Clipboard")
            menuItemC.setSelected(lCopyAllToClipBoard_TB)
            menu1.add(menuItemC)

            menuItemG = JCheckBoxMenuItem("Geek Out Mode")
            menuItemG.setMnemonic(KeyEvent.VK_G)  # Can't think of a spare letter to use!!!!
            menuItemG.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, keyToUse))
            menuItemG.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItemG.setToolTipText("Enables the Geek Out Button to show very technical stuff - readonly")
            menuItemG.setSelected(lGeekOutModeEnabled_TB)
            menu1.add(menuItemG)

            menuItemH = JCheckBoxMenuItem("Hacker Mode")
            menuItemH.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItemH.setToolTipText("Enables 'Hacker' Mode - Do not do this unless you know what you are doing... Allows you to update data!")
            menuItemH.setSelected(False)
            menu1.add(menuItemH)

            menuItemD = JCheckBoxMenuItem("Debug")
            menuItemD.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItemD.setToolTipText("Enables script to output debug information - technical stuff - readonly")
            menuItemD.setSelected(debug)
            menu1.add(menuItemD)

            menuItemP = JCheckBoxMenuItem("Auto Prune Internal Backups")
            menuItemP.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItemP.setToolTipText("Enables auto pruning of the internal backups that Toolbox makes of config.dict, custom_theme.properties, and ./safe/settings")
            menuItemP.setSelected(lAutoPruneInternalBackups_TB)
            menu1.add(menuItemP)

            menuItemF = JMenuItem("Find/Search")
            menuItemF.setToolTipText("Finds text within the main display window..")
            menuItemF.addActionListener(mySearchAction)
            menuItemF.setEnabled(True)
            menu1.add(menuItemF)

            menuItemPS = JMenuItem("Page Setup")
            menuItemPS.setToolTipText("Printer Page Setup")
            menuItemPS.addActionListener(self.DoTheMenu(displayPanel, menu1, self))
            menuItemPS.setEnabled(True)
            menu1.add(menuItemPS)

            menuItem2 = JMenuItem("Exit")
            menuItem2.setMnemonic(KeyEvent.VK_E)
            menuItem2.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, keyToUse))
            menuItem2.addActionListener(self.CloseAction(toolbox_frame_))
            menuItem2.setToolTipText("Exit this Toolbox")
            menu1.add(menuItem2)

            mb.add(menu1)

            # menuH = JMenu("<html>HELP</html>")
            menuH = JMenu("HELP")
            menuH.setMnemonic(KeyEvent.VK_I)
            menuH.setForeground(SetupMDColors.FOREGROUND_REVERSED); menuH.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            menuItemH = JMenuItem("Help")
            menuItemH.setMnemonic(KeyEvent.VK_I)
            menuItemH.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_I, keyToUse))
            menuItemH.setToolTipText("Display Help")
            menuItemH.addActionListener(self.DoTheMenu(displayPanel, menuH, self))
            menuItemH.setEnabled(True)
            menuH.add(menuItemH)

            menuItemA = JMenuItem("About Toolbox")
            menuItemA.setToolTipText("About...")
            menuItemA.addActionListener(self.DoTheMenu(displayPanel, menuH, self))
            menuItemA.setEnabled(True)
            menuH.add(menuItemA)

            menuItemAMD = JMenuItem("About Moneydance")
            menuItemAMD.setToolTipText("About...")
            menuItemAMD.addActionListener(self.DoTheMenu(displayPanel, menuH, self))
            menuItemAMD.setEnabled(True)
            menuH.add(menuItemAMD)

            mb.add(menuH)

            # ##############

            mb.add(Box.createHorizontalGlue())

            btnConsole = JButton("Launch Console Window")
            btnConsole.setToolTipText("launches the Moneydance Console Window (and turns DEBUG on).. Useful for extra diagnostics!")

            btnConsole.setOpaque(SetupMDColors.OPAQUE)
            btnConsole.setBackground(SetupMDColors.BACKGROUND)
            btnConsole.setForeground(SetupMDColors.FOREGROUND)

            btnSaveConsole = JButton("Save Console Log")
            btnSaveConsole.setToolTipText("Copy/save the Console Error log file to a directory of your choosing..")
            btnSaveConsole.setOpaque(SetupMDColors.OPAQUE)
            btnSaveConsole.setBackground(SetupMDColors.BACKGROUND)
            btnSaveConsole.setForeground(SetupMDColors.FOREGROUND)

            btnOpenMDFolder = JButton("Open MD Folder")
            btnOpenMDFolder.setToolTipText("Open the selected Moneydance (internal) folder in Explorer/Finder window (etc)")
            btnOpenMDFolder.setOpaque(SetupMDColors.OPAQUE)
            btnOpenMDFolder.setBackground(SetupMDColors.BACKGROUND)
            btnOpenMDFolder.setForeground(SetupMDColors.FOREGROUND)

            btnCopyDiagnostics = JButton("Copy/Save/Print Diagnostics below")
            btnCopyDiagnostics.setToolTipText("Option to Copy the contents of the main diagnostics window (below) to the Clipboard.., or save to file, or print...")
            btnCopyDiagnostics.setOpaque(SetupMDColors.OPAQUE)
            btnCopyDiagnostics.setBackground(SetupMDColors.BACKGROUND)
            btnCopyDiagnostics.setForeground(SetupMDColors.FOREGROUND)

            mb.add(btnConsole)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnSaveConsole)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnOpenMDFolder)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnCopyDiagnostics)

            mb.add(Box.createRigidArea(Dimension(30, 0)))

            btnConsole.addActionListener(ShowTheConsole())
            btnSaveConsole.addActionListener(CopyConsoleLogFileButtonAction(MD_REF.getLogFile()))
            btnOpenMDFolder.addActionListener(OpenFolderButtonAction())
            btnCopyDiagnostics.addActionListener(ClipboardButtonAction(displayString))
            # ##############

            toolbox_frame_.setJMenuBar(mb)

            # toolbox_frame_.add(displayPanel)
            toolbox_frame_.getContentPane().setLayout(BorderLayout())
            toolbox_frame_.getContentPane().add(mainPnl, BorderLayout.CENTER)

            toolbox_frame_.pack()
            toolbox_frame_.setLocationRelativeTo(None)

            try:
                toolbox_frame_.MoneydanceAppListener = MyMoneydanceEventListener(toolbox_frame_)
                MD_REF.addAppEventListener(toolbox_frame_.MoneydanceAppListener)
                myPrint("DB","@@ added AppEventListener() %s @@" %(classPrinter("MoneydanceAppListener", toolbox_frame_.MoneydanceAppListener)))
            except:
                myPrint("B","FAILED to add MD App Listener...")
                dump_sys_error_to_md_console_and_errorlog()

            toolbox_frame_.setVisible(True)     # already on the EDT
            toolbox_frame_.toFront()            # already on the EDT
            toolbox_frame_.isActiveInMoneydance = True

            if Platform.isOSX():
                System.setProperty("apple.laf.useScreenMenuBar", save_useScreenMenuBar)
                System.setProperty("com.apple.macos.useScreenMenuBar", save_useScreenMenuBar)


            # Check for secondary node (potentially restored from backup).. Popup alert message
            if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():

                MyPopUpDialogBox(toolbox_frame_,"INFORMATION ONLY - THIS IS NOT A PROBLEM",
                                                 "This Dataset is running as a 'Secondary Node'\n" 
                                                 "- either you are Synchronising to it,\n" 
                                                 "- or you have restored it from a backup/sync copy.\n" 
                                                 "If these statements are true / OK, then ignore this message...\n" 
                                                 ">>Otherwise, to convert to Primary, use Advanced Tools Menu.",
                                                 120,
                                                 "SECONDARY DATASET/NODE",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=True).go()

            # Now look for cached downloaded txns that can be purged..
            try:
                countCachedAccount, countCachedTxns = quick_check_cached_online_txns()
                if countCachedTxns > 0:

                    if debug:
                        myPopupInformationBox(toolbox_frame_,
                                              "You appear to have %s Accounts\n"
                                              "with %s cached OFX downloaded bank transactions.\n"
                                              "These should not really be there.\n"
                                              "Consider using Online Banking (OFX) Tools menu to delete cached OnlineTxnList txns"
                                              %(countCachedAccount, countCachedTxns),
                                              "ALERT: Cached OnlineTxnList records exist",
                                              JOptionPane.WARNING_MESSAGE)
                    else:
                        myPrint("J","")
                        myPrint("B","#########################################################################################################################################################")
                        myPrint("B","### ALERT: You appear to have %s Accounts with %s cached OFX downloaded bank transactions."%(countCachedAccount, countCachedTxns))
                        myPrint("B","### These should not really be there.")
                        myPrint("B","### Consider using Online Banking (OFX) Tools menu to delete cached OnlineTxnList txns.")
                        myPrint("B","#########################################################################################################################################################\n")
                        myPrint("J","")
                del countCachedAccount, countCachedTxns
            except:
                pass

            # Check to see if Tabbing mode needs changing on a MAc
            if lTabbingModeNeedsChanging:
                myPopupInformationBox(toolbox_frame_,
                                      "Your Mac has 'Tabbing Mode' set to 'always'\n" +
                                      "- You can find this in Settings>General>Prefer tabs:,\n" +
                                      "- THIS CAUSES STRANGE MONEYDANCE FREEZES.\n" +
                                      ">> To change this setting now, use Advanced Mode...\n" +
                                      "........\n",
                                      "MacOS TABBING MODE WARNING",
                                      JOptionPane.ERROR_MESSAGE)

            # Check whether UserHome is missing - probably on a development platform
            if Platform.isOSX() and System.getProperty(u"UserHome") is None:
                myPopupInformationBox(toolbox_frame_,
                                      "Your Mac's System Property 'UserHome' is not set\n" +
                                      "Some features in Toolbox may not work as expected",
                                      "MacOS UserHome Warning",
                                      JOptionPane.WARNING_MESSAGE)

            # Check for repeated opening of backup files
            try:
                datapath = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()
                datafile = os.path.basename(datapath)
                datafilenew = datafile.replace(".moneydance","")
                if len(datafilenew) > 17:
                    searchDash = datafilenew[-3] + datafilenew[-6] + datafilenew[-14] + datafilenew[-17]
                    if searchDash == "----":
                        MyPopUpDialogBox(toolbox_frame_,
                                         "ALERT: Detected multiple dates in dataset filename.",
                                         "This might mean you're opening backup (*.moneydancearchive) files by double-clicking\n"
                                         "...and this may be creating a new dataset everytime as a result... and so on....\n"
                                         ">> If so, please correct your file opening procedure <<\n"
                                         "(But, if you're happy with your procedure & dataset name, then ignore this alert)",
                                         140,
                                         "POTENTIAL IMPROPER OPENING OF BACKUP FILES",
                                         OKButtonText="ACKNOWLEDGE",
                                         lAlertLevel=1,
                                         lModal=True).go()
            except:
                pass

            check_for_old_StuWareSoftSystems_scripts()

            _tb_extn_avail_version = check_for_updatable_extensions_on_startup()

            checkModule = myModuleID
            myExtensions = downloadStuWareSoftSystemsExtensions(checkModule)
            if myExtensions:
                myModule = myExtensions.get("id")
                if myModule == checkModule:
                    availableFromGitHubVersion = int(myExtensions.get("module_build"))

                    if _tb_extn_avail_version > int(version_build):
                        myPrint("B","@@ Extension version %s (signed) is available from Moneydance Menu>>Manage Extensions Menu @@" %_tb_extn_avail_version)
                        theStr = "You are running version %s\n" %version_build
                        theStr += "Extension version %s (signed) is available from Moneydance Menu>>Manage Extensions Menu\n" %_tb_extn_avail_version
                        MyPopUpDialogBox(toolbox_frame_,"Toolbox Version:",theStr,200,"UPGRADE AVAILABLE",OKButtonText="Acknowledge").go()

                    elif availableFromGitHubVersion > int(version_build) and availableFromGitHubVersion > _tb_extn_avail_version:
                        myPrint("DB","@@ FYI - Toolbox upgrade to version %s (unsigned) is available from Author's code site.... @@" %(availableFromGitHubVersion))

                    else:
                        myPrint("DB","I've checked and Toolbox is running latest version available: %s" %max(version_build,availableFromGitHubVersion))

            checkForREADONLY()


    if not i_am_an_extension_so_run_headless: print("""
Script is analysing your moneydance & system settings....
------------------------------------------------------------------------------
>> DISCLAIMER: This script has the ability to change your data
>> Always perform backup first before making any changes!
>> The Author of this script can take no responsibility for any harm caused
>> If you do not accept this, please exit the script
------------------------------------------------------------------------------
""")

    # This gets the latest build info from the developer... and it overrides the program defaults...
    download_toolbox_version_info()

    lAbort=False
    if TOOLBOX_STOP_NOW:
        lAbort = True
    elif float(MD_REF.getVersion()) < TOOLBOX_MINIMUM_TESTED_MD_VERSION or not lImportOK:
        lAbort = True
    elif int(float(MD_REF.getVersion())) > int(TOOLBOX_MAXIMUM_TESTED_MD_VERSION):  # Just stick to major version checks....
        lAbort = True
    else:
        if (float(MD_REF.getBuild()) <= TOOLBOX_MAXIMUM_TESTED_MD_BUILD
                    or myPopupAskQuestion(None,"Toolbox(build: %s) - Moneydance Version/Build" %(version_build),
                                      "MD build (%s)%s is newer than the Toolbox tested build of (%s)%s - Proceed?"
                                      %(MD_REF.getVersion(),MD_REF.getBuild(),TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD),
                                      JOptionPane.WARNING_MESSAGE)):

            # if float(MD_REF.getBuild()) > TOOLBOX_MAXIMUM_TESTED_MD_BUILD:
            #     myPrint("B","@@ WARNING - MD build (%s)%s is newer than the Toolbox tested build of (%s)%s....!"
            #             %(MD_REF.getVersion(),MD_REF.getBuild(),TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD))

            fixRCurrencyCheck = 0

            MD_REF.getUI().setStatus(">> Infinite Kind (co-authored by Stuart Beesley: StuWareSoftSystems) - Toolbox launching.......",0)

            # These checks already run at Dataset Load time:
            # >> com.infinitekind.moneydance.model.AccountBook.performPostLoadVerification()
            # That Currency BaseType is set
            #   >> com.infinitekind.moneydance.model.CurrencyType.performPostLoadVerification()
            #       >> Relative currency loops, zero rate
            #   >> Orphan snapshots with no registered Currency - deletes them
            #   >> Redundant Base currency snapshots - deletes them
            #   >> On each snapshot com.infinitekind.moneydance.model.CurrencySnapshot.performPostLoadVerification
            #       >> resets relative rates < 0 relative to base rate
            #   >> For csplits registered with currency
            #   >> Then sorts the Currency's snapshots and cplits
            # That Account structures are valid
            #   >> Broken acct numbers (old)
            #   >> Validates account structures: com.infinitekind.moneydance.model.Account.ensureAccountStructure()
            #       >> Iterates all accounts. If it finds acct eq type ROOT validates it's the root, fixes duplicate roots, replaces root
            #       >> where not ROOT, validates the parent of this acct has sub accounts
            #   >> Then checks that getRootAccount() is not None - else:
            #       >> it finds it & sets it, or creates it
            #       >> also it also detects and cleans up duplicate roots
            #   >> It also finds orphan accounts, with no parent and links them to root
            # That budget structures are OK.
            # That Txns are valid
            #   >> Txns with getOtherCount() <= 0 get deleted (when a parent)
            #   >> That Txns are not linked to Root (warning only)
            #   >> If Account does not exist:
            #       >> Makes a new account (with ts = 0 = ghost account)
            # Then sorts Accounts
            # Then refreshes balances

            # Check based on fix_restored_accounts.py
            _root = MD_REF.getCurrentAccount().getBook().getRootAccount()   # Should never happen!
            if _root is None or _root.getAccountType()!=Account.AccountType.ROOT:                                       # noqa
                myPrint("B","@@ ERROR: I've Detected that your ROOT Account is Missing or not type ROOT! Contact support or the Author of Toolbox for a fix")
                myPrint("B","@@ FYI - there used to be scripts called fix_restored_accounts.py or fix_root_account_type.py for this (but the last time I looked they were broken.....")
                myPopupInformationBox(None,"ERROR: I've Detected that your ROOT Account is Missing or not type ROOT! Contact support or the Author of Toolbox for a fix",
                                      "ROOT ACCOUNT WARNING",JOptionPane.ERROR_MESSAGE)
                cleanup_references()
            else:

                class MainAppRunnable(Runnable):
                    def __init__(self):
                        pass

                    def run(self):                                                                                      # noqa
                        global debug, toolbox_frame_

                        myPrint("DB", "In MainAppRunnable()", inspect.currentframe().f_code.co_name, "()")
                        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                        theDisplay = DiagnosticDisplay()
                        theDisplay.openDisplay()

                if not SwingUtilities.isEventDispatchThread():
                    myPrint("DB",".. Main App Not running within the EDT so calling via MainAppRunnable()...")
                    SwingUtilities.invokeAndWait(MainAppRunnable())
                else:
                    myPrint("DB",".. Main App Already within the EDT so calling naked...")
                    MainAppRunnable().run()

                myPrint("DB","Requesting System Garbage Collection....")
                System.gc()

                myPrint("P","-----------------------------------------------------------------------------------------------------------")
                myPrint("B", "Infinite Kind in conjunction with StuWareSoftSystems - ", myScriptName, " script ending (frame is open/running)......")
                myPrint("P","-----------------------------------------------------------------------------------------------------------")
        else:
            lAbort = True

    if lAbort:
        if TOOLBOX_STOP_NOW:
            myPrint("B", "STOP-NOW COMMAND RECEIVED!")
            myPopupInformationBox(None,
                                  "Sorry, Toolbox has received a STOP-NOW command from developer....!",
                                  "Toolbox- STOP-NOW",
                                  JOptionPane.ERROR_MESSAGE)
        else:
            myPrint("B", "Sorry, this Toolbox (build %s) has only been tested on Moneydance versions %s thru' %s(build %s)... Yours is %s(%s) >> Exiting....."
                    %(version_build, TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD,MD_REF.getVersion(),MD_REF.getBuild()))
            myPopupInformationBox(None,
                                  "Sorry, this Toolbox (build %s) has only been tested on Moneydance versions %s thru' %s(build %s)... Yours is %s(%s) >> Exiting....."
                                  %(version_build, TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD,MD_REF.getVersion(),MD_REF.getBuild()),
                                  "Toolbox- VERSION TOO NEW",
                                  JOptionPane.ERROR_MESSAGE)
        cleanup_references()
