#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# ######################################################################################################################
# The Infinite Kind (Moneydance) - Co-authored by Stuart Beesley in collaboration with Moneydance as a support tool
#
# Moneydance Support Tool
# ######################################################################################################################

# toolbox.py build: 1060 - November 2020 thru 2023 onwards - Stuart Beesley StuWareSoftSystems (>1000 coding hours)
# Thanks and credit to Derek Kent(23) for his extensive testing and suggestions....
# Further thanks to Kevin(N), Dan T Davis, and dwg for their testing, input and OFX Bank help/input.....
# Credit of course to Moneydance(Sean) and IK retain all copyright over Moneydance internal code
# Designed to show user a number of settings / fixes / updates they may find useful (some normally hidden)
# READ-ONLY and Curious (view settings) are very safe >> They do NOT change any data or settings
# If you switch to Update mode then you have the ability to perform fixes, change data, change config etc
# NOTE: Any change that impacts config.dict, custom_theme.properties, LocalStorage() ./safe/settings...
#       will always backup that single config/settings file (in the directory where it's located).
#       This is not the same as backing up your Dataset that contains your financial data.

# NOTE: You will see some usage of globals... I wrote this when I was learning Python and Java... Know I know a lot more,
# I would do this differently, but leaving this as-is for now... (I'll upgrade elements as I make future changes)

# DISCLAIMER >> PLEASE ALWAYS BACKUP YOUR DATA BEFORE MAKING CHANGES (Menu>Create Backup will achieve this).

# Also includes these IK/Moneydance support scripts (but with enhanced capabilities)
# reset_relative_currencies.py                          (from Moneydance support)
# remove_ofx_account_bindings.py                        (from Moneydance support)
# convert_secondary_to_primary_data_set.py              (from Moneydance support)
# remove_one_service.py                                 (from Moneydance support)
# delete_invalid_txns.py                                (from Moneydance support)
# price_history_thinner.py                              (from Moneydance support)
# fix_dropbox_one_way_syncing.py                        (from Moneydance support)
# reset_sync_and_dropbox_settings.py                    (from Moneydance support)
# force_change_account_currency.py                      (from Moneydance support)
# fix_restored_accounts.py (check only)                 (from Moneydance support)
# export_all_attachments.py                             (from Moneydance support)
# fix_account_parent.py                                 (from Moneydance support)
# (... and old check_root_structure.py)                 (from Moneydance support)
# fix_non-hierarchical_security_account_txns.py         (from Moneydance support)
# (... and fix_investment_txns_to_wrong_security.py)    (from Moneydance support)
# remove_ofx_security_bindings.py                       (from Moneydance support)
# show_object_type_quantities.py                        (from Moneydance support)
# delete_intermediate_downloaded_transaction_caches.py  (from Moneydance support)
# delete_orphaned_downloaded_txn_lists.py               (from Moneydance support)
# set_account_type.py                                   (from Moneydance support)
# force_change_all_currencies.py                        (from Moneydance support)
# fix_invalid_currency_rates.py                         (from Moneydance support)
# reverse_txn_amounts.py                                (from Moneydance support)
# reverse_txn_exchange_rates_by_account_and_date.py     (from Moneydance support)
# show_open_tax_lots.py                                 (author unknown)
# MakeFifoCost.py                                       (author unknown)
# change-security-cusip.py                              (from Finite Mobius, LLC / Jason R. Miller)
# https://github.com/finitemobius/moneydance-py

###############################################################################
# MIT License
#
# Copyright (c) 2021-2023 Stuart Beesley - StuWareSoftSystems & Infinite Kind (Moneydance)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
###############################################################################

# NOTE: java.lang.IllegalArgumentException can occur when doing something like '"%s" %(java.util.HashMap)' containing unicode (or calling print on the same HashMap)
#       Should be fixed in Jython 2.7.3 sometime)... Also note that unicode() should be used instead of str() where appropriate....

# build: 1048 - Bugfix deleteOFXService() if no service selected...; Enhanced View OFX data for multiple service options (OFX and MD+)
# build: 1048 - Improved the 'STOP-NOW' command message (suggest to check for upgrade)
# build: 1049 - Updated Zap md+ option to wipe all md+ data from system (including all banking links)
# build: 1049 - Added redactor() to various outputs (especially OFX and curious modes)
# build: 1049 - Fixed calls to .setEscapeKeyCancels() on older MD versions...
# build: 1050 - Added force change currency for categories options...
# build: 1051 - Tweaks to internal code. Improved reset window positions code to pre-close all MD windows....
# build: 1051 - Changed invalid preferences locations/sizes code to zap keys from toolbox_init.py at MD launch.......
# build: 1051 - Improve vmoptions detector.
# build: 1051 - Added 'Rename this dataset (within the same location)' & 'Relocate this dataset back to the default 'internal' location' features
# build: 1051 - Added 'Cleanup MD's File/Open list of 'external' files (does not touch actual files)' feature
# build: 1051 - Moved the Delete internal/external files option to General Tools Menu (and auto purge external orphans)
# build: 1051 - Auto-magically restart MD (same dataset) when needed....; Changed menus so they all exit after each usage
# build: 1051 - Added 'Force MD+ name cache & access tokens rebuild' feature; Tweaked Export/Import/Zap/Wipe MD+ features
# build: 1051 - Added 'REGISTER MONEYDANCE' button (if not registered)...; Fixed invalid locations detection for off-screen negative (left)
# build: 1052 - Small bugfix when debug message crashed merge duplicate securities with java.lang.IllegalArgumentException
# build: 1052 - Updated toolbox_total_selected_transactions.py script; Added Detect/Fix Txns assigned to Root...
# build: 1052 - Enhanced fix_non_hier_sec_acct_txns() with autofix and tweak for concurrent modification of txn list error
# build: 1052 - Change lAutoPruneInternalBackups_TB default to True
# build: 1052 - Redact these keys and also added to remove list: 'netsync.db.access_token_key', 'netsync.db.access_token_secret', 'netsync.db.v2token'
# build: 1052 - Also detect/display/zap 'netsync.download_attachments'; Added 'Toggle Sync Downloading of Attachments' feature
# build: 1052 - Turned off linewrap on main diagnostic display... WATCHOUT FOR SLUGGISH DIAGNOSTICS SCREEN with long lines and wordwrap off! (Probably Mac only)
# build: 1052 - Fixed get_sync_folder() when Dropbox Connection (cloud service has no local folder on disk)
# build: 1052 - Added some more startup diag info to console error log during init and main script
# build: 1052 - Fixed bug with VAQua9 that causes Mac long lines in main display to slow down the scroll and cause memory issues. Don't do this: 'scrollpane.setBorder(BorderFactory.createLineBorder....
# build: 1052 - .... and thus removed the call to System.gc()
# build: 1052 - Tweaked init so that JVM stats captured from new thread after 10 seconds (to allow JVM memory to settle)...
# build: 1052 - Added 'Relocate this dataset to another location' option
# build: 1052 - Added AppleScript File Open selector (for when needed - e.g. trying to open 'special locations' or .moneydance bundle file)
# build: 1052 - Enhanced 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' to self-repair where 'sec' split missing (creates dummy fake security)
# build: 1052 - Added 'FIX: Detect and merge/fix duplicate Securities within same Investment Account(s)'
# build: 1052 - Added check for no currencies at launch... Odd, but has happened!
# build: 1052 - Enhanced Shrink Dataset... Allow 0 days, always delete out/txn-tmp...
# build: 1052 - Fix Merge Duplicate Securities (security split match check); fix apple script check on Mac version
# build: 1053 - Added 'DIAG: Show Securities with 'invalid' LOT Matching (cause of LOT matching popup window)' feature
# build: 1053 - FileDialog() (refer: java.desktop/sun/lwawt/macosx/CFileDialog.java) seems to no longer use "com.apple.macos.use-file-dialog-packages" in favor of "apple.awt.use-file-dialog-packages" since Monterrey...
# build: 1053 - New feature 'Decrypt entire dataset' feature...
# build: 1053 - New feature 'Force Disconnect an MD+ Connection' (also added to view service profiles)
# build: 1053 - Allow md+ payload ids to appear in the view service profile output, unless user selects redacted option...
# build: 1053 - Now clear MDPlus.licenseCache when shutting down the plusPoller...
# build: 1053 - Improved ManuallyCloseAndReloadDataset() to release all references to (old) book, and shutdown more things - memory consumption etc....
# build: 1053 - Added CMD-/ - calls up QuickJVMDiags(); tweaked Common Code...
# build: 1053 - Flip to restart after Import and Zap md+ license (was exit) - now that we reset licenseCache.....
# build: 1053 - Alerts to detect invalid backup locations (or auto-backup off); init code now warns about memory % and invalid backup locations too...
# build: 1053 - Common code update - remove Decimal Grouping Character - not necessary to collect and crashes on newer Java versions (> byte)
# build: 1053 - Added unlock (secret) option 'Close Dataset'; added JVM Memory stats to status line...
# build: 1054 - Fixed MyPopupDialogBox() height from becoming too tall on Windows.....; also set the relativeLocation to parent (not None).....
# build: 1054 - Tweaked rename/relocate dataset to detect crash when calling .setCurrentBook() - e.g. out of memory.....
# build: 1055 - Tweaked Dropbox Config error popup to recommend / try reset sync method...; New logger for all updates performed.....
# build: 1055 - Tweaked diagnose_currencies... Stopped fix applying if newRate was still zero/NaN..... Remains as a warning....
# build: 1055 - Turned off Syncer.DEBUG when performing mass changes - to stop console log filling up etc...; also MD_REF.DEBUG when refreshing (GUI) sync status
# build: 1055 - Added Remove inactive accounts from SideBar function...
# build: 1055 - Rebuilt launch code so that latest extension version checks download(s) from internet occur in parallel in own thread....
# build: 1055 - New feature: 'Toggle investment securities with zero shares status to active/inactive'
# build: 1055 - New options added to open md folder button: View Toolbox's common & dataset update logfile
# build: 1055 - Tweaked md+ connections routines to call .getMask() to grab last digits of account number... ;->
# build: 1055 - Added MD Build and Toolbox Build to logger...
# build: 1056 - Tweaked toolbox_init.py with error message; tweaked OFX_view_reconcile_AsOf_Dates()
# build: 1056 - New feature: 'DIAG: Produce report of Accounts and bank/account number information'
# build: 1056 - Added startup check for accounts that have both OFX AND md+ connections configured...
# build: 1056 - DECOMMISSIONED find_IOS_sync_data() as py file too large...
# build: 1056 - Added SwingTimer Blinking JMenuItem for Toolbox Options....; Changed menus to popup alerts when update/advanced modes not enabled...
# build: 1056 - Eliminated Advanced Mode... Now all updates within Update Mode..
# build: 1056 - Tweaks for .getAbsolutePath() vs .getCanonicalPath() and Dropbox updated Dropbox location on MacOS
# build: 1056 - Accepted Pull Request from xx whereby Edit Security Decimals Places was changed to allow 16dpc. NOTE: 922.3372036854775807 is the max shares number MD can hold at 16dpc
# build: 1056 - Added 'FIX: Add alternative account numbers for 'Accounts and bank/account number' report (above)' feature
# build: 1056 - Added 'lBypassAllBackupsAndDisclaimers_TB' feature....
# build: 1056 - Added launch check for base CurrencyType relative rate != 1.0; fixed diagnose/repair currency option to fix != 1.0 (properly)
# build: 1057 - Changed errortrap in force disconnect md+ connection....
# build: 1057 - Bold'ified [sic] blinking cells...; tweaked security account information output (curious view selected object)
# build: 1057 - Added MacOSx Finder path for internal root folder (fake alias)....; launch check for non-hierarchical security txn(s)
# build: 1057 - Added bootstrap to execute compiled version of extension (faster to load)....
# build: 1057 - Added launch detection for potential duplicate securities....
# build: 1058 - Support for MD2023.0(5000) Kotlin compiled version(s)....; Wrapped responses that now return okio.BufferedSource instead of java.io.InputStream
#               Kotlin affected LocalStorage and getSyncFolder methods: extract_attachments, Shrink Dataset, Load (old) Pickle file, advanced_options_decrypt_file_from_sync...
#               More Kotlin fixes.... loadMDPreferences() to .readSet() call when using StringBuilder()...
#               More Kotlin fixes.... Import MD+ Licence call to .getDecryptStream() needs BufferredSource.
#               Clone Dataset - fix for new balance adjustment methods...; also outputs that show Start Balance...
#               Fixed call to .updateFonts() with True parameter from MD2022.3(4077) onwards
#               updated bundled toolbox_move_merge_investment_txns.py script to handle/block when balance adjustment detected...
#               Updated reset window data methods to account for new/enhanced filter keys ("custom_filter_int" and "last_custom_filter_int")
#               MD2023 fixes to common code...
#               Quick check for earlier MD2023 Sync issue repair flagged......
# build: 1059 - MD2023.2(5007); Launch check for invalid 'processed.dct' file (I have seen this as a folder!?)....
#               Change isSwingComponentInvalid() not to check for .isValid()...
#               Fixed Windows, (hot) keystrokes to use CTRL when attached to Menus so they are consistent (also with MD)...
#               Tweak to IAGREE message - wrap to next line...
#               Fix CMD-M (CTRL-M) that didn't work on Windows.... (keystroke 'm' not passed to .getActionCommand())
#               Tweak startup check messages detect_non_hier_sec_acct_or_orphan_txns()....
#               Common code tweaks...
#               Added 'toolbox_zap_mdplus_default_memo_fields' menu option
#               Enhanced: detect_non_hier_sec_acct_or_orphan_txns() and fix_non_hier_sec_acct_txns() for when investment txn is sitting in a non investment account
#                         Usually caused by batch change category feature view viewing a xfr split in a non investment register (should be blocked really).
#               Fix to missing class reference in 'buddy' toolbox_move_merge_investment_txns.py script....
#               Added "Remove (hidden) downloaded OFX/MD+ data from Transactions within an Account" feature
#               Renamed script to toolbox_zap_mdplus_ofx_default_memo_fields.py. Now fixes OFX too...
# build: 1060 - Enhanced buddy 'toolbox_zap_mdplus_ofx_default_memo_fields' script
#               Renamed script to 'toolbox_zap_mdplus_ofx_qif_default_memo_fields' script
#               Tweaked OFX_removeDownloadedDataFromTxns() to include QIF in the settings zap routines....
#               Disabled the createUSAAProfile() menu option (no longer needed)
#               MD2023.2(5008): Kotlin entire code set recompiled build >> tweaks/fixes...
#               ... Tweaked ManuallyCloseAndReloadDataset() to cope with multi syncer threads...
#               added call to .showURL("moneydance:fmodule:extract_data:disable_events") and enable_events when restarting dataset....
#               Deprecated DetectAndChangeMacTabbingMode class to avoid PyBytecode-approach: java.lang.RuntimeException: java.lang.RuntimeException: For unknown reason, too large method code couldn't be resolved
#               Added new DetectMobileAppTxnFiles class...; Added new advanced_options_encrypt_file_into_sync_folder() feature
#               Deprecated: advanced_options_set_check_days()
#               NOTE: MD2023.2(5008+) KOTLIN ALL uses Java 20.0.1 on Mac. Thread.stop() no longer work affects ManuallyCloseAndReloadDataset's ability to kill Syncer Threads.. :-(
#               Tweak to detect_fix_txns_assigned_root (removed detect_non_hier_sec_acct_or_orphan_txns() check).
#               Tweaks to class ManuallyCloseAndReloadDataset() to better handle (new) syncer threads when dataset closing
#               Enhanced _init, _handle_event, _invoke (etc).py scripts; Now maintain list of WeakReferences() to all observed wrapper, book, syncer, thread objects
#               MD2023.2(5019) started using WeakReference()s to 'book' (as 'book' and 'bookRef')...
#               New menu for Observer Mode. Enable/Disable the capture of WeakReferences. Normally disabled.
#               MD2023.2(5020) fixes - .getInternalAccountBooks() / getExternalAccountBooks() now returns [books]...
#               Tweak MyJFrame.dispose() with .getContentsPane().removeAll()
#               Change when Moneydance's DEBUGs are turned on (when debug on, or from new options menu toggle):
#               Enhanced: advanced_options_DEBUG() and advanced_options_other_DEBUG()
#               Tweaked isSyncing() detection capability
#               Build 5031 removed the MD+ licenseCache field - tweak to deal with the change...
#               Added feature to disable MoneyForesight whenever MD is launched (prevents memory leaks etc)
#               Cleaned up references holding onto MD Objects....
#               Added advanced_show_encryption_keys() feature

# todo - consider whether to allow blank securities on dividends (and MiscInc, MiscExp) in fix_non_hier_sec_acct_txns() etc?

# todo - Change JMenuBar in all extensions.... Swap in a parent JRootPane etc...
# todo - CMD-P select the pickle file to load/view/edit etc.....
# todo - Clone Dataset - stage-2 - date and keep some data/balances (what about Loan/Liability/Investment accounts... (Fake cat for cash)?
# todo - add SwingWorker Threads as appropriate (on heavy duty methods)
# todo - change from str() to unicode() where appropriate...
# todo - com.moneydance.apps.md.controller.olb.MoneybotURLStreamHandlerFactory.REQUEST_LOG_BASE = File("/Users/xxx/moneydance_http_logs")

# NOTE: Toolbox will connect to the internet to gather some data. IT WILL NOT SEND ANY OF YOUR DATA OUT FROM YOUR SYSTEM....:
# 1. At launch it connects to the Author's code site to get information about the latest version of Toolbox and version requirements
# 2. At various times it may connect to the Infinite Kind server to gather information about extensions and versions
# 3. Within the OFX banking menu, it can connect to the Infinite Kind server to get the latest bank connection profiles for viewing

# NOTE - I Use IntelliJ IDE - you may see # noinspection Pyxxxx or # noqa comments
# These tell the IDE to ignore certain irrelevant/erroneous warnings being reporting:
# Further options at: https://www.jetbrains.com/help/pycharm/disabling-and-enabling-inspections.html#comments-ref

# CUSTOMIZE AND COPY THIS ##############################################################################################
# CUSTOMIZE AND COPY THIS ##############################################################################################
# CUSTOMIZE AND COPY THIS ##############################################################################################

# SET THESE LINES
myModuleID = u"toolbox"
version_build = "1060"
MIN_BUILD_REQD = 1915                   # Min build for Toolbox 2020.0(1915)
_I_CAN_RUN_AS_MONEYBOT_SCRIPT = True

global moneydance, moneydance_ui, moneydance_extension_loader, moneydance_extension_parameter

global MD_REF, MD_REF_UI
if "moneydance" in globals(): MD_REF = moneydance           # Make my own copy of reference as MD removes it once main thread ends.. Don't use/hold on to _data variable
if "moneydance_ui" in globals(): MD_REF_UI = moneydance_ui  # Necessary as calls to .getUI() will try to load UI if None - we don't want this....
if "MD_REF" not in globals(): raise Exception("ERROR: 'moneydance' / 'MD_REF' NOT set!?")
if "MD_REF_UI" not in globals(): raise Exception("ERROR: 'moneydance_ui' / 'MD_REF_UI' NOT set!?")

# Nuke unwanted (direct/indirect) reference(s) to AccountBook etc....
if "moneydance_data" in globals():
    moneydance_data = None
    del moneydance_data

if "moneybot" in globals():
    moneybot = None
    del moneybot

from java.lang import Boolean
global debug
if "debug" not in globals():
    # if Moneydance is launched with -d, or this property is set, or extension is being (re)installed with Console open.
    debug = (False or MD_REF.DEBUG or Boolean.getBoolean("moneydance.debug"))

global toolbox_frame_
# SET LINES ABOVE ^^^^

# COPY >> START
import __builtin__ as builtins

def checkObjectInNameSpace(objectName):
    """Checks globals() and builtins for the existence of the object name (used for StuWareSoftSystems' bootstrap)"""
    if objectName is None or not isinstance(objectName, basestring) or objectName == u"": return False
    if objectName in globals(): return True
    return objectName in dir(builtins)


if MD_REF is None: raise Exception(u"CRITICAL ERROR - moneydance object/variable is None?")
if checkObjectInNameSpace(u"moneydance_extension_loader"):
    MD_EXTENSION_LOADER = moneydance_extension_loader
else:
    MD_EXTENSION_LOADER = None

if (u"__file__" in globals() and __file__.startswith(u"bootstrapped_")): del __file__       # Prevent bootstrapped loader setting this....

from java.lang import System, Runnable
from javax.swing import JFrame, SwingUtilities, SwingWorker
from java.awt.event import WindowEvent

class QuickAbortThisScriptException(Exception): pass

class MyJFrame(JFrame):

    def __init__(self, frameTitle=None):
        super(JFrame, self).__init__(frameTitle)
        self.disposing = False
        self.myJFrameVersion = 4
        self.isActiveInMoneydance = False
        self.isRunTimeExtension = False
        self.MoneydanceAppListener = None
        self.HomePageViewObj = None

    def dispose(self):
        # This removes all content as Java/Swing (often) retains the JFrame reference in memory...
        if self.disposing: return
        try:
            self.disposing = True
            self.getContentPane().removeAll()
            if self.getJMenuBar() is not None: self.setJMenuBar(None)
            super(self.__class__, self).dispose()
        except:
            _msg = "%s: ERROR DISPOSING OF FRAME: %s\n" %(myModuleID, self)
            print(_msg); System.err.write(_msg)
        finally:
            self.disposing = False

class GenericWindowClosingRunnable(Runnable):

    def __init__(self, theFrame):
        self.theFrame = theFrame

    def run(self):
        self.theFrame.setVisible(False)
        self.theFrame.dispatchEvent(WindowEvent(self.theFrame, WindowEvent.WINDOW_CLOSING))

class GenericDisposeRunnable(Runnable):
    def __init__(self, theFrame):
        self.theFrame = theFrame

    def run(self):
        self.theFrame.setVisible(False)
        self.theFrame.dispose()

class GenericVisibleRunnable(Runnable):
    def __init__(self, theFrame, lVisible=True, lToFront=False):
        self.theFrame = theFrame
        self.lVisible = lVisible
        self.lToFront = lToFront

    def run(self):
        self.theFrame.setVisible(self.lVisible)
        if self.lVisible and self.lToFront:
            if self.theFrame.getExtendedState() == JFrame.ICONIFIED:
                self.theFrame.setExtendedState(JFrame.NORMAL)
            self.theFrame.toFront()

def getMyJFrame(moduleName):
    try:
        frames = JFrame.getFrames()
        for fr in frames:
            if (fr.getName().lower().startswith(u"%s_main" %moduleName)
                    and (type(fr).__name__ == MyJFrame.__name__ or type(fr).__name__ == u"MyCOAWindow")  # isinstance() won't work across namespaces
                    and fr.isActiveInMoneydance):
                _msg = "%s: Found live frame: %s (MyJFrame() version: %s)\n" %(myModuleID,fr.getName(),fr.myJFrameVersion)
                print(_msg); System.err.write(_msg)
                if fr.isRunTimeExtension:
                    _msg = "%s: ... and this is a run-time self-installed extension too...\n" %(myModuleID)
                    print(_msg); System.err.write(_msg)
                return fr
    except:
        _msg = "%s: Critical error in getMyJFrame(); caught and ignoring...!\n" %(myModuleID)
        print(_msg); System.err.write(_msg)
    return None


frameToResurrect = None
try:
    # So we check own namespace first for same frame variable...
    if (u"%s_frame_"%myModuleID in globals()
            and (isinstance(toolbox_frame_, MyJFrame)                 # EDIT THIS
                 or type(toolbox_frame_).__name__ == u"MyCOAWindow")  # EDIT THIS
            and toolbox_frame_.isActiveInMoneydance):                 # EDIT THIS
        frameToResurrect = toolbox_frame_                             # EDIT THIS
    else:
        # Now check all frames in the JVM...
        getFr = getMyJFrame( myModuleID )
        if getFr is not None:
            frameToResurrect = getFr
        del getFr
except:
    msg = "%s: Critical error checking frameToResurrect(1); caught and ignoring...!\n" %(myModuleID)
    print(msg); System.err.write(msg)

# ############################
# Trap startup conditions here.... The 'if's pass through to oblivion (and thus a clean exit)... The final 'else' actually runs the script
if int(MD_REF.getBuild()) < MIN_BUILD_REQD:     # Check for builds less than 1904 (version 2019.4) or build 3056 accordingly
    msg = "SORRY YOUR MONEYDANCE VERSION IS TOO OLD FOR THIS SCRIPT/EXTENSION (min build %s required)" %(MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try:    MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif frameToResurrect and frameToResurrect.isRunTimeExtension:
    msg = "%s: Sorry - runtime extension already running. Please uninstall/reinstall properly. Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif not _I_CAN_RUN_AS_MONEYBOT_SCRIPT and u"__file__" in globals():
    msg = "%s: Sorry - this script cannot be run in Moneybot console. Please install mxt and run extension properly. Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif not _I_CAN_RUN_AS_MONEYBOT_SCRIPT and not checkObjectInNameSpace(u"moneydance_extension_loader"):
    msg = "%s: Error - moneydance_extension_loader seems to be missing? Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif frameToResurrect:  # and it's active too...
    try:
        msg = "%s: Detected that %s is already running..... Attempting to resurrect..\n" %(myModuleID, myModuleID)
        print(msg); System.err.write(msg)
        SwingUtilities.invokeLater(GenericVisibleRunnable(frameToResurrect, True, True))
    except:
        msg  = "%s: Failed to resurrect main Frame.. This duplicate Script/extension is now terminating.....\n" %(myModuleID)
        print(msg); System.err.write(msg)
        raise Exception(msg)

else:
    del frameToResurrect
    msg = "%s: Startup conditions passed (and no other instances of this program detected). Now executing....\n" %(myModuleID)
    print(msg); System.err.write(msg)

    # COMMON IMPORTS #######################################################################################################
    # COMMON IMPORTS #######################################################################################################
    # COMMON IMPORTS #######################################################################################################

    global sys
    if "sys" not in globals():
        # NOTE: As of MD2022(4040), python.getSystemState().setdefaultencoding("utf8") is called on the python interpreter at script launch...
        import sys
        reload(sys)                     # Dirty hack to eliminate UTF-8 coding errors
        sys.setdefaultencoding('utf8')  # Without this str() fails on unicode strings...

    import os
    import os.path
    import codecs
    import inspect
    import pickle
    import platform
    import csv
    import datetime
    import traceback
    import subprocess

    from org.python.core.util import FileUtil

    from com.moneydance.util import Platform
    from com.moneydance.awt import JTextPanel, GridC, JDateField
    from com.moneydance.apps.md.view.gui import MDImages

    from com.infinitekind.util import DateUtil, CustomDateFormat, StringUtils

    from com.infinitekind.moneydance.model import *
    from com.infinitekind.moneydance.model import AccountUtil, AcctFilter, CurrencyType, CurrencyUtil
    from com.infinitekind.moneydance.model import Account, Reminder, ParentTxn, SplitTxn, TxnSearch, InvestUtil, TxnUtil

    from com.moneydance.apps.md.controller import AccountBookWrapper, AppEventManager                                   # noqa
    from com.infinitekind.moneydance.model import AccountBook
    from com.infinitekind.tiksync import SyncRecord                                                                     # noqa
    from com.infinitekind.util import StreamTable                                                                       # noqa

    from javax.swing import JButton, JScrollPane, WindowConstants, JLabel, JPanel, JComponent, KeyStroke, JDialog, JComboBox
    from javax.swing import JOptionPane, JTextArea, JMenuBar, JMenu, JMenuItem, AbstractAction, JCheckBoxMenuItem, JFileChooser
    from javax.swing import JTextField, JPasswordField, Box, UIManager, JTable, JCheckBox, JRadioButton, ButtonGroup
    from javax.swing import Timer as SwingTimer

    from javax.swing.text import PlainDocument
    from javax.swing.border import EmptyBorder
    from javax.swing.filechooser import FileFilter

    exec("from javax.print import attribute")       # IntelliJ doesnt like the use of 'print' (as it's a keyword). Messy, but hey!
    exec("from java.awt.print import PrinterJob")   # IntelliJ doesnt like the use of 'print' (as it's a keyword). Messy, but hey!
    global attribute, PrinterJob

    from java.awt.datatransfer import StringSelection
    from javax.swing.text import DefaultHighlighter
    from javax.swing.event import AncestorListener

    from java.awt import Color, Dimension, FileDialog, FlowLayout, Toolkit, Font, GridBagLayout, GridLayout
    from java.awt import BorderLayout, Dialog, Insets, Point
    from java.awt.event import KeyEvent, WindowAdapter, InputEvent
    from java.util import Date, Locale

    from java.text import DecimalFormat, SimpleDateFormat, MessageFormat
    from java.util import Calendar, ArrayList
    from java.lang import Thread, IllegalArgumentException, String, Integer, Long
    from java.lang import Double, Math, Character, NoSuchFieldException, NoSuchMethodException, Boolean
    from java.lang.reflect import Modifier
    from java.io import FileNotFoundException, FilenameFilter, File, FileInputStream, FileOutputStream, IOException, StringReader
    from java.io import BufferedReader, InputStreamReader
    from java.nio.charset import Charset

    if int(MD_REF.getBuild()) >= 3067:
        from com.moneydance.apps.md.view.gui.theme import ThemeInfo                                                     # noqa
    else:
        from com.moneydance.apps.md.view.gui.theme import Theme as ThemeInfo                                            # noqa

    if isinstance(None, (JDateField,CurrencyUtil,Reminder,ParentTxn,SplitTxn,TxnSearch, JComboBox, JCheckBox,
                         AccountBook, AccountBookWrapper, Long, Integer, Boolean,
                         JTextArea, JMenuBar, JMenu, JMenuItem, JCheckBoxMenuItem, JFileChooser, JDialog,
                         JButton, FlowLayout, InputEvent, ArrayList, File, IOException, StringReader, BufferedReader,
                         InputStreamReader, Dialog, JTable, BorderLayout, Double, InvestUtil, JRadioButton, ButtonGroup,
                         AccountUtil, AcctFilter, CurrencyType, Account, TxnUtil, JScrollPane, WindowConstants, JFrame,
                         JComponent, KeyStroke, AbstractAction, UIManager, Color, Dimension, Toolkit, KeyEvent, GridLayout,
                         WindowAdapter, CustomDateFormat, SimpleDateFormat, Insets, FileDialog, Thread, SwingWorker)): pass
    if codecs.BOM_UTF8 is not None: pass
    if csv.QUOTE_ALL is not None: pass
    if datetime.MINYEAR is not None: pass
    if Math.max(1,1): pass
    # END COMMON IMPORTS ###################################################################################################

    # COMMON GLOBALS #######################################################################################################
    # All common globals have now been eliminated :->
    # END COMMON GLOBALS ###################################################################################################
    # COPY >> END

    # SET THESE VARIABLES FOR ALL SCRIPTS ##################################################################################
    if "GlobalVars" in globals():   # Prevent wiping if 'buddy' extension - like Toolbox - is running too...
        global GlobalVars
    else:
        class GlobalVars:        # Started using this method for storing global variables from August 2021
            CONTEXT = MD_REF
            defaultPrintService = None
            defaultPrinterAttributes = None
            defaultPrintFontSize = None
            defaultPrintLandscape = None
            defaultDPI = 72     # NOTE: 72dpi is Java2D default for everything; just go with it. No easy way to change
            STATUS_LABEL = None
            DARK_GREEN = Color(0, 192, 0)
            resetPickleParameters = False
            decimalCharSep = "."
            lGlobalErrorDetected = False
            MYPYTHON_DOWNLOAD_URL = "https://yogi1967.github.io/MoneydancePythonScripts/"
            i_am_an_extension_so_run_headless = None
            parametersLoadedFromFile = {}
            thisScriptName = None
            MD_MDPLUS_BUILD = 4040                          # 2022.0
            MD_ALERTCONTROLLER_BUILD = 4077                 # 2022.3
            def __init__(self): pass    # Leave empty

            class Strings:
                def __init__(self): pass    # Leave empty

    GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME = "gui.current_theme"
    GlobalVars.thisScriptName = u"%s.py(Extension)" %(myModuleID)

    # END SET THESE VARIABLES FOR ALL SCRIPTS ##############################################################################

    # >>> THIS SCRIPT'S IMPORTS ############################################################################################
    import re
    import fnmatch
    import time
    import shutil
    import threading
    from collections import OrderedDict

    from java.lang import Process, NoClassDefFoundError, OutOfMemoryError, InterruptedException, Runtime, UnsupportedOperationException
    from java.lang.ref import WeakReference

    from org.python.core import PySystemState

    from javax.swing import BorderFactory, JSeparator, DefaultComboBoxModel                                                 # noqa
    from javax.swing import JList, ListSelectionModel, DefaultListCellRenderer, DefaultListSelectionModel

    from java.io import ByteArrayInputStream, OutputStream, InputStream, BufferedOutputStream
    from java.net import URL, URLEncoder, URLDecoder                                                                        # noqa
    from java.awt import Component                                                                                          # noqa
    from java.awt import GraphicsEnvironment, Rectangle, GraphicsDevice, Desktop, Event, GridBagConstraints, Window, Frame  # noqa
    from java.awt.event import ComponentAdapter, ItemListener, ItemEvent, HierarchyListener, ActionListener, MouseAdapter   # noqa
    from java.util import UUID, Timer, TimerTask, Map, HashMap, Vector
    from java.util.zip import ZipInputStream, ZipEntry, ZipOutputStream
    from java.nio.charset import StandardCharsets
    from java.nio.file import Paths, Files, StandardCopyOption
    from java.security import MessageDigest, KeyFactory
    from java.security.spec import PKCS8EncodedKeySpec, X509EncodedKeySpec, MGF1ParameterSpec

    from javax.crypto import Cipher, BadPaddingException                                                                # noqa
    from javax.crypto.spec import SecretKeySpec, OAEPParameterSpec, PSource

    from com.google.gson import Gson

    try:
        if Platform.isOSX() and int(MD_REF.getBuild()) >= 3088:
            from com.moneydance.apps.md.view.gui.sync import ICloudSyncConfigurer
            from com.moneydance.apps.md.controller.sync import ICloudContainer
    except: pass

    from com.moneydance.apps.md.view.gui import MoneydanceGUI
    from com.moneydance.apps.md.view.gui.sync import SyncFolderUtil
    from com.moneydance.apps.md.controller import MDException, Util, AppEventListener, PreferencesListener
    from com.moneydance.apps.md.controller import ModuleLoader, ModuleMetaData, LocalStorageCipher, Common, BalanceType
    from com.moneydance.apps.md.controller.sync import MDSyncCipher
    from com.moneydance.apps.md.controller.io import FileUtils, AccountBookUtil
    from com.moneydance.apps.md.controller.olb import MoneybotURLStreamHandlerFactory, CustomURLStreamHandlerFactory
    from com.moneydance.apps.md.controller.olb.ofx import OFXConnection

    from com.infinitekind.util import StreamVector
    from com.infinitekind.util import IOUtils as MDIOUtils
    from com.infinitekind.tiksync import SyncableItem, Syncer

    from com.infinitekind.moneydance.model import ReportSpec, AddressBookEntry, OnlineService, MoneydanceSyncableItem
    from com.infinitekind.moneydance.model import OnlinePayeeList, OnlinePaymentList, InvestFields, AbstractTxn
    from com.infinitekind.moneydance.model import CurrencySnapshot, CurrencySplit, OnlineTxnList, CurrencyTable
    from com.infinitekind.moneydance.model import TxnSet, InvestTxnType, SecurityType, CostCalculation

    from com.infinitekind.moneydance.online import OnlineTxnMerger, OFXAuthInfo
    from com.moneydance.awt import JCurrencyField, AwtUtil                                                              # noqa
    from com.moneydance.security import SecretKeyCallback
    from com.moneydance.apps.md.view.gui import OnlineUpdateTxnsWindow, MDAccountProxy, ConsoleWindow, AboutWindow
    from com.moneydance.apps.md.view.gui import MainFrame, SecondaryFrame, SecondaryWindow, LicenseKeyWindow            # noqa
    from com.moneydance.apps.md.view.gui import WelcomeWindow, SearchRegTxnListModel, SecondaryDialog
    from com.moneydance.apps.md.view.gui.bot import MoneyBotWindow
    from com.moneydance.apps.md.view.gui.txnreg import TxnDetailsPanel, TxnRegister, TxnRegisterType, InvestRegisterType
    from com.moneydance.apps.md.view.gui.txnreg import DownloadedTxnsView
    from com.moneydance.apps.md.view.gui.extensions import ExtensionsWindow                                             # noqa
    from com.moneydance.apps.md.view.gui.sync import DropboxSyncConfigurer
    # from com.moneydance.apps.md.view.gui.sidebar import FullSideBarItemList
    from com.moneydance.apps.md.view.gui.sidebar.nodes import SideBarNodeFactory, SideBarNodeType

    try: from com.infinitekind.moneydance.model import TxnSortOrder
    except: pass
    # >>> END THIS SCRIPT'S IMPORTS ########################################################################################

    # >>> THIS SCRIPT'S GLOBALS ############################################################################################
    GlobalVars.__TOOLBOX = None

    GlobalVars.TOOLBOX_MINIMUM_TESTED_MD_VERSION = 2020.0
    GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION = 2023.2
    GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =   5035
    GlobalVars.MD_OFX_BANK_SETTINGS_DIR = "https://infinitekind.com/app/md/fis/"
    GlobalVars.MD_OFX_DEFAULT_SETTINGS_FILE = "https://infinitekind.com/app/md/fi2004.dict"
    GlobalVars.MD_OFX_DEBUG_SETTINGS_FILE = "https://infinitekind.com/app/md.debug/fi2004.dict"
    GlobalVars.MD_EXTENSIONS_DIRECTORY_FILE = "https://infinitekind.com/app/md/extensions.dct"
    GlobalVars.TOOLBOX_OWN_DICT_URL = "https://raw.githubusercontent.com/yogi1967/MoneydancePythonScripts/master/source/%s/meta_info.dict" %(myModuleID)
    GlobalVars.TOOLBOX_VERSION_VALIDATION_URL = "https://raw.githubusercontent.com/yogi1967/MoneydancePythonScripts/master/source/toolbox/toolbox_version_requirements.dict"
    # Alternatively perhaps use....: "https://raw.githubusercontent.com/TheInfiniteKind/moneydance_open/main/python_scripts/toolbox/toolbox_version_requirements.dict"

    GlobalVars.MD_ICLOUD_ENABLED = 3088                                     # 2021.2 (special beta, but really from 2022.0)
    GlobalVars.MD_RRATE_ISSUE_FIXED_BUILD = 3089                            # 2021.2 (special beta, but really from 2022.0)
    GlobalVars.MD_MDPLUS_TEST_UNIQUE_BANKING_SERVICES_BUILD = 4078          # 2022.4
    GlobalVars.MD_MULTI_OFX_TXN_DNLD_DATES_BUILD = 4074                     # 2022.3
    GlobalVars.MD_MDPLUS_GETPLAIDCLIENT_BUILD = 4090                        # 2022.5
    GlobalVars.MD_KOTLIN_COMPILED_BUILD_ALL = 5008                          # 2023.2 (Entire codebase compiled in Kotlin)

    GlobalVars.fixRCurrencyCheck = 0
    GlobalVars.globalSaveFI_data = None
    GlobalVars.globalSave_DEBUG_FI_data = None

    GlobalVars.mainPnl_preview_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_debug_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_syncing_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_backupWarningsDisabled_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_toolboxUnlocked_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_memory_lbl = JLabel("", JLabel.CENTER)

    GlobalVars.allButtonsList = []
    GlobalVars.TOOLBOX_UNLOCK = False
    GlobalVars.SCRIPT_RUNNING_LOCK = threading.Lock()

    GlobalVars.globalShowDisabledMenuItems = True       # set to False to hide menu items when Update Mode disabled

    GlobalVars.Strings.OFX_LAST_TXN_UPDATE = "ofx_last_txn_update"
    GlobalVars.Strings.MD_KEY_ASOF_PREF = "gen.rec_asof_enabled"
    GlobalVars.Strings.MD_KEY_OLFITID = "ol_fitid_"
    GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW = "applies_to_net_worth"

    GlobalVars.Strings.MD_KEY_STORAGE_5006SYNCFIX = "pre-5006-sync_backtrack"     # MD2023.1(5006) fix for earlier Sync Issue

    GlobalVars.Strings.EXTENSION_QL_ID = "securityquoteload"
    GlobalVars.Strings.EXTENSION_QER_ID = "yahooqt"

    GlobalVars.Strings.TOOLBOX_PREFERENCES_ZAPPER = "toolbox_preferences_zapper"

    GlobalVars.Strings.MD_CONFIGDICT_CURRENT_ACCOUNT_BOOK = "current_accountbook"
    GlobalVars.Strings.MD_CONFIGDICT_BACKUP_TYPE = "backup.backup_type"
    GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES = "external_files"

    GlobalVars.Strings.MD_PLAID_SETTINGS_OBJ_ID = "plaid_settings"

    GlobalVars.Strings.CONFIG_COLWIDTHS = ["bank", "cc", "invest", "security", "loan", "misc", "split","rec_credits","rec_debits","secdetail"]

    GlobalVars.redact = True

    GlobalVars.lCopyAllToClipBoard_TB = False
    GlobalVars.lIgnoreOutdatedExtensions_TB = False
    GlobalVars.lAutoPruneInternalBackups_TB = True
    GlobalVars.lBypassAllBackupsAndDisclaimers_TB = False
    GlobalVars.TOOLBOX_STOP_NOW = False

    GlobalVars.saveSettings_reportAccountNumbers = {}

    # >>> END THIS SCRIPT'S GLOBALS ############################################################################################

    # COPY >> START
    # COMMON CODE ######################################################################################################
    # COMMON CODE ################# VERSION 108 ########################################################################
    # COMMON CODE ######################################################################################################
    GlobalVars.i_am_an_extension_so_run_headless = False
    try:
        GlobalVars.thisScriptName = os.path.basename(__file__)
    except:
        GlobalVars.i_am_an_extension_so_run_headless = True

    scriptExit = """
----------------------------------------------------------------------------------------------------------------------
Thank you for using %s!
The author has other useful Extensions / Moneybot Python scripts available...:

Extension (.mxt) format only:
Toolbox: View Moneydance settings, diagnostics, fix issues, change settings and much more
         + Extension menus: Total selected txns; Move Investment Txns; Zap md+/ofx/qif (default) memo fields;

Custom Balances (net_account_balances): Summary Page (HomePage) widget. Display the total of selected Account Balances

Extension (.mxt) and Script (.py) Versions available:
Extract Data: Extract various data to screen /or csv.. (also auto-extract mode): Includes:
    - StockGlance2020: Securities/stocks, total by security across investment accounts;
    - Reminders; Account register transaction (attachments optional);
    - Investment transactions (attachments optional); Security Balances; Currency price history;
    - Decrypt / extract raw 'Trunk' file; Extract raw data as JSON file; All attachments;

List Future Reminders:                  View future reminders on screen. Allows you to set the days to look forward
Security Performance Graph:             Graphs selected securities, calculating relative price performance as percentage
Accounts Categories Mega Search Window: Combines MD Menu> Tools>Accounts/Categories and adds Quick Search box/capability

A collection of useful ad-hoc scripts (zip file)
useful_scripts:                         Just unzip and select the script you want for the task at hand...

Visit: %s (Author's site)
----------------------------------------------------------------------------------------------------------------------
""" %(GlobalVars.thisScriptName, GlobalVars.MYPYTHON_DOWNLOAD_URL)

    def cleanup_references():
        global MD_REF, MD_REF_UI, MD_EXTENSION_LOADER
        # myPrint("DB","About to delete reference to MD_REF, MD_REF_UI and MD_EXTENSION_LOADER....!")
        # del MD_REF, MD_REF_UI, MD_EXTENSION_LOADER

        GlobalVars.allButtonsList = None
        GlobalVars.mainPnl_backupWarningsDisabled_lbl = None
        GlobalVars.mainPnl_debug_lbl = None
        GlobalVars.mainPnl_memory_lbl = None
        GlobalVars.mainPnl_preview_lbl = None
        GlobalVars.mainPnl_syncing_lbl = None
        GlobalVars.mainPnl_toolboxUnlocked_lbl = None
        GlobalVars.SCRIPT_RUNNING_LOCK = None
        GlobalVars.parametersLoadedFromFile = None

    def load_text_from_stream_file(theStream):
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

        cs = Charset.forName("UTF-8")

        istream = theStream

        if not istream:
            myPrint("B","... Error - the input stream is None")
            return "<NONE>"

        fileContents = ""
        istr = bufr = None
        try:
            istr = InputStreamReader(istream, cs)
            bufr = BufferedReader(istr)
            while True:
                line = bufr.readLine()
                if line is not None:
                    line += "\n"                   # not very efficient - should convert this to "\n".join() to contents
                    fileContents+=line
                    continue
                break
            fileContents+="\n<END>"
        except:
            myPrint("B", "ERROR reading from input stream... ")
            dump_sys_error_to_md_console_and_errorlog()

        try: bufr.close()
        except: pass

        try: istr.close()
        except: pass

        try: istream.close()
        except: pass

        myPrint("DB", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return fileContents

    # P=Display on Python Console, J=Display on MD (Java) Console Error Log, B=Both, D=If Debug Only print, DB=print both
    def myPrint(where, *args):
        if where[0] == "D" and not debug: return

        try:
            printString = ""
            for what in args:
                printString += "%s " %what
            printString = printString.rstrip(" ")

            if where == "P" or where == "B" or where[0] == "D":
                if not GlobalVars.i_am_an_extension_so_run_headless:
                    try:
                        print(printString)
                    except:
                        print("Error writing to screen...")
                        dump_sys_error_to_md_console_and_errorlog()

            if where == "J" or where == "B" or where == "DB":
                dt = datetime.datetime.now().strftime("%Y/%m/%d-%H:%M:%S")
                try:
                    System.err.write(GlobalVars.thisScriptName + ":" + dt + ": ")
                    System.err.write(printString)
                    System.err.write("\n")
                except:
                    System.err.write(GlobalVars.thisScriptName + ":" + dt + ": " + "Error writing to console")
                    dump_sys_error_to_md_console_and_errorlog()

        except IllegalArgumentException:
            myPrint("B","ERROR - Probably on a multi-byte character..... Will ignore as code should just continue (PLEASE REPORT TO DEVELOPER).....")
            dump_sys_error_to_md_console_and_errorlog()

        return


    if debug: myPrint("B", "** DEBUG IS ON **")

    def dump_sys_error_to_md_console_and_errorlog(lReturnText=False):

        tb = traceback.format_exc()
        trace = traceback.format_stack()
        theText =  ".\n" \
                   "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n" \
                   "@@@@@ Unexpected error caught!\n".upper()
        theText += tb
        for trace_line in trace: theText += trace_line
        theText += "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"
        myPrint("B", theText)
        if lReturnText: return theText
        return

    def safeStr(_theText): return ("%s" %(_theText))

    def pad(theText, theLength, padChar=u" "):
        if not isinstance(theText, (unicode, str)): theText = safeStr(theText)
        theText = theText[:theLength].ljust(theLength, padChar)
        return theText

    def rpad(theText, theLength, padChar=u" "):
        if not isinstance(theText, (unicode, str)): theText = safeStr(theText)
        theText = theText[:theLength].rjust(theLength, padChar)
        return theText

    def cpad(theText, theLength, padChar=u" "):
        if not isinstance(theText, (unicode, str)): theText = safeStr(theText)
        if len(theText) >= theLength: return theText[:theLength]
        padLength = int((theLength - len(theText)) / 2)
        theText = theText[:theLength]
        theText = ((padChar * padLength)+theText+(padChar * padLength))[:theLength]
        return theText

    myPrint("B", GlobalVars.thisScriptName, ": Python Script Initialising.......", "Build:", version_build)

    def getMonoFont():
        try:
            theFont = MD_REF.getUI().getFonts().code
            # if debug: myPrint("B","Success setting Font set to Moneydance code: %s" %theFont)
        except:
            theFont = Font("monospaced", Font.PLAIN, 15)
            if debug: myPrint("B","Failed to Font set to Moneydance code - So using: %s" %theFont)

        return theFont

    def isOSXVersionAtLeast(compareVersion):
        # type: (basestring) -> bool
        """Pass a string in the format 'x.x.x'. Will check that this MacOSX version is at least that version. The 3rd micro number is optional"""

        try:
            if not Platform.isOSX(): return False

            def convertVersion(convertString):
                _os_major = _os_minor = _os_micro = 0
                _versionNumbers = []

                for versionPart in StringUtils.splitIntoList(convertString, '.'):
                    strippedPart = StringUtils.stripNonNumbers(versionPart, '.')
                    if (StringUtils.isInteger(strippedPart)):
                        _versionNumbers.append(Integer.valueOf(Integer.parseInt(strippedPart)))
                    else:
                        _versionNumbers.append(0)

                if len(_versionNumbers) >= 1: _os_major = max(0, _versionNumbers[0])
                if len(_versionNumbers) >= 2: _os_minor = max(0, _versionNumbers[1])
                if len(_versionNumbers) >= 3: _os_micro = max(0, _versionNumbers[2])

                return _os_major, _os_minor, _os_micro


            os_major, os_minor, os_micro = convertVersion(System.getProperty("os.version", "0.0.0"))
            myPrint("DB", "MacOS Version number(s): %s.%s.%s" %(os_major, os_minor, os_micro))

            if not isinstance(compareVersion, basestring) or len(compareVersion) < 1:
                myPrint("B", "ERROR: Invalid compareVersion of '%s' passed - returning False" %(compareVersion))
                return False

            chk_os_major, chk_os_minor, chk_os_micro = convertVersion(compareVersion)
            myPrint("DB", "Comparing against Version(s): %s.%s.%s" %(chk_os_major, chk_os_minor, chk_os_micro))


            if os_major < chk_os_major: return False
            if os_major > chk_os_major: return True

            if os_minor < chk_os_minor: return False
            if os_minor > chk_os_minor: return True

            if os_micro < chk_os_micro: return False
            return True

        except:
            myPrint("B", "ERROR: isOSXVersionAtLeast() failed - returning False")
            dump_sys_error_to_md_console_and_errorlog()
            return False

    def isOSXVersionCheetahOrLater():       return isOSXVersionAtLeast("10.0")
    def isOSXVersionPumaOrLater():          return isOSXVersionAtLeast("10.1")
    def isOSXVersionJaguarOrLater():        return isOSXVersionAtLeast("10.2")
    def isOSXVersionPantherOrLater():       return isOSXVersionAtLeast("10.3")
    def isOSXVersionTigerOrLater():         return isOSXVersionAtLeast("10.4")
    def isOSXVersionLeopardOrLater():       return isOSXVersionAtLeast("10.5")
    def isOSXVersionSnowLeopardOrLater():   return isOSXVersionAtLeast("10.6")
    def isOSXVersionLionOrLater():          return isOSXVersionAtLeast("10.7")
    def isOSXVersionMountainLionOrLater():  return isOSXVersionAtLeast("10.8")
    def isOSXVersionMavericksOrLater():     return isOSXVersionAtLeast("10.9")
    def isOSXVersionYosemiteOrLater():      return isOSXVersionAtLeast("10.10")
    def isOSXVersionElCapitanOrLater():     return isOSXVersionAtLeast("10.11")
    def isOSXVersionSierraOrLater():        return isOSXVersionAtLeast("10.12")
    def isOSXVersionHighSierraOrLater():    return isOSXVersionAtLeast("10.13")
    def isOSXVersionMojaveOrLater():        return isOSXVersionAtLeast("10.14")
    def isOSXVersionCatalinaOrLater():      return isOSXVersionAtLeast("10.15")
    def isOSXVersionBigSurOrLater():        return isOSXVersionAtLeast("10.16")  # BigSur is officially 11.0, but started at 10.16
    def isOSXVersionMontereyOrLater():      return isOSXVersionAtLeast("12.0")
    def isOSXVersionVenturaOrLater():       return isOSXVersionAtLeast("13.0")

    def get_home_dir():
        homeDir = None

        # noinspection PyBroadException
        try:
            if Platform.isOSX():
                homeDir = System.getProperty(u"UserHome")  # On a Mac in a Java VM, the homedir is hidden
            else:
                # homeDir = System.getProperty("user.home")
                homeDir = os.path.expanduser(u"~")  # Should work on Unix and Windows
                if homeDir is None or homeDir == u"":
                    homeDir = System.getProperty(u"user.home")
                if homeDir is None or homeDir == u"":
                    homeDir = os.environ.get(u"HOMEPATH")
        except:
            pass

        if homeDir is None or homeDir == u"":
            homeDir = MD_REF.getCurrentAccountBook().getRootFolder().getParent()  # Better than nothing!

        if homeDir is None or homeDir == u"":
            homeDir = u""

        myPrint("DB", "Home Directory detected...:", homeDir)
        return homeDir

    def getDecimalPoint():
        decimalFormat = DecimalFormat.getInstance()
        # noinspection PyUnresolvedReferences
        decimalSymbols = decimalFormat.getDecimalFormatSymbols()

        try:
            _decimalCharSep = decimalSymbols.getDecimalSeparator()
            myPrint(u"D",u"Decimal Point Character: %s" %(_decimalCharSep))
            return _decimalCharSep
        except:
            myPrint(u"B",u"Error in getDecimalPoint() routine....?")
            dump_sys_error_to_md_console_and_errorlog()
        return u"error"


    GlobalVars.decimalCharSep = getDecimalPoint()


    def isMacDarkModeDetected():
        darkResponse = "LIGHT"
        if Platform.isOSX():
            try:
                darkResponse = subprocess.check_output("defaults read -g AppleInterfaceStyle", shell=True)
                darkResponse = darkResponse.strip().lower()
            except: pass
        return ("dark" in darkResponse)

    def isMDThemeDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            try:
                if currentTheme.isSystemDark(): return True     # NOTE: Only VAQua has isSystemDark()
            except: pass
            if "dark" in currentTheme.getThemeID().lower(): return True
            if isMDThemeFlatDark(): return True
            if isMDThemeDarcula(): return True
        except: pass
        return False

    def isMDThemeDarcula():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if isMDThemeFlatDark(): return False                    # Flat Dark pretends to be Darcula!
            if "darcula" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeCustomizable():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if currentTheme.isCustomizable(): return True
        except: pass
        return False

    def isMDThemeHighContrast():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "high_contrast" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeDefault():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "default" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeClassic():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "classic" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeSolarizedLight():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "solarized_light" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeSolarizedDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "solarized_dark" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeFlatDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "flat dark" in currentTheme.toString().lower(): return True
        except: pass
        return False

    def isMDThemeVAQua():
        if Platform.isOSX():
            try:
                # currentTheme = MD_REF.getUI().getCurrentTheme()   # Not reset when changed in-session as it's a "private final" variable >> FIXED (not final) in MD2023.2(5008)
                # if ".vaqua" in safeStr(currentTheme.getClass()).lower(): return True
                currentTheme = ThemeInfo.themeForID(MD_REF.getUI(), MD_REF.getPreferences().getSetting(GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME, ThemeInfo.DEFAULT_THEME_ID))
                if ".vaqua" in currentTheme.getClass().getName().lower(): return True                                   # noqa
            except:
                myPrint("B", "@@ Error in isMDThemeVAQua() - Alert author! Error:", sys.exc_info()[1])
        return False

    def isIntelX86_32bit():
        """Detect Intel x86 32bit system"""
        return String(System.getProperty("os.arch", "null").strip()).toLowerCase(Locale.ROOT) == "x86"

    def getMDIcon(startingIcon=None, lAlwaysGetIcon=False):
        if lAlwaysGetIcon or isIntelX86_32bit():
            return MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png")
        return startingIcon

    # JOptionPane.DEFAULT_OPTION, JOptionPane.YES_NO_OPTION, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.OK_CANCEL_OPTION
    # JOptionPane.ERROR_MESSAGE, JOptionPane.INFORMATION_MESSAGE, JOptionPane.WARNING_MESSAGE, JOptionPane.QUESTION_MESSAGE, JOptionPane.PLAIN_MESSAGE

    # Copies MD_REF.getUI().showInfoMessage (but a newer version now exists in MD internal code)
    def myPopupInformationBox(theParent=None, theMessage="What no message?!", theTitle="Info", theMessageType=JOptionPane.INFORMATION_MESSAGE):

        if theParent is None and (theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE):
            icon = getMDIcon(lAlwaysGetIcon=True)
        else:
            icon = getMDIcon(None)
        JOptionPane.showMessageDialog(theParent, JTextPanel(theMessage), theTitle, theMessageType, icon)

    def wrapLines(message, numChars=40):
        charCount = 0
        result=""
        for ch in message:
            if ch == '\n' or ch == '\r':
                charCount = 0
            elif charCount > numChars and not Character.isWhitespace(ch):
                result+="\n"
                charCount = 0
            else:
                charCount+=1
            result+=ch
        return result

    def myPopupAskBackup(theParent=None, theMessage="What no message?!", lReturnTheTruth=False):

        _options=["STOP", "PROCEED WITHOUT BACKUP", "DO BACKUP NOW"]
        response = JOptionPane.showOptionDialog(theParent,
                                                theMessage,
                                                "PERFORM BACKUP BEFORE UPDATE?",
                                                0,
                                                JOptionPane.WARNING_MESSAGE,
                                                getMDIcon(),
                                                _options,
                                                _options[0])

        if response == 2:
            myPrint("B", "User requested to create a backup before update/fix - calling Moneydance's 'Export Backup' routine...")
            MD_REF.getUI().setStatus("%s is creating a backup...." %(GlobalVars.thisScriptName),-1.0)
            MD_REF.getUI().saveToBackup(None)
            MD_REF.getUI().setStatus("%s create (export) backup process completed...." %(GlobalVars.thisScriptName),0)
            return True

        elif response == 1:
            myPrint("B", "User DECLINED to create a backup before update/fix...!")
            if not lReturnTheTruth:
                return True

        return False

    # Copied MD_REF.getUI().askQuestion
    def myPopupAskQuestion(theParent=None,
                           theTitle="Question",
                           theQuestion="What?",
                           theOptionType=JOptionPane.YES_NO_OPTION,
                           theMessageType=JOptionPane.QUESTION_MESSAGE):

        if theParent is None and (theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE):
            icon = getMDIcon(lAlwaysGetIcon=True)
        else:
            icon = getMDIcon(None)

        # question = wrapLines(theQuestion)
        question = theQuestion
        result = JOptionPane.showConfirmDialog(theParent,
                                               question,
                                               theTitle,
                                               theOptionType,
                                               theMessageType,
                                               icon)
        return result == 0

    # Copies Moneydance .askForQuestion
    def myPopupAskForInput(theParent,
                           theTitle,
                           theFieldLabel,
                           theFieldDescription="",
                           defaultValue=None,
                           isPassword=False,
                           theMessageType=JOptionPane.INFORMATION_MESSAGE):

        if theParent is None and (theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE):
            icon = getMDIcon(lAlwaysGetIcon=True)
        else:
            icon = getMDIcon(None)

        p = JPanel(GridBagLayout())
        defaultText = None
        if defaultValue: defaultText = defaultValue
        if isPassword:
            field = JPasswordField(defaultText)
        else:
            field = JTextField(defaultText)
        field.addAncestorListener(RequestFocusListener())

        _x = 0
        if theFieldLabel:
            p.add(JLabel(theFieldLabel), GridC.getc(_x, 0).east())
            _x+=1

        p.add(field, GridC.getc(_x, 0).field())
        p.add(Box.createHorizontalStrut(244), GridC.getc(_x, 0))
        if theFieldDescription:
            p.add(JTextPanel(theFieldDescription), GridC.getc(_x, 1).field().colspan(_x + 1))
        if (JOptionPane.showConfirmDialog(theParent,
                                          p,
                                          theTitle,
                                          JOptionPane.OK_CANCEL_OPTION,
                                          theMessageType,
                                          icon) == 0):
            return field.getText()
        return None

    # APPLICATION_MODAL, DOCUMENT_MODAL, MODELESS, TOOLKIT_MODAL
    class MyPopUpDialogBox():

        def __init__(self,
                     theParent=None,
                     theStatus="",
                     theMessage="",
                     maxSize=Dimension(0,0),
                     theTitle="Info",
                     lModal=True,
                     lCancelButton=False,
                     OKButtonText="OK",
                     lAlertLevel=0):

            self.theParent = theParent
            self.theStatus = theStatus
            self.theMessage = theMessage
            self.maxSize = maxSize
            self.theTitle = theTitle
            self.lModal = lModal
            self.lCancelButton = lCancelButton
            self.OKButtonText = OKButtonText
            self.lAlertLevel = lAlertLevel
            self.fakeJFrame = None
            self._popup_d = None
            self.lResult = [None]
            self.statusLabel = None
            self.messageJText = None
            if not self.theMessage.endswith("\n"): self.theMessage+="\n"
            if self.OKButtonText == "": self.OKButtonText="OK"
            if isMDThemeDark() or isMacDarkModeDetected(): self.lAlertLevel = 0

        def updateMessages(self, newTitle=None, newStatus=None, newMessage=None, lPack=True):
            # We wait when on the EDT as most scripts execute on the EDT.. So this is probably an in execution update message
            # ... if we invokeLater() then the message will (probably) only appear after the EDT script finishes....
            genericSwingEDTRunner(False, True, self._updateMessages, newTitle, newStatus, newMessage, lPack)

        def _updateMessages(self, newTitle=None, newStatus=None, newMessage=None, lPack=True):
            if not newTitle and not newStatus and not newMessage: return
            if newTitle:
                self.theTitle = newTitle
                self._popup_d.setTitle(self.theTitle)
            if newStatus:
                self.theStatus = newStatus
                self.statusLabel.setText(self.theStatus)
            if newMessage:
                self.theMessage = newMessage
                self.messageJText.setText(self.theMessage)
            if lPack: self._popup_d.pack()

        class WindowListener(WindowAdapter):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def windowClosing(self, WindowEvent):                                                                       # noqa
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                myPrint("DB", "JDialog Frame shutting down....")

                self.lResult[0] = False

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class OKButtonAction(AbstractAction):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def actionPerformed(self, event):
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                self.lResult[0] = True

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class CancelButtonAction(AbstractAction):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def actionPerformed(self, event):
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                self.lResult[0] = False

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        def kill(self):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(GenericVisibleRunnable(self._popup_d, False))
                if self.fakeJFrame is not None:
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self._popup_d))
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self.fakeJFrame))
                else:
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self._popup_d))
            else:
                self._popup_d.setVisible(False)
                if self.fakeJFrame is not None:
                    self._popup_d.dispose()
                    self.fakeJFrame.dispose()
                else:
                    self._popup_d.dispose()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        def result(self): return self.lResult[0]

        def go(self):
            myPrint("DB", "In MyPopUpDialogBox.", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            class MyPopUpDialogBoxRunnable(Runnable):
                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                          # noqa
                    myPrint("DB", "In MyPopUpDialogBoxRunnable.", inspect.currentframe().f_code.co_name, "()")
                    myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                    # Create a fake JFrame so we can set the Icons...
                    if self.callingClass.theParent is None:
                        self.callingClass.fakeJFrame = MyJFrame()
                        self.callingClass.fakeJFrame.setName(u"%s_fake_dialog" %(myModuleID))
                        self.callingClass.fakeJFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)
                        self.callingClass.fakeJFrame.setUndecorated(True)
                        self.callingClass.fakeJFrame.setVisible(False)
                        if not Platform.isOSX():
                            self.callingClass.fakeJFrame.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    class MyJDialog(JDialog):
                        def __init__(self, maxSize, *args):
                            self.maxSize = maxSize                                                                      # type: Dimension
                            super(self.__class__, self).__init__(*args)

                        # On Windows, the height was exceeding the screen height when default size of Dimension (0,0), so set the max....
                        def getPreferredSize(self):
                            calcPrefSize = super(self.__class__, self).getPreferredSize()
                            newPrefSize = Dimension(min(calcPrefSize.width, self.maxSize.width), min(calcPrefSize.height, self.maxSize.height))
                            return newPrefSize

                    screenSize = Toolkit.getDefaultToolkit().getScreenSize()

                    if isinstance(self.callingClass.maxSize, Dimension)\
                            and self.callingClass.maxSize.height and self.callingClass.maxSize.width:
                        maxDialogWidth = min(screenSize.width-20, self.callingClass.maxSize.width)
                        maxDialogHeight = min(screenSize.height-40, self.callingClass.maxSize.height)
                        maxDimension = Dimension(maxDialogWidth,maxDialogHeight)
                    else:
                        maxDialogWidth = min(screenSize.width-20, max(GetFirstMainFrame.DEFAULT_MAX_WIDTH, int(round(GetFirstMainFrame.getSize().width *.9,0))))
                        maxDialogHeight = min(screenSize.height-40, max(GetFirstMainFrame.DEFAULT_MAX_WIDTH, int(round(GetFirstMainFrame.getSize().height *.9,0))))
                        maxDimension = Dimension(maxDialogWidth,maxDialogHeight)

                    # noinspection PyUnresolvedReferences
                    self.callingClass._popup_d = MyJDialog(maxDimension,
                                                           self.callingClass.theParent, self.callingClass.theTitle,
                                                           Dialog.ModalityType.APPLICATION_MODAL if (self.callingClass.lModal) else Dialog.ModalityType.MODELESS)

                    self.callingClass._popup_d.getContentPane().setLayout(BorderLayout())
                    self.callingClass._popup_d.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()

                    # Add standard CMD-W keystrokes etc to close window
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")
                    self.callingClass._popup_d.getRootPane().getActionMap().put("close-window", self.callingClass.CancelButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult))
                    self.callingClass._popup_d.addWindowListener(self.callingClass.WindowListener(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult))

                    if (not Platform.isMac()):
                        # MD_REF.getUI().getImages()
                        self.callingClass._popup_d.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    self.callingClass.messageJText = JTextArea(self.callingClass.theMessage)
                    self.callingClass.messageJText.setFont(getMonoFont())
                    self.callingClass.messageJText.setEditable(False)
                    self.callingClass.messageJText.setLineWrap(False)
                    self.callingClass.messageJText.setWrapStyleWord(False)

                    _popupPanel = JPanel(BorderLayout())
                    _popupPanel.setBorder(EmptyBorder(8, 8, 8, 8))

                    if self.callingClass.theStatus:
                        _statusPnl = JPanel(BorderLayout())
                        self.callingClass.statusLabel = JLabel(self.callingClass.theStatus)
                        self.callingClass.statusLabel.setForeground(getColorBlue())
                        self.callingClass.statusLabel.setBorder(EmptyBorder(8, 0, 8, 0))
                        _popupPanel.add(self.callingClass.statusLabel, BorderLayout.NORTH)

                    myScrollPane = JScrollPane(self.callingClass.messageJText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
                    myScrollPane.setWheelScrollingEnabled(True)
                    _popupPanel.add(myScrollPane, BorderLayout.CENTER)

                    buttonPanel = JPanel()
                    if self.callingClass.lModal or self.callingClass.lCancelButton:
                        buttonPanel.setLayout(FlowLayout(FlowLayout.CENTER))

                        if self.callingClass.lCancelButton:
                            cancel_button = JButton("CANCEL")
                            cancel_button.setPreferredSize(Dimension(100,40))
                            cancel_button.setBackground(Color.LIGHT_GRAY)
                            cancel_button.setBorderPainted(False)
                            cancel_button.setOpaque(True)
                            cancel_button.setBorder(EmptyBorder(8, 8, 8, 8))

                            cancel_button.addActionListener(self.callingClass.CancelButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult) )
                            buttonPanel.add(cancel_button)

                        if self.callingClass.lModal:
                            ok_button = JButton(self.callingClass.OKButtonText)
                            if len(self.callingClass.OKButtonText) <= 2:
                                ok_button.setPreferredSize(Dimension(100,40))
                            else:
                                ok_button.setPreferredSize(Dimension(200,40))

                            ok_button.setBackground(Color.LIGHT_GRAY)
                            ok_button.setBorderPainted(False)
                            ok_button.setOpaque(True)
                            ok_button.setBorder(EmptyBorder(8, 8, 8, 8))
                            ok_button.addActionListener( self.callingClass.OKButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame, self.callingClass.lResult) )
                            buttonPanel.add(ok_button)

                        _popupPanel.add(buttonPanel, BorderLayout.SOUTH)

                    if self.callingClass.lAlertLevel >= 2:
                        # internalScrollPane.setBackground(Color.RED)
                        self.callingClass.messageJText.setBackground(Color.RED)
                        self.callingClass.messageJText.setForeground(Color.BLACK)
                        self.callingClass.messageJText.setOpaque(True)
                        _popupPanel.setBackground(Color.RED)
                        _popupPanel.setForeground(Color.BLACK)
                        _popupPanel.setOpaque(True)
                        buttonPanel.setBackground(Color.RED)
                        buttonPanel.setOpaque(True)

                    elif self.callingClass.lAlertLevel >= 1:
                        # internalScrollPane.setBackground(Color.YELLOW)
                        self.callingClass.messageJText.setBackground(Color.YELLOW)
                        self.callingClass.messageJText.setForeground(Color.BLACK)
                        self.callingClass.messageJText.setOpaque(True)
                        _popupPanel.setBackground(Color.YELLOW)
                        _popupPanel.setForeground(Color.BLACK)
                        _popupPanel.setOpaque(True)
                        buttonPanel.setBackground(Color.YELLOW)
                        buttonPanel.setOpaque(True)

                    self.callingClass._popup_d.add(_popupPanel, BorderLayout.CENTER)
                    self.callingClass._popup_d.pack()
                    self.callingClass._popup_d.setLocationRelativeTo(self.callingClass.theParent)
                    self.callingClass._popup_d.setVisible(True)

            if not SwingUtilities.isEventDispatchThread():
                if not self.lModal:
                    myPrint("DB",".. Not running on the EDT, but also NOT Modal, so will .invokeLater::MyPopUpDialogBoxRunnable()...")
                    SwingUtilities.invokeLater(MyPopUpDialogBoxRunnable(self))
                else:
                    myPrint("DB",".. Not running on the EDT so calling .invokeAndWait::MyPopUpDialogBoxRunnable()...")
                    SwingUtilities.invokeAndWait(MyPopUpDialogBoxRunnable(self))
            else:
                myPrint("DB",".. Already on the EDT, just executing::MyPopUpDialogBoxRunnable() now...")
                MyPopUpDialogBoxRunnable(self).run()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

            return self.lResult[0]

    def play_the_money_sound():

        # Seems to cause a crash on Virtual Machine with no Audio - so just in case....
        try:
            if MD_REF.getPreferences().getSetting("beep_on_transaction_change", "y") == "y":
                MD_REF.getUI().getSounds().playSound("cash_register.wav")
        except:
            pass

        return

    def get_filename_addition():

        cal = Calendar.getInstance()
        hhmm = str(10000 + cal.get(11) * 100 + cal.get(12))[1:]
        nameAddition = "-" + str(DateUtil.getStrippedDateInt()) + "-"+hhmm

        return nameAddition

    def check_file_writable(fnm):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )
        myPrint("DB","Checking path: ", fnm)

        if os.path.exists(fnm):
            myPrint("DB", "path exists..")
            # path exists
            if os.path.isfile(fnm):  # is it a file or a dir?
                myPrint("DB","path is a file..")
                # also works when file is a link and the target is writable
                return os.access(fnm, os.W_OK)
            else:
                myPrint("DB", "path is not a file..")
                return False  # path is a dir, so cannot write as a file
        # target does not exist, check perms on parent dir
        myPrint("DB","path does not exist...")
        pdir = os.path.dirname(fnm)
        if not pdir: pdir = '.'
        # target is creatable if parent dir is writable
        return os.access(pdir, os.W_OK)

    class ExtFilenameFilter(FilenameFilter):
        """File extension filter for FileDialog"""
        def __init__(self, ext): self.ext = "." + ext.upper()                                                           # noqa

        def accept(self, thedir, filename):                                                                             # noqa
            if filename is not None and filename.upper().endswith(self.ext): return True
            return False

    class ExtFileFilterJFC(FileFilter):
        """File extension filter for JFileChooser"""
        def __init__(self, ext): self.ext = "." + ext.upper()

        def getDescription(self): return "*"+self.ext                                                                   # noqa

        def accept(self, _theFile):                                                                                     # noqa
            if _theFile is None: return False
            return _theFile.getName().upper().endswith(self.ext)

    def MDDiag():
        myPrint("D", "Moneydance Build:", MD_REF.getVersion(), "Build:", MD_REF.getBuild())


    MDDiag()

    myPrint("DB","System file encoding is:", sys.getfilesystemencoding() )   # Not used, but interesting. Perhaps useful when switching between Windows/Macs and writing files...

    def checkVersions():
        lError = False
        plat_j = platform.system()
        plat_p = platform.python_implementation()
        python_maj = sys.version_info.major
        python_min = sys.version_info.minor

        myPrint("DB","Platform:", plat_p, plat_j, python_maj, ".", python_min)
        myPrint("DB", sys.version)

        if plat_p != "Jython":
            lError = True
            myPrint("DB", "Error: Script requires Jython")
        if plat_j != "Java":
            lError = True
            myPrint("DB", "Error: Script requires Java  base")
        if (python_maj != 2 or python_min != 7):
            lError = True
            myPrint("DB", "\n\nError: Script was  designed on version 2.7. By all means bypass this test and see what happens.....")

        if lError:
            myPrint("J", "Platform version issue - will terminate script!")
            myPrint("P", "\n@@@ TERMINATING PROGRAM @@@\n")
            raise(Exception("Platform version issue - will terminate script!"))

        return not lError


    checkVersions()

    def setDefaultFonts():
        """Grabs the MD defaultText font, reduces default size down to below 18, sets UIManager defaults (if runtime extension, will probably error, so I catch and skip)"""
        if MD_REF_UI is None: return

        # If a runtime extension, then this may fail, depending on timing... Just ignore and return...
        try:
            myFont = MD_REF.getUI().getFonts().defaultText
        except:
            myPrint("B","ERROR trying to call .getUI().getFonts().defaultText - skipping setDefaultFonts()")
            return

        if myFont is None:
            myPrint("B","WARNING: In setDefaultFonts(): calling .getUI().getFonts().defaultText has returned None (but moneydance_ui was set) - skipping setDefaultFonts()")
            return

        if myFont.getSize()>18:
            try:
                myFont = myFont.deriveFont(16.0)
                myPrint("B", "I have reduced the font size down to point-size 16 - Default Fonts are now set to: %s" %(myFont))
            except:
                myPrint("B","ERROR - failed to override font point size down to 16.... will ignore and continue. Font set to: %s" %(myFont))
        else:
            myPrint("DB", "Attempting to set default font to %s" %myFont)

        try:
            UIManager.getLookAndFeelDefaults().put("defaultFont", myFont )

            # https://thebadprogrammer.com/swing-uimanager-keys/
            UIManager.put("CheckBoxMenuItem.acceleratorFont", myFont)
            UIManager.put("Button.font", myFont)
            UIManager.put("ToggleButton.font", myFont)
            UIManager.put("RadioButton.font", myFont)
            UIManager.put("CheckBox.font", myFont)
            UIManager.put("ColorChooser.font", myFont)
            UIManager.put("ComboBox.font", myFont)
            UIManager.put("Label.font", myFont)
            UIManager.put("List.font", myFont)
            UIManager.put("MenuBar.font", myFont)
            UIManager.put("Menu.acceleratorFont", myFont)
            UIManager.put("RadioButtonMenuItem.acceleratorFont", myFont)
            UIManager.put("MenuItem.acceleratorFont", myFont)
            UIManager.put("MenuItem.font", myFont)
            UIManager.put("RadioButtonMenuItem.font", myFont)
            UIManager.put("CheckBoxMenuItem.font", myFont)
            UIManager.put("OptionPane.buttonFont", myFont)
            UIManager.put("OptionPane.messageFont", myFont)
            UIManager.put("Menu.font", myFont)
            UIManager.put("PopupMenu.font", myFont)
            UIManager.put("OptionPane.font", myFont)
            UIManager.put("Panel.font", myFont)
            UIManager.put("ProgressBar.font", myFont)
            UIManager.put("ScrollPane.font", myFont)
            UIManager.put("Viewport.font", myFont)
            UIManager.put("TabbedPane.font", myFont)
            UIManager.put("Slider.font", myFont)
            UIManager.put("Table.font", myFont)
            UIManager.put("TableHeader.font", myFont)
            UIManager.put("TextField.font", myFont)
            UIManager.put("Spinner.font", myFont)
            UIManager.put("PasswordField.font", myFont)
            UIManager.put("TextArea.font", myFont)
            UIManager.put("TextPane.font", myFont)
            UIManager.put("EditorPane.font", myFont)
            UIManager.put("TabbedPane.smallFont", myFont)
            UIManager.put("TitledBorder.font", myFont)
            UIManager.put("ToolBar.font", myFont)
            UIManager.put("ToolTip.font", myFont)
            UIManager.put("Tree.font", myFont)
            UIManager.put("FormattedTextField.font", myFont)
            UIManager.put("IconButton.font", myFont)
            UIManager.put("InternalFrame.optionDialogTitleFont", myFont)
            UIManager.put("InternalFrame.paletteTitleFont", myFont)
            UIManager.put("InternalFrame.titleFont", myFont)
        except:
            myPrint("B","Failed to set Swing default fonts to use Moneydance defaults... sorry")

        myPrint("DB",".setDefaultFonts() successfully executed...")
        return

    setDefaultFonts()

    def who_am_i():
        try: username = System.getProperty("user.name")
        except: username = "???"
        return username

    def getHomeDir():
        # Yup - this can be all over the place...
        myPrint("D", 'System.getProperty("user.dir")', System.getProperty("user.dir"))
        myPrint("D", 'System.getProperty("UserHome")', System.getProperty("UserHome"))
        myPrint("D", 'System.getProperty("user.home")', System.getProperty("user.home"))
        myPrint("D", 'os.path.expanduser("~")', os.path.expanduser("~"))
        myPrint("D", 'os.environ.get("HOMEPATH")', os.environ.get("HOMEPATH"))
        return

    myPrint("D", "I am user:", who_am_i())
    if debug: getHomeDir()

    # noinspection PyArgumentList
    class JTextFieldLimitYN(PlainDocument):

        limit = 10  # Default
        toUpper = False
        what = ""

        def __init__(self, limit, toUpper, what):

            super(PlainDocument, self).__init__()
            self.limit = limit
            self.toUpper = toUpper
            self.what = what

        def insertString(self, myOffset, myString, myAttr):

            if (myString is None): return
            if self.toUpper: myString = myString.upper()
            if (self.what == "YN" and (myString in "YN")) \
                    or (self.what == "DELIM" and (myString in ";|,")) \
                    or (self.what == "1234" and (myString in "1234")) \
                    or (self.what == "CURR"):
                if ((self.getLength() + len(myString)) <= self.limit):
                    super(JTextFieldLimitYN, self).insertString(myOffset, myString, myAttr)                             # noqa

    def fix_delimiter( theDelimiter ):

        try:
            if sys.version_info.major >= 3: return theDelimiter
            if sys.version_info.major <  2: return str(theDelimiter)

            if sys.version_info.minor >  7: return theDelimiter
            if sys.version_info.minor <  7: return str(theDelimiter)

            if sys.version_info.micro >= 2: return theDelimiter
        except:
            pass

        return str( theDelimiter )

    def get_StuWareSoftSystems_parameters_from_file(myFile="StuWareSoftSystems.dict"):
        global debug    # This global for debug must be here as we set it from loaded parameters

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if GlobalVars.resetPickleParameters:
            myPrint("B", "User has specified to reset parameters... keeping defaults and skipping pickle()")
            GlobalVars.parametersLoadedFromFile = {}
            return

        migratedFilename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(), myFile)

        myPrint("DB", "Now checking for parameter file:", migratedFilename)

        if os.path.exists(migratedFilename):
            myPrint("DB", "loading parameters from (non-encrypted) Pickle file:", migratedFilename)
            myPrint("DB", "Parameter file", migratedFilename, "exists..")
            # Open the file
            try:
                # Really we should open() the file in binary mode and read/write as binary, then we wouldn't get platform differences!
                istr = FileInputStream(migratedFilename)
                load_file = FileUtil.wrap(istr)
                if not Platform.isWindows():
                    load_string = load_file.read().replace('\r', '')    # This allows for files migrated from windows (strip the extra CR)
                else:
                    load_string = load_file.read()

                GlobalVars.parametersLoadedFromFile = pickle.loads(load_string)
                load_file.close()
            except FileNotFoundException:
                myPrint("B", "Error: failed to find parameter file...")
                GlobalVars.parametersLoadedFromFile = None
            except EOFError:
                myPrint("B", "Error: reached EOF on parameter file....")
                GlobalVars.parametersLoadedFromFile = None
            except:
                myPrint("B", "Error opening Pickle File Unexpected error:", sys.exc_info()[0], "Error:", sys.exc_info()[1], "Line:", sys.exc_info()[2].tb_lineno)
                myPrint("B", ">> Will ignore saved parameters, and create a new file...")
                GlobalVars.parametersLoadedFromFile = None

            if GlobalVars.parametersLoadedFromFile is None:
                GlobalVars.parametersLoadedFromFile = {}
                myPrint("DB","Parameters did NOT load, will use defaults..")
            else:
                myPrint("DB","Parameters successfully loaded from file...")
        else:
            myPrint("DB", "Parameter Pickle file does NOT exist - will use default and create new file..")
            GlobalVars.parametersLoadedFromFile = {}

        if not GlobalVars.parametersLoadedFromFile: return

        myPrint("DB","GlobalVars.parametersLoadedFromFile read from file contains...:")
        for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
            myPrint("DB","...variable:", key, GlobalVars.parametersLoadedFromFile[key])

        if GlobalVars.parametersLoadedFromFile.get("debug") is not None: debug = GlobalVars.parametersLoadedFromFile.get("debug")

        myPrint("DB","Parameter file loaded if present and GlobalVars.parametersLoadedFromFile{} dictionary set.....")

        # Now load into memory!
        load_StuWareSoftSystems_parameters_into_memory()

        return

    def save_StuWareSoftSystems_parameters_to_file(myFile="StuWareSoftSystems.dict"):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

        # Don't forget, any parameters loaded earlier will be preserved; just add changed variables....
        GlobalVars.parametersLoadedFromFile["__Author"] = "Stuart Beesley - (c) StuWareSoftSystems"
        GlobalVars.parametersLoadedFromFile["debug"] = debug

        dump_StuWareSoftSystems_parameters_from_memory()

        # Pickle was originally encrypted, no need, migrating to unencrypted
        migratedFilename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(),myFile)

        myPrint("DB","Will try to save parameter file:", migratedFilename)

        ostr = FileOutputStream(migratedFilename)

        myPrint("DB", "about to Pickle.dump and save parameters to unencrypted file:", migratedFilename)

        try:
            save_file = FileUtil.wrap(ostr)
            pickle.dump(GlobalVars.parametersLoadedFromFile, save_file, protocol=0)
            save_file.close()

            myPrint("DB","GlobalVars.parametersLoadedFromFile now contains...:")
            for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
                myPrint("DB","...variable:", key, GlobalVars.parametersLoadedFromFile[key])

        except:
            myPrint("B", "Error - failed to create/write parameter file.. Ignoring and continuing.....")
            dump_sys_error_to_md_console_and_errorlog()

            return

        myPrint("DB","Parameter file written and parameters saved to disk.....")

        return

    def get_time_stamp_as_nice_text(timeStamp, _format=None, lUseHHMMSS=True):

        if _format is None: _format = MD_REF.getPreferences().getShortDateFormat()

        humanReadableDate = ""
        try:
            c = Calendar.getInstance()
            c.setTime(Date(timeStamp))
            longHHMMSSText = " HH:mm:ss(.SSS) Z z zzzz" if (lUseHHMMSS) else ""
            dateFormatter = SimpleDateFormat("%s%s" %(_format, longHHMMSSText))
            humanReadableDate = dateFormatter.format(c.getTime())
        except: pass
        return humanReadableDate

    def currentDateTimeMarker():
        c = Calendar.getInstance()
        dateformat = SimpleDateFormat("_yyyyMMdd_HHmmss")
        _datetime = dateformat.format(c.getTime())
        return _datetime

    def destroyOldFrames(moduleName):
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))
        frames = JFrame.getFrames()
        for fr in frames:
            if fr.getName().lower().startswith(moduleName+"_"):
                myPrint("DB","Found old frame %s and active status is: %s" %(fr.getName(),fr.isActiveInMoneydance))
                try:
                    fr.isActiveInMoneydance = False
                    if not SwingUtilities.isEventDispatchThread():
                        SwingUtilities.invokeLater(GenericVisibleRunnable(fr, False, False))
                        SwingUtilities.invokeLater(GenericDisposeRunnable(fr))  # This should call windowClosed() which should remove MD listeners.....
                    else:
                        fr.setVisible(False)
                        fr.dispose()            # This should call windowClosed() which should remove MD listeners.....
                    myPrint("DB","disposed of old frame: %s" %(fr.getName()))
                except:
                    myPrint("B","Failed to dispose old frame: %s" %(fr.getName()))
                    dump_sys_error_to_md_console_and_errorlog()

    def classPrinter(className, theObject):
        try:
            text = "Class: %s %s@{:x}".format(System.identityHashCode(theObject)) %(className, theObject.__class__)
        except:
            text = "Error in classPrinter(): %s: %s" %(className, theObject)
        return text

    def getColorBlue():
        # if not isMDThemeDark() and not isMacDarkModeDetected(): return(MD_REF.getUI().getColors().reportBlueFG)
        # return (MD_REF.getUI().getColors().defaultTextForeground)
        return MD_REF.getUI().getColors().reportBlueFG

    def getColorRed(): return (MD_REF.getUI().getColors().errorMessageForeground)

    def getColorDarkGreen(): return (MD_REF.getUI().getColors().budgetHealthyColor)

    def setDisplayStatus(_theStatus, _theColor=None):
        """Sets the Display / Status label on the main diagnostic display: G=Green, B=Blue, R=Red, DG=Dark Green"""

        if GlobalVars.STATUS_LABEL is None or not isinstance(GlobalVars.STATUS_LABEL, JLabel): return

        class SetDisplayStatusRunnable(Runnable):
            def __init__(self, _status, _color):
                self.status = _status; self.color = _color

            def run(self):
                GlobalVars.STATUS_LABEL.setText((_theStatus))
                if self.color is None or self.color == "": self.color = "X"
                self.color = self.color.upper()
                if self.color == "R":    GlobalVars.STATUS_LABEL.setForeground(getColorRed())
                elif self.color == "B":  GlobalVars.STATUS_LABEL.setForeground(getColorBlue())
                elif self.color == "DG": GlobalVars.STATUS_LABEL.setForeground(getColorDarkGreen())
                else:                    GlobalVars.STATUS_LABEL.setForeground(MD_REF.getUI().getColors().defaultTextForeground)

        if not SwingUtilities.isEventDispatchThread():
            SwingUtilities.invokeLater(SetDisplayStatusRunnable(_theStatus, _theColor))
        else:
            SetDisplayStatusRunnable(_theStatus, _theColor).run()

    def setJFileChooserParameters(_jf, lReportOnly=False, lDefaults=False, lPackagesT=None, lApplicationsT=None, lOptionsButton=None, lNewFolderButton=None):
        """sets up Client Properties for JFileChooser() to behave as required >> Mac only"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not Platform.isOSX(): return
        if not isinstance(_jf, JFileChooser): return

        _PKG = "JFileChooser.packageIsTraversable"
        _APP = "JFileChooser.appBundleIsTraversable"
        _OPTIONS = "JFileChooser.optionsPanelEnabled"
        _NEWFOLDER = "JFileChooser.canCreateDirectories"

        # JFileChooser defaults: https://violetlib.org/vaqua/filechooser.html
        # "JFileChooser.packageIsTraversable"   default False   >> set "true" to allow Packages to be traversed
        # "JFileChooser.appBundleIsTraversable" default False   >> set "true" to allow App Bundles to be traversed
        # "JFileChooser.optionsPanelEnabled"    default False   >> set "true" to allow Options button
        # "JFileChooser.canCreateDirectories"   default False   >> set "true" to allow New Folder button

        if debug or lReportOnly:
            myPrint("B", "Parameters set: ReportOnly: %s, Defaults:%s, PackagesT: %s, ApplicationsT:%s, OptionButton:%s, NewFolderButton: %s" %(lReportOnly, lDefaults, lPackagesT, lApplicationsT, lOptionsButton, lNewFolderButton))
            txt = ("Before setting" if not lReportOnly else "Reporting only")
            for setting in [_PKG, _APP, _OPTIONS, _NEWFOLDER]: myPrint("DB", "%s: '%s': '%s'" %(pad(txt,14), pad(setting,50), _jf.getClientProperty(setting)))
            if lReportOnly: return

        if lDefaults:
            _jf.putClientProperty(_PKG, None)
            _jf.putClientProperty(_APP, None)
            _jf.putClientProperty(_OPTIONS, None)
            _jf.putClientProperty(_NEWFOLDER, None)
        else:
            if lPackagesT       is not None: _jf.putClientProperty(_PKG, lPackagesT)
            if lApplicationsT   is not None: _jf.putClientProperty(_APP, lApplicationsT)
            if lOptionsButton   is not None: _jf.putClientProperty(_OPTIONS, lOptionsButton)
            if lNewFolderButton is not None: _jf.putClientProperty(_NEWFOLDER, lNewFolderButton)

        for setting in [_PKG, _APP, _OPTIONS, _NEWFOLDER]: myPrint("DB", "%s: '%s': '%s'" %(pad("After setting",14), pad(setting,50), _jf.getClientProperty(setting)))

        return

    def setFileDialogParameters(lReportOnly=False, lDefaults=False, lSelectDirectories=None, lPackagesT=None):
        """sets up System Properties for FileDialog() to behave as required >> Mac only"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not Platform.isOSX(): return

        _TRUE = "true"
        _FALSE = "false"

        _DIRS_FD = "apple.awt.fileDialogForDirectories"        # When True you can select a Folder (rather than a file)
        _PKGS_FD = "apple.awt.use-file-dialog-packages"        # When True allows you to select a 'bundle' as a file; False means navigate inside the bundle
        # "com.apple.macos.use-file-dialog-packages"           # DEPRECATED since Monterrey - discovered this about MD2022.5(4090) - refer: java.desktop/sun/lwawt/macosx/CFileDialog.java

        # FileDialog defaults
        # "apple.awt.fileDialogForDirectories"       default "false" >> set "true"  to allow Directories to be selected
        # "apple.awt.use-file-dialog-packages"       default "true"  >> set "false" to allow access to Mac 'packages'

        if debug or lReportOnly:
            myPrint("B", "Parameters set: ReportOnly: %s, Defaults:%s, SelectDirectories:%s, PackagesT:%s" % (lReportOnly, lDefaults, lSelectDirectories, lPackagesT))
            txt = ("Before setting" if not lReportOnly else "Reporting only")
            for setting in [_DIRS_FD, _PKGS_FD]: myPrint("DB", "%s: '%s': '%s'" %(pad(txt,14), pad(setting,50), System.getProperty(setting)))
            if lReportOnly: return

        if lDefaults:
            System.setProperty(_DIRS_FD,_FALSE)
            System.setProperty(_PKGS_FD,_TRUE)
        else:
            if lSelectDirectories is not None: System.setProperty(_DIRS_FD, (_TRUE if lSelectDirectories   else _FALSE))
            if lPackagesT         is not None: System.setProperty(_PKGS_FD, (_TRUE if lPackagesT           else _FALSE))

        for setting in [_DIRS_FD, _PKGS_FD]: myPrint("DB", "After setting:  '%s': '%s'" %(pad(setting,50), System.getProperty(setting)))

        return

    def getFileFromFileChooser(fileChooser_parent,                  # The Parent Frame, or None
                               fileChooser_starting_dir,            # The Starting Dir
                               fileChooser_filename,                # Default filename (or None)
                               fileChooser_title,                   # The Title (with FileDialog, only works on SAVE)
                               fileChooser_multiMode,               # Normally False (True has not been coded!)
                               fileChooser_open,                    # True for Open/Load, False for Save
                               fileChooser_selectFiles,             # True for files, False for Directories
                               fileChooser_OK_text,                 # Normally None, unless set - use text
                               fileChooser_fileFilterText=None,     # E.g. "txt" or "qif"
                               lForceJFC=False,
                               lForceFD=False,
                               lAllowTraversePackages=None,
                               lAllowTraverseApplications=None,     # JFileChooser only..
                               lAllowNewFolderButton=True,          # JFileChooser only..
                               lAllowOptionsButton=None):           # JFileChooser only..
        """Launches FileDialog on Mac, or JFileChooser on other platforms... NOTE: Do not use Filter on Macs!"""

        _THIS_METHOD_NAME = "Dynamic File Chooser"

        if fileChooser_multiMode:
            myPrint("B","@@ SORRY Multi File Selection Mode has not been coded! Exiting...")
            return None

        if fileChooser_starting_dir is None or fileChooser_starting_dir == "" or not os.path.exists(fileChooser_starting_dir):
            fileChooser_starting_dir = MD_REF.getPreferences().getSetting("gen.data_dir", None)

        if fileChooser_starting_dir is None or not os.path.exists(fileChooser_starting_dir):
            fileChooser_starting_dir = None
            myPrint("B","ERROR: Starting Path does not exist - will start with no starting path set..")

        else:
            myPrint("DB", "Preparing the Dynamic File Chooser with path: %s" %(fileChooser_starting_dir))
            if Platform.isOSX() and "/Library/Containers/" in fileChooser_starting_dir:
                myPrint("DB", "WARNING: Folder will be restricted by MacOSx...")
                if not lForceJFC:
                    txt = ("FileDialog: MacOSx restricts Java Access to 'special' locations like 'Library\n"
                          "Folder: %s\n"
                          "Please navigate to this location manually in the next popup. This grants permission"
                          %(fileChooser_starting_dir))
                else:
                    txt = ("JFileChooser: MacOSx restricts Java Access to 'special' locations like 'Library\n"
                          "Folder: %s\n"
                          "Your files will probably be hidden.. If so, switch to FileDialog()...(contact author)"
                          %(fileChooser_starting_dir))
                MyPopUpDialogBox(fileChooser_parent,
                                 "NOTE: Mac Security Restriction",
                                 txt,
                                 theTitle=_THIS_METHOD_NAME,
                                 lAlertLevel=1).go()

        if (Platform.isOSX() and not lForceJFC) or lForceFD:

            setFileDialogParameters(lPackagesT=lAllowTraversePackages, lSelectDirectories=(not fileChooser_selectFiles))

            myPrint("DB", "Preparing FileDialog() with path: %s" %(fileChooser_starting_dir))
            if fileChooser_filename is not None: myPrint("DB", "... and filename:                 %s" %(fileChooser_filename))

            fileDialog = FileDialog(fileChooser_parent, fileChooser_title)

            fileDialog.setTitle(fileChooser_title)

            if fileChooser_starting_dir is not None:    fileDialog.setDirectory(fileChooser_starting_dir)
            if fileChooser_filename is not None:        fileDialog.setFile(fileChooser_filename)

            fileDialog.setMultipleMode(fileChooser_multiMode)

            if fileChooser_open:
                fileDialog.setMode(FileDialog.LOAD)
            else:
                fileDialog.setMode(FileDialog.SAVE)

            # if fileChooser_fileFilterText is not None and (not Platform.isOSX() or not Platform.isOSXVersionAtLeast("10.13")):
            if fileChooser_fileFilterText is not None and (not Platform.isOSX() or isOSXVersionMontereyOrLater()):
                myPrint("DB",".. Adding file filter for: %s" %(fileChooser_fileFilterText))
                fileDialog.setFilenameFilter(ExtFilenameFilter(fileChooser_fileFilterText))

            fileDialog.setVisible(True)

            setFileDialogParameters(lDefaults=True)

            myPrint("DB", "FileDialog returned File:      %s" %(fileDialog.getFile()))
            myPrint("DB", "FileDialog returned Directory: %s" %(fileDialog.getDirectory()))

            if fileDialog.getFile() is None or fileDialog.getFile() == "": return None

            _theFile = os.path.join(fileDialog.getDirectory(), fileDialog.getFile())

        else:

            myPrint("DB", "Preparing JFileChooser() with path: %s" %(fileChooser_starting_dir))
            if fileChooser_filename is not None: myPrint("DB", "... and filename:                   %s" %(fileChooser_filename))

            if fileChooser_starting_dir is not None:
                jfc = JFileChooser(fileChooser_starting_dir)
            else:
                jfc = JFileChooser()

            if fileChooser_filename is not None: jfc.setSelectedFile(File(fileChooser_filename))
            setJFileChooserParameters(jfc,
                                      lPackagesT=lAllowTraversePackages,
                                      lApplicationsT=lAllowTraverseApplications,
                                      lNewFolderButton=lAllowNewFolderButton,
                                      lOptionsButton=lAllowOptionsButton)

            jfc.setDialogTitle(fileChooser_title)
            jfc.setMultiSelectionEnabled(fileChooser_multiMode)

            if fileChooser_selectFiles:
                jfc.setFileSelectionMode(JFileChooser.FILES_ONLY)         # FILES_ONLY, DIRECTORIES_ONLY, FILES_AND_DIRECTORIES
            else:
                jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)   # FILES_ONLY, DIRECTORIES_ONLY, FILES_AND_DIRECTORIES

            # if fileChooser_fileFilterText is not None and (not Platform.isOSX() or not Platform.isOSXVersionAtLeast("10.13")):
            if fileChooser_fileFilterText is not None and (not Platform.isOSX() or isOSXVersionMontereyOrLater()):
                myPrint("DB",".. Adding file filter for: %s" %(fileChooser_fileFilterText))
                jfc.setFileFilter(ExtFileFilterJFC(fileChooser_fileFilterText))

            if fileChooser_OK_text is not None:
                returnValue = jfc.showDialog(fileChooser_parent, fileChooser_OK_text)
            else:
                if fileChooser_open:
                    returnValue = jfc.showOpenDialog(fileChooser_parent)
                else:
                    returnValue = jfc.showSaveDialog(fileChooser_parent)

            if returnValue == JFileChooser.CANCEL_OPTION \
                    or (jfc.getSelectedFile() is None or jfc.getSelectedFile().getName()==""):
                myPrint("DB","JFileChooser was cancelled by user, or no file was selected...")
                return None

            _theFile = jfc.getSelectedFile().getAbsolutePath()
            myPrint("DB","JFileChooser returned File/path..: %s" %(_theFile))

        myPrint("DB","...File/path exists..: %s" %(os.path.exists(_theFile)))
        return _theFile

    class RequestFocusListener(AncestorListener):
        """Add this Listener to a JTextField by using .addAncestorListener(RequestFocusListener()) before calling JOptionPane.showOptionDialog()"""

        def __init__(self, removeListener=True):
            self.removeListener = removeListener

        def ancestorAdded(self, e):
            component = e.getComponent()
            component.requestFocusInWindow()
            component.selectAll()
            if (self.removeListener): component.removeAncestorListener(self)

        def ancestorMoved(self, e): pass
        def ancestorRemoved(self, e): pass

    class SearchAction(AbstractAction):

        def __init__(self, theFrame, searchJText):
            self.theFrame = theFrame
            self.searchJText = searchJText
            self.lastSearch = ""
            self.lastPosn = -1
            self.previousEndPosn = -1
            self.lastDirection = 0

        def actionPerformed(self, event):
            myPrint("D","in SearchAction(), Event: ", event)

            p = JPanel(FlowLayout())
            lbl = JLabel("Enter the search text:")
            tf = JTextField(self.lastSearch,20)
            p.add(lbl)
            p.add(tf)

            tf.addAncestorListener(RequestFocusListener())

            _search_options = [ "Next", "Previous", "Cancel" ]

            defaultDirection = _search_options[self.lastDirection]

            response = JOptionPane.showOptionDialog(self.theFrame,
                                                    p,
                                                    "Search for text",
                                                    JOptionPane.OK_CANCEL_OPTION,
                                                    JOptionPane.QUESTION_MESSAGE,
                                                    getMDIcon(None),
                                                    _search_options,
                                                    defaultDirection)

            lSwitch = False
            if (response == 0 or response == 1):
                if response != self.lastDirection: lSwitch = True
                self.lastDirection = response
                searchWhat = tf.getText()
            else:
                searchWhat = None

            del p, lbl, tf, _search_options

            if not searchWhat or searchWhat == "": return

            theText = self.searchJText.getText().lower()
            highlighter = self.searchJText.getHighlighter()
            highlighter.removeAllHighlights()

            startPos = 0

            if response == 0:
                direction = "[forwards]"
                if searchWhat == self.lastSearch:
                    startPos = self.lastPosn
                    if lSwitch: startPos=startPos+len(searchWhat)+1
                self.lastSearch = searchWhat

                # if startPos+len(searchWhat) >= len(theText):
                #     startPos = 0
                #
                pos = theText.find(searchWhat.lower(),startPos)     # noqa
                myPrint("DB", "Search %s Pos: %s, searchWhat: '%s', startPos: %s, endPos: %s" %(direction, pos, searchWhat,startPos, -1))

            else:
                direction = "[backwards]"
                endPos = len(theText)-1

                if searchWhat == self.lastSearch:
                    if self.previousEndPosn < 0: self.previousEndPosn = len(theText)-1
                    endPos = max(0,self.previousEndPosn)
                    if lSwitch: endPos = max(0,self.lastPosn-1)

                self.lastSearch = searchWhat

                pos = theText.rfind(searchWhat.lower(),startPos,endPos)     # noqa
                myPrint("DB", "Search %s Pos: %s, searchWhat: '%s', startPos: %s, endPos: %s" %(direction, pos, searchWhat,startPos,endPos))

            if pos >= 0:
                self.searchJText.setCaretPosition(pos)
                try:
                    highlighter.addHighlight(pos,min(pos+len(searchWhat),len(theText)),DefaultHighlighter.DefaultPainter)
                except: pass
                if response == 0:
                    self.lastPosn = pos+len(searchWhat)
                    self.previousEndPosn = len(theText)-1
                else:
                    self.lastPosn = pos-len(searchWhat)
                    self.previousEndPosn = pos-1
            else:
                self.lastPosn = 0
                self.previousEndPosn = len(theText)-1
                myPopupInformationBox(self.theFrame,"Searching %s text not found" %direction)

            return

    def saveOutputFile(_theFrame, _theTitle, _fileName, _theText):

        theTitle = "Select location to save the current displayed output... (CANCEL=ABORT)"
        copyToFile = getFileFromFileChooser(_theFrame,          # Parent frame or None
                                            get_home_dir(),     # Starting path
                                            _fileName,          # Default Filename
                                            theTitle,           # Title
                                            False,              # Multi-file selection mode
                                            False,              # True for Open/Load, False for Save
                                            True,               # True = Files, else Dirs
                                            None,               # Load/Save button text, None for defaults
                                            "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if copyToFile is None or copyToFile == "":
            return
        elif not safeStr(copyToFile).endswith(".txt"):
            myPopupInformationBox(_theFrame, "Sorry - please use a .txt file extension when saving output txt")
            return
        elif ".moneydance" in os.path.dirname(copyToFile):
            myPopupInformationBox(_theFrame, "Sorry, please choose a location outside of the Moneydance location")
            return

        if not check_file_writable(copyToFile):
            myPopupInformationBox(_theFrame, "Sorry, that file/location does not appear allowed by the operating system!?")

        toFile = copyToFile
        try:
            with open(toFile, 'w') as f: f.write(_theText)
            myPrint("B", "%s: text output copied to: %s" %(_theTitle, toFile))

            if os.path.exists(toFile):
                play_the_money_sound()
                txt = "%s: Output text saved as requested to: %s" %(_theTitle, toFile)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(_theFrame, txt)
            else:
                txt = "ERROR - failed to write output text to file: %s" %(toFile)
                myPrint("B", txt)
                myPopupInformationBox(_theFrame, txt)
        except:
            txt = "ERROR - failed to write output text to file: %s" %(toFile)
            dump_sys_error_to_md_console_and_errorlog()
            myPopupInformationBox(_theFrame, txt)

        return

    if MD_REF_UI is not None:       # Only action if the UI is loaded - e.g. scripts (not run time extensions)
        try: GlobalVars.defaultPrintFontSize = eval("MD_REF.getUI().getFonts().print.getSize()")   # Do this here as MD_REF disappears after script ends...
        except: GlobalVars.defaultPrintFontSize = 12
    else:
        GlobalVars.defaultPrintFontSize = 12

    ####################################################################################################################
    # PRINTING UTILITIES...: Points to MM, to Inches, to Resolution: Conversion routines etc
    _IN2MM = 25.4; _IN2CM = 2.54; _IN2PT = 72
    def pt2dpi(_pt,_resolution):    return _pt * _resolution / _IN2PT
    def mm2pt(_mm):                 return _mm * _IN2PT / _IN2MM
    def mm2mpt(_mm):                return _mm * 1000 * _IN2PT / _IN2MM
    def pt2mm(_pt):                 return round(_pt * _IN2MM / _IN2PT, 1)
    def mm2in(_mm):                 return _mm / _IN2MM
    def in2mm(_in):                 return _in * _IN2MM
    def in2mpt(_in):                return _in * _IN2PT * 1000
    def in2pt(_in):                 return _in * _IN2PT
    def mpt2in(_mpt):               return _mpt / _IN2PT / 1000
    def mm2px(_mm, _resolution):    return mm2in(_mm) * _resolution
    def mpt2px(_mpt, _resolution):  return mpt2in(_mpt) * _resolution

    def printDeducePrintableWidth(_thePageFormat, _pAttrs):

        _BUFFER_PCT = 0.95

        myPrint("DB", "PageFormat after user dialog: Portrait=%s Landscape=%s W: %sMM(%spts) H: %sMM(%spts) Paper: %s Paper W: %sMM(%spts) H: %sMM(%spts)"
                %(_thePageFormat.getOrientation()==_thePageFormat.PORTRAIT, _thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE,
                  pt2mm(_thePageFormat.getWidth()),_thePageFormat.getWidth(), pt2mm(_thePageFormat.getHeight()),_thePageFormat.getHeight(),
                  _thePageFormat.getPaper(),
                  pt2mm(_thePageFormat.getPaper().getWidth()), _thePageFormat.getPaper().getWidth(), pt2mm(_thePageFormat.getPaper().getHeight()), _thePageFormat.getPaper().getHeight()))

        if _pAttrs.get(attribute.standard.MediaSizeName):
            myPrint("DB", "Requested Media: %s" %(_pAttrs.get(attribute.standard.MediaSizeName)))

        if not _pAttrs.get(attribute.standard.MediaPrintableArea):
            raise Exception("ERROR: MediaPrintableArea not present in pAttrs!?")

        mediaPA = _pAttrs.get(attribute.standard.MediaPrintableArea)
        myPrint("DB", "MediaPrintableArea settings from Printer Attributes..: w%sMM h%sMM MediaPrintableArea: %s, getPrintableArea: %s "
                % (mediaPA.getWidth(attribute.standard.MediaPrintableArea.MM),
                   mediaPA.getHeight(attribute.standard.MediaPrintableArea.MM),
                   mediaPA, mediaPA.getPrintableArea(attribute.standard.MediaPrintableArea.MM)))

        if (_thePageFormat.getOrientation()==_thePageFormat.PORTRAIT):
            deducedWidthMM = mediaPA.getWidth(attribute.standard.MediaPrintableArea.MM)
        elif (_thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE):
            deducedWidthMM = mediaPA.getHeight(attribute.standard.MediaPrintableArea.MM)
        else:
            raise Exception("ERROR: thePageFormat.getOrientation() was not PORTRAIT or LANDSCAPE!?")

        myPrint("DB","Paper Orientation: %s" %("LANDSCAPE" if _thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE else "PORTRAIT"))

        _maxPaperWidthPTS = mm2px(deducedWidthMM, GlobalVars.defaultDPI)
        _maxPaperWidthPTS_buff = _maxPaperWidthPTS * _BUFFER_PCT

        myPrint("DB", "MediaPrintableArea: deduced printable width: %sMM(%sPTS) (using factor of *%s = %sPTS)" %(round(deducedWidthMM,1), round(_maxPaperWidthPTS,1), _BUFFER_PCT, _maxPaperWidthPTS_buff))
        return deducedWidthMM, _maxPaperWidthPTS, _maxPaperWidthPTS_buff

    def loadDefaultPrinterAttributes(_pAttrs=None):

        if _pAttrs is None:
            _pAttrs = attribute.HashPrintRequestAttributeSet()
        else:
            _pAttrs.clear()

        # Refer: https://docs.oracle.com/javase/7/docs/api/javax/print/attribute/standard/package-summary.html
        _pAttrs.add(attribute.standard.DialogTypeSelection.NATIVE)
        if GlobalVars.defaultPrintLandscape:
            _pAttrs.add(attribute.standard.OrientationRequested.LANDSCAPE)
        else:
            _pAttrs.add(attribute.standard.OrientationRequested.PORTRAIT)
        _pAttrs.add(attribute.standard.Chromaticity.MONOCHROME)
        _pAttrs.add(attribute.standard.JobSheets.NONE)
        _pAttrs.add(attribute.standard.Copies(1))
        _pAttrs.add(attribute.standard.PrintQuality.NORMAL)

        return _pAttrs

    def printOutputFile(_callingClass=None, _theTitle=None, _theJText=None, _theString=None):

        # Possible future modification, leverage MDPrinter, and it's classes / methods to save/load preferences and create printers
        try:
            if _theJText is None and _theString is None: return
            if _theJText is not None and len(_theJText.getText()) < 1: return
            if _theString is not None and len(_theString) < 1: return

            # Make a new one for printing
            if _theJText is not None:
                printJTextArea = JTextArea(_theJText.getText())
            else:
                printJTextArea = JTextArea(_theString)

            printJTextArea.setEditable(False)
            printJTextArea.setLineWrap(True)    # As we are reducing the font size so that the width fits the page width, this forces any remainder to wrap
            # if _callingClass is not None: printJTextArea.setLineWrap(_callingClass.lWrapText)  # Mirror the word wrap set by user
            printJTextArea.setWrapStyleWord(False)
            printJTextArea.setOpaque(False); printJTextArea.setBackground(Color(0,0,0,0)); printJTextArea.setForeground(Color.BLACK)
            printJTextArea.setBorder(EmptyBorder(0, 0, 0, 0))

            # IntelliJ doesnt like the use of 'print' (as it's a keyword)
            try:
                if checkObjectInNameSpace("MD_REF"):
                    usePrintFontSize = eval("MD_REF.getUI().getFonts().print.getSize()")
                elif checkObjectInNameSpace("moneydance"):
                    usePrintFontSize = eval("moneydance.getUI().getFonts().print.getSize()")
                else:
                    usePrintFontSize = GlobalVars.defaultPrintFontSize  # Just in case cleanup_references() has tidied up once script ended
            except:
                usePrintFontSize = 12   # Font print did not exist before build 3036

            theFontToUse = getMonoFont()       # Need Monospaced font, but with the font set in MD preferences for print
            theFontToUse = theFontToUse.deriveFont(float(usePrintFontSize))
            printJTextArea.setFont(theFontToUse)

            def computeFontSize(_theComponent, _maxPaperWidth, _dpi):

                # Auto shrink font so that text fits on one line when printing
                # Note: Java seems to operate it's maths at 72DPI (so must factor that into the maths)
                try:
                    _DEFAULT_MIN_WIDTH = mm2px(100, _dpi)   # 100MM
                    _minFontSize = 5                        # Below 5 too small
                    theString = _theComponent.getText()
                    _startingComponentFont = _theComponent.getFont()

                    if not theString or len(theString) < 1: return -1

                    fm = _theComponent.getFontMetrics(_startingComponentFont)
                    _maxFontSize = curFontSize = _startingComponentFont.getSize()   # Max out at the MD default for print font size saved in preferences
                    myPrint("DB","Print - starting font:", _startingComponentFont)
                    myPrint("DB","... calculating.... The starting/max font size is:", curFontSize)

                    maxLineWidthInFile = _DEFAULT_MIN_WIDTH
                    longestLine = ""
                    for line in theString.split("\n"):              # Look for the widest line adjusted for font style
                        _w = pt2dpi(fm.stringWidth(line), _dpi)
                        # myPrint("DB", "Found line (len: %s):" %(len(line)), line)
                        # myPrint("DB", "...calculated length metrics: %s/%sPTS (%sMM)" %(fm.stringWidth(line), _w, pt2mm(_w)))
                        if _w > maxLineWidthInFile:
                            longestLine = line
                            maxLineWidthInFile = _w
                    myPrint("DB","longest line width %s chars; maxLineWidthInFile now: %sPTS (%sMM)" %(len(longestLine),maxLineWidthInFile, pt2mm(maxLineWidthInFile)))

                    # Now shrink the font size to fit.....
                    while (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi) > _maxPaperWidth):
                        myPrint("DB","At font size: %s; (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi):" %(curFontSize), (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), pt2mm(pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), "MM", " >> max width:", _maxPaperWidth)
                        curFontSize -= 1
                        fm = _theComponent.getFontMetrics(Font(_startingComponentFont.getName(), _startingComponentFont.getStyle(), curFontSize))
                        myPrint("DB","... next will be: at font size: %s; (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi):" %(curFontSize), (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), pt2mm(pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), "MM")

                        myPrint("DB","... calculating.... length of line still too long... reducing font size to:", curFontSize)
                        if curFontSize < _minFontSize:
                            myPrint("DB","... calculating... Next font size is too small... exiting the reduction loop...")
                            break

                    if not Platform.isMac():
                        curFontSize -= 1   # For some reason, sometimes on Linux/Windows still too big....
                        myPrint("DB","..knocking 1 off font size for good luck...! Now: %s" %(curFontSize))

                    # Code to increase width....
                    # while (pt2dpi(fm.stringWidth(theString) + 5,_dpi) < _maxPaperWidth):
                    #     curSize += 1
                    #     fm = _theComponent.getFontMetrics(Font(_startingComponentFont.getName(), _startingComponentFont.getStyle(), curSize))

                    curFontSize = max(_minFontSize, curFontSize); curFontSize = min(_maxFontSize, curFontSize)
                    myPrint("DB","... calculating.... Adjusted final font size to:", curFontSize)

                except:
                    myPrint("B", "ERROR: computeFontSize() crashed?"); dump_sys_error_to_md_console_and_errorlog()
                    return -1
                return curFontSize

            myPrint("DB", "Creating new PrinterJob...")
            printer_job = PrinterJob.getPrinterJob()

            if GlobalVars.defaultPrintService is not None:
                printer_job.setPrintService(GlobalVars.defaultPrintService)
                myPrint("DB","Assigned remembered PrintService...: %s" %(printer_job.getPrintService()))

            if GlobalVars.defaultPrinterAttributes is not None:
                pAttrs = attribute.HashPrintRequestAttributeSet(GlobalVars.defaultPrinterAttributes)
            else:
                pAttrs = loadDefaultPrinterAttributes(None)

            pAttrs.remove(attribute.standard.JobName)
            pAttrs.add(attribute.standard.JobName("%s: %s" %(myModuleID.capitalize(), _theTitle), None))

            if GlobalVars.defaultDPI != 72:
                pAttrs.remove(attribute.standard.PrinterResolution)
                pAttrs.add(attribute.standard.PrinterResolution(GlobalVars.defaultDPI, GlobalVars.defaultDPI, attribute.standard.PrinterResolution.DPI))

            for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes before user dialog: %s:%s" %(atr.getName(), atr))

            if not printer_job.printDialog(pAttrs):
                myPrint("DB","User aborted the Print Dialog setup screen, so exiting...")
                return

            selectedPrintService = printer_job.getPrintService()
            myPrint("DB", "User selected print service:", selectedPrintService)

            thePageFormat = printer_job.getPageFormat(pAttrs)

            # .setPrintable() seems to modify pAttrs & adds MediaPrintableArea. Do this before printDeducePrintableWidth()
            header = MessageFormat(_theTitle)
            footer = MessageFormat("- page {0} -")
            printer_job.setPrintable(printJTextArea.getPrintable(header, footer), thePageFormat)    # Yes - we do this twice

            for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes **AFTER** user dialog (and setPrintable): %s:%s" %(atr.getName(), atr))

            deducedWidthMM, maxPaperWidthPTS, maxPaperWidthPTS_buff = printDeducePrintableWidth(thePageFormat, pAttrs)

            if _callingClass is None or not _callingClass.lWrapText:

                newFontSize = computeFontSize(printJTextArea, int(maxPaperWidthPTS), GlobalVars.defaultDPI)

                if newFontSize > 0:
                    theFontToUse = theFontToUse.deriveFont(float(newFontSize))
                    printJTextArea.setFont(theFontToUse)

            # avoiding Intellij errors
            # eval("printJTextArea.print(header, footer, False, selectedPrintService, pAttrs, True)")  # If you do this, then native features like print to PDF will get ignored - so print via PrinterJob

            # Yup - calling .setPrintable() twice - before and after .computeFontSize()
            printer_job.setPrintable(printJTextArea.getPrintable(header, footer), thePageFormat)
            eval("printer_job.print(pAttrs)")

            del printJTextArea

            myPrint("DB", "Saving current print service:", printer_job.getPrintService())
            GlobalVars.defaultPrinterAttributes = attribute.HashPrintRequestAttributeSet(pAttrs)
            GlobalVars.defaultPrintService = printer_job.getPrintService()

        except:
            myPrint("B", "ERROR in printing routines.....:"); dump_sys_error_to_md_console_and_errorlog()
        return

    def pageSetup():

        myPrint("DB","Printer Page setup routines..:")

        myPrint("DB", 'NOTE: A4        210mm x 297mm	8.3" x 11.7"	Points: w595 x h842')
        myPrint("DB", 'NOTE: Letter    216mm x 279mm	8.5" x 11.0"	Points: w612 x h791')

        pj = PrinterJob.getPrinterJob()

        # Note: PrintService is not used/remembered/set by .pageDialog

        if GlobalVars.defaultPrinterAttributes is not None:
            pAttrs = attribute.HashPrintRequestAttributeSet(GlobalVars.defaultPrinterAttributes)
        else:
            pAttrs = loadDefaultPrinterAttributes(None)

        for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes before Page Setup: %s:%s" %(atr.getName(), atr))

        if not pj.pageDialog(pAttrs):
            myPrint("DB", "User cancelled Page Setup - exiting...")
            return

        for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes **AFTER** Page Setup: %s:%s" %(atr.getName(), atr))

        if debug: printDeducePrintableWidth(pj.getPageFormat(pAttrs), pAttrs)

        myPrint("DB", "Printer selected: %s" %(pj.getPrintService()))

        GlobalVars.defaultPrinterAttributes = attribute.HashPrintRequestAttributeSet(pAttrs)
        myPrint("DB", "Printer Attributes saved....")

        return

    class SetupMDColors:

        OPAQUE = None
        FOREGROUND = None
        FOREGROUND_REVERSED = None
        BACKGROUND = None
        BACKGROUND_REVERSED = None

        def __init__(self): raise Exception("ERROR - Should not create instance of this class!")

        @staticmethod
        def updateUI():
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

            SetupMDColors.OPAQUE = False

            SetupMDColors.FOREGROUND = GlobalVars.CONTEXT.getUI().getColors().defaultTextForeground
            SetupMDColors.FOREGROUND_REVERSED = SetupMDColors.FOREGROUND

            SetupMDColors.BACKGROUND = GlobalVars.CONTEXT.getUI().getColors().defaultBackground
            SetupMDColors.BACKGROUND_REVERSED = SetupMDColors.BACKGROUND

            if ((not isMDThemeVAQua() and not isMDThemeDark() and isMacDarkModeDetected())
                    or (not isMacDarkModeDetected() and isMDThemeDarcula())):
                SetupMDColors.FOREGROUND_REVERSED = GlobalVars.CONTEXT.getUI().colors.defaultBackground
                SetupMDColors.BACKGROUND_REVERSED = GlobalVars.CONTEXT.getUI().colors.defaultTextForeground

    global ManuallyCloseAndReloadDataset            # Declare it for QuickJFrame/IDE, but not present in common code. Other code will ignore it

    class GetFirstMainFrame:

        DEFAULT_MAX_WIDTH = 1024
        DEFAULT_MAX_HEIGHT = 768

        def __init__(self): raise Exception("ERROR: DO NOT CREATE INSTANCE OF GetFirstMainFrame!")

        @staticmethod
        def getSize(defaultWidth=None, defaultHeight=None):
            if defaultWidth is None: defaultWidth = GetFirstMainFrame.DEFAULT_MAX_WIDTH
            if defaultHeight is None: defaultHeight = GetFirstMainFrame.DEFAULT_MAX_HEIGHT
            try:
                firstMainFrame = MD_REF.getUI().firstMainFrame
                return firstMainFrame.getSize()
            except: pass
            return Dimension(defaultWidth, defaultHeight)

        @staticmethod
        def getSelectedAccount():
            try:
                firstMainFrame = MD_REF.getUI().firstMainFrame
                return firstMainFrame.getSelectedAccount()
            except: pass
            return None

    class QuickJFrame():

        def __init__(self,
                     title,
                     output,
                     lAlertLevel=0,
                     copyToClipboard=False,
                     lJumpToEnd=False,
                     lWrapText=True,
                     lQuitMDAfterClose=False,
                     lRestartMDAfterClose=False,
                     screenLocation=None,
                     lAutoSize=False):
            self.title = title
            self.output = output
            self.lAlertLevel = lAlertLevel
            self.returnFrame = None
            self.copyToClipboard = copyToClipboard
            self.lJumpToEnd = lJumpToEnd
            self.lWrapText = lWrapText
            self.lQuitMDAfterClose = lQuitMDAfterClose
            self.lRestartMDAfterClose = lRestartMDAfterClose
            self.screenLocation = screenLocation
            self.lAutoSize = lAutoSize
            # if Platform.isOSX() and int(float(MD_REF.getBuild())) >= 3039: self.lAlertLevel = 0    # Colors don't work on Mac since VAQua
            if isMDThemeDark() or isMacDarkModeDetected(): self.lAlertLevel = 0

        class QJFWindowListener(WindowAdapter):

            def __init__(self, theFrame, lQuitMDAfterClose=False, lRestartMDAfterClose=False):
                self.theFrame = theFrame
                self.lQuitMDAfterClose = lQuitMDAfterClose
                self.lRestartMDAfterClose = lRestartMDAfterClose
                self.saveMD_REF = MD_REF

            def windowClosing(self, WindowEvent):                                                                       # noqa
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                myPrint("DB", "QuickJFrame() Frame shutting down.... Calling .dispose()")
                self.theFrame.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

            def windowClosed(self, WindowEvent):                                                                       # noqa
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))

                if self.lQuitMDAfterClose or self.lRestartMDAfterClose:
                    if "ManuallyCloseAndReloadDataset" not in globals():
                        myPrint("DB", "'ManuallyCloseAndReloadDataset' not in globals(), so just exiting MD the easy way...")
                        myPrint("B", "@@ EXITING MONEYDANCE @@")
                        MD_REF.getUI().exit()
                    else:
                        if self.lQuitMDAfterClose:
                            myPrint("B", "Quit MD after Close triggered... Now quitting MD")
                            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False)
                        elif self.lRestartMDAfterClose:
                            myPrint("B", "Restart MD after Close triggered... Now restarting MD")
                            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)
                else:
                    myPrint("DB", "FYI No Quit MD after Close triggered... So doing nothing...")

        class CloseAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):
                myPrint("D","in CloseAction(), Event: ", event)
                myPrint("DB", "QuickJFrame() Frame shutting down....")

                try:
                    if not SwingUtilities.isEventDispatchThread():
                        SwingUtilities.invokeLater(GenericDisposeRunnable(self.theFrame))
                    else:
                        self.theFrame.dispose()
                except:
                    myPrint("B","Error. QuickJFrame dispose failed....?")
                    dump_sys_error_to_md_console_and_errorlog()


        class ToggleWrap(AbstractAction):

            def __init__(self, theCallingClass, theJText):
                self.theCallingClass = theCallingClass
                self.theJText = theJText

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                self.theCallingClass.lWrapText = not self.theCallingClass.lWrapText
                self.theJText.setLineWrap(self.theCallingClass.lWrapText)

        class QuickJFrameNavigate(AbstractAction):

            def __init__(self, theJText, lTop=False, lBottom=False):
                self.theJText = theJText
                self.lTop = lTop
                self.lBottom = lBottom

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if self.lBottom: self.theJText.setCaretPosition(self.theJText.getDocument().getLength())
                if self.lTop:    self.theJText.setCaretPosition(0)

        class QuickJFramePrint(AbstractAction):

            def __init__(self, theCallingClass, theJText, theTitle=""):
                self.theCallingClass = theCallingClass
                self.theJText = theJText
                self.theTitle = theTitle

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                printOutputFile(_callingClass=self.theCallingClass, _theTitle=self.theTitle, _theJText=self.theJText)

        class QuickJFramePageSetup(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                pageSetup()

        class QuickJFrameSaveTextToFile(AbstractAction):

            def __init__(self, theText, callingFrame):
                self.theText = theText
                self.callingFrame = callingFrame

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                saveOutputFile(self.callingFrame, "QUICKJFRAME", "%s_output.txt" %(myModuleID), self.theText)

        def show_the_frame(self):

            class MyQuickJFrameRunnable(Runnable):

                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                          # noqa
                    screenSize = Toolkit.getDefaultToolkit().getScreenSize()
                    frame_width = min(screenSize.width-20, max(GetFirstMainFrame.DEFAULT_MAX_WIDTH, int(round(GetFirstMainFrame.getSize().width *.9,0))))
                    frame_height = min(screenSize.height-20, max(GetFirstMainFrame.DEFAULT_MAX_HEIGHT, int(round(GetFirstMainFrame.getSize().height *.9,0))))

                    # JFrame.setDefaultLookAndFeelDecorated(True)   # Note: Darcula Theme doesn't like this and seems to be OK without this statement...
                    if self.callingClass.lQuitMDAfterClose:
                        extraText =  ">> MD WILL QUIT AFTER VIEWING THIS <<"
                    elif self.callingClass.lRestartMDAfterClose:
                        extraText =  ">> MD WILL RESTART AFTER VIEWING THIS <<"
                    else:
                        extraText = ""

                    jInternalFrame = MyJFrame(self.callingClass.title + " (%s+F to find/search for text)%s" %(MD_REF.getUI().ACCELERATOR_MASK_STR, extraText))
                    jInternalFrame.setName(u"%s_quickjframe" %myModuleID)

                    if not Platform.isOSX(): jInternalFrame.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    jInternalFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)
                    jInternalFrame.setResizable(True)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W,  shortcut), "close-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F,  shortcut), "search-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, shortcut),  "print-me")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")

                    theJText = JTextArea(self.callingClass.output)
                    theJText.setEditable(False)
                    theJText.setLineWrap(self.callingClass.lWrapText)
                    theJText.setWrapStyleWord(False)
                    theJText.setFont(getMonoFont())

                    jInternalFrame.getRootPane().getActionMap().put("close-window", self.callingClass.CloseAction(jInternalFrame))
                    jInternalFrame.getRootPane().getActionMap().put("search-window", SearchAction(jInternalFrame,theJText))
                    jInternalFrame.getRootPane().getActionMap().put("print-me", self.callingClass.QuickJFramePrint(self.callingClass, theJText, self.callingClass.title))
                    jInternalFrame.addWindowListener(self.callingClass.QJFWindowListener(jInternalFrame, self.callingClass.lQuitMDAfterClose, self.callingClass.lRestartMDAfterClose))

                    internalScrollPane = JScrollPane(theJText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)

                    if self.callingClass.lAlertLevel>=2:
                        # internalScrollPane.setBackground(Color.RED)
                        theJText.setBackground(Color.RED)
                        theJText.setForeground(Color.BLACK)
                        theJText.setOpaque(True)
                    elif self.callingClass.lAlertLevel>=1:
                        # internalScrollPane.setBackground(Color.YELLOW)
                        theJText.setBackground(Color.YELLOW)
                        theJText.setForeground(Color.BLACK)
                        theJText.setOpaque(True)

                    if not self.callingClass.lAutoSize:
                        jInternalFrame.setPreferredSize(Dimension(frame_width, frame_height))

                    SetupMDColors.updateUI()

                    printButton = JButton("Print")
                    printButton.setToolTipText("Prints the output displayed in this window to your printer")
                    printButton.setOpaque(SetupMDColors.OPAQUE)
                    printButton.setBackground(SetupMDColors.BACKGROUND); printButton.setForeground(SetupMDColors.FOREGROUND)
                    printButton.addActionListener(self.callingClass.QuickJFramePrint(self.callingClass, theJText, self.callingClass.title))

                    if GlobalVars.defaultPrinterAttributes is None:
                        printPageSetup = JButton("Page Setup")
                        printPageSetup.setToolTipText("Printer Page Setup")
                        printPageSetup.setOpaque(SetupMDColors.OPAQUE)
                        printPageSetup.setBackground(SetupMDColors.BACKGROUND); printPageSetup.setForeground(SetupMDColors.FOREGROUND)
                        printPageSetup.addActionListener(self.callingClass.QuickJFramePageSetup())

                    saveButton = JButton("Save to file")
                    saveButton.setToolTipText("Saves the output displayed in this window to a file")
                    saveButton.setOpaque(SetupMDColors.OPAQUE)
                    saveButton.setBackground(SetupMDColors.BACKGROUND); saveButton.setForeground(SetupMDColors.FOREGROUND)
                    saveButton.addActionListener(self.callingClass.QuickJFrameSaveTextToFile(self.callingClass.output, jInternalFrame))

                    wrapOption = JCheckBox("Wrap Contents (Screen & Print)", self.callingClass.lWrapText)
                    wrapOption.addActionListener(self.callingClass.ToggleWrap(self.callingClass, theJText))
                    wrapOption.setForeground(SetupMDColors.FOREGROUND_REVERSED); wrapOption.setBackground(SetupMDColors.BACKGROUND_REVERSED)

                    topButton = JButton("Top")
                    topButton.setOpaque(SetupMDColors.OPAQUE)
                    topButton.setBackground(SetupMDColors.BACKGROUND); topButton.setForeground(SetupMDColors.FOREGROUND)
                    topButton.addActionListener(self.callingClass.QuickJFrameNavigate(theJText, lTop=True))

                    botButton = JButton("Bottom")
                    botButton.setOpaque(SetupMDColors.OPAQUE)
                    botButton.setBackground(SetupMDColors.BACKGROUND); botButton.setForeground(SetupMDColors.FOREGROUND)
                    botButton.addActionListener(self.callingClass.QuickJFrameNavigate(theJText, lBottom=True))

                    closeButton = JButton("Close")
                    closeButton.setOpaque(SetupMDColors.OPAQUE)
                    closeButton.setBackground(SetupMDColors.BACKGROUND); closeButton.setForeground(SetupMDColors.FOREGROUND)
                    closeButton.addActionListener(self.callingClass.CloseAction(jInternalFrame))

                    if Platform.isOSX():
                        save_useScreenMenuBar= System.getProperty("apple.laf.useScreenMenuBar")
                        if save_useScreenMenuBar is None or save_useScreenMenuBar == "":
                            save_useScreenMenuBar= System.getProperty("com.apple.macos.useScreenMenuBar")
                        System.setProperty("apple.laf.useScreenMenuBar", "false")
                        System.setProperty("com.apple.macos.useScreenMenuBar", "false")
                    else:
                        save_useScreenMenuBar = "true"

                    mb = JMenuBar()
                    mb.setBorder(EmptyBorder(0, 0, 0, 0))
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(topButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(botButton)
                    mb.add(Box.createHorizontalGlue())
                    mb.add(wrapOption)

                    if GlobalVars.defaultPrinterAttributes is None:
                        mb.add(Box.createRigidArea(Dimension(10, 0)))
                        mb.add(printPageSetup)                                                                          # noqa

                    mb.add(Box.createHorizontalGlue())
                    mb.add(printButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(saveButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(closeButton)
                    mb.add(Box.createRigidArea(Dimension(30, 0)))

                    jInternalFrame.setJMenuBar(mb)

                    jInternalFrame.add(internalScrollPane)

                    jInternalFrame.pack()
                    if self.callingClass.screenLocation and isinstance(self.callingClass.screenLocation, Point):
                        jInternalFrame.setLocation(self.callingClass.screenLocation)
                    else:
                        jInternalFrame.setLocationRelativeTo(None)

                    jInternalFrame.setVisible(True)

                    if Platform.isOSX():
                        System.setProperty("apple.laf.useScreenMenuBar", save_useScreenMenuBar)
                        System.setProperty("com.apple.macos.useScreenMenuBar", save_useScreenMenuBar)

                    if "errlog.txt" in self.callingClass.title or self.callingClass.lJumpToEnd:
                        theJText.setCaretPosition(theJText.getDocument().getLength())

                    try:
                        if self.callingClass.copyToClipboard:
                            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(self.callingClass.output), None)
                    except:
                        myPrint("J","Error copying contents to Clipboard")
                        dump_sys_error_to_md_console_and_errorlog()

                    self.callingClass.returnFrame = jInternalFrame

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyQuickJFrameRunnable()...")
                SwingUtilities.invokeAndWait(MyQuickJFrameRunnable(self))
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                MyQuickJFrameRunnable(self).run()

            return (self.returnFrame)

    class AboutThisScript(AbstractAction, Runnable):

        def __init__(self, theFrame):
            self.theFrame = theFrame
            self.aboutDialog = None

        def actionPerformed(self, event):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event:", event)
            self.aboutDialog.dispose()  # Listener is already on the Swing EDT...

        def go(self):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyAboutRunnable()...")
                SwingUtilities.invokeAndWait(self)
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                self.run()

        def run(self):                                                                                                  # noqa
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            # noinspection PyUnresolvedReferences
            self.aboutDialog = JDialog(self.theFrame, "About", Dialog.ModalityType.MODELESS)

            shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
            self.aboutDialog.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
            self.aboutDialog.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
            self.aboutDialog.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")

            self.aboutDialog.getRootPane().getActionMap().put("close-window", self)
            self.aboutDialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)

            if (not Platform.isMac()):
                # MD_REF.getUI().getImages()
                self.aboutDialog.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

            aboutPanel = JPanel()
            aboutPanel.setLayout(FlowLayout(FlowLayout.LEFT))
            aboutPanel.setPreferredSize(Dimension(1120, 550))

            _label1 = JLabel(pad("Author: Stuart Beesley", 800))
            _label1.setForeground(getColorBlue())
            aboutPanel.add(_label1)

            _label2 = JLabel(pad("StuWareSoftSystems (2020-2023)", 800))
            _label2.setForeground(getColorBlue())
            aboutPanel.add(_label2)

            _label3 = JLabel(pad("Script/Extension: %s (build: %s)" %(GlobalVars.thisScriptName, version_build), 800))
            _label3.setForeground(getColorBlue())
            aboutPanel.add(_label3)

            displayString = scriptExit
            displayJText = JTextArea(displayString)
            displayJText.setFont(getMonoFont())
            displayJText.setEditable(False)
            displayJText.setLineWrap(False)
            displayJText.setWrapStyleWord(False)
            displayJText.setMargin(Insets(8, 8, 8, 8))

            aboutPanel.add(displayJText)

            self.aboutDialog.add(aboutPanel)

            self.aboutDialog.pack()
            self.aboutDialog.setLocationRelativeTo(None)
            self.aboutDialog.setVisible(True)

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def isGoodRate(theRate):

        if Double.isNaN(theRate) or Double.isInfinite(theRate) or theRate == 0:
            return False
        return True

    def safeInvertRate(theRate):

        if not isGoodRate(theRate):
            return theRate
        return (1.0 / theRate)

    def convertBytesGBs(_size): return round((_size/(1000.0*1000.0*1000)),1)

    def convertBytesMBs(_size): return round((_size/(1000.0*1000.0)),1)

    def convertBytesKBs(_size): return round((_size/(1000.0)),1)

    def convertMDShortDateFormat_strftimeFormat(lIncludeTime=False, lForceYYMMDDHMS=False):
        """Returns a Python strftime format string in accordance with MD Preferences for Date Format"""
        # https://strftime.org

        _MDFormat = MD_REF.getPreferences().getShortDateFormat()

        rtnFormat = "%Y-%m-%d"

        if lForceYYMMDDHMS:
            lIncludeTime = True
        else:
            if _MDFormat == "MM/dd/yyyy":
                rtnFormat = "%m/%d/%Y"
            elif _MDFormat == "MM.dd.yyyy":
                rtnFormat = "%m.%d.%Y"
            elif _MDFormat == "yyyy/MM/dd":
                rtnFormat = "%Y/%m/%d"
            elif _MDFormat == "yyyy.MM.dd":
                rtnFormat = "%Y.%m.%d"
            elif _MDFormat == "dd/MM/yyyy":
                rtnFormat = "%d/%m/%Y"
            elif _MDFormat == "dd.MM.yyyy":
                rtnFormat = "%d.%m.%Y"

        if lIncludeTime: rtnFormat += " %H:%M:%S"
        return rtnFormat

    def getHumanReadableDateTimeFromTimeStamp(_theTimeStamp, lIncludeTime=False, lForceYYMMDDHMS=False):
        return datetime.datetime.fromtimestamp(_theTimeStamp).strftime(convertMDShortDateFormat_strftimeFormat(lIncludeTime=lIncludeTime, lForceYYMMDDHMS=lForceYYMMDDHMS))

    def getHumanReadableModifiedDateTimeFromFile(_theFile, lIncludeTime=True, lForceYYMMDDHMS=True):
        return getHumanReadableDateTimeFromTimeStamp(os.path.getmtime(_theFile), lIncludeTime=lIncludeTime, lForceYYMMDDHMS=lForceYYMMDDHMS)

    def convertStrippedIntDateFormattedText(strippedDateInt, _format=None):

        # if _format is None: _format = "yyyy/MM/dd"
        if _format is None: _format = MD_REF.getPreferences().getShortDateFormat()

        if strippedDateInt is None or strippedDateInt == 0:
            return "<not set>"

        try:
            c = Calendar.getInstance()
            dateFromInt = DateUtil.convertIntDateToLong(strippedDateInt)
            c.setTime(dateFromInt)
            dateFormatter = SimpleDateFormat(_format)
            convertedDate = dateFormatter.format(c.getTime())
        except:
            return "<error>"

        return convertedDate

    def selectHomeScreen():

        try:
            currentViewAccount = MD_REF.getUI().firstMainFrame.getSelectedAccount()
            if currentViewAccount != MD_REF.getRootAccount():
                myPrint("DB","Switched to Home Page Summary Page (from: %s)" %(currentViewAccount))
                MD_REF.getUI().firstMainFrame.selectAccount(MD_REF.getRootAccount())
        except:
            myPrint("B","@@ Error switching to Summary Page (Home Page)")

    def fireMDPreferencesUpdated():
        """This triggers MD to firePreferencesUpdated().... Hopefully refreshing Home Screen Views too"""
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        class FPSRunnable(Runnable):
            def __init__(self): pass

            def run(self):
                myPrint("DB",".. Inside FPSRunnable() - calling firePreferencesUpdated()...")
                myPrint("B","Triggering an update to the Summary/Home Page View")
                MD_REF.getPreferences().firePreferencesUpdated()

        if not SwingUtilities.isEventDispatchThread():
            myPrint("DB",".. Not running within the EDT so calling via FPSRunnable()...")
            SwingUtilities.invokeLater(FPSRunnable())
        else:
            myPrint("DB",".. Already running within the EDT so calling FPSRunnable() naked...")
            FPSRunnable().run()
        return

    def decodeCommand(passedEvent):
        param = ""
        uri = passedEvent
        command = uri
        theIdx = uri.find('?')
        if(theIdx>=0):
            command = uri[:theIdx]
            param = uri[theIdx+1:]
        else:
            theIdx = uri.find(':')
            if(theIdx>=0):
                command = uri[:theIdx]
                param = uri[theIdx+1:]
        return command, param

    def getFieldByReflection(theObj, fieldName, isInt=False):
        try: theClass = theObj.getClass()
        except TypeError: theClass = theObj     # This catches where the object is already the Class
        reflectField = None
        while theClass is not None:
            try:
                reflectField = theClass.getDeclaredField(fieldName)
                break
            except NoSuchFieldException:
                theClass = theClass.getSuperclass()
        if reflectField is None: raise Exception("ERROR: could not find field: %s in class hierarchy" %(fieldName))
        if Modifier.isPrivate(reflectField.getModifiers()): reflectField.setAccessible(True)
        elif Modifier.isProtected(reflectField.getModifiers()): reflectField.setAccessible(True)
        isStatic = Modifier.isStatic(reflectField.getModifiers())
        if isInt: return reflectField.getInt(theObj if not isStatic else None)
        return reflectField.get(theObj if not isStatic else None)

    def invokeMethodByReflection(theObj, methodName, params, *args):
        try: theClass = theObj.getClass()
        except TypeError: theClass = theObj     # This catches where the object is already the Class
        reflectMethod = None
        while theClass is not None:
            try:
                if params is None:
                    reflectMethod = theClass.getDeclaredMethod(methodName)
                    break
                else:
                    reflectMethod = theClass.getDeclaredMethod(methodName, params)
                    break
            except NoSuchMethodException:
                theClass = theClass.getSuperclass()
        if reflectMethod is None: raise Exception("ERROR: could not find method: %s in class hierarchy" %(methodName))
        reflectMethod.setAccessible(True)
        return reflectMethod.invoke(theObj, *args)

    def setFieldByReflection(theObj, fieldName, newValue):
        try: theClass = theObj.getClass()
        except TypeError: theClass = theObj     # This catches where the object is already the Class
        reflectField = None
        while theClass is not None:
            try:
                reflectField = theClass.getDeclaredField(fieldName)
                break
            except NoSuchFieldException:
                theClass = theClass.getSuperclass()
        if reflectField is None: raise Exception("ERROR: could not find field: %s in class hierarchy" %(fieldName))
        if Modifier.isPrivate(reflectField.getModifiers()): reflectField.setAccessible(True)
        elif Modifier.isProtected(reflectField.getModifiers()): reflectField.setAccessible(True)
        isStatic = Modifier.isStatic(reflectField.getModifiers())
        return reflectField.set(theObj if not isStatic else None, newValue)

    def find_feature_module(theModule):
        # type: (str) -> bool
        """Searches Moneydance for a specific extension loaded"""
        fms = MD_REF.getLoadedModules()
        for fm in fms:
            if fm.getIDStr().lower() == theModule:
                myPrint("DB", "Found extension: %s" %(theModule))
                return fm
        return None

    GlobalVars.MD_KOTLIN_COMPILED_BUILD = 5000                                                                          # 2023.0
    def isKotlinCompiledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_KOTLIN_COMPILED_BUILD)                                           # 2023.0(5000)

    def isMDPlusEnabledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_MDPLUS_BUILD)                         # 2022.0

    def isAlertControllerEnabledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_ALERTCONTROLLER_BUILD)       # 2022.3

    def genericSwingEDTRunner(ifOffEDTThenRunNowAndWait, ifOnEDTThenRunNowAndWait, codeblock, *args):
        """Will detect and then run the codeblock on the EDT"""

        isOnEDT = SwingUtilities.isEventDispatchThread()
        # myPrint("DB", "** In .genericSwingEDTRunner(), ifOffEDTThenRunNowAndWait: '%s', ifOnEDTThenRunNowAndWait: '%s', codeblock: '%s', args: '%s'" %(ifOffEDTThenRunNowAndWait, ifOnEDTThenRunNowAndWait, codeblock, args))
        myPrint("DB", "** In .genericSwingEDTRunner(), ifOffEDTThenRunNowAndWait: '%s', ifOnEDTThenRunNowAndWait: '%s', codeblock: <codeblock>, args: <args>" %(ifOffEDTThenRunNowAndWait, ifOnEDTThenRunNowAndWait))
        myPrint("DB", "** In .genericSwingEDTRunner(), isOnEDT:", isOnEDT)

        class GenericSwingEDTRunner(Runnable):

            def __init__(self, _codeblock, arguments):
                self.codeBlock = _codeblock
                self.params = arguments

            def run(self):
                myPrint("DB", "** In .genericSwingEDTRunner():: GenericSwingEDTRunner().run()... about to execute codeblock.... isOnEDT:", SwingUtilities.isEventDispatchThread())
                self.codeBlock(*self.params)
                myPrint("DB", "** In .genericSwingEDTRunner():: GenericSwingEDTRunner().run()... finished executing codeblock....")

        _gser = GenericSwingEDTRunner(codeblock, args)

        if ((isOnEDT and not ifOnEDTThenRunNowAndWait) or (not isOnEDT and not ifOffEDTThenRunNowAndWait)):
            myPrint("DB", "... calling codeblock via .invokeLater()...")
            SwingUtilities.invokeLater(_gser)
        elif not isOnEDT:
            myPrint("DB", "... calling codeblock via .invokeAndWait()...")
            SwingUtilities.invokeAndWait(_gser)
        else:
            myPrint("DB", "... calling codeblock.run() naked...")
            _gser.run()

        myPrint("DB", "... finished calling the codeblock via method reported above...")

    def genericThreadRunner(daemon, codeblock, *args):
        """Will run the codeblock on a new Thread"""

        # myPrint("DB", "** In .genericThreadRunner(), codeblock: '%s', args: '%s'" %(codeblock, args))
        myPrint("DB", "** In .genericThreadRunner(), codeblock: <codeblock>, args: <args>")

        class GenericThreadRunner(Runnable):

            def __init__(self, _codeblock, arguments):
                self.codeBlock = _codeblock
                self.params = arguments

            def run(self):
                myPrint("DB", "** In .genericThreadRunner():: GenericThreadRunner().run()... about to execute codeblock....")
                self.codeBlock(*self.params)
                myPrint("DB", "** In .genericThreadRunner():: GenericThreadRunner().run()... finished executing codeblock....")

        _gtr = GenericThreadRunner(codeblock, args)

        _t = Thread(_gtr, "NAB_GenericThreadRunner".lower())
        _t.setDaemon(daemon)
        _t.start()

        myPrint("DB", "... finished calling the codeblock...")

    GlobalVars.EXTN_PREF_KEY = "stuwaresoftsystems" + "." + myModuleID
    GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER = "enable_observer"
    GlobalVars.EXTN_PREF_KEY_DISABLE_FORESIGHT = "disable_moneyforesight"

    class StreamTableFixed(StreamTable):
        """Replicates StreamTable. Provide a source to merge. Method .getBoolean() is 'fixed' to be backwards compatible with builds prior to Kotlin (Y/N vs 0/1)"""
        def __init__(self, _streamTableToCopy):
            # type: (StreamTable) -> None
            if not isinstance(_streamTableToCopy, StreamTable): raise Exception("LOGIC ERROR: Must pass a StreamTable! (Passed: %s)" %(type(_streamTableToCopy)))
            self.merge(_streamTableToCopy)

        def getBoolean(self, key, defaultVal):
            # type: (basestring, bool) -> bool
            if isKotlinCompiledBuild():     # MD2023.0 First Kotlin release - changed the code from detecting only Y/N to Y/N/T/F/0/1
                return super(self.__class__, self).getBoolean(key, defaultVal)
            _value = self.get(key, None)
            if _value in ["1", "Y", "y", "T", "t", "true", True]: return True
            if _value in ["0", "N", "n", "F", "f", "false", False]: return False
            return defaultVal

    def getExtensionDatasetSettings():
        # type: () -> SyncRecord
        _extnSettings =  GlobalVars.CONTEXT.getCurrentAccountBook().getLocalStorage().getSubset(GlobalVars.EXTN_PREF_KEY)
        if debug: myPrint("B", "Retrieved Extension Dataset Settings from LocalStorage: %s" %(_extnSettings))
        return _extnSettings

    def saveExtensionDatasetSettings(newExtnSettings):
        # type: (SyncRecord) -> None
        if not isinstance(newExtnSettings, SyncRecord):
            raise Exception("ERROR: 'newExtnSettings' is not a SyncRecord (given: '%s')" %(type(newExtnSettings)))
        _localStorage = GlobalVars.CONTEXT.getCurrentAccountBook().getLocalStorage()
        _localStorage.put(GlobalVars.EXTN_PREF_KEY, newExtnSettings)
        if debug: myPrint("B", "Stored Extension Dataset Settings into LocalStorage: %s" %(newExtnSettings))

    def getExtensionGlobalPreferences(enhancedBooleanCheck=True):
        # type: (bool) -> StreamTable
        _extnPrefs =  GlobalVars.CONTEXT.getPreferences().getTableSetting(GlobalVars.EXTN_PREF_KEY, StreamTable())
        if not isKotlinCompiledBuild():
            if enhancedBooleanCheck:
                _extnPrefs = StreamTableFixed(_extnPrefs)
                myPrint("DB", "... copied retrieved Extension Global Preferences into enhanced StreamTable for backwards .getBoolean() capability...")
        if debug: myPrint("B", "Retrieved Extension Global Preference: %s" %(_extnPrefs))
        return _extnPrefs

    def saveExtensionGlobalPreferences(newExtnPrefs):
        # type: (StreamTable) -> None
        if not isinstance(newExtnPrefs, StreamTable):
            raise Exception("ERROR: 'newExtnPrefs' is not a StreamTable (given: '%s')" %(type(newExtnPrefs)))
        GlobalVars.CONTEXT.getPreferences().setSetting(GlobalVars.EXTN_PREF_KEY, newExtnPrefs)
        if debug: myPrint("B", "Stored Extension Global Preferences: %s" %(newExtnPrefs))

    # END COMMON DEFINITIONS ###############################################################################################
    # END COMMON DEFINITIONS ###############################################################################################
    # END COMMON DEFINITIONS ###############################################################################################
    # COPY >> END

    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    def load_StuWareSoftSystems_parameters_into_memory():
        myPrint("DB", "Loading variables into memory...")

        if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

        if GlobalVars.parametersLoadedFromFile.get("__TOOLBOX") is not None: GlobalVars.__TOOLBOX = GlobalVars.parametersLoadedFromFile.get("__TOOLBOX")
        if GlobalVars.parametersLoadedFromFile.get("lCopyAllToClipBoard_TB") is not None: GlobalVars.lCopyAllToClipBoard_TB = GlobalVars.parametersLoadedFromFile.get("lCopyAllToClipBoard_TB")
        if GlobalVars.parametersLoadedFromFile.get("lIgnoreOutdatedExtensions_TB") is not None: GlobalVars.lIgnoreOutdatedExtensions_TB = GlobalVars.parametersLoadedFromFile.get("lIgnoreOutdatedExtensions_TB")
        if GlobalVars.parametersLoadedFromFile.get("lAutoPruneInternalBackups_TB") is not None: GlobalVars.lAutoPruneInternalBackups_TB = GlobalVars.parametersLoadedFromFile.get("lAutoPruneInternalBackups_TB")
        if GlobalVars.parametersLoadedFromFile.get("lBypassAllBackupsAndDisclaimers_TB") is not None: GlobalVars.lBypassAllBackupsAndDisclaimers_TB = GlobalVars.parametersLoadedFromFile.get("lBypassAllBackupsAndDisclaimers_TB")

        # No longer needed as button will be ever-present...
        if GlobalVars.parametersLoadedFromFile.get("lGeekOutModeEnabled_TB") is not None: GlobalVars.parametersLoadedFromFile.pop("lGeekOutModeEnabled_TB")

        myPrint("DB","GlobalVars.parametersLoadedFromFile{} set into memory (as variables).....")

        return

    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    def dump_StuWareSoftSystems_parameters_from_memory():
        # NOTE: Parameters were loaded earlier on... Preserve existing, and update any used ones...
        # (i.e. other StuWareSoftSystems programs might be sharing the same file)

        if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

        GlobalVars.parametersLoadedFromFile["__TOOLBOX"] = version_build
        GlobalVars.parametersLoadedFromFile["lCopyAllToClipBoard_TB"] = GlobalVars.lCopyAllToClipBoard_TB
        GlobalVars.parametersLoadedFromFile["lIgnoreOutdatedExtensions_TB"] = GlobalVars.lIgnoreOutdatedExtensions_TB
        GlobalVars.parametersLoadedFromFile["lAutoPruneInternalBackups_TB"] = GlobalVars.lAutoPruneInternalBackups_TB
        GlobalVars.parametersLoadedFromFile["lBypassAllBackupsAndDisclaimers_TB"] = GlobalVars.lBypassAllBackupsAndDisclaimers_TB

        myPrint("DB","variables dumped from memory back into GlobalVars.parametersLoadedFromFile{}.....")

        return

    lFailed_get_StuWareSoftSystems_parameters_from_file = False
    try:
        get_StuWareSoftSystems_parameters_from_file()
    except:
        lFailed_get_StuWareSoftSystems_parameters_from_file = True
        myPrint("B", "ERROR: Failed on get_StuWareSoftSystems_parameters_from_file()...  ** IS YOUR DATASET CLOSED? **")
        dump_sys_error_to_md_console_and_errorlog()

    # clear up any old left-overs....
    destroyOldFrames(myModuleID)

    myPrint("DB", "DEBUG IS ON..")

    if SwingUtilities.isEventDispatchThread():
        myPrint("DB", "FYI - This script/extension is currently running within the Swing Event Dispatch Thread (EDT)")
    else:
        myPrint("DB", "FYI - This script/extension is NOT currently running within the Swing Event Dispatch Thread (EDT)")

    def cleanup_actions(theFrame=None):
        myPrint("DB", "In", inspect.currentframe().f_code.co_name, "()")
        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

        if theFrame is not None and not theFrame.isActiveInMoneydance:
            destroyOldFrames(myModuleID)

        for t in Thread.getAllStackTraces().keySet():
            if "toolbox_DownloadExtensionVersionData".lower() in t.getName().lower() and t.isAlive():
                myPrint("B", "** Interrupting Thread '%s'(id: %s) (download of latest extension(s) version data) which seems to still be alive" %(t, t.getId()))
                t.interrupt()

        try: MD_REF.getUI().setStatus(">> Infinite Kind (co-authored by Stuart Beesley: StuWareSoftSystems) - Thanks for using Toolbox.......",0)
        except: pass  # If this fails, then MD is probably shutting down.......

        if not GlobalVars.i_am_an_extension_so_run_headless: print(scriptExit)

        cleanup_references()

    # .moneydance_invoke_called() is used via the _invoke.py script as defined in script_info.dict. Not used for runtime extensions
    def moneydance_invoke_called(theCommand):
        # ... modify as required to handle .showURL() events sent to this extension/script...
        myPrint("B","INVOKE - Received extension command: '%s'" %(theCommand))
        cmd, param = decodeCommand(theCommand)
        try: genericSwingEDTRunner(False, False, setDisplayStatus, "Received unhandled event/invoke command ('%s' : '%s')" %(cmd, param), "B")
        except: pass

    GlobalVars.defaultPrintLandscape = True
    # END ALL CODE COPY HERE ###############################################################################################
    # END ALL CODE COPY HERE ###############################################################################################
    # END ALL CODE COPY HERE ###############################################################################################

    def isSyncTaskSyncing(checkMainTask=False, checkAttachmentsTask=False):
        if ((not checkMainTask and not checkAttachmentsTask) or (checkMainTask and checkAttachmentsTask)):
            raise Exception("LOGIC ERROR: Must provide either checkMainTask or checkAttachmentsTask True parameter...!")
        _b = MD_REF.getCurrentAccountBook()
        if _b is not None:
            _s = _b.getSyncer()
            if _s is not None:
                try:      # This method only works from MD2023.2(5008) onwards...
                    checkTasks = []
                    if checkMainTask: checkTasks.append("getMainSyncTask")
                    if checkAttachmentsTask: checkTasks.append("getAttachmentsSyncTask")
                    for checkTask in checkTasks:
                        _st = invokeMethodByReflection(_s, checkTask, [])
                        _isSyncing = invokeMethodByReflection(_st, "isSyncing", [])
                        myPrint("DB", "isSyncTaskSyncing(): Task: .%s(), Thread: '%s', .isSyncing(): %s" %(checkTask, _st, _isSyncing))
                        if _isSyncing:
                            return True
                except:
                    # There is only one big sync thread for versions prior to build 5008...
                    myPrint("DB", "isSyncTaskSyncing(): Ignoring parameters (main: %s, attachments: %s) >> Simply checking the single Syncer status. .isSyncing(): %s"
                            %(checkMainTask, checkAttachmentsTask, _s.isSyncing()))
                    return _s.isSyncing()
        return False


    # Variables initialised by _init.py script and managed by _invoke_handle_event.py script... (extension only)...
    global _ALL_OBSERVED_BOOKS, _observeMoneydanceObjects
    if "_ALL_OBSERVED_BOOKS" not in globals():
        _ALL_OBSERVED_BOOKS = []
        myPrint("B", "@@ resetting _ALL_OBSERVED_BOOKS (perhaps running as a script, not extension?)")
    try: _observeMoneydanceObjects(_ALL_OBSERVED_BOOKS)
    except: myPrint("B", "NOPE: Could not execute _observeMoneydanceObjects().... ignoring....")

    # Now hitting method too large issue, so relocating code to toolbox_extra_code.py script file - no choice...!
    GlobalVars.EXTRA_CODE_INITIALISED = False
    try:
        # Reference all code/objects from extra script here (back into main code)....
        global _extra_code_initialiser, getCloudDirectory
        global advanced_options_encrypt_file_into_dataset, advanced_options_encrypt_file_into_sync_folder
        global advanced_options_decrypt_file_from_dataset, advanced_options_decrypt_file_from_sync
        global advanced_options_decrypt_dataset, advanced_show_encryption_keys

        _extraCodeString = myModuleID + "_extra_code" + ".py"
        if MD_EXTENSION_LOADER is not None:
            # Try launching the extra code from within the MXT...
            _pyi = getFieldByReflection(MD_REF.getModuleForID(myModuleID), "python")
            extraCodeScriptStream = MD_EXTENSION_LOADER.getResourceAsStream("/%s" %(_extraCodeString))
            if extraCodeScriptStream is not None:
                myPrint("DB", "About to launch extra code initialiser (via mxt)....")
                _pyi.execfile(extraCodeScriptStream)
                extraCodeScriptStream.close()
            del _pyi, extraCodeScriptStream

        if not GlobalVars.EXTRA_CODE_INITIALISED and "__file__" in globals():
            # OK, so try launching the extra code from disk if running as a script....
            _extraCodeFile = __file__[:-len(os.path.basename(__file__))] + _extraCodeString
            if os.path.exists(_extraCodeFile):
                myPrint("DB", "About to launch extra code initialiser (via script)....")
                execfile(_extraCodeFile)
            del _extraCodeFile
        del _extraCodeString
    except:
        dump_sys_error_to_md_console_and_errorlog()
    if not GlobalVars.EXTRA_CODE_INITIALISED: myPrint("B", "@@ WARNING >> Failed to find/execute '%s_extra_code.py' script (from within mxt or disk)..?! Will ignore and continue...." %(myModuleID))
    ####################################################################################################################


    class ToolboxMode:
        DEFAULT_TEXT = "Update Mode"
        DEFAULT_CMD = "update_mode"
        DEFAULT_MENU_LBL = JLabel("       ** to activate.. EXIT, click '%s' on menu bar **" %(DEFAULT_TEXT))
        DEFAULT_MENU_READONLY_TXT_LBL = JLabel("---------- READONLY FUNCTIONS ----------")
        DEFAULT_MENU_UPDATE_TXT_LBL = JLabel("----------- UPDATE FUNCTIONS -----------")
        DEFAULT_MENU_LBL.setForeground(getColorRed())
        DEFAULT_KEY = KeyEvent.VK_M
        DEFAULT_KEY_CMD = "m"
        UPDATE_MODE = False
        STATUS_LABEL = JLabel("", JLabel.CENTER)
        JCB = JCheckBox(DEFAULT_TEXT, UPDATE_MODE)
        JCB.setActionCommand(DEFAULT_CMD)

        def __init__(self): raise Exception("ERROR - Should not create instance of this class!")

        @staticmethod
        def getJCheckBox(): return ToolboxMode.JCB

        @staticmethod
        def getStatusLabel(): return ToolboxMode.STATUS_LABEL

        @staticmethod
        def getMenuLabel(): return ToolboxMode.DEFAULT_MENU_LBL

        @staticmethod
        def isUpdateMode(): return ToolboxMode.UPDATE_MODE

        @staticmethod
        def setUpdateMode(newMode):
            ToolboxMode.UPDATE_MODE = newMode
            ToolboxMode.getJCheckBox().setSelected(newMode)
            ToolboxMode.getJCheckBox().setForeground(getColorRed() if newMode else MD_REF.getUI().getColors().defaultTextForeground)
            ToolboxMode.STATUS_LABEL.setText("<%s>" %(ToolboxMode.DEFAULT_TEXT.upper()) if newMode else "")
            ToolboxMode.STATUS_LABEL.setForeground(getColorRed())

        @staticmethod
        def addActionListener(*args, **kwargs): ToolboxMode.getJCheckBox().addActionListener(*args, **kwargs)

        @staticmethod
        def setForeground(*args, **kwargs): ToolboxMode.getJCheckBox().setForeground(*args, **kwargs)

        @staticmethod
        def setBackground(*args, **kwargs): ToolboxMode.getJCheckBox().setBackground(*args, **kwargs)

    def shutdownMDPlusPoller():
        if isMDPlusEnabledBuild():
            myPrint("DB", "Shutting down the MD+ poller")
            plusPoller = MD_REF.getUI().getPlusController()
            if plusPoller is not None:
                invokeMethodByReflection(plusPoller, "shutdown", None)
                setFieldByReflection(MD_REF.getUI(), "plusPoller", None)

            try:
                myPrint("DB", "... Clearing out the in-memory license cache...")
                licenseCache = getFieldByReflection(MDPlus, "licenseCache")
                if licenseCache is not None: licenseCache.clear()
            except:
                myPrint("DB", "... There appears to be no in-memory license cache ('licenseCache') to clear (probably builds 5031 onwards)...")

            myPrint("DB", "... MD+ poller shutdown...")

    def shutdownMDAlertController():
        if isAlertControllerEnabledBuild():
            myPrint("DB", "Shutting down the Alert Controller")
            alertController = MD_REF.getUI().getAlertController()
            if alertController is not None:
                invokeMethodByReflection(alertController, "shutdown", None)
                setFieldByReflection(MD_REF.getUI(), "alertController", None)

    def doesUserAcceptDisclaimer(theParent, theTitle, disclaimerQuestion):
        if not GlobalVars.lBypassAllBackupsAndDisclaimers_TB:
            disclaimer = myPopupAskForInput(theParent,
                                            theTitle,
                                            "DISCLAIMER:",
                                            # "%s Type 'IAGREE' to continue.." %(disclaimerQuestion),
                                            "Type 'IAGREE' to continue..",
                                            "NO",
                                            False,
                                            JOptionPane.ERROR_MESSAGE)
            agreed = (disclaimer == "IAGREE")
            if agreed:
                myPrint("B", "%s: User AGREED to disclaimer question: '%s'" %(theTitle, disclaimerQuestion))
            else:
                myPrint("B", "%s: User DECLINED disclaimer question: '%s' - no action/changes made" %(theTitle, disclaimerQuestion))
            return agreed

        myPrint("B", "%s: User has DISABLED Backup and Disclaimer warnings: Implicit agreement with disclaimer question: '%s'" %(theTitle, disclaimerQuestion))
        return True

    def confirm_backup_confirm_disclaimer(theFrame, theTitleToDisplay, theAction):

        if not myPopupAskQuestion(theFrame,
                                  theTitle=theTitleToDisplay,
                                  theQuestion=theAction,
                                  theOptionType=JOptionPane.YES_NO_OPTION,
                                  theMessageType=JOptionPane.ERROR_MESSAGE):

            txt = "'%s' User did not say yes to '%s' - no changes made" %(theTitleToDisplay, theAction)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(theFrame,"User did not agree to proceed - no changes made...","NO UPDATE",JOptionPane.ERROR_MESSAGE)
            return False

        if not GlobalVars.lBypassAllBackupsAndDisclaimers_TB:
            if not myPopupAskBackup(theFrame, "Would you like to perform a backup before %s" %(theTitleToDisplay)):
                txt = "'%s' - User chose to exit without the fix/update...."%(theTitleToDisplay)
                setDisplayStatus(txt, "R")
                myPrint("B","'%s' User aborted at the backup prompt to '%s' - no changes made" %(theTitleToDisplay, theAction))
                myPopupInformationBox(theFrame,"User aborted at the backup prompt - no changes made...","DISCLAIMER",JOptionPane.ERROR_MESSAGE)
                return False

            if not doesUserAcceptDisclaimer(theFrame, theTitleToDisplay, theAction):
                setDisplayStatus("'%s' - User declined the disclaimer - no changes made...." %(theTitleToDisplay), "R")
                myPrint("B","'%s' User did not say accept Disclaimer to '%s' - no changes made" %(theTitleToDisplay, theAction))
                myPopupInformationBox(theFrame,"User did not accept Disclaimer - no changes made...","DISCLAIMER",JOptionPane.ERROR_MESSAGE)
                return False

            myPrint("B","'%s' - User has been offered opportunity to create a backup and they accepted the DISCLAIMER on Action: %s - PROCEEDING" %(theTitleToDisplay, theAction))
        else:
            myPrint("B","'%s' - User has DISABLED Backup and Disclaimer warnings: PROCEEDING with %s" %(theTitleToDisplay, theAction))
        return True

    def html_strip_chars(_textToStrip):
        _textToStrip = _textToStrip.replace("  ","&nbsp;&nbsp;")
        _textToStrip = _textToStrip.replace("<","&lt;")
        _textToStrip = _textToStrip.replace(">","&gt;")
        return _textToStrip

    def wrap_HTML_italics(_textToWrap):
        return "<html><i>%s</i></html>" %(html_strip_chars(_textToWrap))

    def wrap_HTML_multi_color(_bigText, _morebigText, _secondaryColor=None):
        if _secondaryColor is None: _secondaryColor = GlobalVars.CONTEXT.getUI().colors.tertiaryTextFG
        _secondaryColorHex = AwtUtil.hexStringForColor(_secondaryColor)
        _htmlBigText = html_strip_chars(_bigText)
        _htmlMoreBigText = html_strip_chars(_morebigText)
        return "<html>%s<font color=#%s>%s</font></html>" %(_htmlBigText, _secondaryColorHex, _htmlMoreBigText)

    class MoneybotURLDebug:
        saveState = None

        def __init__(self): raise Exception("ERROR: Do not call this constructor!")

        @staticmethod
        def changeState(newState):
            MoneybotURLDebug.saveSyncerState = MoneybotURLStreamHandlerFactory.DEBUG
            MoneybotURLStreamHandlerFactory.DEBUG = newState

        @staticmethod
        def resetState():
            if MoneybotURLDebug.saveState is None: return
            MoneybotURLStreamHandlerFactory.DEBUG = MoneybotURLDebug.saveState

    class SyncerDebug:
        saveState = None

        def __init__(self): raise Exception("ERROR: Do not call this constructor!")

        @staticmethod
        def changeState(newState):
            SyncerDebug.saveState = Syncer.DEBUG
            Syncer.DEBUG = newState

        @staticmethod
        def resetState():
            if SyncerDebug.saveState is None: return
            Syncer.DEBUG = SyncerDebug.saveState

    class MainDebug:
        saveState = None

        def __init__(self): raise Exception("ERROR: Do not call this constructor!")

        @staticmethod
        def changeState(newState):
            MainDebug.saveState = MD_REF.DEBUG
            MD_REF.DEBUG = newState

        @staticmethod
        def resetState():
            if MainDebug.saveState is None: return
            MD_REF.DEBUG = MainDebug.saveState

    def logToolboxUpdates(methodName, comments, book=None, onlyLogGenericEntry=False, lOnlyRtnCommonPath=False, lOnlyRtnDatasetPath=False):
        """
        :type methodName: basestring
        :type comments: basestring
        :type book: AccountBook | basestring
        :type onlyLogGenericEntry: bool
        :type lOnlyRtnCommonPath: bool
        :type lOnlyRtnDatasetPath: bool
        :rtype: bool | basestring
        """

        LOGNAME = "toolbox_update_log.txt"

        try:
            nowTimeMS = System.currentTimeMillis()
            intNowTime = DateUtil.convertLongDateToInt(nowTimeMS)

            logPathGeneric = os.path.join(MD_REF.getLogFile().getParent(), LOGNAME)
            if lOnlyRtnCommonPath: return logPathGeneric

            logPathDataset = datasetPath = None
            if not onlyLogGenericEntry or book is not None:
                if book is None: book = MD_REF.getCurrentAccountBook()
                if book is None: raise Exception("ERROR: .getCurrentAccountBook() returned None")

                if isinstance(book, basestring):
                    if not os.path.exists(book): raise Exception("ERROR: book '%s' passed as string but path does not exist!?" %(book))
                    datasetPath = book
                    logPathDataset = os.path.join(datasetPath, LOGNAME)
                else:
                    if isinstance(book, AccountBook): pass
                    datasetPath = book.getRootFolder().getAbsolutePath()
                    logPathDataset = os.path.join(datasetPath, LOGNAME)

                if lOnlyRtnDatasetPath: return logPathDataset

            i = 0
            for logPath in [logPathGeneric, logPathDataset]:
                if i > 0 and onlyLogGenericEntry: break
                logFileExists = os.path.exists(logPath)
                logSize = os.path.getsize(logPath) if logFileExists else 0

                with open(logPath, "ab") as logFile:
                    datasetPathOutput = "." if (i > 0) else datasetPath
                    writer = csv.writer(logFile, dialect='excel', quoting=csv.QUOTE_MINIMAL, delimiter=fix_delimiter(","))
                    if not logFileExists or logSize < 4:
                        logFile.write(codecs.BOM_UTF8)
                        writer.writerow(["TimeUpdateCompletedMS", "DateUpdateCompletedINT", "DatasetPath", "ToolboxFunctionName", "Comments", "MoneydanceBuild", "ToolboxBuild"])
                    writer.writerow([nowTimeMS, intNowTime, datasetPathOutput, methodName, comments, MD_REF.getBuild(), version_build, ""])
                    i += 1

        except:
            myPrint("B", "ERROR in logToolboxUpdates() - No log entry written... Non-critical, so Will just continue...")
            dump_sys_error_to_md_console_and_errorlog()
            return False

        return True

    def isMDThread(threadName):
        for checkName in [ManuallyCloseAndReloadDataset.SYNC_THREAD_NAME, "MD Background Ops", "MDPlus", "MD+", "TaskIndicator"]:
            if threadName.lower().startswith(checkName.lower()): return True
        return False

    def getYN(_bool=False): return "Y" if _bool else "N"

    def getJVMThreadInformation(_thread, _addNewLine=False):
        if _thread is None or not isinstance(_thread, Thread): return
        try:
            _txt = ("%s%s (id: %s) State: %s isAlive: %s isInterrupted: %s isDaemon: %s Priority: %s ThreadGroup: %s @%s(hash: %s)"
                            %(pad("**" if (isMDThread(_thread.getName())) else "", 2),
                              pad(_thread.getName(),70), rpad(_thread.getId(),4),
                              pad(_thread.getState(),15), getYN(_thread.isAlive()), getYN(_thread.isInterrupted()),
                              getYN(_thread.isDaemon()), rpad(_thread.getPriority(),2), _thread.getThreadGroup(),
                              Integer.toHexString(System.identityHashCode(_thread)), System.identityHashCode(_thread)))
        except: _txt = "**ERROR translating Thread information**"
        if _addNewLine: _txt += "\n"
        return _txt

    def getJVMUsageStatistics(memoryUsageStats=True, maxMemoryStats=False, availableProcessorsStats=False):

        runTime = Runtime.getRuntime()
        maxMemory = Runtime.getRuntime().maxMemory()

        countParams = 0
        if memoryUsageStats:         countParams += 1
        if maxMemoryStats:           countParams += 1
        if availableProcessorsStats: countParams += 1

        statsText = u""; lineEnd = u""
        if countParams > 1:
            lineEnd = u"\n"
            statsText += (u"Java JVM Resources" + lineEnd)

        if availableProcessorsStats:
            statsText += (u"JVM - Available processor cores: %s" %(runTime.availableProcessors()) + lineEnd)

        if maxMemoryStats:
            statsText += (u"JVM - Maximum memory possible:   %s" %(u"{}".format(u"no limit") if (Long(maxMemory) == Long.MAX_VALUE) else u"{:,} GB".format(convertBytesGBs(maxMemory))) + lineEnd)

        if memoryUsageStats:
            statsText += (u"JVM - Total memory allocated:    {:,} GB (used {:,} GB / free {:,} GB)"
                .format(convertBytesGBs(runTime.totalMemory()),
                        convertBytesGBs(runTime.totalMemory() - runTime.freeMemory()),
                        convertBytesGBs(runTime.freeMemory()))
                + lineEnd)

        return statsText

    class ManuallyCloseAndReloadDataset(Runnable):

        SYNC_THREAD_NAME = "TIKSync"

        @staticmethod
        def setOtherExtensionsEnabled(otherExtnsEnabled):
            myPrint("DB", "In ManuallyCloseAndReloadDataset.setOtherExtensionsEnabled()")
            ortherExtns = ["extract_data"]
            baseUrl = "moneydance:fmodule:"
            sendCmd = "enable_events" if otherExtnsEnabled else "disable_events"
            for otherExtn in ortherExtns:
                try:
                    wholeCmd = baseUrl + otherExtn + ":" + sendCmd
                    myPrint("DB", "Sending '%s'" %(wholeCmd))
                    MD_REF.showURL(wholeCmd)
                except:
                    e_type, exc_value, exc_traceback = sys.exc_info()                                                   # noqa
                    txt = "Error sending command - ! Error was: '%s'" %(exc_value)
                    myPrint("B", txt)

        @staticmethod
        def closeSecondaryWindows():
            myPrint("DB", "In ManuallyCloseAndReloadDataset.closeSecondaryWindows()")
            if not SwingUtilities.isEventDispatchThread(): return False
            if not ManuallyCloseAndReloadDataset.isSafeToCloseDataset(): return False
            return invokeMethodByReflection(MD_REF.getUI(), "closeSecondaryWindows", [Boolean.TYPE], [False])

        @staticmethod
        def isSafeToCloseDataset():
            # type: () -> bool
            """Checks with MD whether all the Secondary Windows report that they are in a state to close"""
            myPrint("DB", "In ManuallyCloseAndReloadDataset.isSafeToCloseDataset()")
            if not SwingUtilities.isEventDispatchThread(): return False
            return invokeMethodByReflection(MD_REF.getUI(), "isOKToCloseFile", None)

        @staticmethod
        def clearWindowBookReferences(lClearCurrentBookToo=False):
            # type: (bool) -> bool
            """Iterates all known AWT Windows, searching for 'book' references (as 'book' / 'bookRef') and sets to None (or clears the WeakReference)"""
            for _win in Window.getWindows():
                if isinstance(_win, (Component, Window)): pass
                for tryBookRefStr in ["book", "bookRef"]:
                    wr_book = None
                    try: ref_book = getFieldByReflection(_win, tryBookRefStr)
                    except: continue
                    if ref_book is not None:
                        if isinstance(ref_book, WeakReference):
                            wr_book = ref_book                                                                          # type: WeakReference
                            ref_book = wr_book.get()                                                                    # type: AccountBook
                        if (ref_book is not None and isinstance(ref_book, AccountBook)
                                and (lClearCurrentBookToo or ref_book is not MD_REF.getCurrentAccountBook())):
                            if isinstance(_win, (SecondaryWindow, SecondaryFrame, SecondaryDialog)): clearTxt = "CLEARING"
                            else: clearTxt = "IGNORING"
                            myPrint("DB", "%s 'book' %s from: %s '%s' : %s @{:x} %s (Owner: %s:%s)\n".format(System.identityHashCode(ref_book))
                                                                            %(clearTxt,
                                                                              "WeakReference" if (wr_book is not None) else "reference",
                                                                              type(_win),
                                                                              _win.getName(),
                                                                              "** THIS BOOK **" if (ref_book is MD_REF.getCurrentAccountBook()) else "!! OLD BOOK !! ",
                                                                              ref_book,
                                                                              type(_win.getOwner()), (None if (_win.getOwner()) is None else _win.getOwner().getName())))
                            if isinstance(_win, (SecondaryWindow, SecondaryFrame, SecondaryDialog)):
                                try:
                                    if wr_book is not None:
                                        wr_book.clear()
                                    else:
                                        setFieldByReflection(_win, tryBookRefStr, None)
                                except:
                                    myPrint("B", "@@ Error clearing out reference to 'book' (ignoring/continuing)")
                                    dump_sys_error_to_md_console_and_errorlog()
                    del ref_book
            return True

        @staticmethod
        def startBackgroundSyncing():
            """Start a new Background Ops Thread.. Does nothing if 'backgroundThread' is not None and isRunning()"""
            myPrint("DB", "... launching a new BackgroundOpsThread if old one dead or not running...")
            invokeMethodByReflection(MD_REF, "startBackgroundSyncing", None)

        @staticmethod
        def areSyncerThreadsAlive(syncerObj, debugMessage="", checkAllSyncers=False, checkThreadIDs=None):
            # type: (Syncer, basestring, bool, [int]) -> bool
            if checkThreadIDs is None: checkThreadIDs = []
            sThreads = []
            sAliveThreads = []
            myPrint("DB", "In .areSyncerThreadsAlive(syncerObj:%s, debugMessage:'%s', checkAllSyncers:%s, checkThreadIDs:%s)" %(syncerObj, debugMessage, checkAllSyncers, checkThreadIDs))
            for t in [t for t in Thread.getAllStackTraces().keySet() if ManuallyCloseAndReloadDataset.SYNC_THREAD_NAME.lower() in t.getName().lower()]:
                if checkAllSyncers or t.getId() in checkThreadIDs:
                    sThreads.append(t)
            if syncerObj is None:
                myPrint("DB", "... %s getSyncer(): No Syncer Object passed...")
            else:
                syncer_keepSyncing = getFieldByReflection(syncerObj, "keepSyncing")
                myPrint("DB", "... %s getSyncer(): %s (keepSyncing: %s) isRunningInBackground: %s isSyncing: %s"
                        %(debugMessage, syncerObj, syncer_keepSyncing, syncerObj.isRunningInBackground(), syncerObj.isSyncing()))
                if debug: isSyncTaskSyncing(checkMainTask=True, checkAttachmentsTask=False)
                if debug: isSyncTaskSyncing(checkMainTask=False, checkAttachmentsTask=True)
            for t in sThreads:
                myPrint("B", "... Existent Syncer Thread(s)...:", getJVMThreadInformation(t, True))
                if t.isAlive(): sAliveThreads.append(t)
            myPrint("DB", ">>(%s) >> There appear to be %s thread(s) alive (out of %s existing)...."
                    %("ALL Syncers' Threads" if (checkAllSyncers) else "Current Syncer's Threads: %s" %(syncerObj),
                      len(sAliveThreads),
                      len(sThreads)))
            return len(sAliveThreads) > 0

        @staticmethod
        def moneydanceExitOrRestart(lRestart=True, lAllowSaveWorkspace=True):
            # type: (bool, bool) -> bool
            """Checks with MD whether all the Secondary Windows report that they are in a state to close"""
            myPrint("DB", "In ManuallyCloseAndReloadDataset.moneydanceExitOrRestart() - lRestart: %s, lAllowSaveWorkspace: %s" %(lRestart, lAllowSaveWorkspace))

            if lRestart and not lAllowSaveWorkspace: raise Exception("Sorry: you cannot use lRestart=True and lAllowSaveWorkspace=False together...!")

            disableToolboxButtons()

            if lRestart:
                myPrint("B", "@@ RESTARTING MONEYDANCE >> RELOADING SAME DATASET @@")
                Thread(ManuallyCloseAndReloadDataset(), "toolbox_moneydanceExitOrRestart").start()
            else:
                ManuallyCloseAndReloadDataset.setOtherExtensionsEnabled(False)
                if lAllowSaveWorkspace:
                    myPrint("B", "@@ EXITING MONEYDANCE @@")
                    MD_REF.getUI().exit()
                else:
                    myPrint("B", "@@ SHUTTING DOWN MONEYDANCE >> NOT SAVING 'WORKSPACE' @@")
                    MD_REF.getUI().shutdownApp(False)

        @staticmethod
        def manuallyCloseDataset(theBook, lCloseWindows=True, lKillAllSyncers=False, lKillAllFramesWithBookReferences=False):
            # type: (AccountBook, bool, bool, bool) -> int
            """Mimics .setCurrentBook(None) but avoids the Auto Backup 'issue'. Also closes open SecondaryWindows, pauses MD+ etc
            You should decide whether to run this on the EDT or on a new background thread when calling this method. This will also
            try to force kill Syncer thread(s) found... parameter: lKillAllSyncers:False will only kill this dataset's Syncer (True = kill all Syncers found)
            NOTE: As of MD2023.2(5008+)/Java20, Thread.stop() no longer works, so this method will return 0 if successful.
            Returns: 0 if dataset closed OK (and all syncer threads stopped), 1 if closeSecondaryWindows() failed, 2 if closed but Syncer Threads still running"""

            myPrint("DB", "In ManuallyCloseAndReloadDataset.manuallyCloseDataset(), lCloseWindows: %s, lKillAllSyncers: %s lKillAllFramesWithBookReferences: %s" %(lCloseWindows, lKillAllSyncers, lKillAllFramesWithBookReferences))

            lClosedOKStatus = 0

            ManuallyCloseAndReloadDataset.setOtherExtensionsEnabled(False)

            wr_bookToClose = WeakReference(theBook)
            del theBook

            wr_oldSyncer = WeakReference(wr_bookToClose.get().getSyncer())                                              # noqa

            if debug: myPrint("B", getJVMUsageStatistics())

            if lCloseWindows:
                if not SwingUtilities.isEventDispatchThread():
                    raise Exception("ERROR: you must run manuallyCloseDataset() on the EDT if you wish to also call closeSecondaryWindows()...!")
                if not ManuallyCloseAndReloadDataset.closeSecondaryWindows():
                    lClosedOKStatus = 1
                    myPrint("B", "manuallyCloseDataset().closeSecondaryWindows() returned False?")
                    return lClosedOKStatus

            SyncerDebug.changeState(True)

            # Shutdown the MD+ poller... When we open a new dataset it should reset itself.....
            shutdownMDPlusPoller()

            # Shutdown the Alert Controller... When we open a new dataset it should reset itself.....
            shutdownMDAlertController()

            MD_REF.getUI().closeBotInterface()

            wr_bookToClose.get().setUndoManager(None)                                                                   # noqa

            ManuallyCloseAndReloadDataset.areSyncerThreadsAlive(wr_oldSyncer.get(), "pre-close", checkAllSyncers=True)

            myPrint("DB", "... closing SyncManager / settings window etc..")
            if MD_REF.getUI().getSyncManager() is not None:
                MD_REF.getUI().getSyncManager().dataFileWasLoaded(None)  # Essentially will close Sync Manager settings window if open...

            myPrint("DB", "... setting 'olMgr' to None..")
            setFieldByReflection(MD_REF.getUI(), "olMgr", None)

            myPrint("DB", "... saving LocalStorage..")
            wr_bookToClose.get().getLocalStorage().save()                                                               # noqa

            myPrint("DB", "... Mimicking .setCurrentBook(None).... (without auto-backup etc)....")

            MD_REF.fireAppEvent(AppEventManager.FILE_CLOSING)
            MD_REF.saveCurrentAccount()                         # Flush any current txns in memory and start a new sync record..

            MD_REF.fireAppEvent(AppEventManager.FILE_CLOSED)

            # This will call syncer.stopSyncing() and syncer.compressLocalStorage()
            myPrint("DB", "... calling .cleanUp() ....")
            wr_bookToClose.get().cleanUp()                                                                              # noqa

            myPrint("B", "... waiting for background tasks to complete... (shutting down 'backgroundThread'....)...")
            saveBGT = MD_REF.getBackgroundThread()
            saveBGT.waitForAllTasksToFinish()                        # This will actually shut down the Thread.....
            setFieldByReflection(MD_REF, "backgroundThread", None)   # com.moneydance.apps.md.controller.Main.backgroundThread : BackgroundOpsThread

            # Force kill all Syncer Threads. Should not need to do this, but something in MD can keep these alive. Syncer must NOT run after we move a dataset (for example)
            # .... MD2023.2(5008) changed to use multi-threaded Sync (for attachments)....
            # NOTE: The Dropbox Connection (i.e cloud access) syncAttachments thread can block the thread for a long time (resolved in MD2023.2(5019))
            wr_syncerThreads = []
            if wr_oldSyncer.get() is not None:
                try:
                    sThread = getFieldByReflection(wr_oldSyncer.get(), "syncThread")
                    if sThread is not None:
                        wr_syncerThreads.append(WeakReference(sThread))
                    del sThread
                except:
                    sTasks = getFieldByReflection(wr_oldSyncer.get(), "syncTasks")
                    myPrint("DB", "Current book's Syncer: %s, 'syncTasks': %s" %(wr_oldSyncer.get(), sTasks))           # noqa
                    if sTasks is not None and len(sTasks) > 0:
                        for sTask in sTasks:
                            wr_syncerThreads.append(WeakReference(sTask))
                        del sTask
                    del sTasks

            syncerThreadIds = []
            for wr_sThread in wr_syncerThreads:
                if wr_sThread.get() is not None:
                    syncerThreadIds.append(wr_sThread.get().getId())                                                    # noqa
                    myPrint("DB", "Current book's Syncer: %s, SyncerThread: %s (id: %s, isAlive: %s)" %(wr_oldSyncer.get(), wr_sThread.get(), wr_sThread.get().getId(), wr_sThread.get().isAlive()))   # noqa

            if len(syncerThreadIds) < 1:
                myPrint("DB", "Current book's Syncer - no active threads found....")

            iSyncerChecks = 0
            if wr_oldSyncer.get() is not None:
                myPrint("B", "... waiting for current syncer's background task(s) to complete...")
                while wr_oldSyncer.get().isRunningInBackground() or wr_oldSyncer.get().isSyncing():                     # noqa

                    countAlive = 0
                    for wr_sThread in wr_syncerThreads:
                        if wr_sThread.get() is None or not wr_sThread.get().isAlive():                                  # noqa
                            myPrint("B", "...... current syncer's thread appears to have died already.... checking any other threads....")
                        else:
                            countAlive += 1

                    if countAlive < 1:
                        myPrint("B", "...... current syncer's thread(s) appears to have all died already.... will proceed....")
                        break

                    iSyncerChecks += 1
                    if iSyncerChecks <= 40:
                        myPrint("B", "...... syncer task(s) still running.... waiting....")
                        try:
                            Thread.sleep(250)
                            continue
                        except: myPrint("B", "......... Caught exception during sleep... will ignore/continue....")
                    else: myPrint("B", "......... giving up after 40 checks (~10 seconds)...")
                    break

                myPrint("B", "...... current syncer appears to have finished (or Toolbox gave up waiting).....")

            for t in [t for t in Thread.getAllStackTraces().keySet() if ManuallyCloseAndReloadDataset.SYNC_THREAD_NAME.lower() in t.getName().lower()]:
                if lKillAllSyncers or t.getId() in syncerThreadIds:
                    if t.isAlive():
                        myPrint("B", "... Force killing Syncer Thread:", t, t.getId(), t.getName())
                        try:
                            t.interrupt()       # Probably futile....
                            Thread.sleep(250)
                            t.stop()            # This is a deprecated method (and bad practice). (as of MD2023.2(5008+) & java20, no longer works)
                        except UnsupportedOperationException:
                            myPrint("B", "...... Sorry, since java20 toolbox is no longer able to force kill threads.... Ignoring/Continuing...")
                        except:
                            e_type, exc_value, exc_traceback = sys.exc_info()                                               # noqa
                            myPrint("B", "...... Caught exception during stop() command.... Continuing... (Error: '%s')" %(exc_value))
                    else:
                        myPrint("B", "... Ignoring Syncer Thread that reports it's NOT alive:", t, t.getId(), t.getName())

            if ManuallyCloseAndReloadDataset.areSyncerThreadsAlive(wr_oldSyncer.get(), "after-kill syncer threads", checkAllSyncers=lKillAllSyncers, checkThreadIDs=syncerThreadIds):
                myPrint("B", "@@ ERROR - Syncer threads are still alive after shutdown routines. Dataset close will flag this condition to calling code...")
                lClosedOKStatus = 2
                setFieldByReflection(MD_REF, "backgroundThread", saveBGT)   # Allows com.moneydance.apps.md.controller.Main.shutdown() to work
            del saveBGT

            myPrint("DB", "... setting Main's 'currentBook' to None...")
            setFieldByReflection(MD_REF, "currentBook", None)

            myPrint("B", "Closed current dataset (book: %s)" %(wr_bookToClose.get()))

            if lKillAllFramesWithBookReferences:
                myPrint("DB", "... clearing out old references to 'book' (as 'book' / 'bookRef') from Windows/Frames/JFrames etc....")
                ManuallyCloseAndReloadDataset.clearWindowBookReferences()

            if debug: myPrint("B", getJVMUsageStatistics())

            SyncerDebug.resetState()

            myPrint("B", "... FINISHED Closing down the dataset (status: %s) %s" %(lClosedOKStatus, "" if lClosedOKStatus==0 else "@@ WITH ERROR @@"))
            return lClosedOKStatus


        class DisplayErrorMsg(Runnable):
            def __init__(self, _msg): self.msg = _msg
            def run(self): myPopupInformationBox(None, self.msg, "ERROR", JOptionPane.ERROR_MESSAGE)

        THIS_APPS_FRAME_REFERENCE = None

        def __init__(self, lQuitThisAppToo=True):
            self.lQuitThisAppToo = (lQuitThisAppToo and self.__class__.THIS_APPS_FRAME_REFERENCE is not None)
            self.result = None

        def getResult(self): return self.result     # Caution - only call this when you have waited for Thread to complete..... ;->

        def run(self):
            # type: () -> bool
            self.result = self.manuallyCloseAndReloadDataset()

        def manuallyCloseAndReloadDataset(self):
            # type: () -> bool
            """Manually closes current dataset, then reloads the same dataset.. Use when you want to refresh MD's internals"""

            if SwingUtilities.isEventDispatchThread(): raise Exception("ERROR - you must run manuallyCloseAndReloadDataset() from a new non-EDT thread!")

            cswResult = [None]
            class CloseSecondaryWindows(Runnable):
                def __init__(self, result): self.result = result
                def run(self): self.result[0] = ManuallyCloseAndReloadDataset.closeSecondaryWindows()

            SwingUtilities.invokeAndWait(CloseSecondaryWindows(cswResult))
            if not cswResult[0]: return False

            fCurrentFilePath = MD_REF.getCurrentAccountBook().getRootFolder()

            closeDatasetStatus = ManuallyCloseAndReloadDataset.manuallyCloseDataset(MD_REF.getCurrentAccountBook(), lKillAllSyncers=True, lCloseWindows=False, lKillAllFramesWithBookReferences=True)
            if closeDatasetStatus == 1:
                myPrint("B", "WARNING: .manuallyCloseDataset() returned status %s - could not close open windows? No action taken" %(closeDatasetStatus))
                return False

            if closeDatasetStatus != 0:
                txt = "ERROR: .manuallyCloseDataset() returned status %s (probably errant syncer threads). WILL FORCE QUIT MD (RELAUNCH MANUALLY)" %(closeDatasetStatus)
                myPrint("B", txt)
                genericSwingEDTRunner(True, True, myPopupInformationBox, toolbox_frame_, txt, "ERROR RESTARTING", JOptionPane.ERROR_MESSAGE)
                genericSwingEDTRunner(False, False, ManuallyCloseAndReloadDataset.moneydanceExitOrRestart, False, False)
                return False

            if debug: myPrint("B", getJVMUsageStatistics())
            myPrint("DB", "Calling garbage collection after releasing references...")
            System.gc()
            Thread.sleep(100)
            if debug: myPrint("B", getJVMUsageStatistics())

            ManuallyCloseAndReloadDataset.startBackgroundSyncing()

            newWrapper = AccountBookWrapper.wrapperForFolder(fCurrentFilePath)
            if newWrapper is None: raise Exception("ERROR: 'AccountBookWrapper.wrapperForFolder' returned None")
            myPrint("DB", "Successfully obtained 'wrapper' for dataset: %s\n" %(fCurrentFilePath.getCanonicalPath()))

            SyncerDebug.changeState(True)

            ManuallyCloseAndReloadDataset.setOtherExtensionsEnabled(True)

            openResult = None                                                                                           # noqa
            try:
                # .setCurrentBook() always pushes mdGUI().dataFileOpened() on the EDT (if not already on the EDT)....
                myPrint("B", "Opening dataset: %s" %(fCurrentFilePath.getCanonicalPath()))
                openResult = MD_REF.setCurrentBook(newWrapper)
                SyncerDebug.resetState()
            except OutOfMemoryError:
                myPrint("B", "@@@ CRITICAL ERROR <<OUT OF MEMORY>> setCurrentBook() has crashed whilst (re)opening dataset!?")
                dump_sys_error_to_md_console_and_errorlog()
                myPrint("B", getJVMUsageStatistics())
                SwingUtilities.invokeAndWait(self.DisplayErrorMsg("TOOLBOX: OUT OF MEMORY whilst (re)opening dataset. WILL SHUT DOWN MD (review Console/errlog.txt)"))
                MD_REF.getUI().shutdownApp(False)
                return False
            except:
                myPrint("B", "@@@ CRITICAL ERROR - .setCurrentBook() has crashed whilst (re)opening dataset!?")
                dump_sys_error_to_md_console_and_errorlog()
                SwingUtilities.invokeAndWait(self.DisplayErrorMsg("TOOLBOX: ERROR: whilst (re)opening dataset.  WILL SHUT DOWN MD (review Console/errlog.txt)"))
                MD_REF.getUI().shutdownApp(False)
                return False

            if debug: myPrint("B", getJVMUsageStatistics())

            if not openResult or newWrapper.getBook() is None:
                txt = "Failed to open Dataset (wrong password?).... Will show the Welcome Window...."
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                WelcomeWindow.showWelcomeWindow(MD_REF.getUI())

                if self.lQuitThisAppToo:
                    # Remember... the file opened event closes my extensions with app listeners, so do this if file could not be opened....
                    if self.__class__.THIS_APPS_FRAME_REFERENCE is not None:
                        if isinstance(self.__class__.THIS_APPS_FRAME_REFERENCE, JFrame):
                            # Do this after .setCurrentBook() so-as not to co-modify listeners.....
                            SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.__class__.THIS_APPS_FRAME_REFERENCE))

                return False
            return True


    def isQER_running(): return find_feature_module(GlobalVars.Strings.EXTENSION_QER_ID)

    def isQuoteLoader_running():
        # type: () -> int
        """Returns None if not detected/loaded, 0=Detected and NOT busy, 1=Detected but needs manual checks, 2=Detected and is BUSY, 3=Detected, but reflection failed"""

        QL_ID_MIN_VER = 3047        # Mike Bray added special variables for Toolbox to check in QL build 3047

        QL_NOTFOUND = None; QL_NOTBUSY = 0; QL_TOOOLD = 1; QL_BUSY = 2; QL_ERROR = 3                                    # noqa

        foundQLfm = find_feature_module(GlobalVars.Strings.EXTENSION_QL_ID)
        if foundQLfm is None:
            myPrint("DB","QL NOT detected...")
            return QL_NOTFOUND

        if foundQLfm.getBuild() < QL_ID_MIN_VER:                                                                                        # noqa
            myPrint("DB","QL(%s) detected... (but too old for special reflection checks) User to check manually" %(foundQLfm.getBuild()))  # noqa
            return QL_TOOOLD

        try:
            myPrint("DB","Reflecting... Detecting QuoteLoader.....:")
            ql_isGUIOpen = getFieldByReflection(foundQLfm, "isGUIOpen")
            ql_isUpdating = getFieldByReflection(foundQLfm, "isUpdating")
            ql_isQuotesRunning = getFieldByReflection(foundQLfm, "isQuotesRunning")

            myPrint("DB","...QL isGUIOpen:       %s" %(ql_isGUIOpen))
            myPrint("DB","...QL isUpdating:      %s" %(ql_isUpdating))
            myPrint("DB","...QL isQuotesRunning: %s" %(ql_isQuotesRunning))

            if ql_isGUIOpen or ql_isUpdating or ql_isQuotesRunning:
                myPrint("DB",">> Detected QL appears to be BUSY...")
                return QL_BUSY

            myPrint("DB",">> QL was detected, but appears NOT busy")

        except:
            myPrint("DB","@@ QL detected but reflection check failed! (please contact Toolbox author)")
            dump_sys_error_to_md_console_and_errorlog()
            return QL_ERROR

        return QL_NOTBUSY

    def perform_qer_quote_loader_check(_frame, _txt, lDialogs=True):
        # type: (JFrame, str, bool) -> int
        """Checks for QER or QL extensions running, pops up a message if needed asking user to check. Response of True = SAFE"""

        resultQER = isQER_running()

        QL_NOTFOUND = None; QL_NOTBUSY = 0; QL_TOOOLD = 1; QL_BUSY = 2; QL_ERROR = 3                                    # noqa

        # Returns None if not detected/loaded, 0=Detected and NOT busy, 1=Detected but needs manual checks, 2=Detected and is BUSY, 3=Detected, but reflection failed"""
        resultQL = isQuoteLoader_running()

        lSafeToProceed = True
        if not resultQER and not resultQL:
            txt = "Q&ER / QuoteLoader are not detected/running - proceeding...."
            setDisplayStatus(txt, "B")
            return lSafeToProceed

        lSafeToProceed = False
        if not lDialogs: return lSafeToProceed

        QER_text = "Q&ER detected. " if (resultQER) else ""

        QL_text = "QL detected" if (resultQL) else ""
        if resultQL == QL_BUSY: QL_text += " and appears BUSY. "
        else: QL_text += ". "

        if not resultQER and resultQL == QL_BUSY:
            txt = "Sorry: QL appears busy (try again later)"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(_frame, txt, "Quote Loader detection", theMessageType=JOptionPane.WARNING_MESSAGE)
            return lSafeToProceed

        saveYES = UIManager.get("OptionPane.yesButtonText"); saveNO = UIManager.get("OptionPane.noButtonText")
        UIManager.put("OptionPane.yesButtonText", "OK - CONTINUE"); UIManager.put("OptionPane.noButtonText", "STOP - I NEED TO CHECK")
        ask = myPopupAskQuestion(_frame,"Q&ER / QUOTE LOADER DETECTION","%s%s Confirm that they're not updating before running '%s'?" %(QER_text, QL_text, _txt))
        UIManager.put("OptionPane.yesButtonText", saveYES); UIManager.put("OptionPane.noButtonText", saveNO)

        if not ask:
            txt = "Q&ER / QuoteLoader loaded (or busy). Please verify they're not updating before running '%s' - no changes made" %(_txt)
            setDisplayStatus(txt, "R")
            return lSafeToProceed

        txt = "User verified that Q&ER / QuoteLoader are not running - proceeding...."
        setDisplayStatus(txt, "B")

        lSafeToProceed = True
        return lSafeToProceed

    class MyJScrollPaneForJOptionPane(JScrollPane, HierarchyListener):   # Allows a scrollable/resizeable menu in JOptionPane
        def __init__(self, _component, _max_w=800, _max_h=600):
            super(JScrollPane, self).__init__(_component)
            self.maxWidth = _max_w
            self.maxHeight = _max_h
            self.borders = 90
            self.screenSize = Toolkit.getDefaultToolkit().getScreenSize()
            self.setOpaque(False)
            self.setViewportBorder(EmptyBorder(5, 5, 5, 5))
            self.addHierarchyListener(self)

        def getPreferredSize(self):
            frame_width = int(round((toolbox_frame_.getSize().width - self.borders) *.9,0))
            frame_height = int(round((toolbox_frame_.getSize().height - self.borders) *.9,0))
            return Dimension(min(self.maxWidth, frame_width), min(self.maxHeight, frame_height))

        def hierarchyChanged(self, e):                                                                                  # noqa
            dialog = SwingUtilities.getWindowAncestor(self)
            if isinstance(dialog, Dialog):
                if not dialog.isResizable():
                    dialog.setResizable(True)

    def getTheSetting(what, _padLength=0):
        _x = MD_REF.getPreferences().getSetting(what, None)
        if not _x or _x == u"": return None
        if _padLength < 1: return u"%s: %s" %(what, _x)
        return u"%s%s" %(pad("%s:" %(what),_padLength), _x)

    def isPreviewBuild():
        if MD_EXTENSION_LOADER is not None:
            try:
                stream = MD_EXTENSION_LOADER.getResourceAsStream("/_PREVIEW_BUILD_")
                if stream is not None:
                    myPrint("B", "@@ PREVIEW BUILD (%s) DETECTED @@" %(version_build))
                    stream.close()
                    return True
            except: pass
        return False

    def isToolboxUnlocked(): return GlobalVars.TOOLBOX_UNLOCK

    def isMDPlusUniqueBankingServicesEnabledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_MDPLUS_TEST_UNIQUE_BANKING_SERVICES_BUILD)   # 2022.4

    def isMDPlusGetPlaidClientEnabledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_MDPLUS_GETPLAIDCLIENT_BUILD)                        # 2022.5

    def isRRateCurrencyIssueFixedBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_RRATE_ISSUE_FIXED_BUILD)                                # 2021.2

    def isKotlinCompiledBuildAll(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_KOTLIN_COMPILED_BUILD_ALL)                                           # 2023.0(5000)

    if isKotlinCompiledBuild():
        from okio import BufferedSource, Buffer, Okio
        if debug: myPrint("B", "** Kotlin compiled build detected, new libraries enabled.....")

    def convertBufferedSourceToInputStream(bufferedSource):
        if isKotlinCompiledBuild() and isinstance(bufferedSource, BufferedSource):
            return bufferedSource.inputStream()
        return bufferedSource

    if isMDPlusEnabledBuild():
        from com.moneydance.apps.md.controller import MDPlus
        from com.infinitekind.moneydance.model import OnlineServiceLink

    if isMDPlusGetPlaidClientEnabledBuild():
        from com.infinitekind.moneydance.model import OnlineAccountMapping
        from com.moneydance.apps.md.controller.olb.plaid import PlaidConnection
        from com.plaid.client.request import ItemRemoveRequest, AccountsGetRequest

    def getMDPlusLicenseInfoForBook():
        _licenseObject = MD_REF.getCurrentAccountBook().getItemForID("tik.mdplus-license")	    # type: MoneydanceSyncableItem
        return _licenseObject

    def getMDPlusPlaidSettings():
        _plaidSettings = MD_REF.getCurrentAccountBook().getItemForID(GlobalVars.Strings.MD_PLAID_SETTINGS_OBJ_ID)	    # type: MoneydanceSyncableItem
        return _plaidSettings

    def isMDPlusLicenseActivated():
        if isMDPlusEnabledBuild():
            _licenseObject = getMDPlusLicenseInfoForBook()
            if _licenseObject is not None:
                mdplus_email = _licenseObject.getParameter("mdplus.account_email", None)
                mdplus_signup_status = _licenseObject.getParameter("signup_status", None)

                # noinspection PyUnresolvedReferences
                if (mdplus_email and len(mdplus_email) > 0
                        and mdplus_signup_status and mdplus_signup_status.lower() == "activated"):
                    return True
        return False

    def file_chooser_wrapper(_methodTitle, _startingFolder, _dialogTitle, _proceedButtonText, _invisibles):
        # With the latest MacOSx, FileDialog causes some problems when as accessing 'system' locations.
        # ...it presents the last used non-system location - useless for this - we want this specific directory....!
        # JFileChooser has a non native LaF on Mac, but worked... But then VAQua broke it....
        # MacOS: ~/Library/Containers/com.infinitekind.MoneydanceOSX/Data/Documents is a system-location
        # User will have to manually navigate... Oh well!
        # Update.... as of 2022/07/04 - Now using AppleScript to open this location! ;->

        selectedFile = getFileFromAppleScriptFileChooser(toolbox_frame_,                    # Parent frame or None
                                                         _startingFolder,                   # Starting path
                                                         None,                              # Default Filename
                                                         _dialogTitle,                      # Title
                                                         False,                             # Multi-file selection mode
                                                         True,                              # True for Open/Load, False for Save
                                                         True,                              # True = Files, else Dirs
                                                         _proceedButtonText,                # Load/Save button text, None for defaults
                                                         None,                              # File filter (non Mac only). Example: "txt" or "qif"
                                                         lAllowTraversePackages=True,
                                                         lAllowTraverseApplications=True,
                                                         lForceJFC=False,
                                                         lForceFD=False,
                                                         lAllowNewFolderButton=False,
                                                         lAllowOptionsButton=False,
                                                         lInvisibles=_invisibles)

        if selectedFile is None or selectedFile == "":
            txt = "%s: User chose to cancel or no file selected." %(_methodTitle)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _methodTitle, theMessageType=JOptionPane.WARNING_MESSAGE)
            return None

        if not os.path.exists(selectedFile) or not os.path.isfile(selectedFile):
            txt = "%s: Sorry, file selected to extract either does not exist or is not a file?" %(_methodTitle)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _methodTitle, theMessageType=JOptionPane.WARNING_MESSAGE)
            return None

        return selectedFile


    def getFileFromAppleScriptFileChooser(fileChooser_parent,                  # The Parent Frame, or None
                                          fileChooser_starting_dir,            # The Starting Dir
                                          fileChooser_filename,                # Default filename (or None)
                                          fileChooser_title,                   # The Title (with FileDialog, only works on SAVE)
                                          fileChooser_multiMode,               # Normally False (True has not been coded!)
                                          fileChooser_open,                    # True for Open/Load, False for Save
                                          fileChooser_selectFiles,             # True for files, False for Directories
                                          fileChooser_OK_text,                 # Normally None, unless set - use text
                                          fileChooser_fileFilterText=None,     # E.g. "txt" or "qif"
                                          lForceJFC=False,
                                          lForceFD=False,
                                          lAllowTraversePackages=None,
                                          lAllowTraverseApplications=None,     # JFileChooser only..
                                          lAllowNewFolderButton=True,          # JFileChooser only..
                                          lAllowOptionsButton=None,            # JFileChooser only..
                                          lInvisibles=False):                  # AppleScript only..
        # type: (JFrame, str, str, str, bool, bool, bool, str, str, bool, bool, bool, bool, bool, bool, bool) -> str
        """If on a Mac and AppleScript exists then will attempt to load AppleScript file/folder chooser, else calls getFileFromFileChooser() which loads JFileChooser() or FileDialog() accordingly"""

        if not Platform.isOSX() or not File("/usr/bin/osascript").exists() or not isOSXVersionBigSurOrLater():
            return getFileFromFileChooser(fileChooser_parent,
                                          fileChooser_starting_dir,
                                          fileChooser_filename,
                                          fileChooser_title,
                                          fileChooser_multiMode,
                                          fileChooser_open,
                                          fileChooser_selectFiles,
                                          fileChooser_OK_text,
                                          fileChooser_fileFilterText,
                                          lForceJFC, lForceFD,
                                          lAllowTraversePackages, lAllowTraverseApplications,
                                          lAllowNewFolderButton, lAllowOptionsButton)

        myPrint("B", "Mac: switching to AppleScript for folder/file selector..:")

        _TRUE = "true"; _FALSE = "false"
        appleScript = "/usr/bin/osascript"

        lAllowInvisibles = lInvisibles
        multipleSelectionsAllowed = _TRUE if fileChooser_multiMode else _FALSE
        showPackageContents = _TRUE if lAllowTraversePackages else _FALSE
        showInvisibles = _TRUE if lAllowInvisibles else _FALSE

        cmdTitle = ""
        cmdDefaultPath = ""
        cmdExtension = ""
        cmdInvisibles = ""
        cmdMultipleSelections = ""
        cmdShowPackageContents = ""
        cmdNewName = ""

        cmdChooseWhat = "file " if fileChooser_selectFiles else "folder "

        if fileChooser_title is not None and isinstance(fileChooser_title, basestring) and len(fileChooser_title) > 0:
            cmdTitle = "with prompt \"%s\" " %(fileChooser_title)

        lRequestingNewName = (not fileChooser_open and fileChooser_selectFiles)
        if lRequestingNewName:
            cmdChooseWhat = "file name "
            if fileChooser_filename is not None and isinstance(fileChooser_filename, basestring) and len(fileChooser_filename) > 0:
                cmdNewName = "default name \"%s\" " %(fileChooser_filename)
        else:
            if (fileChooser_fileFilterText is not None and fileChooser_selectFiles):
                cmdExtension = "of type {\"%s\"} " %(fileChooser_fileFilterText)
            cmdInvisibles = "invisibles %s " %(showInvisibles)
            cmdMultipleSelections = "multiple selections allowed %s " %(multipleSelectionsAllowed)
            cmdShowPackageContents = "showing package contents %s " %(showPackageContents)

        if File(fileChooser_starting_dir).exists():
            cmdDefaultPath = "default location (POSIX file \"%s\") " %(fileChooser_starting_dir)

        cmdStr = ["%s" %(appleScript),
                 "-e",
                 "return POSIX path of (choose %s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                  ")"
                  %(cmdChooseWhat, cmdTitle, cmdExtension, cmdNewName, cmdDefaultPath, cmdInvisibles, cmdMultipleSelections, cmdShowPackageContents),
                ]

        try:
            myPrint("DB", "AppleScript Command: '%s'" %(cmdStr))

            process = None
            exec("process = Runtime.getRuntime().exec(cmdStr)")         # Use exec to avoid Intellij [invalid] code error
            if isinstance(process, Process): pass
            result = process.waitFor()
            err = BufferedReader(InputStreamReader(process.getErrorStream())).readLine()
            if err is not None and isinstance(err, basestring) and ("user cancelled" in err.lower() or "(-128)" in err):
                myPrint("DB", "** AppleScript: USER CANCELLED FILE SELECTION ** ")
                return None
            if result != 0:
                myPrint("DB", "ERROR: AppleScript returned error:", result, err)
                return None
            _theFile = BufferedReader(InputStreamReader(process.getInputStream())).readLine()
            myPrint("DB", "AppleScript - User selected file:", _theFile, "Exists:", File(_theFile).exists())
            return _theFile

        except:
            myPrint("B", "ERROR: getFileFromAppleScriptFileChooser() has crashed?!")
            dump_sys_error_to_md_console_and_errorlog()
            return None

    def calculateMoneydanceDatasetSize(_lReturnMBs=False, whichBook=None):
        """Calculates and returns the size of the Moneydance dataset in bytes (or MBs when _lReturnMBs=True), and file count"""

        if whichBook is None or not isinstance(whichBook, AccountBook):
            book = MD_REF.getCurrentAccountBook()
        else:
            book = whichBook

        total_size_MBs = 0.0
        count_files = total_size = 0

        try:
            startDir = book.getRootFolder().getCanonicalPath()

            for path, dirs, files in os.walk(startDir):
                for f in files:
                    fp = os.path.join(path, f)
                    count_files += 1
                    total_size += os.path.getsize(fp)

            if total_size > 0: total_size_MBs = convertBytesMBs(total_size)

        except:
            myPrint("B", "ERROR: Crashed whilst calculating dataset size?!")
            dump_sys_error_to_md_console_and_errorlog()
            return (0.0,0)

        myPrint("DB", "Calculated dataset size as %s bytes, %sMBs (containing: %s files)" %(total_size, total_size_MBs, count_files))

        if _lReturnMBs: return (total_size_MBs, count_files)
        return (total_size, count_files)

    def removeEmptyDirs(_pathToSearch):
        """Given a valid path, this method searches for and then removes all empty sub-directories"""

        # Failsafe checks....
        if not isinstance(_pathToSearch, (unicode, str)):   return False
        if _pathToSearch is None:                           return False
        if not os.path.exists(_pathToSearch):               return False
        if not os.path.isdir(_pathToSearch):                return False
        if len(_pathToSearch) < len(".moneydance"):         return False

        lOK = True
        countDeleted = 0
        storeEmptyDirs = []
        try:
            for root, dirs, files in os.walk(_pathToSearch, topdown=False):
                for name in dirs:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp): continue
                    if not os.path.isdir(fp): continue
                    if len(os.listdir(fp)) < 1: storeEmptyDirs.append(fp)

            myPrint("DB", "removeEmptyDirs(%s) Found %s empty directories" %(_pathToSearch, len(storeEmptyDirs)))
            for f in storeEmptyDirs:
                try:
                    os.removedirs(f)    # This actually deletes up the tree until a non empty dir is found..... (I hope..)
                    myPrint("DB", ".. removed structure for: %s" %(f))
                    countDeleted += 1
                except:
                    lOK = False
                    myPrint("B", ".. ERROR removing structure for: %s" %(f))
        except:
            lOK = False
            myPrint("B","ERROR: removeEmptyDirs(%s) crashed" %(_pathToSearch))
            dump_sys_error_to_md_console_and_errorlog()

        if not lOK: myPrint("B","ERROR: 1 or more directory structures could not be removed...")
        myPrint("B","%s: %s directory structures sucessfully deleted" %(_pathToSearch, countDeleted))
        return lOK

    def is_file_older_than_x_days(_file, _days=1):
        file_time = os.path.getmtime(_file) 	# Check against 24 hours
        if ((time.time() - file_time) / 3600) > (24 * _days):
            return True
        return False

    class DownloadExtensionVersionData(Runnable):       # Runs in a separate non-EDT thread - prevents Toolbox GUI hanging on launch

        _isDownloading = _downloadsCompleted = _didErrorOccur = False

        downloadedIKExtensionsDict = StreamTable()
        downloadedGitHubToolboxMetaInfoDict = StreamTable()
        downloadedGitHubVersionRequirementsDict = StreamTable()

        @staticmethod
        def isDownloading(): return DownloadExtensionVersionData._isDownloading

        @staticmethod
        def downloadsCompleted(): return DownloadExtensionVersionData._downloadsCompleted

        @staticmethod
        def didErrorOccur(): return DownloadExtensionVersionData._didErrorOccur

        def __init__(self):
            if (DownloadExtensionVersionData.isDownloading() or DownloadExtensionVersionData.downloadsCompleted() or DownloadExtensionVersionData.didErrorOccur()
                    or DownloadExtensionVersionData.downloadedGitHubVersionRequirementsDict or DownloadExtensionVersionData.downloadedIKExtensionsDict or DownloadExtensionVersionData.downloadedGitHubToolboxMetaInfoDict):
                raise Exception("ERROR: Class DownloadExtensionVersionData - seems to have been initialized more than once?!")

        class DisplayErrorMsg(Runnable):
            def __init__(self, _msg, _parent=None): self.msg = _msg; self.parent = _parent
            def run(self): myPopupInformationBox(self.parent, self.msg, "ERROR", JOptionPane.ERROR_MESSAGE)

        def run(self):
            myPrint("DB", "EXECUTING::DownloadExtensionVersionData.run() in new Thread(): %s(id: %s)" %(Thread.currentThread(), Thread.currentThread().getId()))
            if SwingUtilities.isEventDispatchThread(): raise Exception("ERROR: Class DownloadExtensionVersionData.run() - should not run on the EDT!")

            MD_EXTNS_DICT_URL = System.getProperty("moneydance.extension_list_url", GlobalVars.MD_EXTENSIONS_DIRECTORY_FILE)

            loopConnections = [
                [GlobalVars.TOOLBOX_VERSION_VALIDATION_URL, DownloadExtensionVersionData.downloadedGitHubVersionRequirementsDict, "Toolbox code servers"],
                [MD_EXTNS_DICT_URL, DownloadExtensionVersionData.downloadedIKExtensionsDict, "IK Servers"],
                [GlobalVars.TOOLBOX_OWN_DICT_URL, DownloadExtensionVersionData.downloadedGitHubToolboxMetaInfoDict, "Toolbox code servers"]
            ]

            DownloadExtensionVersionData._isDownloading = True
            startTimeMS = System.currentTimeMillis()
            connectionTimeoutMS = (10 * 1000)   # 10 seconds... But not sure timeout actually works on all platforms....

            try:
                for theURL, theVariable, txtType in loopConnections:
                    txt = "### INFORMATION: %s connecting to %s to check extension version data / requirement(s) - IT IS NOT SENDING ANY DATA ###" %(myModuleID.capitalize(), txtType)
                    myPrint("B", txt)
                    MoneybotURLDebug.changeState(debug)

                    inx = None
                    try:
                        myPrint("DB", "About to open url: %s" %(theURL))
                        url = URL(theURL)
                        conn = url.openConnection()
                        conn.setConnectTimeout(connectionTimeoutMS)
                        conn.setReadTimeout(connectionTimeoutMS)
                        inx = BufferedReader(InputStreamReader(conn.getInputStream(), "UTF8"))
                        theVariable.readFrom(inx)
                        myPrint("DB", "Success downloading extension version data / requirement(s) from %s ...." %(txtType))
                    except:
                        DownloadExtensionVersionData._didErrorOccur = True
                        myPrint("B", "ERROR downloading extension version data / requirement(s) from: %s" %(theURL))
                        if debug: dump_sys_error_to_md_console_and_errorlog()
                    finally:
                        MoneybotURLDebug.resetState()
                        if inx:
                            try: inx.close()
                            except: pass

                    if Thread.currentThread().isInterrupted(): raise InterruptedException
                    if DownloadExtensionVersionData.didErrorOccur(): break

                DownloadExtensionVersionData._isDownloading = False
                DownloadExtensionVersionData._downloadsCompleted = True

                txt = ">>> %s finished downloading latest extension(s) version data >> Took %s seconds... Performing version checks..." %(myModuleID.capitalize(), (System.currentTimeMillis() - startTimeMS) / 1000.0)
                myPrint("DB", ">>> DownloadExtensionVersionData.run() %s" %(txt))

                if DownloadExtensionVersionData.didErrorOccur():
                    txt = "Error downloading latest extension(s) version data from Internet. Continuing without live version validation..."
                    myPrint("B", txt)

                self.updateWithLatestToolboxVersionRequirements()

                lAbort = False
                if (GlobalVars.TOOLBOX_STOP_NOW
                        or (float(MD_REF.getVersion()) < GlobalVars.TOOLBOX_MINIMUM_TESTED_MD_VERSION)
                        or (int(float(MD_REF.getVersion())) > int(GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION))):
                    lAbort = True
                else:
                    if (float(MD_REF.getBuild()) > GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD):
                        sTxt = "MD build (%s)%s is newer than the Toolbox tested build of (%s)%s"\
                              %(MD_REF.getVersion(), MD_REF.getBuild(), GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION, GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD)
                        mTxt = "Toolbox(build: %s) has not been tested on this version of Moneydance\n" \
                               "Click proceed to continue using Toolbox on untested newer MD version\n" \
                               "... or cancel to quit Toolbox ..." %(version_build)

                        ask = MyPopUpDialogBox(toolbox_frame_,
                                             theStatus=sTxt,
                                             theTitle="NEWER MD VERSION",
                                             theMessage=mTxt,
                                             lCancelButton=True,
                                             OKButtonText="PROCEED",
                                             lAlertLevel=1)
                        if not ask.go(): lAbort = True

                if lAbort:
                    disableToolboxButtons()
                    if GlobalVars.TOOLBOX_STOP_NOW:
                        sTxt = "Toolbox DISABLED (check for version update Extension>Manage Extensions)"
                        mTxt = "This is not necessarily a problem. Please check for an update\n" \
                               "... if no updates are available, contact Mr Toolbox ..."
                        myPrint("B", txt)
                        MyPopUpDialogBox(toolbox_frame_, theStatus=sTxt, theMessage=mTxt, theTitle="TOOLBOX DISABLED", OKButtonText="QUIT", lAlertLevel=2).go()
                    else:
                        sTxt = ("Sorry, this Toolbox (build %s) has only been tested on Moneydance versions %s thru' %s(build %s)... Yours is %s(%s)"
                                %(version_build, GlobalVars.TOOLBOX_MINIMUM_TESTED_MD_VERSION, GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION, GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD,MD_REF.getVersion(),MD_REF.getBuild()))
                        mTxt = "Please install 'compatible' Toolbox / MD versions...."
                        myPrint("B", txt)
                        MyPopUpDialogBox(toolbox_frame_, theStatus=sTxt, theMessage=mTxt, theTitle="VERSION INCOMPATIBILITY", OKButtonText="QUIT", lAlertLevel=2).go()

                    terminate_script()

                else:
                    myPrint("DB", "FINISHED checking downloaded version requirements data... All OK!")

                    myPrint("DB", "Checking for updatable extensions....")
                    _tb_extn_avail_version = self.check_for_updatable_extensions_on_startup()

                    myModule = DownloadExtensionVersionData.downloadedGitHubToolboxMetaInfoDict.get("id")
                    if myModule == myModuleID:
                        availableFromGitHubVersion = int(DownloadExtensionVersionData.downloadedGitHubToolboxMetaInfoDict.get("module_build"))

                        if _tb_extn_avail_version > int(version_build):
                            myPrint("B","@@ Extension version %s (signed) is available from Moneydance Menu>>Manage Extensions Menu @@" %(_tb_extn_avail_version))
                            mTxt = "You are running version %s\n" %(version_build)
                            mTxt += "Extension version %s (signed) is available from Moneydance Menu>>Manage Extensions Menu\n" %(_tb_extn_avail_version)
                            MyPopUpDialogBox(toolbox_frame_, theStatus="Toolbox Version:", theMessage=mTxt, theTitle="UPGRADE AVAILABLE", OKButtonText="Acknowledge", lModal=False).go()

                        elif availableFromGitHubVersion > int(version_build) and availableFromGitHubVersion > _tb_extn_avail_version:
                            myPrint("DB","@@ FYI - Toolbox upgrade to version %s (unsigned) is available from Author's code site.... @@" %(availableFromGitHubVersion))
                        else:
                            myPrint("DB","Toolbox is running latest version available: %s" %(max(version_build, availableFromGitHubVersion)))

                    elif DownloadExtensionVersionData.didErrorOccur():
                        txt = "TOOLBOX: Error occurred downloading latest extension(s) version data from internet"
                        MyPopUpDialogBox(toolbox_frame_, theStatus=txt, theMessage="Toolbox will ignore and just continue", theTitle="INTERNET CONNECTION ERROR", OKButtonText="Acknowledge", lAlertLevel=2, lModal=False).go()

                    myPrint("DB", "FINISHED checking for updatable extensions....")

            except InterruptedException:
                myPrint("DB", "** DownloadExtensionVersionData.run() - Interrupted (perhaps Toolbox (re)install/(re)launch?) - will just quit this thread...")

            myPrint("DB", ">>> Finished executing DownloadExtensionVersionData.run() - Took %s cumulative seconds" %((System.currentTimeMillis() - startTimeMS) / 1000.0))

        def updateWithLatestToolboxVersionRequirements(self):

            this_toolbox_build = int(version_build)
            if this_toolbox_build < 1000:
                myPrint("B", "ERROR with Toolbox build (early) version %s  - will just proceed without safeguards" %(this_toolbox_build))
                return

            if DownloadExtensionVersionData.downloadedGitHubVersionRequirementsDict is None:
                myPrint("B", "Error: Toolbox version requirement(s) information after download is Empty - will just proceed without safeguards")
                return

            lastUpdated = DownloadExtensionVersionData.downloadedGitHubVersionRequirementsDict.getStr("last_updated", "UNKNOWN")
            myPrint("DB","Last Updated: %s" %(lastUpdated))

            GlobalVars.TOOLBOX_STOP_NOW = DownloadExtensionVersionData.downloadedGitHubVersionRequirementsDict.getBoolean("disable_all", False)
            if GlobalVars.TOOLBOX_STOP_NOW:
                myPrint("B","Sorry - disable_all has been set by the Developer.... Toolbox must close...".upper())
                return
            else:
                myPrint("DB", "Confirmed that disable_all NOT set....")

            buildList = DownloadExtensionVersionData.downloadedGitHubVersionRequirementsDict.get("builds", None)        # type: StreamVector
            if not buildList or buildList is None:
                myPrint("DB","Error - failed to download or decode build list - will just proceed without safeguards")
                return

            buildTable = []

            try:
                for buildObj in buildList:                                                                              # type: StreamTable
                    if not (isinstance(buildObj, StreamTable)):
                        myPrint("DB", "ERROR - Retrieved toolbox build info is not a StreamTable(). It's %s %s" %(type(buildObj), buildObj))
                        continue

                    buildTable.append(ToolboxBuildInfo(buildObj))

            except:
                dump_sys_error_to_md_console_and_errorlog()
                myPrint("B", "ERROR decoding downloading toolbox version/build data! - will just proceed without safeguards...")
                return

            if len(buildTable) < 1:
                myPrint("B", "ERROR decoded downloaded toolbox version/build data is empty! - will just proceed without safeguards...")
                return

            buildTable = sorted(buildTable, key=lambda _x: (_x.build), reverse=True)          # type: [ToolboxBuildInfo]
            # Already sorted - newest build first
            for moduleBuild in buildTable:          # type: ToolboxBuildInfo
                if moduleBuild.build < 1000:
                    myPrint("DB","Found INVALID downloaded module build %s (ignoring and stopping search)... (%s)" %(moduleBuild.build, moduleBuild.obj ))
                    return
                elif moduleBuild.build > this_toolbox_build:
                    myPrint("DB","Found NEWER downloaded module build %s (ignoring and continuing search).. (%s)" %(moduleBuild.build, moduleBuild.obj ))
                    continue
                elif moduleBuild.build == this_toolbox_build:
                    myPrint("DB","Found EXACT-HIT downloaded module build %s OVERRIDING PROGRAM's DEFAULTS....! (%s)" %(moduleBuild.build, moduleBuild.obj ))

                    if debug:
                        myPrint("DB", "Program defaults were...:")
                        myPrint("DB", " TOOLBOX_STOP_NOW:                     %s"     %(GlobalVars.TOOLBOX_STOP_NOW))
                        myPrint("DB", " TOOLBOX_MINIMUM_TESTED_MD_VERSION:    %s"     %(GlobalVars.TOOLBOX_MINIMUM_TESTED_MD_VERSION))
                        myPrint("DB", " TOOLBOX_MAXIMUM_TESTED_MD_VERSION:    %s"     %(GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION))
                        myPrint("DB", " TOOLBOX_MAXIMUM_TESTED_MD_BUILD:      %s"     %(GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD))
                        myPrint("DB", " MD_OFX_BANK_SETTINGS_DIR:             %s"     %(GlobalVars.MD_OFX_BANK_SETTINGS_DIR))
                        myPrint("DB", " MD_OFX_DEFAULT_SETTINGS_FILE:         %s"     %(GlobalVars.MD_OFX_DEFAULT_SETTINGS_FILE))
                        myPrint("DB", " MD_OFX_DEBUG_SETTINGS_FILE:           %s"     %(GlobalVars.MD_OFX_DEBUG_SETTINGS_FILE))
                        myPrint("DB", " MD_EXTENSIONS_DIRECTORY_FILE:         %s"     %(GlobalVars.MD_EXTENSIONS_DIRECTORY_FILE))
                        myPrint("DB", " MYPYTHON_DOWNLOAD_URL:                %s"     %(GlobalVars.MYPYTHON_DOWNLOAD_URL))

                    GlobalVars.TOOLBOX_STOP_NOW = moduleBuild.disable
                    if moduleBuild.TOOLBOX_MINIMUM_TESTED_MD_VERSION > 0:
                        GlobalVars.TOOLBOX_MINIMUM_TESTED_MD_VERSION =     moduleBuild.TOOLBOX_MINIMUM_TESTED_MD_VERSION
                    if moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_VERSION:
                        GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =     moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_VERSION
                    if moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_BUILD > 0:
                        GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =       moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_BUILD
                    if len(moduleBuild.MD_OFX_BANK_SETTINGS_DIR) > 0:
                        GlobalVars.MD_OFX_BANK_SETTINGS_DIR =              moduleBuild.MD_OFX_BANK_SETTINGS_DIR
                    if len(moduleBuild.MD_OFX_DEFAULT_SETTINGS_FILE) > 0:
                        GlobalVars.MD_OFX_DEFAULT_SETTINGS_FILE =          moduleBuild.MD_OFX_DEFAULT_SETTINGS_FILE
                    if len(moduleBuild.MD_OFX_DEBUG_SETTINGS_FILE) > 0:
                        GlobalVars.MD_OFX_DEBUG_SETTINGS_FILE =            moduleBuild.MD_OFX_DEBUG_SETTINGS_FILE
                    if len(moduleBuild.MD_EXTENSIONS_DIRECTORY_FILE) > 0:
                        GlobalVars.MD_EXTENSIONS_DIRECTORY_FILE =          moduleBuild.MD_EXTENSIONS_DIRECTORY_FILE
                    if len(moduleBuild.MYPYTHON_DOWNLOAD_URL) > 0:
                        GlobalVars.MYPYTHON_DOWNLOAD_URL =                 moduleBuild.MYPYTHON_DOWNLOAD_URL

                    if debug:
                        myPrint("DB", "Program variables are now...:")
                        myPrint("DB", " TOOLBOX_STOP_NOW:                     %s"     %(GlobalVars.TOOLBOX_STOP_NOW))
                        myPrint("DB", " TOOLBOX_MINIMUM_TESTED_MD_VERSION:    %s"     %(GlobalVars.TOOLBOX_MINIMUM_TESTED_MD_VERSION))
                        myPrint("DB", " TOOLBOX_MAXIMUM_TESTED_MD_VERSION:    %s"     %(GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_VERSION))
                        myPrint("DB", " TOOLBOX_MAXIMUM_TESTED_MD_BUILD:      %s"     %(GlobalVars.TOOLBOX_MAXIMUM_TESTED_MD_BUILD))
                        myPrint("DB", " MD_OFX_BANK_SETTINGS_DIR:             %s"     %(GlobalVars.MD_OFX_BANK_SETTINGS_DIR))
                        myPrint("DB", " MD_OFX_DEFAULT_SETTINGS_FILE:         %s"     %(GlobalVars.MD_OFX_DEFAULT_SETTINGS_FILE))
                        myPrint("DB", " MD_OFX_DEBUG_SETTINGS_FILE:           %s"     %(GlobalVars.MD_OFX_DEBUG_SETTINGS_FILE))
                        myPrint("DB", " MD_EXTENSIONS_DIRECTORY_FILE:         %s"     %(GlobalVars.MD_EXTENSIONS_DIRECTORY_FILE))
                        myPrint("DB", " MYPYTHON_DOWNLOAD_URL:                %s"     %(GlobalVars.MYPYTHON_DOWNLOAD_URL))

                    if GlobalVars.TOOLBOX_STOP_NOW:
                        myPrint("B", "Sorry - disable has been set by the Developer for this build.... Toolbox must close...".upper())
                    return

                else:
                    myPrint("DB", "Found LOWER downloaded module build %s - so I will keep program's defaults, and ignore these - exiting search... (%s) " %(moduleBuild.build, moduleBuild.obj ))
                    return

            myPrint("DB", "No suitable module build info found.. (so I will keep program's defaults, and ignore these - exiting search)")

        def check_for_updatable_extensions_on_startup(self):
            if SwingUtilities.isEventDispatchThread(): raise Exception("ERROR: Class DownloadExtensionVersionData - should not run on the EDT!")

            toolboxVersion = 0
            displayData = "\nALERT INFORMATION ABOUT YOUR EXTENSIONS:\n\n"

            try:
                theUpdateList = DownloadExtensionVersionData.get_extension_update_info()

                if not theUpdateList or len(theUpdateList) < 1: return toolboxVersion

                for key in theUpdateList.keys():
                    updateInfo = theUpdateList[key]
                    _txt = "** UPGRADEABLE EXTENSION: %s to version: %s" %(pad(key, 20), (updateInfo[0].getBuild()))
                    displayData += "%s\n" %(_txt)
                    myPrint("B", _txt)
                    if key.lower() == "%s" %(myModuleID) and int(updateInfo[0].getBuild()) > 0:
                        toolboxVersion = int(updateInfo[0].getBuild())
            except:
                dump_sys_error_to_md_console_and_errorlog()
                return toolboxVersion

            displayData += "\n<END>\n"
            howMany = int(len(theUpdateList))
            if not GlobalVars.lIgnoreOutdatedExtensions_TB:
                txt = "ALERT - YOU HAVE %s EXTENSION(S) THAT CAN BE UPGRADED!... (CANCEL stops future reminders)" %(howMany)
                setDisplayStatus(txt, "B"); myPrint("B", txt)
                ask = MyPopUpDialogBox(toolbox_frame_,
                                     theStatus=txt,
                                     theTitle="OUTDATED EXTENSIONS",
                                     theMessage=displayData,
                                     lCancelButton=True,
                                     OKButtonText="Acknowledge",
                                     lAlertLevel=1)
                if not ask.go():
                    myPrint("B", "User requested to ignore Outdated warning extensions going forward.....")
                    GlobalVars.lIgnoreOutdatedExtensions_TB = True
                    try: save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()
            else:
                txt = "ALERT - YOU HAVE %s EXTENSION(S) THAT CAN BE UPGRADED!...YOU HAVE SUPPRESSED STARTUP POPUP WARNINGS" %(howMany)
                setDisplayStatus(txt, "B")

            return toolboxVersion

        @staticmethod
        def get_extension_update_info():

            moduleList = DownloadExtensionVersionData.downloadedIKExtensionsDict.get(u"feature_modules")                # StreamVector

            installed = MD_REF.getLoadedModules()                                                                       # FeatureModule[]
            excludedIDs = MD_REF.getSuppressedExtensionIDs()                                                            # List<String>
            for installedMod in installed:
                if installedMod.isBundled():
                    excludedIDs.add(installedMod.getIDStr().lower())

            miniUpdateList = {}
            try:
                if moduleList:
                    for obj in moduleList:
                        if not (isinstance(obj, StreamTable)):
                            myPrint("B", "@@ ERROR - Retrieved data is not a StreamTable()", obj)
                            continue

                        extInfo = ModuleMetaData(obj)

                        # Mirrors code from com.moneydance.apps.md.view.gui.extensions.ExtensionsWindow...

                        # noinspection PyUnresolvedReferences
                        if excludedIDs.contains(extInfo.getModuleID().lower()):     # Probably internal modules like Python/Jython
                            continue
                        if not ((float(MD_REF.getBuild())) >= extInfo.getMinimumSupportedBuild() and (float(MD_REF.getBuild())) <= extInfo.getMaximumSupportedBuild()):  # noqa
                            continue
                        if not (extInfo.getMinimumSupportedBuild() >= 1000):
                            continue
                        if (extInfo.isMacSandboxFriendly() or not Platform.isMac() or not MD_REF.getPlatformHelper().isConstrainedToSandbox()):
                            pass
                        else:
                            continue
                        existingMod = None          # FeatureModule
                        for mod in installed:

                            # noinspection PyUnresolvedReferences
                            if mod.getIDStr().lower() == extInfo.getModuleID().lower():
                                existingMod = mod
                                break
                        isInstalled = (existingMod is not None)
                        isUpdatable = (existingMod is not None and existingMod.getBuild() < extInfo.getBuild())
                        if existingMod and isInstalled and isUpdatable:

                            # noinspection PyUnresolvedReferences
                            miniUpdateList[extInfo.getModuleID().lower()] = [extInfo, isInstalled, isUpdatable]

                else:
                    myPrint("DB", "@@ ERROR - Failed to download latest extension(s) version data from internet...")
            except:
                myPrint("B", "@@ ERROR decoding downloaded module list!)")
                dump_sys_error_to_md_console_and_errorlog()

            return miniUpdateList


    def detect_broken_critical_javaio_temp_dir_OK():
        KEY = "java.io.tmpdir"                                                                                          # noqa
        javaTmpDir = System.getProperty(KEY)
        if javaTmpDir is None or javaTmpDir == "":
            myPrint("B","'%s' property missing!?" %(KEY))
            return False
        tmpDir = File(javaTmpDir)
        try:
            f = File.createTempFile("TOOLBOX-TEST-TEMP_DIR", str(System.currentTimeMillis()), tmpDir)
            f.delete()
            myPrint("DB","Successfully created temp file in '%s':" %(KEY), f.getCanonicalPath())

        except IOException as e:
            myPrint("B","ERROR with property '%s' - Could not create file in temp dir:" %(KEY), tmpDir.getCanonicalPath(), "Message:", e.getMessage())
            return False

        except:
            myPrint("B","ERROR with property '%s' - Could not create file in temp dir:" %(KEY), tmpDir.getCanonicalPath())
            dump_sys_error_to_md_console_and_errorlog()
            return False

        return True

    def return_critical_javaio_temp_dir_msg():
        KEY = "java.io.tmpdir"                                                                                          # noqa
        javaTmpDir = System.getProperty(KEY)

        if detect_broken_critical_javaio_temp_dir_OK():
            if debug:
                rtnMsg = u"\nImportant java temp folder looks OK ('%s' = '%s')\n" %(KEY, javaTmpDir)
            else:
                rtnMsg = u""
        else:
            rtnMsg = u"\n** ERROR >> Problem with important java temp folder - review console\n" \
                     u"('%s' = '%s')\n" %(KEY, javaTmpDir)
        return rtnMsg

    class MyPopupRegister(SecondaryDialog):

        class MyTxnRegisterType(TxnRegisterType):
            def __init__(self, mdGUI, editableRegister=False, showCashBalance=False):
                self.editableRegister = editableRegister
                self.showCashBalance = showCashBalance
                super(self.__class__, self).__init__(mdGUI)
            def isEditable(self): return self.editableRegister
            def getNumColumns(self):
                defaultCols = super(self.__class__, self).getNumColumns()
                if not self.showCashBalance: defaultCols -= 1
                return defaultCols

        class MyInvestRegisterType(InvestRegisterType):
            def __init__(self, mdGUI, editableRegister=False, showCashBalance=False):
                self.editableRegister = editableRegister
                self.showCashBalance = showCashBalance
                self.cashColumn = 8
                super(self.__class__, self).__init__(mdGUI)
            def isEditable(self): return self.editableRegister
            def getPreferredFieldWidth(self, info, col):
                if not self.showCashBalance and col == self.cashColumn: return 0
                return super(self.__class__, self).getPreferredFieldWidth(info, col)
            def getColMinWidth(self, info, col):
                if not self.showCashBalance and col == self.cashColumn: return 0
                return super(self.__class__, self).getColMinWidth(info, col)
            def getColPreferredWidth(self, info, col):
                if not self.showCashBalance and col == self.cashColumn: return 0
                return super(self.__class__, self).getColPreferredWidth(info, col)

        def __init__(self, title, registerType, txnSearchFilter, parent=None, editableRegister=False, showCashBalance=False, modal=True, singleLineMode=False, escapeCancels=True):
            # type: (str, type, TxnSearch, JComponent, bool, bool, bool, bool, bool) -> None
            mdGUI = MD_REF.getUI()
            title += " >> EDITING ENABLED - BE CAREFUL! <<" if editableRegister else " -- READONLY MODE --"
            super(self.__class__, self).__init__(mdGUI, parent, title, modal)
            self.setEscapeKeyCancels(escapeCancels)
            book = MD_REF.getCurrentAccountBook()

            if registerType == InvestRegisterType:
                txnRegister = TxnRegister(mdGUI, book, MyPopupRegister.MyInvestRegisterType(mdGUI, editableRegister=editableRegister, showCashBalance=showCashBalance))
            else:
                if registerType != TxnRegisterType:
                    myPrint("B", "@@ ERROR: MyPopupRegister() registerType incorrect:", registerType, ">> Defaulting to TxnRegisterType @@")
                txnRegister = TxnRegister(mdGUI, book, MyPopupRegister.MyTxnRegisterType(mdGUI, editableRegister=editableRegister, showCashBalance=showCashBalance))

            txnRegister.setDetailPanels([TxnDetailsPanel(mdGUI, txnRegister)])
            txnRegister.setSingleLineMode(singleLineMode)
            txnResultSet = SearchRegTxnListModel(book, txnSearchFilter, TxnSortOrder.DATE)
            txnRegister.setTxnModel(txnResultSet)
            self.add(txnRegister)

        def setEscapeKeyCancels(self, escapeKeyCancels):
            try: super(self.__class__, self).setEscapeKeyCancels(escapeKeyCancels)
            except:
                # This was a new method in a recent build....
                if escapeKeyCancels:
                    self.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close_window")
                else:
                    self.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).remove(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0))

    # class DetectAndChangeMacTabbingMode(AbstractAction):
    #
    #     def __init__(self, lQuickCheckOnly):
    #         self.lQuickCheckOnly = lQuickCheckOnly
    #
    #     def actionPerformed(self, event):
    #         myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
    #
    #         if not Platform.isOSX():
    #             if self.lQuickCheckOnly: return True
    #             txt = "Change Mac Tabbing Mode - This can only be run on a Mac!"
    #             setDisplayStatus(txt, "R")
    #             myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
    #             return
    #
    #         if not isOSXVersionBigSurOrLater():
    #             if self.lQuickCheckOnly: return True
    #             txt = "Change Mac Tabbing Mode - You are not running Big Sur - no changes made!"
    #             setDisplayStatus(txt, "R")
    #             myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
    #             return
    #
    #         if (float(MD_REF.getBuild()) > 1929 and float(MD_REF.getBuild()) < 2008):                                         # noqa
    #             txt = "You are running 2021.build %s - This version has problems with DUAL MONITORS - Upgrade to at least 2021. build 2012: https://infinitekind.com/preview" %(MD_REF.getBuild())
    #             setDisplayStatus(txt, "R")
    #             txt = "Change Mac Tabbing Mode - You are running 2021.build %s - This version has problems with DUAL MONITORS\nPlease upgrade to at least 2021. build 2012:\nhttps://infinitekind.com/preview" %(MD_REF.getBuild())
    #             myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
    #             return
    #
    #         prefFile = os.path.join(System.getProperty("UserHome", "Library/Preferences/.GlobalPreferences.plist"))
    #         if not os.path.exists(prefFile):
    #             if self.lQuickCheckOnly: return True
    #             txt = "Change Mac Tabbing Mode - Sorry - For some reason I could not find: %s - no changes made!" %(prefFile)
    #             setDisplayStatus(txt, "R")
    #             myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
    #             return
    #
    #         try:
    #             tabbingMode = subprocess.check_output("defaults read -g AppleWindowTabbingMode", shell=True)
    #         except:
    #             if self.lQuickCheckOnly: return True
    #             txt = "Change Mac Tabbing Mode - Sorry - error getting your Tabbing mode! - no changes made!"
    #             setDisplayStatus(txt, "R"); myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
    #             dump_sys_error_to_md_console_and_errorlog()
    #             return
    #
    #         tabbingMode=tabbingMode.strip().lower()
    #         if not (tabbingMode == "fullscreen" or tabbingMode == "manual" or tabbingMode == "always"):
    #             if self.lQuickCheckOnly: return True
    #             txt = "Change Mac Tabbing Mode - Sorry - I don't understand your tabbing mode: %s - no changes made!" %(tabbingMode)
    #             setDisplayStatus(txt, "R"); myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.ERROR_MESSAGE)
    #             return
    #
    #         if tabbingMode == "fullscreen" or tabbingMode == "manual":
    #             if self.lQuickCheckOnly:
    #                 myPrint("J", "Quick check of MacOS tabbing showed it's OK and set to: %s" %tabbingMode)
    #                 return True
    #             txt = "Change Mac Tabbing Mode - NO PROBLEM FOUND - Your tabbing mode is: %s - no changes made!" %(tabbingMode)
    #             setDisplayStatus(txt, "B"); myPrint("B", txt)
    #             myPopupInformationBox(toolbox_frame_,txt)
    #             return
    #
    #         if self.lQuickCheckOnly:
    #             myPrint("J", "Quick check of MacOS tabbing showed it's NEEDS CHANGING >> It's set to: %s" %tabbingMode)
    #             return False
    #
    #         myPrint("B","More information here: https://support.apple.com/en-gb/guide/mac-help/mchla4695cce/mac")
    #
    #         myPrint("B", "@@@ PROBLEM - Your Tabbing Mode is set to: %s - NEEDS CHANGING" %tabbingMode)
    #         myPopupInformationBox(toolbox_frame_,"@@@ PROBLEM - Your Tabbing Mode is set to: %s\nTHIS NEEDS CHANGING!" %tabbingMode,theMessageType=JOptionPane.ERROR_MESSAGE)
    #         myPopupInformationBox(toolbox_frame_,"Info:\n<https://support.apple.com/en-gb/guide/mac-help/mchla4695cce/mac>\nPress OK to select new mode...",theMessageType=JOptionPane.ERROR_MESSAGE)
    #
    #         mode_options = ["fullscreen", "manual"]
    #         selectedMode = JOptionPane.showInputDialog(toolbox_frame_,
    #                                                     "TABBING MODE", "Select the new Tabbing Mode?",
    #                                                     JOptionPane.WARNING_MESSAGE,
    #                                                     getMDIcon(lAlwaysGetIcon=True),
    #                                                     mode_options,
    #                                                     None)
    #         if selectedMode is None:
    #             txt = "Change Mac Tabbing Mode - No new Tabbing Mode was selected - aborting.."
    #             setDisplayStatus(txt, "R")
    #             myPopupInformationBox(toolbox_frame_,txt)
    #             return
    #
    #         if not doesUserAcceptDisclaimer(toolbox_frame_, "TABBING MODE", "Are you really sure you want to change MacOS system setting>>Tabbing Mode?"):
    #             txt = "Change Mac Tabbing Mode - User declined the disclaimer - no changes made...."
    #             setDisplayStatus(txt, "R")
    #             myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
    #             return
    #
    #         try:
    #             tabbingModeChanged = subprocess.check_output('defaults write -g AppleWindowTabbingMode -string "%s"' %selectedMode, shell=True)
    #             if tabbingModeChanged.strip() != "":
    #                 myPrint("B", "Tabbing mode change output>>>>")
    #                 myPrint("B", tabbingModeChanged)
    #             myPrint("B","!!! Your tabbing mode has been changed to %s - MONEYDANCE WILL NOW RESTART" %selectedMode)
    #         except:
    #             txt = "Change Mac Tabbing Mode - Sorry - error setting your Tabbing mode! - no changes made!"
    #             setDisplayStatus(txt, "R"); myPrint("B", txt)
    #             dump_sys_error_to_md_console_and_errorlog()
    #             myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.ERROR_MESSAGE)
    #             return
    #
    #         if tabbingModeChanged.strip() != "":
    #             myPopupInformationBox(toolbox_frame_,"Change Mac Tabbing Mode: Response: %s" %tabbingModeChanged, JOptionPane.WARNING_MESSAGE)
    #
    #         txt = "MacOS Tabbing Mode: OK I Made the Change to your Mac Tabbing Mode: MONEYDANCE WILL NOW RESTART"
    #         setDisplayStatus(txt, "R")
    #         logToolboxUpdates("DetectAndChangeMacTabbingMode", txt, onlyLogGenericEntry=True)
    #         myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
    #         ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    class DetectInvalidWindowLocations(AbstractAction):

        def __init__(self, lQuickCheckOnly):
            self.lQuickCheckOnly = lQuickCheckOnly

        def actionPerformed(self, event):                                                                               # noqa
            _THIS_METHOD_NAME = "Detect invalid window locations/sizes".upper()

            virtualBounds = Rectangle(0, 0, 0, 0)
            ge = GraphicsEnvironment.getLocalGraphicsEnvironment()  # type: GraphicsEnvironment
            lstGDs = ge.getScreenDevices()                          # type: [GraphicsDevice]
            for gd in lstGDs:
                print gd, gd.getDefaultConfiguration(), gd.getDefaultConfiguration().getBounds()
                virtualBounds.add(gd.getDefaultConfiguration().getBounds())

            output = "%s:\n" \
                     " ---------------------------------\n" %(_THIS_METHOD_NAME)

            txt = "*** Found: %s screens, with Virtual Bounds of: %s" %(len(lstGDs), virtualBounds)

            output += "%s\n\n" %(txt)
            myPrint("DB", txt)

            prefs = MD_REF.getPreferences()

            invalidLocns = []
            invalidSizes = []

            prefSt, prefKeys = read_preferences_file(True)
            for theKey in prefKeys:
                value = prefSt.get(theKey)
                if not check_for_window_display_data(theKey, value): continue
                lFoundLocation = check_for_just_locations_window_display_data(theKey, value)
                lFoundSize = check_for_just_sizes_window_display_data(theKey, value)
                if lFoundLocation:
                    livePrefValue = prefs.getXYSetting(theKey, 0, 0)
                    if livePrefValue.x == 0 and livePrefValue.y == 0: continue
                    if ((livePrefValue.x > virtualBounds.width or livePrefValue.y > virtualBounds.height)
                            or (livePrefValue.x < virtualBounds.x or livePrefValue.y < virtualBounds.y)):
                        invalidLocns.append(theKey)
                        txt = "Found INVALID location outside current virtual bounds: %s (%s)" %(theKey, livePrefValue)
                        output += "%s\n" %(txt)
                        myPrint("B", txt)
                    continue

                if lFoundSize:
                    livePrefValue = prefs.getSizeSetting(theKey, 0, 0)
                    if livePrefValue.width > 100 and livePrefValue.height > 50: continue
                    invalidSizes.append(theKey)
                    txt = "Found INVALID size (too small): %s (%s)" %(theKey, livePrefValue)
                    output += "%s\n" %(txt)
                    myPrint("B", txt)
                    continue

            output += "\n"

            if self.lQuickCheckOnly:
                if invalidLocns:
                    myPrint("B","*** %s invalid saved window location(s) detected (use 'UPDATE MODE' to zap these)...." %(len(invalidLocns)))
                else:
                    myPrint("B","No invalid saved window locations detected....")

                if invalidSizes:
                    myPrint("B","*** %s invalid saved window size(s) detected (use 'UPDATE MODE' to zap these)...." %(len(invalidSizes)))
                else:
                    myPrint("B","No invalid saved window sizes detected....")
                return (invalidLocns or invalidSizes)

            if not invalidLocns and not invalidSizes:
                output += "NO INVALID LOCATIONS / SIZES DETECTED - no changes made\n<END>\n"
                QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
                return False

            output += "ALERT: %s invalid saved window location(s) / size(s) detected\n\n" %(len(invalidLocns) + len(invalidSizes))
            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True, lAlertLevel=1).show_the_frame()

            if not GlobalVars.i_am_an_extension_so_run_headless:
                myPopupInformationBox(jif, "PLEASE RUN THIS AS AN EXTENSION TO PROCEED", _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
                return

            ask = MyPopUpDialogBox(jif,
                                   theStatus="%s invalid saved window location(s) / size(s) detected!" %(len(invalidLocns) + len(invalidSizes)),
                                   theMessage=output,
                                   theTitle=_THIS_METHOD_NAME,
                                   lAlertLevel=1,
                                   lCancelButton=True,
                                   OKButtonText="ZAP INVALID LOCATIONS")
            if not ask.go():
                txt = "%s: User declined to zap invalid saved window location(s) / size(s) - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                return

            if not doesUserAcceptDisclaimer(jif, _THIS_METHOD_NAME, "Are you really sure you want to zap %s invalid saved window location(s)/size(s)?" %(len(invalidLocns) + len(invalidSizes))):
                txt = "%s: User declined the disclaimer - no changes made...." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not backup_config_dict():
                txt = "%s: ERROR making backup of config.dict - no changes made!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            jif.dispose()
            output += "User accepted disclaimer and is proceeding with zap of invalid window locations/sizes...\n\n"

            lAddMainWindowKeysToo = False
            invalidKeysToZap = StreamVector()
            if isinstance(invalidKeysToZap, Vector): pass
            for sizes_locations in [invalidSizes, invalidLocns]:
                for zapKey in sizes_locations:
                    invalidKeysToZap.add(zapKey)
                    if "mainwindow" in zapKey: lAddMainWindowKeysToo = True

            if lAddMainWindowKeysToo:
                for zapThisToo in ["gui.is_maximized-mainwindow", "gui.source_list_width+mainwindow", "gui.winloc-mainwindow", "gui.winsize-mainwindow"]:
                    invalidKeysToZap.add(zapThisToo)

            MD_REF.getPreferences().setSetting(GlobalVars.Strings.TOOLBOX_PREFERENCES_ZAPPER, invalidKeysToZap)

            ##### FORCE CLOSE ALL WINDOWS SO THEY DO NOT SAVE THEIR SETTINGS AFTER TOOLBOX CHANGES #####################
            # try:
            #     forceCloseMoneydanceWindows()
            # except:
            #     dump_sys_error_to_md_console_and_errorlog()
            #     myPopupInformationBox(toolbox_frame_, "ERROR: forceCloseMoneydanceWindows() crashed (will continue anyway)", _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
            #
            # for sizes_locations in [invalidSizes, invalidLocns]:
            #     for locSizeKey in list(sizes_locations):
            #         output += "Zapping: %s\n" %(locSizeKey)
            #         myPrint("B", "Zapping: %s\n" %(locSizeKey))
            #         MD_REF.getPreferences().setSetting(locSizeKey, None)
            #
            # MD_REF.savePreferences()    # save config.dict

            txt = "%s: %s invalid saved window location(s) / size(s) zapped.... MONEYDANCE WILL EXIT - PLEASE RESTART MD" %(_THIS_METHOD_NAME, len(invalidLocns) + len(invalidSizes))
            output += "\n\n%s\n<END>" %(txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("DetectInvalidWindowLocations", txt, onlyLogGenericEntry=True)

            play_the_money_sound()
            MyPopUpDialogBox(toolbox_frame_, txt, output, theTitle="INVALID LOCATION(S)/SIZE(S) ZAPPED", lAlertLevel=1).go()

            myPrint("B","Requesting Moneydance shuts down now...")
            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False, lAllowSaveWorkspace=False)

    class DetectMobileAppTxnFiles(AbstractAction):

        def __init__(self, lQuickCheckOnly):
            self.lQuickCheckOnly = lQuickCheckOnly

        def actionPerformed(self, event):                                                                               # noqa
            _THIS_METHOD_NAME = "DETECT MOBILE APP SYNC TXN FILES".upper()

            DAY_IN_MS = 24 * 60 * 60 * 1000
            DAYS_TO_KEEP = 1

            # from com.moneydance.apps.md.controller.sync import AbstractSyncFolder
            try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
            except: syncFolder = None
            if syncFolder is None:
                myPrint("B", "Syncing not enabled - skipping detection for old(er) mobile app sync .txn file(s)")
                return False

            oldTxnFiles = []
            ignoringTxnFiles = []
            nowTimeMS = System.currentTimeMillis()
            cutoffTimeMS = nowTimeMS - (DAYS_TO_KEEP * DAY_IN_MS)

            output = "%s:\n" \
                     " ---------------------------------\n" %(_THIS_METHOD_NAME)

            MD_REF.saveCurrentAccount()

            try:
                output += "Sync method: '%s'\n" %(syncFolder.getSyncTypeID())
                output += "Sync path:   '%s'\n" %(syncFolder.toString())

                myPrint("B", "Checking '%s' sync folder (%s) for mobile app sync .txn files....." %(syncFolder.getSyncTypeID(), syncFolder.toString()))
                txnfiles = syncFolder.listTxnFiles()
                for txnfile in txnfiles:
                    myPrint("B", "@@@@ mobile app sync file detected:", txnfile, syncFolder.getModified(txnfile), " @@@")
                    if syncFolder.getFileTimestamp(txnfile) >= cutoffTimeMS:
                        ignoringTxnFiles.append(txnfile)
                    else:
                        oldTxnFiles.append(txnfile)

                # ignoringTxnFiles = sorted(ignoringTxnFiles, key=lambda sort_x: (syncFolder.getFileTimestamp(sort_x)))
                # oldTxnFiles = sorted(ignoringTxnFiles, key=lambda sort_x: (syncFolder.getFileTimestamp(sort_x)))

                for fileSet in [ignoringTxnFiles, oldTxnFiles]:
                    output += "\n"
                    for txnfile in fileSet:
                        txnFileTimestamp = syncFolder.getFileTimestamp(txnfile)
                        txnFileDateInt = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
                        txnFileDateHuman = convertStrippedIntDateFormattedText(txnFileDateInt)
                        lIgnore = (txnFileTimestamp >= cutoffTimeMS)
                        output += "%s Mobile app sync .txn file dated: %s (time stamp: %s): '%s' \n"\
                                  %("(ignoring recent)" if lIgnore else "<SUGGEST DELETE!>",txnFileDateHuman, txnFileTimestamp, txnfile)
                    output += "\n"

            except:
                myPrint("B", "Error processing mobile app sync .txn file(s)? (aborting checks)")
                dump_sys_error_to_md_console_and_errorlog()
                return False

            myPrint("B", "Detected %s recent and %s old(er) mobile app sync .txn file(s)" %(len(ignoringTxnFiles), len(oldTxnFiles)))
            if self.lQuickCheckOnly:
                return len(oldTxnFiles) > 0

            if len(oldTxnFiles) < 1:
                txt = "No old(er) mobile app .txn sync file(s) detected - no changes made"
                output += "%s\n<END>\n" %(txt); myPrint("B", txt)
                QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
                return False

            output += "ALERT: %s old(er) mobile app .txn sync file(s) detected\n\n" %(len(oldTxnFiles))
            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True, lAlertLevel=1).show_the_frame()


            if not confirm_backup_confirm_disclaimer(jif,
                                                     _THIS_METHOD_NAME,
                                                     "DELETE %s old(er) mobile app .txn sync file(s)?" %(len(oldTxnFiles))):
                return

            jif.dispose()

            iCountErrors = 0
            for txnfile in oldTxnFiles:
                try:
                    syncFolder.delete(txnfile)
                    txt = "Deleted old(er) mobile app sync .txn file: '%s'" %(txnfile)
                    output += "%s\n" %(txt); myPrint("B", txt)
                except:
                    iCountErrors += 1
                    txt = "ERROR Deleting old(er) mobile app sync .txn file: '%s' (review help/console)" %(txnfile)
                    output += "%s\n" %(txt); myPrint("B", txt)
                    dump_sys_error_to_md_console_and_errorlog()


            txt = "%s - Deleted %s old(er) mobile app sync .txn file(s) (with %s errors)" %(_THIS_METHOD_NAME, len(oldTxnFiles), iCountErrors)
            output += "\n\n%s\n<END>" %(txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("DetectMobileAppTxnFiles", txt)

            play_the_money_sound()
            MyPopUpDialogBox(toolbox_frame_, txt, output, theTitle="OLD(ER) MOBILE APP SYNC .TXN FILE(S) DELETED", OKButtonText="RESTART MD", lAlertLevel=1).go()

            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def find_other_datasets():
        output = ""
        output+=("\nQUICK SEARCH FOR OTHER DATASETS:\n"
                 " --------------------------------\n")

        try:
            md_extn = ".moneydance"
            md_archive = ".moneydancearchive"

            saveFiles = {}
            saveArchiveFiles = {}

            myDataset = MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()

            errorDirs = []

            internalDir = Common.getDocumentsDirectory().getCanonicalPath()
            try:
                dirList =  os.listdir(internalDir)
                for fileName in dirList:
                    fullPath = os.path.join(internalDir,fileName)
                    if fileName.endswith(md_extn):
                        saveFiles[fullPath] = True
                    elif fileName.endswith(md_archive):
                        saveArchiveFiles[fullPath] = True
                del dirList
            except OSError:
                myPrint("B","@@ Error accessing internalDir: '%s' - skipping...." %(internalDir))
                errorDirs.append(internalDir)

            parentofDataset = MD_REF.getCurrentAccountBook().getRootFolder().getParent()
            if os.path.exists(parentofDataset):
                try:
                    dirList =  os.listdir(parentofDataset)
                    for fileName in dirList:
                        fullPath = os.path.join(parentofDataset,fileName)
                        if fileName.endswith(md_extn):
                            saveFiles[fullPath] = True
                        elif fileName.endswith(md_archive):
                            saveArchiveFiles[fullPath] = True
                    del dirList
                except OSError:
                    myPrint("B","@@ Error accessing dataset's folder: '%s' - skipping...." %(parentofDataset))
                    errorDirs.append(parentofDataset)
            del parentofDataset

            externalFiles = AccountBookUtil.getExternalAccountBooks()
            for wrapperOrBook in externalFiles:
                _book = wrapperOrBook if isinstance(wrapperOrBook, AccountBook) else wrapperOrBook.getBook()            # changed in MD2023.2(5020) to return [books]
                saveFiles[_book.getRootFolder().getCanonicalPath()] = True
                externalDir = _book.getRootFolder().getParent()
                if os.path.exists(externalDir):
                    try:
                        dirList =  os.listdir(externalDir)
                        for fileName in dirList:
                            fullPath = os.path.join(externalDir,fileName)
                            if fileName.endswith(md_extn):
                                saveFiles[fullPath] = True
                            elif fileName.endswith(md_archive):
                                saveArchiveFiles[fullPath] = True
                        del dirList
                    except OSError:
                        myPrint("B","@@ Error accessing externalDir: '%s' - skipping...." %(externalDir))
                        errorDirs.append(externalDir)
                del _book

            del externalFiles

            for backupLocation in [ FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath(),
                                    MD_REF.getUI().getPreferences().getSetting("backup.location",""),
                                    MD_REF.getUI().getPreferences().getSetting("backup.last_saved",""),
                                    MD_REF.getUI().getPreferences().getSetting("backup.last_browsed","")]:
                if backupLocation is not None and backupLocation != "" and os.path.exists(backupLocation):
                    try:
                        dirList =  os.listdir(backupLocation)
                        for fileName in dirList:
                            fullPath = os.path.join(backupLocation,fileName)
                            if fileName.endswith(md_extn):
                                if saveFiles.get(fileName) is not None:
                                    saveFiles[fullPath] = True
                            elif fileName.endswith(md_archive):
                                saveArchiveFiles[fullPath] = True
                        del dirList
                    except OSError:
                        myPrint("B","@@ Error accessing backupLocationDir: '%s' - skipping...." %(backupLocation))
                        errorDirs.append(backupLocation)
            del backupLocation

            saveFiles[myDataset] = None

            listTheFiles=sorted(saveFiles.keys())
            listTheArchiveFiles=sorted(saveArchiveFiles.keys())

            for _f in listTheFiles:
                if saveFiles[_f] is not None:
                    output+=("Dataset: Mod: %s %s\n"
                             % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(_f)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), _f))
            del listTheFiles

            output+=("\nBACKUP FILES\n"
                     " ------------\n")

            for _f in listTheArchiveFiles:
                if saveArchiveFiles[_f] is not None:
                    output+=("Archive: Mod: %s %s\n"
                             % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(_f)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), _f))
            del listTheArchiveFiles

            output+=("\nSYNC FOLDERS FOUND:\n"
                     " --------------------\n")

            saveSyncFolder=None
            try:
                # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
                # Also, MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
                syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
                syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

                if syncMethod is not None and syncMethod.getSyncFolder() is not None:
                    # noinspection PyUnresolvedReferences
                    syncBaseFolder = syncMethod.getSyncFolder().getSyncBaseFolder()

                    saveSyncFolder = syncBaseFolder.getCanonicalPath()
                    dirList =  os.listdir(saveSyncFolder)

                    for fileName in dirList:
                        fullPath = os.path.join(saveSyncFolder,fileName)
                        if len(fileName)>32:
                            output+=("Sync Folder: %s %s\n"
                                     % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(fullPath)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), fullPath))
                else:
                    output+=("<NONE FOUND>\n")

                del syncMethod, syncMethods
            except:
                pass

            dropboxPath = tell_me_if_dropbox_folder_exists()
            if dropboxPath and dropboxPath is not None and dropboxPath != saveSyncFolder:

                output+=("\nDROPBOX FOLDERS FOUND:\n"
                         " ----------------------\n")
                dirList =  os.listdir(dropboxPath)

                for fileName in dirList:
                    fullPath = os.path.join(dropboxPath,fileName)
                    if len(fileName)>32:
                        output+=("Dropbox Sync Folder: %s %s\n"
                                 % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(fullPath)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), fullPath))
            del dropboxPath

            if len(errorDirs) > 0:
                output += ("\nERROR ACCESSING DIRECTORY:\n"
                           " --------------------------\n")
                for errorDir in errorDirs: output += (" @@ %s\n" %(errorDir))

            output+="\n\n(for a more extensive search please use Toolbox - Find my Datasets and Backups button\n\n"

        except:
            myPrint("B","@@ ERROR: Failed in find_other_datasets()?")
            output += dump_sys_error_to_md_console_and_errorlog(lReturnText=True)

        return output

    def count_database_objects(whichBook=None):
        # type: (AccountBook) -> str
        """Analyses the objects contained in the specified AccountBook. Returns a printable string"""

        if whichBook is None or not isinstance(whichBook, AccountBook):
            book = MD_REF.getCurrentAccountBook()
        else:
            book = whichBook
        if book is None: return "<NO ACCOUNT BOOK SPECIFIED OR FOUND>"

        output = ""
        output+=("\nDATABASE OBJECT COUNT        (count) (est.size KBs): %s\n"
                 " -----------------------------------------------------\n" %("" if whichBook is None else "(Book: "+book.getName()+"):"))
        foundStrange=0
        types={}

        onlineTxns=0
        onlineTxnsCharacters=0
        onlinePayees=0
        onlinePayments=0

        if book.getSyncer() is None or book.getSyncer().getSyncedDocument() is None:
            output += "\n** WARNING: Book's getSyncer() or getSyncedDocument() was None **\n"
            return output

        for mdItem in book.getSyncer().getSyncedDocument().allItems():
            if isinstance(mdItem, MoneydanceSyncableItem):

                if isinstance(mdItem, OnlineTxnList):
                    onlineTxns +=mdItem.getTxnCount()
                    for olKey in mdItem.getParameterKeys():
                        onlineTxnsCharacters += len(olKey)
                        onlineTxnsCharacters += len(mdItem.getParameter(olKey))

                if isinstance(mdItem, OnlinePayeeList):     onlinePayees    += mdItem.getPayeeCount()
                if isinstance(mdItem, OnlinePaymentList):   onlinePayments  += mdItem.getPaymentCount()

                getTheSavedData = types.get(mdItem.getParameter("obj_type", "UNKNOWN"))
                if getTheSavedData is not None:
                    x,theLength = getTheSavedData
                else:
                    x = 0
                    theLength = 0

                theSyncInfo = mdItem.getSyncInfo()
                theDescription = theSyncInfo.toMultilineHumanReadableString()  # format is "key: data\n" but file is '&key=data'
                theLength += len( ("mod.%s:" %(mdItem.getParameter("obj_type",""))) )
                theLength += len(theDescription)
                theLength -= len(mdItem.getParameterKeys())  # remove the number of "\n"s

                types[mdItem.getParameter("obj_type", "UNKNOWN")] = [x+1, theLength]
            else:
                foundStrange += 1
        i = 0
        charCount = 0
        for x in types.keys():
            i += types[x][0]
            charCount += types[x][1]
            extraText = ""
            if x == "oltxns":
                if onlineTxns:
                    extraText = "(containing %s Online Txns consuming %s KBs)" %(onlineTxns, round(onlineTxnsCharacters/1000.0,1))
            elif x == "olpayees":
                if onlinePayees:
                    extraText = "(containing %s Online Payees)" %(onlinePayees)
            elif x == "olpmts":
                if onlinePayments:
                    extraText = "(containing %s Online Payments)" %(onlinePayments)

            output += ("Object: %s %s   %s %s\n" %(pad(x,15),rpad(types[x][0],12),rpad(round(types[x][1] / (1000.0),1),12), extraText))

        if foundStrange:
            output += ("\n@@ I also found %s non Moneydance Syncable Items?! Why? @@\n" %(foundStrange))

        output += (" ==========\n TOTAL:                 %s   %s\n\n" %(rpad(i,12),rpad(round(charCount/(1000.0),1),12)))
        return output

    def getShouldDownloadAllAttachments():
        return MD_REF.getCurrentAccountBook().getLocalStorage().getBoolean("netsync.download_attachments", True)

    def returnPathStrings(fileReference, arePathsIdentical=False):
        _pathStr = u""
        if fileReference is not None:
            if isinstance(fileReference, URL):
                return u"'%s'" %(fileReference.toString())
            elif isinstance(fileReference, File):
                _pathStr = u"'%s'" %(fileReference.getAbsolutePath())
                if fileReference.getAbsolutePath() != fileReference.getCanonicalPath():
                    _pathStr += u" (alias to: '%s')" %(fileReference.getCanonicalPath())
        if arePathsIdentical: return (fileReference.getAbsolutePath() == fileReference.getCanonicalPath())
        return _pathStr

    def detectMigratedDropboxFolderProblem(createSymbolicLink=False):
        homeDir = get_home_dir()
        oldDropboxPath = os.path.join(homeDir, "Dropbox")
        newDropboxPath = os.path.join(homeDir, "Library", "CloudStorage", "Dropbox")
        if not Platform.isOSX() or not os.path.exists(homeDir) or not os.path.exists(newDropboxPath): return False
        if os.path.exists(oldDropboxPath):
            oldPath = Paths.get(oldDropboxPath)
            if Files.isSymbolicLink(oldPath):
                myPrint("DB", "Dropbox folder appears to have been successfully migrated to: '%s'" %(newDropboxPath))
                return False
            myPrint("B", "ERROR: Dropbox folder appears to have been migrated to: '%s', but old Folder exists: '%s' (it should be an alias)" %(newDropboxPath, oldDropboxPath))
            if createSymbolicLink:
                myPrint("B", "ERROR: Because Dropbox folder folder exists in old location, a new Alias CANNOT BE CREATED!")
        else:
            myPrint("B", "ERROR: Dropbox folder appears to have been migrated to: '%s', but no alias from old location ('%s') exists!" %(newDropboxPath, oldDropboxPath))
            if createSymbolicLink:
                try:
                    Files.createSymbolicLink(Paths.get(oldDropboxPath), Paths.get(newDropboxPath))
                    myPrint("B", "ALIAS from old Dropbox folder '%s' to migrated folder: '%s' CREATED!" %(oldDropboxPath, newDropboxPath))
                    return False
                except:
                    myPrint("B", "ERROR - COULD NOT CREATE ALIAS from old Dropbox folder '%s' to migrated folder: '%s'" %(oldDropboxPath, newDropboxPath))
        return True

    def showMacAliasPath():
        fRawPath = Common.getRootDirectory()
        rawPath = fRawPath.getCanonicalPath()
        checkForStr = u"/com.infinitekind.MoneydanceOSX/"
        replaceWithStr = u"/Moneydance/"
        if (Platform.isOSX() and fRawPath.exists() and fRawPath.isDirectory() and isinstance(rawPath, basestring) and checkForStr in rawPath):
            return rawPath.replace(checkForStr, replaceWithStr)
        return None

    def buildDiagText():

        textArray = []                                                                                                  # noqa

        if isPreviewBuild(): textArray.append(u"*** PREVIEW BUILD (%s) DETECTED ***\n" %(version_build))

        x = getMonoFont()
        textArray.append(u"FONT USED FOR TOOLBOX OUTPUT/DISPLAY(can be changed): %s(%s)" %(x.getFontName(), x.getSize()))
        try:
            loc = MD_REF.getUI().getPreferences().getLocale()
            if loc is not None and \
                    (loc.getLanguage() in (loc.CHINESE.getLanguage(), loc.JAPANESE.getLanguage(), loc.KOREAN.getLanguage(), loc.SIMPLIFIED_CHINESE.getLanguage(), loc.TRADITIONAL_CHINESE.getLanguage())
                     or loc.getCountry() in (loc.CHINA.getCountry(), loc.JAPAN.getCountry(), loc.KOREA.getCountry(), loc.TAIWAN.getCountry()) ):
                textArray.append(u"** if Toolbox display/outputs do not show your language's double-byte characters properly, then change to a Monospaced Font that supports your character set **")
                textArray.append(u"** (Update Mode) General Tools, Set MD Fonts: Change 'code' Font (please only use Monospaced fonts for text alignment!) **")
        except:
            myPrint("B",u"@@ ERROR: Failed to detect MD Locale..?")
            dump_sys_error_to_md_console_and_errorlog()

        textArray.append(return_critical_javaio_temp_dir_msg())

        # Check for MD2023.1(5006) Earlier Sync Issue Fix...
        syncIssueFix = MD_REF.getCurrentAccountBook().getLocalStorage().getString(GlobalVars.Strings.MD_KEY_STORAGE_5006SYNCFIX, None)
        if syncIssueFix is not None:
            txt = ("** NOTE: Detected that Sync issue fix for versions MD2023.0 (builds 5000 thru 5005) has been applied... (flag: '%s': %s) **"
                   %(GlobalVars.Strings.MD_KEY_STORAGE_5006SYNCFIX, syncIssueFix))
            myPrint("B", txt)
            if debug: textArray.append(u"%s\n" %(txt))

        del syncIssueFix

        textArray.append(u"Moneydance Version / Build:          %s" %(MD_REF.getVersion()) + u"  Build: %s" %(MD_REF.getBuild()))
        textArray.append(u"Moneydance Config file reports:      %s" %MD_REF.getUI().getPreferences().getSetting(u"current_version", u""))
        textArray.append(u"Moneydance updater version to track: %s" %MD_REF.getUI().getPreferences().getSetting(u"updater.version_to_track",u""))
        textArray.append(u"")

        currLicense = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2022",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2021",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2019",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2017",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2015",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2014",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2011",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2010",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2008",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2004",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key",u"?")))))))))))

        license2022 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2022", None)                               # noqa
        license2021 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2021", None)                               # noqa
        license2019 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2019", None)
        license2017 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2017", None)
        license2015 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2015", None)
        license2014 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2014", None)
        license2011 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2011", None)
        license2010 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2010", None)
        license2008 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2008", None)
        license2004 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2004", None)

        if not isMDPlusEnabledBuild():      # The start of MD+ and new licensing....
            if MD_REF.isRegistered():
                textArray.append(u"LICENSED: %s" %(currLicense))
            else:
                textArray.append(u"UNLICENSED!")

        else:
            licenseInfo = MD_REF.getLicenseInfo()
            x = pad((u"UNLICENSED:" if (not licenseInfo.isRegistered()) else u"LICENSED:"),12)
            textArray.append(u"%s%s (key version: %s, key status: %s, isUpgradeable: %s)"
                             %(x, licenseInfo.getLicenseKey(), licenseInfo.getKeyVersion(), licenseInfo.getStatus(), licenseInfo.isUpgradeable()))

            licenseInfo = getMDPlusLicenseInfoForBook()     # type: MoneydanceSyncableItem

            if licenseInfo is None:
                textArray.append(u"Moneydance+ License: NOT FOUND...")
            else:
                mdplus_email = licenseInfo.getParameter(u"mdplus.account_email", None)
                mdplus_pend_email = licenseInfo.getParameter(u"mdplus.pending_email", None)
                mdplus_signup_status = licenseInfo.getParameter(u"signup_status", None)
                mdplus_keyRegenDate = licenseInfo.getLongParameter(u"mdplus.date", 0L)
                mdplus_refreshDate = licenseInfo.getLongParameter(u"mdplus.refresh_date", 0L)
                mdplus_keypairCreated = licenseInfo.getLongParameter(u"mdplus.keypair_created", 0L)
                mdplus_privKeyHex = licenseInfo.getParameter(u"mdplus.priv", None)
                mdplus_pubKeyHex = licenseInfo.getParameter(u"mdplus.pub", None)

                if mdplus_email or mdplus_pend_email or mdplus_signup_status or mdplus_keyRegenDate or mdplus_refreshDate or mdplus_keypairCreated or mdplus_privKeyHex or mdplus_pubKeyHex:
                    textArray.append(u"")
                    textArray.append(u"Moneydance+ License information:")
                    if mdplus_email:            textArray.append(u"Email:            %s" %(mdplus_email))
                    if mdplus_email is None or mdplus_email == u"":
                        if mdplus_pend_email:       textArray.append(u"Email pending:    %s" %(mdplus_pend_email))
                    if mdplus_signup_status:    textArray.append(u"Signup status:    %s" %(mdplus_signup_status))
                    if mdplus_keyRegenDate:     textArray.append(u"MD+ date:         %s" %(get_time_stamp_as_nice_text(mdplus_keyRegenDate)))
                    if mdplus_refreshDate:      textArray.append(u"MD+ refresh date: %s" %(get_time_stamp_as_nice_text(mdplus_refreshDate)))
                    if mdplus_keypairCreated:   textArray.append(u"MD+ keypair date: %s" %(get_time_stamp_as_nice_text(mdplus_keypairCreated)))
                    if mdplus_privKeyHex:       textArray.append(u"MD+ Private Key:  %s (length: %s)" %(u"****** hidden ******", len(mdplus_privKeyHex)))
                    if mdplus_pubKeyHex:        textArray.append(u"MD+ Public Key:   %s (length: %s)" %(u"****** hidden ******", len(mdplus_pubKeyHex)))
                    textArray.append(u"")
                else:
                    textArray.append(u"Moneydance+ License: NOT FOUND...")

                del licenseInfo

        if license2021:      textArray.append(u" >old licenses (2021): " + license2021)
        if license2019:      textArray.append(u" >old licenses (2019): " + license2019)
        if license2017:      textArray.append(u" >old licenses (2017): " + license2017)
        if license2015:      textArray.append(u" >old licenses (2015): " + license2015)
        if license2014:      textArray.append(u" >old licenses (2014): " + license2014)
        if license2011:      textArray.append(u" >old licenses (2011): " + license2011)
        if license2010:      textArray.append(u" >old licenses (2010): " + license2010)
        if license2008:      textArray.append(u" >old licenses (2008): " + license2008)
        if license2004:      textArray.append(u" >old licenses (2004): " + license2004)

        if not MD_REF.getCurrentAccountBook(): textArray.append(u"Moneydance datafile is empty")
        x = MD_REF.getUI().getPreferences().getSetting(GlobalVars.Strings.MD_CONFIGDICT_CURRENT_ACCOUNT_BOOK, None)
        y = MD_REF.getUI().getPreferences().getSetting(u"current_account_file", None)

        theExtn = os.path.splitext((MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()))

        if x:
            textArray.append(u"\n"
                             u"Current Dataset:               '%s'" %(x))
        if y:
            textArray.append(u"\n"
                             u"Current Dataset:               '%s'" %(y))

        textArray.append(u"Full location of this Dataset: %s" %(returnPathStrings(MD_REF.getCurrentAccountBook().getRootFolder())))

        x = find_the_program_install_dir()
        if x and Platform.isOSX() and System.getProperty(u"install4j.exeDir", "") != "":     # Special 'not normal' check.... will normally never trigger
            textArray.append(u"Application Install Directory (Mac running manual launch script): '%s'" %(x))
        elif x:
            textArray.append(u"Application Install Directory: '%s'" %(x))
        else:
            textArray.append(u"UNABLE TO DETERMINE Application's Install Directory! (are you running Moneydance by manually executing the .jar file?)")

        x = Common.getRootDirectory().getCanonicalPath()
        textArray.append(u"Internal 'root' directory:     '%s'" %(x))
        if showMacAliasPath():
            textArray.append(u">>Mac Finder path for path:    '%s'" %(showMacAliasPath()))

        lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
        if lDropbox:
            textArray.append(u"\n@@ WARNING: You have your dataset installed in Dropbox - This can damage your data!")
            if lSuppressed:
                textArray.append(u"@@ WARNING: You have also SUPPRESSED the warning messages - THIS IS AT YOUR OWN RISK!")
            textArray.append(u"@@ The recommendation is to move your Dataset to your local drive (out of Dropbox) and a) use MD's internal Sync feature, or b) set Dropbox as the location for MD Backups\n")

        # MD2021.2(3088) adds this capability.....
        grabEnvPassphrases = findEnvironmentPassphrases()
        if grabEnvPassphrases:
            textArray.append(u"\nENVIRONMENT PASSPHRASE(S) STORED TO BYPASS POPUP ENCRYPTION PROMPTS")
            for k, v in grabEnvPassphrases:
                textArray.append(u"Environment key: %s <Stored Passphrase: ******>"  %(k))
        del grabEnvPassphrases

        textArray.append(u"")
        if MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = u"Dataset is a Master / PRIMARY sync node"
            textArray.append(txt); myPrint("B", txt)
        else:
            txt = u"Dataset is NOT a Master Node >> It is a SECONDARY sync node"
            textArray.append(txt); myPrint("B", txt)

        textArray.append(u"")
        x, y = calculateMoneydanceDatasetSize(True)
        textArray.append(u"Dataset size: %sMBs (%s files)\n" %(x,y))
        myPrint("B", "Dataset size: %sMBs (%s files)\n" %(x,y))

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()
        fileUUID = storage.getStr(u"netsync.dropbox.fileid", u"MISSING")
        migratedFileUUID = storage.getStr(u"migrated.netsync.dropbox.fileid", u"")

        textArray.append(u"Dataset internal UUID: %s" %(fileUUID))
        myPrint("B", "Dataset internal UUID: %s" %(fileUUID))

        if migratedFileUUID != "":
            textArray.append(u"Dataset old migrated UUID: %s" %(migratedFileUUID))
            myPrint("B", "Dataset old migrated UUID: %s" %(migratedFileUUID))
        del storage

        cos = count_database_objects()
        textArray.append(cos)
        myPrint("B", "\n.\n.", cos, " ------------------------------------------------------------------")

        textArray.append(u"\nENCRYPTION")
        x = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
        if x is None or x == u"":
            x = u"Encryption not set! - This means an internal Moneydance passphrase is being used to encrypt your dataset!".upper()
        else:
            x = u"***************"
        textArray.append(u"'Master' / Encryption Passphrase: %s" %x)

        x = u"Encryption Store Online Banking Passwords in File: %s" %(isCachingPasswords())
        if isCachingPasswords():
            textArray.append(x+u" (This means you are able to save your online banking passwords)")
        else:
            textArray.append(x+u"\n>>You cannot save online banking passwords until you set a 'Master' (encryption) password **AND** select 'Store Online Passwords in File'\n")

        x = MD_REF.getUI().getCurrentAccounts().getEncryptionHint()
        if x is None or x == u"":
            x = u"Encryption passphrase hint not set!".upper()
        else:
            x = u"***************"
        textArray.append(u"Encryption passphrase hint: %s" %x)

        keyInfo = loadKeyFile()
        x = keyInfo.getString(u"key", None)
        x = u"<?NOT FOUND?>" if (x is None or x == "") else u"'%s'" %(x)
        textArray.append(u"Encrypted (secret) cryptographic KEY used for dataset encryption seed: %s" %(x))
        del keyInfo

        if MD_REF.getCurrentAccountBook().getLocalStorage().getString("md.crypto_level", None):
            x = u"Encryption level - Moneydance reports 'md.crypto_level' set as: %s" %(MD_REF.getCurrentAccountBook().getLocalStorage().getString("md.crypto_level", None))
            textArray.append(x)

        x = u"Encryption test using your key/passphrase reports algorithm: %s\n" %(getMDEncryptionKey())

        x += u"Dataset & Sync encryption is: AES (aes-128-cbc) >> Advanced Encryption Standard - 128 bit - Cipher Block Chaining (symmetric algorithm)\n"
        x += u"(review Menu: 'Advanced Options' > 'Show your encryption keys, and the Moneydance encryption methodology' for more details)"
        textArray.append(x)

        textArray.append(u"\nSYNC DETAILS")
        # SYNC details
        x = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()
        if x is None or x == u"":
            x = u"Sync passphrase not set!"
        else:
            x = u"***************"
        textArray.append(u"Sync Password:                 %s" %x)

        try:
            if detectMigratedDropboxFolderProblem():
                textArray.append(u"Dropbox Folder Migrated:       *** YOU APPEAR TO HAVE A MISSING SYSTEM ALIAS TO NEW DROPBOX LOCATION ***")

            # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
            # MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            noSyncOption = SyncFolderUtil.configurerForIDFromList(u"none", syncMethods)
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)
            if syncMethod is None:
                syncMethod = noSyncOption
            else:
                syncMethod = syncMethod
            textArray.append(u"Sync Method:                   %s" %(syncMethod.getSyncFolder()))
            myPrint("B", "Sync Method: %s" %(syncMethod.getSyncFolder()))
            x = returnPathStrings(get_sync_folder(lReturnFileOrURLObject=True))
            if x:
                textArray.append(u"Sync local disk/url location:  %s" %(x))
                myPrint("B", "Sync local disk / url location: %s" %(x))
        except:
            textArray.append(u"Sync Method: *** YOU HAVE A PROBLEM WITH YOUR DROPBOX CONFIGURATION! ***")
            myPrint("B",u"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            myPrint("B",u"!! WARNING - You have a Dropbox configuration issue which is crashing .getSyncFolder() !!")
            myPrint("B",u"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            MyPopUpDialogBox(toolbox_frame_,
                             u"WARNING - DROPBOX ERROR",
                             u"You seem to have a Dropbox configuration issue!?\n"
                             u"(or you have launched from command line, not the code-signed app bundle)\n"
                             u"Toolbox cannot directly fix this for you - please review your console logs\n"
                             u"... Try... Toolbox (Update Mode) Advanced Option 'Force RESET Sync settings'\n"
                             u"...... to setup Sync again from scratch (sometimes  fixes old Dropbox settings)",
                             theTitle=u"DROPBOX ERROR",
                             lModal=False,
                             lAlertLevel=2).go()

        if not getShouldDownloadAllAttachments(): textArray.append(u"** Sync downloading of attachments is disabled **")

        if not check_for_dropbox_folder():
            textArray.append(u"Sync WARNING: Dropbox sync will not work until you add the missing .moneydancesync folder - use update mode to fix!")

        textArray.append(u"\nTHEMES")

        try:  x = u"'%s' : %s" %(MD_REF.getUI().getCurrentTheme(),UIManager.getLookAndFeel())
        except:  x = u"failed to get Theme details"

        y = u"(DARK THEME)" if (isMDThemeDark()) else u""
        z = u"(Mac Dark Mode detected)" if (Platform.isOSX() and isMacDarkModeDetected()) else u""

        textArray.append(u"Your selected Theme: %s (%s) %s %s" %(MD_REF.getUI().getPreferences().getSetting(GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME, ThemeInfo.DEFAULT_THEME_ID), x, y, z))
        myPrint("B", "Your selected Theme: %s (%s) %s %s" %(MD_REF.getUI().getPreferences().getSetting(GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME, ThemeInfo.DEFAULT_THEME_ID), x, y, z))

        # noinspection PyUnresolvedReferences
        if not os.path.exists(ThemeInfo.customThemeFile.getCanonicalPath()):
            x = u"custom_theme.properties file DOES NOT EXIST!"
        else:
            x = returnPathStrings(ThemeInfo.customThemeFile)

        textArray.append(u"Custom Theme File:   %s" %(x))
        # noinspection PyUnresolvedReferences
        textArray.append(u"Available themes:    %s" %(ThemeInfo.getAllThemes()))

        textArray.append(u"\nRUNTIME ENVIRONMENT")

        textArray.append(u"Java version:                        %s"  %(System.getProperty(u"java.version")))
        textArray.append(u"Java vendor:                         %s"  %(System.getProperty(u"java.vendor")))

        textArray.append(u"Platform:                            %s %s %s.%s" %(platform.python_implementation(), platform.system(), sys.version_info.major, sys.version_info.minor))

        textArray.append(u"SandBoxed:                           %s" %(MD_REF.getPlatformHelper().isSandboxed()))
        textArray.append(u"Restricted:                          %s" %(MD_REF.getPlatformHelper().isConstrainedToSandbox()))

        if MD_REF.getExecutionMode() == MD_REF.EXEC_MODE_APP:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()) + u" = APP (Normal App)")
        elif MD_REF.getExecutionMode() == MD_REF.EXEC_MODE_APPLET:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()) + u" = APPLET (probably from an AppStore?")
        else:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()))

        textArray.append(u"MD Debug Mode:                       %s" %(MD_REF.DEBUG))
        textArray.append(u"Beta Features:                       %s" %(MD_REF.BETA_FEATURES))
        textArray.append(u"Architecture:                        %s%s" %(System.getProperty(u"os.arch"),
                                                                        u" (Intel 32-bit)" if isIntelX86_32bit() else u""))

        if theExtn and theExtn[1].strip() != u"":
            textArray.append(u"File Extension:                      %s" %theExtn[1])
        else:
            textArray.append(u"File Extension:                      %s" %(MD_REF.FILE_EXTENSION))

        # NOTE: As of MD2022(4040) python.getSystemState().setdefaultencoding("utf8") is called on the python interpreter at launch...
        textArray.append(u"Operating System file encoding:      %s" %(Charset.defaultCharset()))
        textArray.append(u"File system default encoding:        %s, Python default encoding: %s (overridden from ASCII)"
                         %(sys.getfilesystemencoding(), PySystemState().getdefaultencoding()))

        try:
            # New for MD2020.2012
            x = MD_REF.getUI().getFonts().code
        except:
            myPrint("B",u"Failed to get Moneydance code font (must be older version), loading older mono")
            x = MD_REF.getUI().getFonts().mono

        textArray.append(u"Python default display font:         %s(%s)" %(x.getFontName(), x.getSize()))


        textArray.append(u"\nENVIRONMENT")

        try:
            username = System.getProperty(u"user.name")
        except:
            username = u"???"
        textArray.append(u"Username:                            %s" %username)

        textArray.append(u"OS Platform:                         %s" %System.getProperty(u"os.name") + u"OS Version: %s" %(System.getProperty(u"os.version")))

        textArray.append(u"Home Directory:                      %s" %(get_home_dir()))
        if System.getProperty(u"user.dir"): textArray.append(u"  user.dir:                          %s" %System.getProperty(u"user.dir"))
        if System.getProperty(u"UserHome"): textArray.append(u"  UserHome:                          %s" %System.getProperty(u"UserHome"))
        if os.path.expanduser(u"~"):        textArray.append(u"  ~:                                 %s" %os.path.expanduser(u"~"))
        if os.environ.get(u"HOMEPATH"):     textArray.append(u"  HOMEPATH:                          %s" %os.environ.get(u"HOMEPATH"))

        textArray.append(u"Moneydance decimal point:            %s" %MD_REF.getUI().getPreferences().getSetting(u"decimal_character", u"."))
        textArray.append(u"System Locale Decimal Point:         %s" %(getDecimalPoint()))
        if MD_REF.getUI().getPreferences().getSetting(u"decimal_character", u".") != getDecimalPoint():
            textArray.append(u"NOTE - MD Decimal point is DIFFERENT to the Locale decimal point!!!")
        textArray.append(u"MD User set Locale Country:          %s" %(MD_REF.getUI().getPreferences().getSetting(u"locale.country", u"")))
        textArray.append(u"MD User set Locale Language:         %s" %(MD_REF.getUI().getPreferences().getSetting(u"locale.language", u"")))

        loc = Locale.getDefault(); loc_c = loc.getCountry(); loc_l = loc.getLanguage()
        # noinspection PyUnresolvedReferences
        if (loc_c.lower() != MD_REF.getUI().getPreferences().getSetting(u"locale.country", u"_unknown_").lower()) \
                or (loc_l.lower() != MD_REF.getUI().getPreferences().getSetting(u"locale.language", u"_unknown_").lower()):
            textArray.append(u"NOTE - MD User set Locale details are different to System Locale details!!!")
            textArray.append(u"(System Locale Country:              %s)" %(loc_c))
            textArray.append(u"(System Locale Language:             %s)" %(loc_l))
        del loc, loc_c, loc_l

        textArray.append(u"\nFOLDER / FILE LOCATIONS")

        textArray.append(u"MD Dataset internal top level (root) Directory: %s" %(returnPathStrings(MD_REF.getCurrentAccountBook().getRootFolder().getParent())))
        textArray.append(u"Auto Backup Folder:                             %s " %(returnPathStrings(FileUtils.getBackupDir(MD_REF.getPreferences()))))
        textArray.append(u"(Last backup location:                          '%s')" %(MD_REF.getUI().getPreferences().getSetting(u"backup.last_saved", u"")))

        internalFiles = AccountBookUtil.getInternalAccountBooks()
        externalFiles = AccountBookUtil.getExternalAccountBooks()

        if internalFiles.size() + externalFiles.size() > 1:
            textArray.append(u"\nOther MD Datasets I am aware of...:")

        for wrapperOrBook in internalFiles:
            _book = wrapperOrBook if isinstance(wrapperOrBook, AccountBook) else wrapperOrBook.getBook()                # changed in MD2023.2(5020) to return [books]
            if MD_REF.getUI().getCurrentAccounts() is not None and MD_REF.getUI().getCurrentAccounts().getBook() is _book:
                pass
            else:
                textArray.append(u"Internal file:           %s" %(_book.getRootFolder().getCanonicalPath()))
            del _book

        for wrapperOrBook in externalFiles:
            _book = wrapperOrBook if isinstance(wrapperOrBook, AccountBook) else wrapperOrBook.getBook()                # changed in MD2023.2(5020) to return [books]
            if (MD_REF.getUI().getCurrentAccounts() is not None and MD_REF.getUI().getCurrentAccounts().getBook() is _book):
                pass
            else:
                textArray.append(u"External file:           %s" %(_book.getRootFolder().getCanonicalPath()))
            del _book

        if internalFiles.size() + externalFiles.size() > 1:
            textArray.append(u"\n")

        textArray.append(u"MD System Root Directory:    %s" %(Common.getRootDirectory().getCanonicalPath()))

        textArray.append(u"MD Log file:                 %s" %(MD_REF.getLogFile().getCanonicalPath()))
        textArray.append(u"Preferences File:            %s" %(Common.getPreferencesFile().getCanonicalPath()))

        if os.path.exists((Common.getArchiveDirectory().getCanonicalPath())):
            textArray.append(u"Archive Directory:           %s" %(Common.getArchiveDirectory().getCanonicalPath()))
        if os.path.exists((Common.getFeatureModulesDirectory().getCanonicalPath())):
            textArray.append(u"Extensions Directory:        %s" %(Common.getFeatureModulesDirectory().getCanonicalPath()))
        if os.path.exists((Common.getCertificateDirectory().getCanonicalPath())):
            textArray.append(u"Certificates Directory:      %s" %(Common.getCertificateDirectory().getCanonicalPath()))
        if os.path.exists((Common.getDocumentsDirectory().getCanonicalPath())):
            textArray.append(u"Documents Directory:         %s" %(Common.getDocumentsDirectory().getCanonicalPath()))

        if getTheSetting(u"gen.report_dir"):
            textArray.append(getTheSetting(u"gen.report_dir", 29))
        if getTheSetting(u"gen.data_dir"):
            textArray.append(getTheSetting(u"gen.data_dir", 29))
        if getTheSetting(u"gen.import_dir"):
            textArray.append(getTheSetting(u"gen.import_dir", 29))

        textArray.append(u"\n")
        if os.path.exists((Common.getPythonDirectory().getCanonicalPath())):
            textArray.append(u"Python Directory:                %s" %(Common.getPythonDirectory().getCanonicalPath()))
        if getTheSetting(u"gen.last_ext_file_dir"):
            textArray.append(getTheSetting(u"gen.last_ext_file_dir", 33))
        if getTheSetting(u"gen.python_default_file"):
            textArray.append(getTheSetting(u"gen.python_default_file", 33))
        if getTheSetting(u"gen.python_dir"):
            textArray.append(getTheSetting(u"gen.python_dir", 33))
        if getTheSetting(u"gen.graph_dir"):
            textArray.append(getTheSetting(u"gen.graph_dir", 33))
        if getTheSetting(u"gen.recent_files"):
            textArray.append(getTheSetting(u"gen.recent_files", 33))

        textArray.append(u"System 'python.path':            %s" %System.getProperty(u"python.path"))
        textArray.append(u"System 'python.cachedir':        %s" %System.getProperty(u"python.cachedir"))
        textArray.append(u"System 'python.cachedir.skip':   %s" %System.getProperty(u"python.cachedir.skip"))

        try:
            textArray.append(u"\nEXTENSIONS / EDITORS / VIEWS")

            textArray.append(u"Extensions enabled:                          %s" %(MD_REF.getSourceInformation().getExtensionsEnabled()))

            x = MD_REF.getExternalAccountEditors()
            for y in x:
                textArray.append(u"External Account Editor:                     %s" %(y))
            x = MD_REF.getExternalViews()
            for y in x:
                textArray.append(u"External View(HomePage widget):              %s" %(y))
            x = MD_REF.getLoadedModules()
            for y in x:
                textArray.append(u"Extension Loaded:                            %s" %(y.getDisplayName()))
            x = MD_REF.getSuppressedExtensionIDs()
            for y in x:
                textArray.append(u"Internal/suppressed/unloadable extns:        %s" %(y))
            if float(MD_REF.getBuild()) < 3051:
                # .getOutdatedExtensionIDs() name changed prior to 3051
                x = MD_REF.getOutdatedExtensionIDs()                                                                    # noqa
            else:
                x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
            for y in x:
                textArray.append(u"Outdated extensions (not loaded):            %s" %(y))

            textArray.append(u"\n** Use General Tools Menu>View Extension(s) details for more info and available updates **")

        except: pass

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs) < 1 and len(orphan_files) < 1 and len(orphan_confirmed_extn_keys) < 1:
            textArray.append(u"\nCONGRATULATIONS - NO ORPHAN EXTENSIONS DETECTED!!\n")
        else:
            textArray.append(u"\nWARNING: Orphan Extensions detected (%s in config.dict) & (%s in .MXT files)\n" %(len(orphan_prefs)+len(orphan_confirmed_extn_keys),len(orphan_files)))
            myPrint(u"B", u"WARNING: Orphan Extensions detected (%s in config.dict) & (%s in .MXT files)\n" %(len(orphan_prefs)+len(orphan_confirmed_extn_keys),len(orphan_files)))

        textArray.append(u"\n ======================================================================================")
        textArray.append(u"USER PREFERENCES")
        textArray.append(u" ----------------")
        textArray.append(u">> GENERAL")
        textArray.append(u"Show Full Account Paths:             %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"show_full_account_path", True)))
        textArray.append(u"Register Follows Recorded Txns:      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.register_follows_txns", True)))
        textArray.append(u"Use VAT/GST:                         %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.use_vat", False)))
        textArray.append(u"Case Sensitive Auto-Complete:        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.case_sensitive_ac", False)))
        textArray.append(u"Auto Insert Decimal Points:          %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.quickdecimal", False)))
        textArray.append(u"Auto Create New Transactions:        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.new_txn_on_record", True)))
        textArray.append(u"Separate Tax Date for Transactions:  %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.separate_tax_date", False)))
        textArray.append(u"Show All Accounts in Popup:          %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.show_all_accts_in_popup", False)))
        textArray.append(u"Beep when Transactions Change:       %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"beep_on_transaction_change", True)))
        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"Theme: %s" %(MD_REF.getUI().getPreferences().getSetting(GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME, ThemeInfo.DEFAULT_THEME_ID)))
        textArray.append(u"Show Selection Details:              %s" %(MD_REF.getUI().getPreferences().getSetting(u"details_view_mode", u"inwindow")))
        textArray.append(u"Side Bar Balance Type:               %s" %(MD_REF.getUI().getPreferences().getSideBarBalanceType()))
        textArray.append(u"Date Format:                         %s" %(MD_REF.getUI().getPreferences().getSetting(u"date_format", None)))
        # this.prefs.getShortDateFormat());
        textArray.append(u"Decimal Character:                   %s" %(MD_REF.getUI().getPreferences().getSetting(u"decimal_character", ".")))
        # this.prefs.getDecimalChar()));
        textArray.append(u"Locale:                              %s" %(MD_REF.getUI().getPreferences().getLocale()))

        i = MD_REF.getUI().getPreferences().getIntSetting(u"gen.fiscal_year_start_mmdd", 101)
        if i == 101: i = u"January 1"
        elif i == 201: i = u"February 1"
        elif i == 301: i = u"March 1"
        elif i == 401: i = u"April 1"
        elif i == 406: i = u"April 6 (UK Tax Year Start Date)"
        elif i == 501: i = u"May 1"
        elif i == 601: i = u"June 1"
        elif i == 701: i = u"July 1"
        elif i == 801: i = u"August 1"
        elif i == 901: i = u"September 1"
        elif i == 1001: i = u"October 1"
        elif i == 1101: i = u"November 1"
        elif i == 1201: i = u"December 1"
        else: i = i
        textArray.append(u"Fiscal Year Start:                   %s" %(i))

        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"Font Size:                           +%s" %(MD_REF.getUI().getPreferences().getIntSetting(u"gui.font_increment", 0)))

        if float(MD_REF.getBuild()) >= 3032:
            textArray.append(u"\n>> APPEARANCE")
            textArray.append(u"Theme:                               %s" %(MD_REF.getUI().getPreferences().getSetting(GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME, ThemeInfo.DEFAULT_THEME_ID)))
            if (MD_REF.getUI().getPreferences().getSetting(u"main_font")) != u"null":
                textArray.append(u"Font:                                %s" %(MD_REF.getUI().getPreferences().getSetting(u"main_font")))
            else:
                textArray.append(u"Font:                                (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"mono_font")) != u"null":
                textArray.append(u"Numeric Font:                        %s" %(MD_REF.getUI().getPreferences().getSetting(u"mono_font")))
            else:
                textArray.append(u"Numeric Font:                        (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"code_font")) != u"null":
                textArray.append(u"Moneybot Coding (monospaced) Font:   %s" %(MD_REF.getUI().getPreferences().getSetting(u"code_font")))
            else:
                textArray.append(u"Moneybot Coding (monospaced) Font:   (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"print.font_name")) != u"null":
                textArray.append(u"Printing Font:                       %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_name")))
            else:
                textArray.append(u"Printing Font:                       (None/Default)")

            textArray.append(u"Print Font Size:                     %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_size", u"12")))
            textArray.append(u"Screen Font Size:                    +%s" %(MD_REF.getUI().getPreferences().getIntSetting(u"gui.font_increment", 0)))

        textArray.append(u"\n>> NETWORK")
        textArray.append(u"Automatically Download in Background:                             %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.auto_download", False)))
        textArray.append(u"Automatically Merge Downloaded Transactions:                      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.preprocess_dwnlds", False)))
        textArray.append(u"Mark Transactions as Cleared When Confirmed:                      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.clear_confirmed_txns", False)))
        textArray.append(u"Use Bank Dates for Merged Transactions:                           %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"olb.prefer_bank_dates", False)))
        textArray.append(u"Ignore Transaction Types in Favor of Amount Signs:                %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"prefer_amt_sign_to_txn_type", False)))

        dataStorage = MD_REF.getCurrentAccountBook().getLocalStorage()
        autocommit = not dataStorage or dataStorage.getBoolean(u"do_autocommits",MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
        textArray.append(u"Auto-Commit Reminders (applies to current file on this computer): %s" %(autocommit))

        textArray.append(u"Use Proxy:                                                        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.use_proxy", False)))
        textArray.append(u" Proxy Host:                                                      %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_host", "")))
        textArray.append(u" Proxy Port:                                                      %s" %(MD_REF.getUI().getPreferences().getIntSetting(u"net.proxy_port", 80)))
        textArray.append(u"Proxy Requires Authentication:                                    %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.auth_proxy", False)))
        textArray.append(u" Proxy Username:                                                  %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_user", "")))
        textArray.append(u" Proxy Password:                                                  %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_pass", "")))
        textArray.append(u"Observe Online Payment Date Restrictions:                         %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"ofx.observe_bp_window", True)))
        i = MD_REF.getUI().getPreferences().getIntSetting(u"net.downloaded_txn_date_window", -1)
        if i < 0: i = u"Default"
        textArray.append(u"Only Match downloaded transactions when they are at most %s days apart" %(i))

        textArray.append(u"\n>> CHEQUE PRINTING")
        textArray.append(u"preferences not listed here...")

        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"\n>> PRINTING")
            textArray.append(u"Font:      %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_name", u"")))
            textArray.append(u"Font Size: %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_size", u"12")))

        textArray.append(u"\n>> BACKUPS")

        destroyBackupChoices = MD_REF.getUI().getPreferences().getSetting(u"backup.destroy_number", u"5")
        returnedBackupType = MD_REF.getUI().getPreferences().getSetting(GlobalVars.Strings.MD_CONFIGDICT_BACKUP_TYPE, u"every_x_days")
        if returnedBackupType == u"every_time":
            dailyBackupCheckbox = True
            destroyBackupChoices = 1
        elif returnedBackupType == u"every_x_days":
            dailyBackupCheckbox = True
        else:
            dailyBackupCheckbox = False

        textArray.append(u"Save Backups Daily:     %s" %(dailyBackupCheckbox))
        textArray.append(u"Keep no more than       %s" %(destroyBackupChoices) + u" backups")

        textArray.append(u"separate Backup Folder: %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"backup.location_selected", True)))
        textArray.append(u"Backup Folder:          %s " %(FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath() ))

        textArray.append(u"\n>> SUMMARY PAGE")
        textArray.append(u"preferences not listed here...")
        textArray.append(u" ======================================================================================\n")

        textArray.append(u"\nHOME SCREEN USER SELECTED PREFERENCES")
        textArray.append(u" ---------------------------")
        textArray.append(u"Home Screen Configured:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.configured", u"NOT SET"))

        if MD_REF.getUI().getPreferences().getSetting(u"sidebar_bal_type", False):
            textArray.append(u"Side Bar Balance Type:           %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"sidebar_bal_type",0))))
        textArray.append(u"Dashboard Item Selected:         %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.dashboard.item", u"NOT SET"))
        textArray.append(u"Quick Graph Selected:            %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.quick_graph_type", u"NOT SET"))
        textArray.append(u"Budget Bar Date Range Selected:  %s" %MD_REF.getUI().getPreferences().getSetting(u"budgetbars_date_range", u"NOT SET"))
        textArray.append(u"Reminders View:                  %s" %MD_REF.getUI().getPreferences().getSetting(u"upcoming_setting", u"NOT SET"))

        textArray.append(u"Exchange Rates View - Invert?:   %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.invert_rates", u"NOT SET"))

        textArray.append(u"BANK Accounts Expanded:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.bank_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.bank_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.bank_bal_type",0))))

        textArray.append(u"LOAN Accounts Expanded:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.loan_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.loan_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.loan_bal_type",0))))

        textArray.append(u"LIABILITY Accounts Expanded:     %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.liability_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.liability_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.liability_bal_type",0))))

        textArray.append(u"INVESTMENT Accounts Expanded:    %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.invst_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.invst_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.invst_bal_type",0))))

        textArray.append(u"CREDIT CARD Accounts Expanded:   %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.cc_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.cc_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.cc_bal_type",0))))

        textArray.append(u"ASSET Accounts Expanded:         %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.asset_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.asset_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.asset_bal_type",0))))


        textArray.append(u" ======================================================================================\n")

        try:
            textArray.append(u"\nFONTS")
            textArray.append(u">> Swing Manager default:     %s" %(UIManager.getFont("Label.font")))
            textArray.append(u">> Moneydance default:        %s" %(MD_REF.getUI().getFonts().defaultSystemFont))
            textArray.append(u">> Moneydance mono:           %s" %(MD_REF.getUI().getFonts().mono))
            textArray.append(u">> Moneydance default text:   %s" %(MD_REF.getUI().getFonts().defaultText))
            textArray.append(u">> Moneydance default title:  %s" %(MD_REF.getUI().getFonts().detailTitle))
            textArray.append(u">> Moneydance calendar title: %s" %(MD_REF.getUI().getFonts().calendarTitle))
            textArray.append(u">> Moneydance header:         %s" %(MD_REF.getUI().getFonts().header))
            textArray.append(u">> Moneydance register:       %s" %(MD_REF.getUI().getFonts().register))
            textArray.append(u">> Moneydance report header:  %s" %(MD_REF.getUI().getFonts().reportHeader))
            textArray.append(u">> Moneydance report title:   %s" %(MD_REF.getUI().getFonts().reportTitle))

            textArray.append(u">> Moneydance code:           %s" %(getMonoFont()))

        except:
            myPrint(u"B",u"Error getting fonts..?")
            dump_sys_error_to_md_console_and_errorlog()

        textArray.append(u"\n>> OTHER INTERESTING SETTINGS....")

        if getTheSetting(u"net.default_browser"):
            textArray.append(getTheSetting(u"net.default_browser", 29))
        if getTheSetting(u"gen.import_dt_fmt_idx"):
            textArray.append(getTheSetting(u"gen.import_dt_fmt_idx", 29))
        if getTheSetting(u"txtimport_datefmt"):
            textArray.append(getTheSetting(u"txtimport_datefmt", 29))
        if getTheSetting(u"txtimport_csv_delim"):
            textArray.append(getTheSetting(u"txtimport_csv_delim", 29))
        if getTheSetting(u"txtimport_csv_decpoint"):
            textArray.append(getTheSetting(u"txtimport_csv_decpoint", 29))

        textArray.append(u"")

        if getTheSetting(u"ofx.app_id"):
            textArray.append(getTheSetting(u"ofx.app_id", 29))
        if getTheSetting(u"ofx.app_version"):
            textArray.append(getTheSetting(u"ofx.app_version", 29))
        if getTheSetting(u"ofx.bp_country"):
            textArray.append(getTheSetting(u"ofx.bp_country", 29))
        if getTheSetting(u"ofx.app_version"):
            textArray.append(getTheSetting(u"ofx.app_version", 29))

        textArray.append(u"")
        x = getJVMUsageStatistics(memoryUsageStats=True, maxMemoryStats=True, availableProcessorsStats=True)
        textArray.append(x)
        myPrint(u"B", x)

        textArray.append(u"")
        textArray.append(u"Java JVM System Properties containing references to Moneydance")
        for x in System.getProperties():

            # noinspection PyUnresolvedReferences
            if u"moneydance" in System.getProperty(x).lower():
                textArray.append(u">> %s%s" %(pad(x,50), System.getProperty(x)))

        textArray.append(u"\n\n<END>\n")

        # This catches exceptions.UnicodeDecodeError 'utf-8' codec can't decode byte 0xa0 in position 46: unexpected code byte'
        # First spotted with South African Locale and nbsp used for decimal grouping character....

        try:
            returnString = u"\n".join(textArray)
            myPrint(u"DB",u"Success joining diagnostics text array.....")
        except:
            myPrint(u"B",u"UH-OH - Seems like we probably caught an utf8 error... trying to rectify")
            myPrint(u"B", dump_sys_error_to_md_console_and_errorlog(True))
            returnString = u""
            for i in range(0, len(textArray)):
                for char in textArray[i]:
                    if ord(char)>=128:
                        myPrint(u"B",u"char ord(%s) found in row %s; position %s" %(ord(char),i,textArray[i].find(char)))
                        myPrint(u"B",u"@@ FAILING ROW STARTS: '%s'" %(textArray[i][:textArray[i].find(char)]))
                        break
                returnString += (u"".join(char for char in textArray[i] if ord(char) < 128) )+u"\n"
            returnString += u"\n(** NOTE: I had to strip non ASCII characters **)\n"

        return returnString

    def get_list_memorised_reports():
        # Build a quick virtual file of Memorized reports and graphs to display
        memz = []

        iCount = 0
        for x in MD_REF.getCurrentAccountBook().getMemorizedItems().getMemorizedGraphs():
            iCount += 1
            memz.append("Graph: %s" % (x.getName()))

        for x in MD_REF.getCurrentAccountBook().getMemorizedItems().getMemorizedReports():
            iCount += 1
            memz.append("Report: %s" % (x.getName()))

        memz = sorted(memz, key=lambda sort_x: ((sort_x[0]).upper()))

        memz.insert(0,"YOUR MEMORIZED REPORTS\n ======================\n")

        memz.append("\nYOUR MEMORIZED REPORTS in detail\n ======================\n")

        iGs = 0
        for x in MD_REF.getCurrentAccountBook().getMemorizedItems().getMemorizedGraphs():
            if iGs:
                memz.append("\n ---")
            iGs += 1
            memz.append("Graph:           %s" % (x.getName()))
            memz.append(">> SyncItemType: %s" %(x.getSyncItemType()))
            # memz.append(">> Graph ID:     %s" %(x.getReportID()))
            memz.append(">> Graph Genr:   %s" %(x.getReportGenerator()))
            y = x.getReportParameters()
            for yy in y:
                if yy.lower().strip() == "accounts" or yy.lower().strip() == "source_accts":
                    memz.append(">> Parameter key: %s: %s" %(yy, "<not displayed - but contains %s accounts>" %(y.get(yy).count(",")+1)))
                else:
                    memz.append(">> Parameter key: %s: %s" %(yy, y.get(yy)))

        iRs = 0
        for x in MD_REF.getCurrentAccountBook().getMemorizedItems().getMemorizedReports():
            if iRs or iGs:
                memz.append("\n ---")
            iRs += 1
            memz.append("Report           %s" % (x.getName()))
            memz.append(">> SyncItemType: %s" %(x.getSyncItemType()))
            # memz.append(">> Report ID:    %s" %(x.getReportID()))
            memz.append(">> Report Genr:  %s" %(x.getReportGenerator()))
            y = x.getReportParameters()
            for yy in y:
                if yy.lower().strip() == "accounts" or yy.lower().strip() == "source_accts":
                    memz.append(">> Parameter key: %s: %s" %(yy, "<not displayed - but contains %s accounts>" %(y.get(yy).count(",")+1)))
                else:
                    memz.append(">> Parameter key: %s: %s" %(yy, y.get(yy)))

        memz.append("\n\n\n====== DEFAULT REPORTS SETTINGS/PARAMETERS (from Local Storage) RAW DUMP ======\n")
        LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

        last = None
        keys = sorted(LS.keys())
        for theKey in keys:
            value = LS.get(theKey)
            if not theKey.lower().startswith("report_params."): continue
            split_key = theKey.split(".",2)
            if split_key[1] != last:
                memz.append("")
                last = split_key[1]

            if theKey.lower().strip().endswith(".accounts") or theKey.lower().strip().endswith(".source_accts"):
                memz.append("Key:%s Value: %s" % (pad(theKey,70), "<not displayed - but contains %s accounts>" %(value.count(",")+1)))
            else:
                memz.append("Key:%s Value: %s" % (pad(theKey,70), value.strip()))

        x = LS.get("grfRepDefaultParams")
        if x:
            memz.append("\n\nDefault Parameters: 'grfRepDefaultParams' (Probably Legacy keys)")
            memz.append("%s" %x)
            memz.append("")

        memz.append("\n<END>")

        for i in range(0, len(memz)):
            memz[i] = memz[i] + "\n"
        memz = "".join(memz)

        QuickJFrame("Memorized Reports and Graphs", memz, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def view_extensions_details():

        theData = []

        theData.append("EXTENSION(s) DETAILS")
        theData.append(" =====================\n")

        if len(MD_REF.getExternalViews()) > 0:
            theData.append("External Views (HomePage widgets) views:\n")

            for ev in MD_REF.getExternalViews():
                theData.append("   - %s" %(ev.getID()))

            theData.append("\n")

        if not DownloadExtensionVersionData.downloadsCompleted():
            theData.append("** Live extension version / update data not available as these have not yet downloaded (try again later) **\n".upper())
        elif DownloadExtensionVersionData.didErrorOccur():
            theData.append("** Live extension version / update data not available as error during download occurred (check internet and restart Toolbox) **\n".upper())
        elif len(DownloadExtensionVersionData.downloadedIKExtensionsDict) < 1:
            theData.append("** Live extension version / update data appears to be empty?? **\n".upper())

        theData.append("Extensions enabled: %s\n" %MD_REF.getSourceInformation().getExtensionsEnabled())

        theUpdateList = DownloadExtensionVersionData.get_extension_update_info()

        try:
            x = MD_REF.getLoadedModules()
            for y in x:
                isUpdatable= "(latest version)"
                updateInfo = theUpdateList.get(y.getIDStr().lower())
                if updateInfo:
                    isUpdatable = ("\t******* Updatable to version: %s *******" %(updateInfo[0].getBuild())).upper()
                theData.append("Extension ID:           %s" %y.getIDStr())
                theData.append("Extension Name:         %s" %y.getName())
                theData.append("Extension Display Name: %s" %y.getDisplayName())
                theData.append("Extension Description:  %s" %y.getDescription())
                theData.append("Extension Version:      %s" %(y.getBuild()) + isUpdatable)
                theData.append("Extension Source File:  %s" %(y.getSourceFile()))
                theData.append("Extension Vendor:       %s" %y.getVendor())
                theData.append("Extension isBundled:    %s" %(y.isBundled()))
                theData.append("Extension isVerified:   %s" %(y.isVerified()))
                if MD_REF.getUI().getPreferences().getSetting("confirmedext."+str(y.getName()).strip(), None):
                    theData.append("** User has Confirmed this unsigned Extension can run - version: " + MD_REF.getUI().getPreferences().getSetting("confirmedext."+str(y.getName()).strip(), None))
                theData.append("\n\n")

            x = MD_REF.getSuppressedExtensionIDs()
            for y in x:
                theData.append("Internal/suppressed/secret extensions: %s" %(y))

            if float(MD_REF.getBuild()) < 3051:
                # .getOutdatedExtensionIDs() name changed prior to 3051
                x = MD_REF.getOutdatedExtensionIDs()                                                                    # noqa
            else:
                x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
            for y in x:
                theData.append("Outdated / unloadable extensions (not loaded): %s" %(y))
        except:
            theData.append("\nERROR READING EXTENSION DATA!!!!\n")
            dump_sys_error_to_md_console_and_errorlog()

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            theData.append("\nCONGRATULATIONS - NO ORPHAN EXTENSIONS DETECTED!!\n")

        else:
            theData.append("\nLISTING EXTENSIONS ORPHANED IN CONFIG.DICT OR FILES (*.MXT)\n")

            for x in orphan_prefs.keys():
                theData.append("%s Extension: %s is %s" %(pad("config.dict:",40),pad(x,40),pad(orphan_prefs[x],40)))

            theData.append("")

            for x in orphan_confirmed_extn_keys.keys():
                _theVersion = MD_REF.getUI().getPreferences().getSetting(orphan_confirmed_extn_keys[x][1],None)
                theData.append("%s Extension: %s Key: %s (build: %s) is %s" %(pad("config.dict:",40),pad(x,40),pad(orphan_confirmed_extn_keys[x][1],40),_theVersion, pad(orphan_confirmed_extn_keys[x][0],40)))

            theData.append("")

            for x in orphan_files.keys():
                theData.append("%s Extension: %s is %s" %(pad("File: "+orphan_files[x][1],40),pad(x,40),pad(orphan_files[x][0],40)))

        theData.append("\n<END>")

        # Build a quick virtual 'file' of Memorized reports and graphs to display
        for i in range(0, len(theData)):
            theData[i] = theData[i] + "\n"
        theData = "".join(theData)

        jif = QuickJFrame("View Extension(s) details / data", theData, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

        if GlobalVars.lIgnoreOutdatedExtensions_TB:
            if myPopupAskQuestion(jif,
                                  "CHECK FOR OUTDATED EXTENSIONS",
                                  "Turn startup warnings back on for Outdated Extensions?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.QUESTION_MESSAGE):

                txt = "OUTDATED EXTENSIONS - Startup warnings re-enabled"
                setDisplayStatus(txt, "B"); myPrint("B", txt)
                GlobalVars.lIgnoreOutdatedExtensions_TB = False
                try:
                    save_StuWareSoftSystems_parameters_to_file()
                except:
                    myPrint("B", "Error - failed to save parameters to pickle file...!")
                    dump_sys_error_to_md_console_and_errorlog()


    class ToolboxBuildInfo:

        def __init__(self, buildObject):
            self.obj =                                  buildObject
            self.build =                                buildObject.getInt("build", 0)
            self.disable =                              buildObject.getBoolean("disable", False)
            self.TOOLBOX_MINIMUM_TESTED_MD_VERSION =    float(buildObject.getStr("TOOLBOX_MINIMUM_TESTED_MD_VERSION", "0.0"))
            self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =    float(buildObject.getStr("TOOLBOX_MAXIMUM_TESTED_MD_VERSION", "0.0"))
            self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =      buildObject.getInt("TOOLBOX_MAXIMUM_TESTED_MD_BUILD", 0)
            self.MD_OFX_BANK_SETTINGS_DIR =             buildObject.getStr("MD_OFX_BANK_SETTINGS_DIR", "")
            self.MD_OFX_DEFAULT_SETTINGS_FILE =         buildObject.getStr("MD_OFX_DEFAULT_SETTINGS_FILE", "")
            self.MD_OFX_DEBUG_SETTINGS_FILE =           buildObject.getStr("MD_OFX_DEBUG_SETTINGS_FILE", "")
            self.MD_EXTENSIONS_DIRECTORY_FILE =         buildObject.getStr("MD_EXTENSIONS_DIRECTORY_FILE", "")
            self.MYPYTHON_DOWNLOAD_URL =                buildObject.getStr("MYPYTHON_DOWNLOAD_URL", "")

            # noinspection PyChainedComparsons
            if self.build > 1000 and self.build < 9999 and self.disable: return                                         # noqa

            # noinspection PyChainedComparsons
            if (self.build < 1000 or self.build > 9999
                    or (self.TOOLBOX_MINIMUM_TESTED_MD_VERSION > 0  and self.TOOLBOX_MINIMUM_TESTED_MD_VERSION < 2020.0)    # noqa
                    or (self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION > 0  and self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION < 2021.1)    # noqa
                    or (self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD > 0    and self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD   < 3034)      # noqa
                    or (len(self.MD_OFX_BANK_SETTINGS_DIR) > 0      and len(self.MD_OFX_BANK_SETTINGS_DIR)     < 10)        # noqa
                    or (len(self.MD_OFX_DEFAULT_SETTINGS_FILE) > 0  and len(self.MD_OFX_DEFAULT_SETTINGS_FILE) < 10)        # noqa
                    or (len(self.MD_OFX_DEBUG_SETTINGS_FILE) > 0    and len(self.MD_OFX_DEBUG_SETTINGS_FILE)   < 10)        # noqa
                    or (len(self.MD_EXTENSIONS_DIRECTORY_FILE) > 0  and len(self.MD_EXTENSIONS_DIRECTORY_FILE) < 10)        # noqa
                    or (len(self.MYPYTHON_DOWNLOAD_URL) > 0         and len(self.MYPYTHON_DOWNLOAD_URL) < 10)):             # noqa

                myPrint("DB","Error with toolbox downloaded data - invalidating it - was: %s" %(self.obj))
                self.build =                                0
                self.disable =                              False
                self.TOOLBOX_MINIMUM_TESTED_MD_VERSION =    None
                self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =    None
                self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =      None
                self.MD_OFX_BANK_SETTINGS_DIR =             None
                self.MD_OFX_DEFAULT_SETTINGS_FILE =         None
                self.MD_OFX_DEBUG_SETTINGS_FILE =           None
                self.MD_EXTENSIONS_DIRECTORY_FILE =         None
                self.MYPYTHON_DOWNLOAD_URL =                None


        def __str__(self):
            return "Toolbox build info Obj. Build: %s Disabled: %s {%s}" %(self.build,self.disable, self.obj)

        def __repr__(self):
            return "Toolbox build info Obj. Build: %s Disabled: %s {%s}" %(self.build,self.disable, self.obj)

    def check_if_key_string_valid(test_str):
        # http://docs.python.org/library/re.html
        # re.search returns None if no position in the string matches the pattern
        # pattern to search for any character other than "._-A-Za-z0-9"
        pattern = r'[^a-zA-Z0-9-_.:&=;,@]'
        if re.search(pattern, test_str):
            myPrint("DB","Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","Valid: %r" %(test_str))
            return True

    def check_if_key_data_string_valid(test_str):
        # http://docs.python.org/library/re.html
        # re.search returns None if no position in the string matches the pattern
        # pattern to search for any character other than "._-A-Za-z0-9"
        pattern = r"[^a-zA-Z0-9-' _.:&=;,@/\\]"
        if re.search(pattern, test_str):
            myPrint("DB","Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","Valid: %r" %(test_str))
            return True

    def get_register_txn_sort_orders():

        # Flush in memory settings to disk
        MD_REF.savePreferences()

        theSortData = []                                                                                                # noqa

        theSortData.append("VIEW REGISTER TXN SORT ORDERS (for Accounts - excluding legacy keys)")
        theSortData.append(" ==================================================================\n")

        theSortData.append("DEFAULTS (from config.dict)\n")

        for x in GlobalVars.Strings.CONFIG_COLWIDTHS:

            if      x == "bank":        theType = "Bank"
            elif    x == "cc":          theType = "Credit Card"
            elif    x == "invest":      theType = "Investment"
            elif    x == "loan":        theType = "Loan"
            elif    x == "security":    theType = "Security"
            elif    x == "misc":        theType = "Asset/Liability/Expense/Income/Other"
            elif    x == "rec_credits": theType = "Reconciling window - credits"
            elif    x == "rec_debits":  theType = "Reconciling window - debits"
            elif    x == "secdetail":   theType = "Security Detail"
            elif    x == "split":       theType = "Split Window"
            else:                       theType = "????"

            result = loadMDPreferences(None,x)
            if result:
                oneLineMode = result[0]
                splitReg    = result[1]
                splitSz     = result[2]
                sortID      = result[3]
                position    = result[4]
                ascending   = result[5]
                widths      = result[6]
                position2   = result[7]

                theSortData.append("\nType: %s (%s) Register Sort Data:"%(theType,x))
                theSortData.append(">> Sort Order: %s" %sortID)
                theSortData.append(">> Ascending: %s" %ascending)
                theSortData.append(">> One Line View: %s" %oneLineMode)
                theSortData.append(">> Split Register View: %s (%s)" %(splitReg,splitSz))
                theSortData.append(">> Position: %s Widths: %s Position2 %s\n" %(position, widths, position2))


        theSortData.append("\nDATA SAVED INTERNALLY BY (ACTIVE) ACCOUNT")
        theSortData.append(" ----------------------------------------\n")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(1))
        for acct in accounts:

            for x in GlobalVars.Strings.CONFIG_COLWIDTHS:

                if      x == "bank":        theType = "Bank"
                elif    x == "cc":          theType = "Credit Card"
                elif    x == "invest":      theType = "Investment"
                elif    x == "loan":        theType = "Loan"
                elif    x == "security":    theType = "Security"
                elif    x == "misc":        theType = "Asset/Liability/Expense/Income/Other"
                elif    x == "rec_credits": theType = "Reconciling window - credits"
                elif    x == "rec_debits":  theType = "Reconciling window - debits"
                elif    x == "secdetail":   theType = "Security Detail"
                elif    x == "split":       theType = "Split Window"
                else:                       theType = "????"

                result = loadMDPreferences(acct,x, False)

                if result:
                    oneLineMode = result[0]
                    splitReg    = result[1]
                    splitSz     = result[2]
                    sortID      = result[3]
                    position    = result[4]
                    ascending   = result[5]
                    widths      = result[6]
                    position2   = result[7]

                    theSortData.append("\nAccount: %s Account Type: %s Key Type: %s (%s) Register Sort Data:"%(acct.getAccountName(), acct.getAccountType(),theType,x))
                    theSortData.append(">> Sort Order: %s" %sortID)
                    theSortData.append(">> Ascending: %s" %ascending)
                    theSortData.append(">> One Line View: %s" %oneLineMode)
                    theSortData.append(">> Split Register View: %s (%s)" %(splitReg,splitSz))
                    theSortData.append(">> Position: %s Widths: %s Position2 %s\n" %(position, widths, position2))

        theSortData.append("\n<END>")

        for i in range(0, len(theSortData)):
            theSortData[i] = theSortData[i] + "\n"
        theSortData = "".join(theSortData)

        QuickJFrame("Register TXN Sort Orders etc", theSortData, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def view_check_num_settings():
        try:
            from com.infinitekind.moneydance.model import CheckNumSettings
        except:
            txt = "Your version of MD is too early to use this function, must be at least Moneydance 2020.1 (1925)"
            setDisplayStatus(txt, "R")
            return

        theData = []                                                                                                    # noqa

        theData.append("CHECK NUMBER SETTINGS")
        theData.append(" =====================\n")

        acct = root = MD_REF.getCurrentAccountBook().getRootAccount()
        x = root.getCheckNumSettings(True)  # False means don't return defaults
        theData.append("\nMaster Dataset & defaults (root account): " + MD_REF.getCurrentAccountBook().getName())
        if not x:  # Assume old style check numbers
            theData.append(" >>Old style Check numbers as default: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
            theData.append("\n\n")
        else:
            theData.append(" >>Fixed Chq Items: %s" %(x.getPopupStrings()))
            theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
            y = x.getRecentsOption()

            # noinspection PyUnresolvedReferences
            if y == CheckNumSettings.IncludeRecentsOption.ACCOUNT: y = "Include from Same Account"
            elif y == CheckNumSettings.IncludeRecentsOption.GLOBAL: y = "Include from All Accounts"
            elif y == CheckNumSettings.IncludeRecentsOption.NONE: y = "Don't Include"

            theData.append(" >>Recent Entries:          %s" %(y))
            theData.append(" >>Max Entries:             %s" %(x.getMaximumRecents()))
            theData.append(" >>Show Next-Check Number:  %s" %(x.getIncludeNextCheckNumber()))
            theData.append(" >>Show Print-Check Option: %s" %(x.getIncludePrintCheckMarker()))
            theData.append("\n")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(3))

        for acct in accounts:

            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.ROOT: continue

            x = acct.getCheckNumSettings(False)  # False means don't return defaults

            if not x:
                theData.append("Account: " + acct.getFullAccountName() + " (Settings: NONE/Default)")
                theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
                theData.append("\n")
            else:
                theData.append("Account: " + pad(acct.getFullAccountName(), 80))
                theData.append(" >>Fixed Chq Items: %s" %(x.getPopupStrings()))
                if acct.getAccountType() != Account.AccountType.ROOT:                                               # noqa
                    theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))

                y = x.getRecentsOption()
                if y == CheckNumSettings.IncludeRecentsOption.ACCOUNT:                                              # noqa
                    y = "Include from Same Account"
                elif y == CheckNumSettings.IncludeRecentsOption.GLOBAL:                                             # noqa
                    y = "Include from All Accounts"
                elif y == CheckNumSettings.IncludeRecentsOption.NONE:                                               # noqa
                    y = "Don't Include"

                theData.append(" >>Recent Entries:          %s" %(y))
                theData.append(" >>Max Entries:             %s" %(x.getMaximumRecents()))
                theData.append(" >>Show Next-Check Number:  %s" %(x.getIncludeNextCheckNumber()))
                theData.append(" >>Show Print-Check Option: %s" %(x.getIncludePrintCheckMarker()))
                theData.append("\n")
                # CheckNumSettings.IncludeRecentsOption

        theData.append(("\n<END>"))

        # Build a quick virtual file of Memorized reports and graphs to display
        for i in range(0, len(theData)):
            theData[i] = theData[i] + "\n"
        theData = "".join(theData)
        QuickJFrame("View Check Number Settings:", theData, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def loadKeyFile():
        keyInfo = SyncRecord()
        try:
            keyFile = File(MD_REF.getCurrentAccountBook().getRootFolder(), "key")
            fin = FileInputStream(keyFile)
            keyInfo.readSet(fin)    # todo - ???
            fin.close()
        except: pass
        return keyInfo

    def isUserEncryptionPassphraseSet():
        keyInfo = loadKeyFile()
        return keyInfo.getBoolean("userpass", False)

    def isCachingPasswords():
        return (isUserEncryptionPassphraseSet() and MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage().getBoolean("store_passwords", False))

    def getMDEncryptionKey():
        try:
            keyInfo = loadKeyFile()

            # noinspection PyUnresolvedReferences
            cipherLevel = LocalStorageCipher.MDCipherLevel.GOOD

            keyString = keyInfo.getString(u"key", None)
            test_with_random = u"E6520436865636B2C2062616279206F6E65203220312074776F4D6963726F7068306E6520436865636B204D6963723070686F6"
            y = StringUtils.decodeHex(test_with_random[int(len(test_with_random)/2):]+test_with_random[:int(len(test_with_random)/2)])
            z = ""
            for x in y: z += chr(x)
            newPassphrase = z
            encryptedKeyBytes = StringUtils.decodeHex(keyString)
            if keyInfo.getBoolean(u"userpass", False):
                newPassphrase = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
                if not newPassphrase:
                    return u"Not sure: Error retrieving your Encryption key!"
            try:

                # This next line triggers a message in the console error log file: "loading with 128 bit encryption key"
                myPrint(u"J", u"Checking encryption key....")
                key = LocalStorageCipher.encryptionKeyFromBytesAndPassword(encryptedKeyBytes, list(newPassphrase), cipherLevel)
                # cipher = LocalStorageCipher(key, cipherLevel)
            except:
                return u"Not sure: could not validate your encryption!"

            theAlg = key.getAlgorithm()
            if theAlg != "AES": myPrint("B", "@@@ ALERT: Your dataset encryption reports algorithm '%s', not 'AES'.. (Please report to Toolbox developer)!" %(theAlg))

        except:
            return u"Not sure: Error in decryption routine - oh well!!"

        return u"%s" % (theAlg)

    def check_dropbox_and_suppress_warnings():

        dataFile = MD_REF.getCurrentAccountBook().getRootFolder()
        suppressFile = File(dataFile, "suppress_file_in_dropbox_restriction.txt")

        fileIsUnderDropbox = False
        suppressionFileExists = suppressFile.exists()
        parent = dataFile
        while parent is not None:
            if "dropbox" in parent.getName().lower():
                fileIsUnderDropbox = True
                break
            parent = parent.getParentFile()

        return fileIsUnderDropbox, suppressionFileExists

    def isMulti_OFXLastTxnUpdate_build(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_MULTI_OFX_TXN_DNLD_DATES_BUILD)     # 2022.3

    def OFX_view_all_last_txn_download_dates():
        accountsDL = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(21))
        accountsDL = sorted(accountsDL, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        outputDates = "\nBANK OFX: LAST DOWNLOADED TRANSACTION DATE(s)\n" \
                      " -------------------------------------------\n\n"

        if isMulti_OFXLastTxnUpdate_build():
            outputDates += "NOTE: Multiple OFXLastTxnUpdate dates (i.e. per OFX/MD+ connection) are possible with this build...\n\n"

        for acct in accountsDL:
            theOnlineTxnRecord = MyGetDownloadedTxns(acct)     # Use my version to prevent creation of default record(s)
            if theOnlineTxnRecord is None:
                humanReadableOFXLastTxnDate = "Never downloaded = 'Download all available dates'"
                outputDates += "%s %s %s\n" %(pad(repr(acct.getAccountType()),12),
                                              pad(acct.getFullAccountName(),40),
                                              humanReadableOFXLastTxnDate)
            else:
                #  Since build 4074, .getOFXLastTxnUpdate() can be multi connection... But prior is single (all with same key)
                for k in theOnlineTxnRecord.getParameterKeys():
                    if not k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE): continue
                    # theCurrentDate = theOnlineTxnRecord.getOFXLastTxnUpdate()
                    theCurrentDate = theOnlineTxnRecord.getLongParameter(k, 0)

                    if theCurrentDate != 0:
                        humanReadableOFXLastTxnDate = get_time_stamp_as_nice_text(theCurrentDate, lUseHHMMSS=False)
                    else:
                        if isMDPlusEnabledBuild():
                            humanReadableOFXLastTxnDate = "IS SET TO ZERO (MD will prompt for start date)"
                        else:
                            humanReadableOFXLastTxnDate = "IS SET TO ZERO = 'Download all available dates'"

                    outputDates += "%s %s %s %s\n" %(pad(repr(acct.getAccountType()),12),
                                                     pad(acct.getFullAccountName(),40),
                                                     humanReadableOFXLastTxnDate,
                                                     k[len(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):])

        outputDates += "\n<END>"
        QuickJFrame("OFX LAST DOWNLOAD DATES", outputDates,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False,lAutoSize=True).show_the_frame()

        txt = "OFX: All your last txn download txn dates have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    def OFX_view_reconcile_AsOf_Dates(ljustReturnEnabledAccounts=False):

        # Code copied from com.moneydance.apps.md.view.gui.PreReconcilerWindow

        _THIS_METHOD_NAME = "OFX - View accounts' calculated reconcile 'as_of' dates".upper()

        output = "\n%s\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, ("-"*len(_THIS_METHOD_NAME)))

        enabledAccounts = {}
        allActiveAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(0))

        count = 0

        if len(allActiveAccounts) < 1:
            output += "No active Bank/Credit card/Investment accounts found\n\n"

        else:

            wait = MyPopUpDialogBox(toolbox_frame_,theStatus="PLEASE WAIT - CALCULATING THE AS_OF DATES...", theTitle="PLEASE WAIT",lModal=False)
            wait.go()

            if isMulti_OFXLastTxnUpdate_build():
                output += "NOTE: Multiple OFXLastTxnUpdate dates (i.e. per OFX/MD+ connection) are possible with this build...\n\n"

            output += "Processing %s active accounts\n\n" %(len(allActiveAccounts))
            output += "Diagnosing the Reconcile: as_of date:\n\n"

            MD_decimal = MD_REF.getPreferences().getDecimalChar()

            for acct in allActiveAccounts:
                txns = acct.getDownloadedTxns()

                if acct.getPreference(GlobalVars.Strings.MD_KEY_ASOF_PREF, None) is None:
                    asOfPref = "<not set>"  # Deliberately find out if not set
                else:
                    asOfPref = acct.getPreferenceBoolean(GlobalVars.Strings.MD_KEY_ASOF_PREF, True)

                lastUpdate = txns.getOnlineLedgerBalanceDate()

                val_ledgerDate = txns.getOnlineLedgerBalanceDate()

                val_lastTxnUpdateDate = txns.getMostRecentTxnUpdate() if isMulti_OFXLastTxnUpdate_build() else txns.getOFXLastTxnUpdate()

                if lastUpdate == 0:
                    lastUpdate = txns.getMostRecentTxnUpdate() if isMulti_OFXLastTxnUpdate_build() else txns.getOFXLastTxnUpdate()

                OFXLastTxnUpdate_dates = []
                if isMulti_OFXLastTxnUpdate_build():
                    for k in txns.getParameterKeys():
                        if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                            value = txns.getLongParameter(k, 0)
                            OFXLastTxnUpdate_dates.append([k, "<not set>" if value == 0 else get_time_stamp_as_nice_text(value, lUseHHMMSS=False)])

                tset = acct.getBook().getTransactionSet()

                # This is the moneydance code
                if lastUpdate == 0:
                    txnDate = 0
                    for txn in tset.iterableTxns():
                        if not acct.isAncestorOf(txn.getAccount()): continue
                        if txn.getDateInt() <= txnDate or not TxnUtil.wasTxnDownloaded(txn): continue
                        txnDate = txn.getDateInt()
                    if txnDate != 0:
                        lastUpdate = Util.convertIntDateToLong(txnDate).getTime()

                # Do it again so we can show the last txn date too
                txnDate = 0
                txnLastUpdate = 0
                iCountTxns = 0
                for txn in tset.iterableTxns():
                    if not acct.isAncestorOf(txn.getAccount()): continue
                    if not TxnUtil.wasTxnDownloaded(txn): continue
                    iCountTxns += 1
                    if txn.getDateInt() > txnDate: txnDate = txn.getDateInt()
                if txnDate != 0:
                    txnLastUpdate = Util.convertIntDateToLong(txnDate).getTime()

                hasAsOfOption = lastUpdate != 0
                if not hasAsOfOption: continue

                asOfEnabled = True
                asOfDate = lastUpdate
                asOfEndBalance = txns.getOnlineLedgerBalance()
                count += 1

                enabledAccounts[acct] = asOfDate

                output += "Account: %s\n" %(acct.getFullAccountName())
                output += "   as_of enabled:           %s\n" %(safeStr(asOfEnabled))
                output += "   calculated 'as_of' date: %s\n" %(get_time_stamp_as_nice_text(asOfDate, lUseHHMMSS=False))
                output += "   as_of end balance:       %s\n" %(rpad("<not set>", 10) if asOfEndBalance == 0 else rpad(acct.getCurrencyType().formatFancy(asOfEndBalance,MD_decimal), 10))
                output += "         as_of Preference:                 %s\n" %(pad(asOfPref, 10))
                output += "         OFXLedgerDate:                    %s\n" %(pad("<not set>", 10) if val_ledgerDate == 0 else get_time_stamp_as_nice_text(val_ledgerDate, lUseHHMMSS=False))
                output += "         Most Recent Downloaded Txn Date:  %s (%s txns)\n" %(pad("<none fnd>", 10) if txnLastUpdate == 0 else get_time_stamp_as_nice_text(txnLastUpdate, lUseHHMMSS=False), iCountTxns)

                if isMulti_OFXLastTxnUpdate_build():
                    output += "         Most recent OFXLastTxnUpdateDate: %s\n" %(pad("<not set>", 10) if val_lastTxnUpdateDate == 0 else get_time_stamp_as_nice_text(val_lastTxnUpdateDate, lUseHHMMSS=False))
                else:
                    output += "         OFXLastTxnUpdateDate:             %s\n" %(pad("<not set>", 10) if val_lastTxnUpdateDate == 0 else get_time_stamp_as_nice_text(val_lastTxnUpdateDate, lUseHHMMSS=False))

                for k,v in OFXLastTxnUpdate_dates:
                    output += "         ... Multi keys found:             %s %s\n" %(v, k)

                output += "\n"

            wait.kill()

        if count < 1:
            output += "No enabled as_of dates were detected\n\n"
        else:
            output += "To zap the OFXLedgerDate, use Toolbox>Online Banking Tools Menu\n" \
                      "                          option 'Delete Single cached OnlineTxnList Record/Txns'\n" \
                      "                          and then the option 'delete whole record'\n\n" \
                      "To change OFXLastTxnDownloadDate, use Toolbox>Update OFX Last Txn Update Date (Downloaded) field for an account\n" \
                      "                          and edit the date (or if available Toolbox>Reset ALL OFX Last Txn Update Dates)\n\n" \
                      "If 'Most Recent Downloaded Txn Date' shown then not a lot can be done. You have previously downloaded txns\n\n"

        output += "\n<END>"

        if ljustReturnEnabledAccounts: return enabledAccounts

        QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
        txt = "OFX: Your active accounts' calculated reconcile as_of dates have been displayed...."
        setDisplayStatus(txt, "B")

    def OFX_view_CUSIP_settings():
        if MD_REF.getCurrentAccountBook() is None: return

        _THIS_METHOD_NAME = "OFX: View Security's hidden CUSIP settings"

        PARAM_CURRID = "curr_id."

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, " "*len(_THIS_METHOD_NAME))

        output += "The hidden link between your Financial Institution Investment Securities and your MD Securities when downloading\n" \
                  "is stored as a hidden setting against your security in a key known as the CUSIP. For USA Customers this is the USA\n" \
                  "standard called CUSIP and all Securities have a unique number. In other markets this might be called ISIN for example.\n" \
                  "When matching Securities on Download, this setting needs to be blank or match the CUSIP. Your OFX download will contain\n" \
                  "the tags '<UNIQUEIDTYPE>' (which normally contains 'CUSIP') and '<UNIQUEID>' (which contains the CUSIP number).\n" \
                  "If your MD Security already contains a different CUSIP number, then it will NOT appear in the match list.\n" \
                  "You can edit your hidden CUSIP data in Update Mode.\n\n"

        output += " SECURITIES\n" \
                  " ==========\n\n"

        output += "%s %s %s %s %s\n" % (pad("Security", 45),
                                        pad("ID", 15),
                                        pad("Ticker Symbol", 15),
                                        pad("SCHEME", 12),
                                        pad("IDENTIFIER (CUSIP)", 20))

        output += "%s %s %s %s %s\n" % ("-" * 45,
                                        "-" * 15,
                                        "-" * 15,
                                        "-" * 12,
                                        "-" * 20)

        output += "\n"

        securities = sorted(MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies(),
                            key=lambda x: (x.getCurrencyType(), x.getName().upper()))

        iCountFound = 0
        for sec in securities:
            if sec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                            # noqa
            for key in sec.getParameterKeys():

                if key.startswith(PARAM_CURRID):

                    theScheme = key[len(PARAM_CURRID):]
                    theCUSIP = sec.getIDForScheme(theScheme)

                    if not theCUSIP: raise Exception("ERROR: %s - empty CUSIP returned? Security: %s, Scheme: %s" %(_THIS_METHOD_NAME, sec, theScheme))

                    iCountFound += 1
                    output += "%s %s %s %s %s %s %s\n" % (pad(sec.getName(), 45),
                                                    pad(sec.getIDString(), 15),
                                                    pad(sec.getTickerSymbol(), 15),
                                                    pad(theScheme, 12),
                                                    theCUSIP,
                                                    ("** CUSIP & TICKER ARE DIFFERENT **" if (theCUSIP.strip() != sec.getTickerSymbol().strip()) else (""*34)),
                                                    ("id: "+sec.getUUID() if (debug) else ("")))

        if not iCountFound:
            output += "\nNONE FOUND!\n"
        else:
            output += "\n\n%s Security hidden CUSIP record(s) found\n" %(iCountFound)

        output += "\n<END>"

        QuickJFrame(_THIS_METHOD_NAME.upper(), output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False,lAutoSize=True).show_the_frame()

        txt = "OFX: Your Security's hidden CUSIP settings have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    def OFX_view_online_txns_payees_payments():

        _OBJOFXTXNS     =  0
        _OBJOFXOLPAYEES =  1
        _OBJOFXOLPAYMNT =  2

        objWhat = [
                    "OFX Online Transactions",                  # onlineTxnList             "oltxns"
                    "OFX Online Payees",                        # onlinePayeeList           "olpayees"
                    "OFX Online Payments"                       # onlinePaymentList         "olpmts"
            ]

        selectedAcct = None
        selectedObject = None
        textType = ""

        while True:

            selectedObjType = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the type of Online data you want to view",
                                                       "OFX View Online Data",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       objWhat,
                                                       None)
            if not selectedObjType:
                txt = "No online data type was selected to view .."
                setDisplayStatus(txt, "R")
                return

            if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(15))
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(16))
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(17))
            else: continue

            accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))
            selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Acct to view Online Data:",
                                                       "Select ACCOUNT",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       accountsListForOlTxns,
                                                       None)  # type: Account
            if not selectedAcct: continue

            textType = ""
            if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                selectedObject = MyGetDownloadedTxns(selectedAcct)           # Use my version to prevent creation of default record(s)
                textType = "Online Txns"
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                selectedObject = MyGetOnlinePayees(selectedAcct)             # Use my version to prevent creation of default record(s)
                textType = "Online Payees"
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                selectedObject = MyGetOnlinePayments(selectedAcct)           # Use my version to prevent creation of default record(s)
                textType = "Online Payments"
            else: continue

            break

        output = "VIEW SAVED ONLINE DATA: %s\n" \
                 " ===================================\n\n" %(textType.upper())

        output += "Object Type: %s\n\n" %(type(selectedObject))

        # noinspection PyUnresolvedReferences
        output += "Linked Account Type: %s Acct Name: %s\n" %(selectedAcct.getAccountType(), selectedAcct.getFullAccountName())

        if isinstance(selectedObject, OnlineTxnList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlineTxnList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getTxnCount():",50),                        selectedObject.getTxnCount()  )
            output += "%s %s\n" % (pad("hasOnlineAvailBalance():",50),              selectedObject.hasOnlineAvailBalance()  )
            output += "%s %s\n" % (pad("getOnlineAvailBalance():",50),              selectedObject.getOnlineAvailBalance()  )
            output += "%s %s (%s)\n" % (pad("getOnlineAvailBalanceDate():",50),     selectedObject.getOnlineAvailBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineAvailBalanceDate()))  )
            output += "%s %s\n" % (pad("hasOnlineLedgerBalance():",50),             selectedObject.hasOnlineLedgerBalance()  )
            output += "%s %s\n" % (pad("getOnlineLedgerBalance():",50),             selectedObject.getOnlineLedgerBalance()  )
            output += "%s %s (%s)\n" % (pad("getOnlineLedgerBalanceDate():",50),    selectedObject.getOnlineLedgerBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineLedgerBalanceDate()))  )

            if isMulti_OFXLastTxnUpdate_build():
                output += "%s %s (%s)\n" % (pad("getMostRecentTxnUpdate():",50),
                                            selectedObject.getMostRecentTxnUpdate(),
                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getMostRecentTxnUpdate()))  )
                for k in selectedObject.getParameterKeys():
                    if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                        value = selectedObject.getLongParameter(k, 0)
                        output += "... Key: %s %s (%s)\n" %(pad(k,75), value, convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(value)))
            else:
                output += "%s %s (%s)\n" % (pad("getOFXLastTxnUpdate():",50),
                                            selectedObject.getOFXLastTxnUpdate(),
                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOFXLastTxnUpdate()))  )

        if isinstance(selectedObject, OnlinePayeeList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlinePayeeList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getPayeeCount():",50),             selectedObject.getPayeeCount()  )

        if isinstance(selectedObject, OnlinePaymentList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlinePaymentList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getPaymentCount():",50),           selectedObject.getPaymentCount()  )

        output+="\n"

        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
            if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

        keys = sorted(selectedObject.getParameterKeys())
        for theKey in keys:
            # noinspection PyUnresolvedReferences
            value = selectedObject.getParameter(theKey)
            output += pad("Key:%s" %theKey,50)+" Value: '%s'\n" %(value.strip())

        output+="\n\n<END>"

        QuickJFrame("VIEW SAVED ONLINE DATA",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        txt = "OFX: Your Online saved Txns, Payees, Payments have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    # replicates com.moneydance.apps.md.view.gui.MDAccountProxy.getAccountKey()
    def my_get_account_key(acct):
        acctNum = acct.getAccountNum()
        if acctNum <= 0:
            return acct.getUUID()
        return str(acctNum)

    def redactor(_what, lRedactFirstChar=False):
        # type: (str, bool) -> str
        if not GlobalVars.redact: return _what
        if not isinstance(_what, (str, unicode)): _what = safeStr((_what))
        #_what = _what.strip()
        if lRedactFirstChar:
            keepFirstChar = False
        else:
            keepFirstChar = (len(_what) > 1)
        return (_what[:1] if keepFirstChar else "") + ("*" * (len(_what) - (1 if keepFirstChar else 0)))

    def redactAuth(originalAuthToRedact):
        if GlobalVars.redact:
            saveAuthKey = MyOFXAuthInfo.fromCacheString(originalAuthToRedact)
            redactedAuthKey = MyOFXAuthInfo(redactor(saveAuthKey.getUserId()), redactor(saveAuthKey.getPasswd()), saveAuthKey.getExtraAuth(), None, saveAuthKey.getAuthType())
            originalAuthToRedact = redactedAuthKey.toCacheString()
        return originalAuthToRedact

    def online_banking_view_configuration_data():

        _THIS_METHOD_NAME = "View online banking configuration data"

        OFX = []

        lCachePasswords = isCachingPasswords()

        GlobalVars.redact = myPopupAskQuestion(toolbox_frame_, _THIS_METHOD_NAME, "Redact confidential information?")

        _msg = pad("Please wait:", 50, padChar=".")
        pleaseWait = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False)
        pleaseWait.go()

        OFX.append("VIEW YOUR ONLINE BANKING CONFIGURATION/CONNECTION DATA\n"
                   " =====================================================\n\n")

        if GlobalVars.redact:
            OFX.append("** Confidential data will be redacted **\n")
        else:
            OFX.append("** WARNING: Confidential data will be visible **\n")

        if lCachePasswords:
            OFX.append("MD Will allow you to Cache your Authentication (means you have set an encryption key and selected store passwords..")
        else:
            OFX.append("MD Cache Authentication ** DISABLED ** (either no user encryption key or store passwords = no)")

        OFX.append("")

        if not isMDPlusEnabledBuild() and getPlaidService():
            OFX.append("NOTE: Account linkages for MD+/Plaid Services may be incomplete as you are running an older version of Moneydance...!\n")

        # Build a list of Moneydance accounts that are enabled for download and have a service profile linked....
        listAccountMDProxies = []
        olAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(11))
        if len(olAccounts) > 0:
            for acctObj in olAccounts:
                acct = acctObj                                 # type: Account
                svcBank = acct.getBankingFI()                  # type: OnlineService
                svcBP = acct.getBillPayFI()                    # type: OnlineService
                if acct.getBankingFI() is not None:
                    listAccountMDProxies.append([MDAccountProxy(acct, False),svcBank,False])
                if acct.getBillPayFI() is not None:
                    listAccountMDProxies.append([MDAccountProxy(acct, True),svcBP,True])

        OFX.append("MD Accounts enabled for OFX Downloads with linked Service / Bank logon profiles:")
        if len(listAccountMDProxies)<1:
            OFX.append("<NONE FOUND>")
        else:
            for olAcct in listAccountMDProxies:
                if not olAcct[2]:
                    OFX.append("- {:40} ('Key': {:15}) OFXAccNum: {:15} Bank Profile: {}".format(olAcct[0].getAccount().getFullAccountName(), olAcct[0].getAccountKey(), redactor(olAcct[0].getOFXAccountNumber()), olAcct[1]))
                else:
                    OFX.append("- {:40} ('Key': {:15}) OFXAccNum: {:15} BillPay Prof: {}".format(olAcct[0].getAccount().getFullAccountName(), olAcct[0].getAccountKey(), redactor(olAcct[0].getOFXAccountNumber()), olAcct[1]))
        OFX.append("")

        if isMDPlusEnabledBuild() and isMDPlusUniqueBankingServicesEnabledBuild():
            OFX.append("MD Accounts >> listing enabled banking services per account:")
            if len(olAccounts) < 1:
                OFX.append("<NONE FOUND>")
            else:
                for acctObj in olAccounts:
                    gbs = acctObj.getBankingServices()
                    if gbs.size() < 1: continue
                    for bs in gbs:
                        OFX.append("- Account: {:40} Banking Service (out of {}) {:40}".format(acctObj.getFullAccountName(), gbs.size(), bs.getService()))
        OFX.append("")

        if not GlobalVars.redact:
            # This will not disconnect anything, just reproduce the md+ connection information...
            OFX.append(forceDisconnectMDPlusConnection(lReturnConnectionInfoOnly=True))


        for service in MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices():

            # Find the MD accounts specifically linked to this service profile
            thisServiceMDAccountProxies = []
            for olacct in listAccountMDProxies:
                if olacct[1] == service:
                    thisServiceMDAccountProxies.append(olacct)

            OFX.append(" ================================================================================================================================================")
            OFX.append(" ================================================================================================================================================")
            OFX.append(pad("Service/Profile:".upper(),40)       + safeStr(service))
            OFX.append(pad(" ---------------",40))
            OFX.append(pad(">>Moneydance TIK Service ID:",40)   + safeStr(service.getTIKServiceID()))
            OFX.append(pad(">>Profile's UUID:",40)              + safeStr(service.getUUID()))
            if isMDPlusEnabledBuild():
                OFX.append(pad(">>Protocol:",40)                + safeStr(service.getProtocol()))
                OFX.append(pad(">>isMoneydancePlusService:",40) + safeStr(service.isMoneydancePlusService()))
            OFX.append(pad(">>OFX Version:",40)                 + safeStr(service.getOFXVersion()))
            OFX.append(pad(">>Service Id:",40)                  + safeStr(service.getServiceId()))
            OFX.append(pad(">>Service Type:",40)                + safeStr(service.getServiceType()))
            OFX.append(pad(">>Realms:",40)                      + safeStr(service.getRealms()))
            OFX.append(pad(">>Bootstrap URL:",40)               + safeStr(service.getBootstrapURL()))

            OFX.append(pad(">>Needs FI Profile Check()?:",40)   + safeStr(service.needsFIProfileCheck()))

            mappingObject = None                                                                                        # noqa
            if isMDPlusEnabledBuild():
                OFX.append(pad("\n>>MD2022+ Online Banking Mapping table entries...:", 120))
                mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")
                if mappingObject is not None:
                    OFX.append(special_toMultilineHumanReadableString(mappingObject,lSkipSecrets=GlobalVars.redact,sFilterServiceID=service.getTIKServiceID(),lRedact=GlobalVars.redact))
                else: OFX.append("<NONE>")
            del mappingObject

            if service.getTIKServiceID() == "md:plaid":
                tokens = MD_REF.getCurrentAccountBook().getLocalStorage().getSublist("access_tokens")
                OFX.append(pad("\n>>Moneydance+ Access Tokens (local storage 'access_tokens')...:",120))
                if len(tokens) > 0:
                    for token in tokens:
                        for token_key in token:
                            txtAppendTxt = "(Confidential: '_payloadid', 'timestamp', 'token' values have been hidden for security reasons)"
                            if token_key != "item": continue
                            OFX.append("Key: %s AccountRef: %s %s" %(token_key, token.get(token_key), txtAppendTxt if GlobalVars.redact else token))
                else:
                    OFX.append("<NONE>")
                del tokens

                mdp_cache = MD_REF.getCurrentAccountBook().getLocalStorage().getSubset("mdp_items")
                OFX.append(pad("\n>>Moneydance+ Plaid Cache (local storage 'mdp_items')...:", 120))
                if len(mdp_cache) > 0:
                    for cacheItem in mdp_cache:
                        OFX.append("Key: %s Value: %s" %(cacheItem, mdp_cache.get(cacheItem)))
                else:
                    OFX.append("<NONE>")
                del mdp_cache

            OFX.append(pad("\n>>Accounts configured within bank profile:",120))
            if len(service.getAvailableAccounts()) < 1:
                OFX.append("<NONE FOUND>")
            else:
                _availableAccounts = service.getAvailableAccounts()
                if GlobalVars.redact:
                    _redactedAvailableAccounts = "["
                    onAccount = 0
                    for _aa in _availableAccounts:
                        if onAccount > 0: _redactedAvailableAccounts += ", "
                        _redactedAvailableAccounts += (_aa.getDescription() + " " + redactor(_aa.getAccountNumber().strip()))
                        onAccount += 1
                    _redactedAvailableAccounts += "]"
                    OFX.append(" -- List All accounts configured in profile: %s\n" %(_redactedAvailableAccounts))
                else:
                    OFX.append(" -- List All accounts configured in profile: %s\n" %(service.getAvailableAccounts()))

                for availAccount in service.getAvailableAccounts():
                    OFX.append(">> ACCOUNT: %s (%s) ('Key': %s)" %(availAccount.getDescription(), redactor(availAccount.getAccountNumber()), availAccount.getAccountKey()))

                    if service.getTIKServiceID() != "md:plaid":         # Don't bother with MD+ as these are all empty anyway...
                        try:
                            # Rather than listing all methods by hand, just iterate and call them all.. I have checked they are all safe...
                            meths = availAccount.getClass().getDeclaredMethods()
                            for meth in meths:
                                if not Modifier.isPublic(meth.getModifiers()): continue
                                if meth.getName().lower().startswith("get") or meth.getName().lower().startswith("is") \
                                        and meth.getParameterCount() < 1:
                                    result = meth.invoke(availAccount)
                                    if GlobalVars.redact:
                                        for checkKey in ["mapping", "balance", "number", "key"]:
                                            if checkKey in meth.getName().lower():
                                                result = redactor(result)
                                                break
                                    if result is not None:
                                        OFX.append(" >> %s %s" %(pad(meth.getName(), 40), result) )
                            OFX.append("\n")
                        except: pass

            OFX.append("")

            OFX.append(pad("\n>>MD Accounts linked to this service / bank profile:", 120))
            if len(thisServiceMDAccountProxies)<1:
                OFX.append("<NONE FOUND>")
            else:
                for olacct in thisServiceMDAccountProxies:
                    if not olacct[2]:
                        OFX.append(" >> Banking: %s ('Key': %s) (OfxAcctNum: %s)" %(olacct[0].getAccount().getFullAccountName(), olacct[0].getAccountKey(), redactor(olacct[0].getOFXAccountNumber())))
                    else:
                        OFX.append(" >> BillPay: %s ('Key': %s) (OfxAcctNum: %s)" %(olacct[0].getAccount().getFullAccountName(), olacct[0].getAccountKey(), redactor(olacct[0].getOFXAccountNumber())))

            OFX.append("")

            if service.getTIKServiceID() != "md:plaid":         # Don't bother with MD+ as these are all empty anyway...
                try:
                    authenticationCachePrefix = invokeMethodByReflection(service, "getAuthenticationCachePrefix", None)
                    OFX.append(pad("AuthenticationCachePrefix:",33) + (safeStr(authenticationCachePrefix)))

                    sessionCookiePrefix = invokeMethodByReflection(service, "getSessionCookiePrefix", None)
                    OFX.append(pad("SessionCookiePrefix:",33) + (safeStr(sessionCookiePrefix)))
                except:
                    myPrint("B", "ERROR: getting getAuthenticationCachePrefix() or getSessionCookiePrefix()... (continuing)")
                    dump_sys_error_to_md_console_and_errorlog()

                OFX.append(pad("\n>>ROOT Data associated with service profile:", 120))
                authKeyPrefix = "ofx.client_uid"
                root = MD_REF.getRootAccount()
                iCount = 0
                for rk in list(root.getParameterKeys()):
                    if rk.startswith(authKeyPrefix) and (service.getTIKServiceID() in rk):
                        rk_redact = rk
                        val_redact = root.getParameter(rk)
                        if GlobalVars.redact:
                            redactSearch = authKeyPrefix+"::"+service.getTIKServiceID() + "::"
                            if rk.startswith("ofx.client_uid_default_user::"):
                                val_redact = redactor(val_redact)
                            elif rk.startswith(redactSearch):
                                rk_redact = rk[:len(redactSearch)] + redactor(rk[len(redactSearch):])
                        OFX.append("Root key: '%s' value: '%s'" %(rk_redact, val_redact))
                        iCount += 1
                if not iCount: OFX.append("<NONE>")
                del root, iCount, authKeyPrefix

                OFX.append(pad("\n>>REALMs configured:", 120))
                realmsToCheck = service.getRealms()
                if "DEFAULT" not in realmsToCheck:
                    realmsToCheck.insert(0, "DEFAULT")

                for realm in realmsToCheck:

                    realmUserID = service.getUserId(realm, None)
                    if realmUserID is not None and realmUserID != "":
                        OFX.append("Realm: %s User ID: %s" %(realm, redactor(service.getUserId(realm, None))))

                    for olacct in thisServiceMDAccountProxies:

                        userID = service.getUserId(realm, olacct[0])
                        if userID is not None and userID != "":
                            OFX.append("Realm: %s Account's UserID: %s" %(realm, redactor(userID)))

                        if not lCachePasswords:
                            OFX.append("** NOTE: Any Cached Authentication Keys listed below will not be saved when you exit **")

                        authKey = "ofx:" + realm
                        authObj = service.getCachedAuthentication(authKey)
                        if authObj is not None and authObj != "":
                            OFX.append("Realm: %s Cached Authentication: %s" %(realm, redactAuth(authObj)))

                        authKey = "ofx:" + (realm + "::" + olacct[0].getAccountKey())
                        authObj = service.getCachedAuthentication(authKey)
                        if authObj is not None and authObj != "":
                            OFX.append("Realm: %s Account Key: %s (Key: %s / AccNum: %s) Cached Authentication: %s" %(realm, olacct[0].getAccountKey(), olacct[0].getOFXAccountKey(), redactor(olacct[0].getOFXAccountNumber()), redactAuth(authObj)))

                        if service.getSessionCookie(userID) is not None:
                            OFX.append("Session Cookie: %s" %(service.getSessionCookie(userID)))

                OFX.append("getFIId()                        %s" %(service.getFIId()                             ))
                if service.getUpdatedFIId() != service.getFIId():
                    OFX.append("getUpdatedFIId()             %s" %(service.getUpdatedFIId()                      ))
                OFX.append("getFIName()                      %s" %(service.getFIName()                           ))
                OFX.append("getFIOrg()                       %s" %(service.getFIOrg()                            ))
                if service.getUpdatedFIOrg() != service.getUpdatedFIOrg():
                    OFX.append("getUpdatedFIOrg()            %s" %(service.getUpdatedFIOrg()                     ))
                OFX.append("usesFITag()                      %s" %(service.usesFITag()                           ))
                OFX.append("usesPTTAcctIDField()             %s" %(service.usesPTTAcctIDField()                  ))
                OFX.append("getFIUrl()                       %s" %(service.getFIUrl()                            ))
                OFX.append("getFIUrlIsRedirect()             %s" %(service.getFIUrlIsRedirect()                  ))

                OFX.append("getIgnoreTxnsBeforeLastUpdate()  %s" %(service.getIgnoreTxnsBeforeLastUpdate()       ))

                OFX.append("getTxnDownloadOverlap()          %s" %(service.getTxnDownloadOverlap()               ))
                OFX.append("getDateAvailAcctsUpdated()       %s" %(service.getDateAvailAcctsUpdated()            ))
                OFX.append("getAlwaysSendDateRange()         %s" %(service.getAlwaysSendDateRange()              ))


                OFX.append("getUseProfileRequest()           %s" %(service.getUseProfileRequest()                ))
                OFX.append("getUseClientSpecificUIDS()       %s" %(service.getUseClientSpecificUIDS()            ))
                OFX.append("getUseFileUIDs()                 %s" %(service.getUseFileUIDs()                      ))
                OFX.append("getUseBPFileUIDs()               %s" %(service.getUseBPFileUIDs()                    ))
                OFX.append("useTerribleTLSV1Hack()           %s" %(service.useTerribleTLSV1Hack()                ))
                OFX.append("getFIEmail()                     %s" %(service.getFIEmail()                          ))
                OFX.append("getTechServicePhone()            %s" %(service.getTechServicePhone()                 ))

                OFX.append("getInvstBrokerID()               %s" %(service.getInvstBrokerID()                    ))

                OFX.append("usesBillPayExtendedAcctTo()      %s" %(service.usesBillPayExtendedAcctTo()           ))

                OFX.append("getServiceType()                 %s" %(service.getServiceType()                      ))

                OFX.append("getUseShortDates()               %s" %(service.getUseShortDates()                    ))
                OFX.append("shouldDecrementLastTxnDate()     %s" %(service.shouldDecrementLastTxnDate()          ))

                OFX.append("getSignupAcctsAvail()            %s" %(service.getSignupAcctsAvail()                 ))
                OFX.append("getSignupCanActivateAcct()       %s" %(service.getSignupCanActivateAcct()            ))
                OFX.append("getSignupCanChgUserInfo()        %s" %(service.getSignupCanChgUserInfo()             ))
                OFX.append("getSignupCanPreauth()            %s" %(service.getSignupCanPreauth()                 ))
                OFX.append("getSignupClientAcctNumReq()      %s" %(service.getSignupClientAcctNumReq()           ))
                OFX.append("getSignupViaClient()             %s" %(service.getSignupViaClient()                  ))
                OFX.append("getSignupViaOther()              %s" %(service.getSignupViaOther()                   ))
                OFX.append("getSignupViaOtherMsg()           %s" %(service.getSignupViaOtherMsg()                ))
                OFX.append("getSignupViaWeb()                %s" %(service.getSignupViaWeb()                     ))
                OFX.append("getSignupViaWebUrl()             %s" %(service.getSignupViaWebUrl()                  ))
                OFX.append("getStopChkCanUseDescription()    %s" %(service.getStopChkCanUseDescription()         ))
                OFX.append("getStopChkCanUseRange()          %s" %(service.getStopChkCanUseRange()               ))
                OFX.append("getStopChkFee()                  %s" %(service.getStopChkFee()                       ))
                OFX.append("getStopChkProcessingDaysOff()    %s" %(service.getStopChkProcessingDaysOff()         ))
                OFX.append("getStopChkProcessingEndTime()    %s" %(service.getStopChkProcessingEndTime()         ))

                for x in service.getRealms():
                    OFX.append("getClientIDRequired(x)           %s" %(service.getClientIDRequired(x)             ))
                    OFX.append("getUserCanChangePIN(x)           %s" %(service.getUserCanChangePIN(x)             ))
                    OFX.append("getMaxPasswdLength(x)            %s" %(service.getMaxPasswdLength(x)              ))
                    OFX.append("getMinPasswdLength(x)            %s" %(service.getMinPasswdLength(x)              ))
                    OFX.append("getMustChngPINFirst(x)           %s" %(service.getMustChngPINFirst(x)             ))
                    OFX.append("getPasswdCanHaveSpaces(x)        %s" %(service.getPasswdCanHaveSpaces(x)          ))
                    OFX.append("getPasswdCanHaveSpecialChars(x)  %s" %(service.getPasswdCanHaveSpecialChars(x)    ))
                    OFX.append("getPasswdCaseSensitive(x)        %s" %(service.getPasswdCaseSensitive(x)          ))
                    OFX.append("getPasswdCharType(x)             %s" %(service.getPasswdCharType(x)               ))
                    OFX.append("getPasswdType(x)                 %s" %(service.getPasswdType(x)                   ))

                OFX.append("getDateUpdated()                 %s (%s)" %(service.getDateUpdated(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(service.getDateUpdated()))))
                OFX.append("getLastTransactionID()           %s" %(service.getLastTransactionID()                  ))
                OFX.append("getMaxFITIDLength()              %s" %(service.getMaxFITIDLength()                     ))
                OFX.append("getInvalidAcctTypes()            %s" %(service.getInvalidAcctTypes()                   ))

                for msgType in (0,1,3,4,5,6,7,8,9,10,11,12):
                    if service.supportsMsgSet(msgType) or msgType == 0:
                        tag = invokeMethodByReflection(service, "getMsgSetTag", [Integer.TYPE], [msgType])
                        OFX.append("---")
                        OFX.append("  Supports Message Tag:            %s" %(tag))
                        OFX.append("  getMsgSetLanguage(msgType)       %s" %(service.getMsgSetLanguage(msgType)             ))
                        OFX.append("  getMsgSetRspnsFileErrors(msgType)%s" %(service.getMsgSetRspnsFileErrors(msgType)      ))
                        OFX.append("  getMsgSetSecurity(msgType)       %s" %(service.getMsgSetSecurity(msgType)             ))
                        OFX.append("  getMsgSetSignonRealm(msgType)    %s" %(service.getMsgSetSignonRealm(msgType)          ))
                        OFX.append("  getMsgSetSyncMode(msgType)       %s" %(service.getMsgSetSyncMode(msgType)             ))
                        OFX.append("  getMsgSetTransportSecure(msgType)%s" %(service.getMsgSetTransportSecure(msgType)      ))
                        OFX.append("  getMsgSetURL(msgType)            %s" %(service.getMsgSetURL(msgType)                  ))
                        OFX.append("  getMsgSetVersion(msgType)        %s" %(service.getMsgSetVersion(msgType)              ))

                OFX.append("---")

                OFX.append("getCreditCardClosingAvail()      %s" %(service.getCreditCardClosingAvail()           ))
                OFX.append("getCustServicePhone()            %s" %(service.getCustServicePhone()                 ))
                OFX.append("getBankClosingAvail()            %s" %(service.getBankClosingAvail()                 ))
                OFX.append("getBankXfrCanModifyModels()      %s" %(service.getBankXfrCanModifyModels()           ))
                OFX.append("getBankXfrCanModifyTransfers()   %s" %(service.getBankXfrCanModifyTransfers()        ))
                OFX.append("getBankXfrCanScheduleRecurring() %s" %(service.getBankXfrCanScheduleRecurring()      ))
                OFX.append("getBankXfrCanScheduleTransfers() %s" %(service.getBankXfrCanScheduleTransfers()      ))
                OFX.append("getBankXfrDaysWithdrawn()        %s" %(service.getBankXfrDaysWithdrawn()             ))
                OFX.append("getBankXfrDefaultDaysToPay()     %s" %(service.getBankXfrDefaultDaysToPay()          ))
                OFX.append("getBankXfrModelWindow()          %s" %(service.getBankXfrModelWindow()               ))
                OFX.append("getBankXfrNeedsTAN()             %s" %(service.getBankXfrNeedsTAN()                  ))
                OFX.append("getBankXfrProcessingDaysOff()    %s" %(service.getBankXfrProcessingDaysOff()         ))
                OFX.append("getBankXfrProcessingEndTime()    %s" %(service.getBankXfrProcessingEndTime()         ))
                OFX.append("getBankXfrSupportsDTAvail()      %s" %(service.getBankXfrSupportsDTAvail()           ))
                OFX.append("getBillPayCanAddPayee()          %s" %(service.getBillPayCanAddPayee()               ))
                OFX.append("getBillPayCanModPayments()       %s" %(service.getBillPayCanModPayments()            ))
                OFX.append("getBillPayDaysWithdrawn()        %s" %(service.getBillPayDaysWithdrawn()             ))
                OFX.append("getBillPayDefaultDaysToPay()     %s" %(service.getBillPayDefaultDaysToPay()          ))
                OFX.append("getBillPayHasExtendedPmt()       %s" %(service.getBillPayHasExtendedPmt()            ))
                OFX.append("getBillPayNeedsTANPayee()        %s" %(service.getBillPayNeedsTANPayee()             ))
                OFX.append("getBillPayNeedsTANPayment()      %s" %(service.getBillPayNeedsTANPayment()           ))
                OFX.append("getBillPayPostProcessingWindow() %s" %(service.getBillPayPostProcessingWindow()      ))
                OFX.append("getBillPayProcessingDaysOff()    %s" %(service.getBillPayProcessingDaysOff()         ))
                OFX.append("getBillPayProcessingEndTime()    %s" %(service.getBillPayProcessingEndTime()         ))
                OFX.append("getBillPaySupportsDifftFirstPmt()%s" %(service.getBillPaySupportsDifftFirstPmt()     ))
                OFX.append("getBillPaySupportsDifftLastPmt() %s" %(service.getBillPaySupportsDifftLastPmt()      ))
                OFX.append("getBillPaySupportsDtAvail()      %s" %(service.getBillPaySupportsDtAvail()           ))
                OFX.append("getBillPaySupportsPmtByAddr()    %s" %(service.getBillPaySupportsPmtByAddr()         ))
                OFX.append("getBillPaySupportsPmtByPayeeId() %s" %(service.getBillPaySupportsPmtByPayeeId()      ))
                OFX.append("getBillPaySupportsPmtByXfr()     %s" %(service.getBillPaySupportsPmtByXfr()          ))
                OFX.append("getBillPaySupportsStatusModRs()  %s" %(service.getBillPaySupportsStatusModRs()       ))
                OFX.append("getBillPayXfrDaysWith()          %s" %(service.getBillPayXfrDaysWith()               ))
                OFX.append("getBillPayXfrDefaultDaysToPay()  %s" %(service.getBillPayXfrDefaultDaysToPay()       ))
                OFX.append("getEmailSupportsGeneric()        %s" %(service.getEmailSupportsGeneric()             ))
                OFX.append("getEmailSupportsGetMime()        %s" %(service.getEmailSupportsGetMime()             ))
                OFX.append("getInvstCanDownloadBalances()    %s" %(service.getInvstCanDownloadBalances()         ))
                OFX.append("getInvstCanDownloadOOs()         %s" %(service.getInvstCanDownloadOOs()              ))
                OFX.append("getInvstCanDownloadPositions()   %s" %(service.getInvstCanDownloadPositions()        ))
                OFX.append("getInvstCanDownloadTxns()        %s" %(service.getInvstCanDownloadTxns()             ))
                OFX.append("getInvstCanEmail()               %s" %(service.getInvstCanEmail()                    ))
                OFX.append("getSecListCanDownloadSecurities()%s" %(service.getSecListCanDownloadSecurities()     ))

            OFX.append("")

            sortKeys = sorted(service.getParameterKeys())
            OFX.append(pad("Raw Parameter keys:",40))
            for x in sortKeys:
                val = service.getParameter(x,None)
                for checkKey in ["balance", "account_num", "branch_id", "routing_num", "so_user_id"]:
                    if checkKey in x:
                        val = redactor(val, ("balance" in x))
                        break
                OFX.append("%s %s" %(pad(x, 40), val))

            OFX.append("\n------------------------------------------------------------------\n\n")

        OFX.append("\n<END>")
        for i in range(0, len(OFX)):
            OFX[i] = OFX[i] + "\n"
        OFX = "".join(OFX)

        pleaseWait.kill()

        QuickJFrame(_THIS_METHOD_NAME, OFX, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        txt = "Your online banking configuration / connection data has been displayed...."
        setDisplayStatus(txt, "B")

    def load_help_file():
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        if u"__file__" not in globals():
            myPrint("DB", " __file__ not found in globals()")
            return None

        helpfile = os.path.splitext(__file__)[0] + "_readme.txt"
        if not os.path.exists(helpfile):
            myPrint("DB", " file: %s not found.." %(helpfile))
            return None

        try:
            fis = FileInputStream(File(helpfile))
        except:
            myPrint("DB", " Error opening file: %s .." %(helpfile))
            dump_sys_error_to_md_console_and_errorlog()
            return None

        return fis

    class DisplayHelp(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):                                                                               # noqa
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

            def getHelpData():
                localHelpFileStream = None                                                                              # noqa
                stream = None                                                                                           # noqa

                if MD_EXTENSION_LOADER is None:
                    localHelpFileStream = load_help_file()
                    if localHelpFileStream is None:
                        if debug:
                            return "moneydance_extension_loader is None:\nInternal mxt and also local Help file not found (please run as extension)\n(note: feature only enabled from Moneydance build 3051 onwards)"
                        else:
                            return "Internal mxt and also local Help file not found (please run as extension)\n(note: feature only enabled from Moneydance build 3051 onwards)"

                if MD_EXTENSION_LOADER is not None:
                    stream = MD_EXTENSION_LOADER.getResourceAsStream("/%s_readme.txt" %(myModuleID))
                    if stream is None:
                        localHelpFileStream = load_help_file()
                        if localHelpFileStream is None:
                            if debug:
                                return "getResourceAsStream() returned None:\nInternal mxt and also local Help file not found (please run as extension)"
                            else:
                                return "Internal mxt and also local Help file not found (please run as extension)"

                if stream is not None:
                    myPrint("DB",".. loading help file from mxt internal stream")
                    return load_text_from_stream_file(stream)

                elif localHelpFileStream is not None:
                    myPrint("DB",".. loading help file from local file stored with the .py file")
                    return load_text_from_stream_file(localHelpFileStream)

                else:
                    if debug:
                        return "all streams are None:\nInternal mxt and also local Help file not found (please run as extension)"
                    else:
                        return "Internal mxt and also local Help file not found (please run as extension)"

            output = getHelpData()
            QuickJFrame("HELP DOCUMENTATION", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    # noinspection PyArgumentList
    class MyTxnSearchFilter(TxnSearch):

        def __init__(self,dateStart,dateEnd):
            super(TxnSearch, self).__init__()

            self.dateStart = dateStart
            self.dateEnd = dateEnd

        def matchesAll(self):                                                                                           # noqa
            return False

        def matches(self, txn):

            if txn.getDateInt() >= self.dateStart and txn.getDateInt() <= self.dateEnd:                                 # noqa
                return True
            return False

    class MyAcctFilter(AcctFilter):
        selectType = 0

        def __init__(self, selectType=0):
            self.selectType = selectType

        def matches(self, acct):
            if self.selectType == 0:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

            if self.selectType == 10:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

                if acct.getParameter("ofx_import_acct_num", None) is not None \
                        or acct.getParameter("ofx_import_remember_acct_num", None) is not None:
                    return True
                return False

            if self.selectType == 1:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.ROOT
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

            if self.selectType == 2:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.SECURITY: return True
                else: return False

            if self.selectType == 3:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.ROOT):
                    return False

            if self.selectType == 4:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.EXPENSE
                        or acct.getAccountType() == Account.AccountType.INCOME):
                    return False
                return True

            if self.selectType == 5:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            if self.selectType == 6:
                # if not (acct.getAccountType() == Account.AccountType.BANK
                #         or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                #         or acct.getAccountType() == Account.AccountType.LOAN
                #         or acct.getAccountType() == Account.AccountType.ASSET
                #         or acct.getAccountType() == Account.AccountType.ROOT
                #         or acct.getAccountType() == Account.AccountType.LIABILITY
                #         or acct.getAccountType() == Account.AccountType.INVESTMENT):
                #     return False
                return True

            if self.selectType == 7:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            if self.selectType == 8:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.EXPENSE
                        or acct.getAccountType() == Account.AccountType.INCOME):
                    return False
                return True

            if self.selectType == 9:
                # noinspection PyUnresolvedReferences
                if not acct.getAccountType() == Account.AccountType.SECURITY:
                    return False
                return True

            if self.selectType == 11:
                if acct.canDownloadTxns() and not acct.getAccountIsInactive():
                    return True
                else:
                    return False

            if self.selectType == 12:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.ROOT:
                    return True
                else:
                    return False

            if self.selectType == 13:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() != Account.AccountType.SECURITY: return False
                if not acct.getUsesAverageCost(): return False
                else: return True

            if self.selectType == 14:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() != Account.AccountType.SECURITY: return False
                if not acct.getUsesAverageCost():
                    return True
                else:
                    # Check for accounts using avg cost control with LOTS set....
                    txnSet = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(acct)
                    for theTxn in txnSet:
                        if (InvestUtil.isSaleTransaction(theTxn.getParentTxn().getInvestTxnType())
                                and (theTxn.getParameter("cost_basis", None) is not None)):
                            myPrint("DB","MyAcctFilter: Account: %s Found LOT Tags %s" %(acct,theTxn.getParameter("cost_basis", None)))
                            return True

                # OK, No LOTs found on average cost controlled accounts.....
                return False

            if self.selectType == 15 or self.selectType == 16 or self.selectType == 17 or self.selectType == 18:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

                if self.selectType == 15:
                    x = MyGetDownloadedTxns(acct)
                    if x is not None and x.getTxnCount() >= 0:          # change to > 0 for only those with txns etc
                        return True
                elif self.selectType == 18:
                    x = MyGetDownloadedTxns(acct)
                    if x is not None and x.getTxnCount() >= 0:
                        return True
                elif self.selectType == 16:
                    x = MyGetOnlinePayees(acct)
                    if x is not None and x.getPayeeCount() >= 0:        # change to > 0 for only those with payees etc
                        return True
                elif self.selectType == 17:
                    x = MyGetOnlinePayments(acct)
                    if x is not None and x.getPaymentCount() >= 0:      # change to > 0 for only those with payments etc
                        return True

                return False

            if self.selectType == 19:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.SECURITY or acct.getAccountType() == Account.AccountType.ROOT: return False
                else: return True

            if self.selectType == 20:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY):
                    return False
                return True

            if self.selectType == 21:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.INVESTMENT
                        or acct.getAccountType() == Account.AccountType.LIABILITY):
                    return False

            # Security sub accounts for stock holdings
            if self.selectType == 22:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.SECURITY):
                    return False
                return True

            # Investment Accounts only
            if self.selectType == 23:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            # Security sub accounts for stock holdings where the relative currency is None - i.e. not properly linked to it's Security Master
            if self.selectType == 24:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.SECURITY):
                    return False
                acctCurr = acct.getCurrencyType()
                if (acctCurr is None or acctCurr.getCurrencyType() != CurrencyType.Type.SECURITY                        # noqa
                        or acct.getParameter("curr", None) is None or acct.getParameter("currid", None) is None):
                    return True
                return False

            # ALL
            if self.selectType == 25:
                return True

            if self.selectType == 26:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                else:
                    return True

            if (acct.getAccountOrParentIsInactive()): return False
            if (acct.getHideOnHomePage() and acct.getBalance() == 0): return False

            return True

    def MyGetOnlinePayees(theAcct):     # Use my version to prevent creation of default record(s)
        payeesListID = theAcct.getParameter("ol_payees_list_id", None)

        if payeesListID is not None:
            payeesObj = MD_REF.getCurrentAccountBook().getItemForID(payeesListID)    # type: SyncableItem
            if payeesObj is not None and isinstance(payeesObj, OnlinePayeeList):
                return payeesObj    # type: OnlinePayeeList

        # payees = OnlinePayeeList(MD_REF.getCurrentAccountBook())   # type: OnlinePayeeList
        # MD_REF.getCurrentAccountBook().logModifiedItem(payees)
        # theAcct.setOnlinePayees(payees)
        # return payees

        return None

    def MyGetOnlinePayments(theAcct):       # Use my version to prevent creation of default record(s)
        paymentsListID = theAcct.getParameter("ol_payments_list_id", None)
        if paymentsListID is not None:
            paymentsObj = MD_REF.getCurrentAccountBook().getItemForID(paymentsListID)      # type: SyncableItem
            if paymentsObj is not None and isinstance(paymentsObj, OnlinePaymentList):
                return paymentsObj  # type: OnlinePaymentList

        # payments = OnlinePaymentList(MD_REF.getCurrentAccountBook())   # type: OnlinePaymentList
        # MD_REF.getCurrentAccountBook().logModifiedItem(payments)
        # theAcct.setOnlinePayments(payments)
        # return payments

        return None

    # com.infinitekind.moneydance.model.Account.getDownloadedTxns() : OnlineTxnList
    def MyGetDownloadedTxns(theAcct):       # Use my version to prevent creation of default record(s)

        myID = theAcct.getParameter("id", None)
        defaultTxnsListID = myID + ".oltxns"

        if myID is not None and myID != "":
            defaultTxnList = MD_REF.getCurrentAccountBook().getItemForID(defaultTxnsListID)   # type: SyncableItem
            if defaultTxnList is not None and isinstance(defaultTxnList, OnlineTxnList):
                return defaultTxnList

        txnsListID = theAcct.getParameter("ol_txns_list_id", None)
        if txnsListID is None or txnsListID == "":
            if myID is not None and myID != "":
                txnsListID = defaultTxnsListID

        if txnsListID is not None and txnsListID != "":
            txnsObj = MD_REF.getCurrentAccountBook().getItemForID(txnsListID)              # type: SyncableItem
            if (txnsObj is not None and isinstance(txnsObj, OnlineTxnList)):
                return txnsObj

        # WE DON'T WANT TO DO THIS!
        # if myID is not None and myID != "":
        #     txns = OnlineTxnList(MD_REF.getCurrentAccountBook())                 # type: OnlineTxnList
        #     txns.setParameter("id", defaultTxnsListID)
        #     MD_REF.getCurrentAccountBook().logModifiedItem(txns)
        #     return txns
        #
        return None

    class ClipboardButtonAction(AbstractAction):

        def __init__(self, theString):
            self.theString = theString

        def actionPerformed(self, event):                                                                               # noqa
            _THIS_METHOD_NAME = "DIAGNOSTIC OUTPUT"

            options = ["Copy the diagnostics to the Clipboard",
                       "Save the diagnostics to a text file",
                       "Print the diagnostics to your printer"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         _THIS_METHOD_NAME.upper(), "Select Option:",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(lAlwaysGetIcon=True),
                                                         options, None)
            if not selectedOption: return

            optionIndex = options.index(selectedOption)
            if optionIndex == 0:
                x = StringSelection(self.theString)
                Toolkit.getDefaultToolkit().getSystemClipboard().setContents(x, None)
                txt = "Contents of all text below copied to Clipboard.."
                setDisplayStatus(txt, "B")
                return

            if optionIndex == 1:
                saveOutputFile(toolbox_frame_, _THIS_METHOD_NAME.upper(), "toolbox_diagnostics.txt", self.theString)
                return

            if optionIndex == 2:
                printOutputFile(_callingClass=None, _theTitle=_THIS_METHOD_NAME.upper(), _theJText=None, _theString=self.theString)
                return

    class ShowTheConsole(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):                                                                               # noqa
            ConsoleWindow.showConsoleWindow(MD_REF.getUI())

            txt = "Standard Moneydance Console Window Launched...."
            setDisplayStatus(txt, "B")

    class CopyConsoleLogFileButtonAction(AbstractAction):

        def __init__(self, theFile): self.theFile = theFile

        def actionPerformed(self, event):                                                                               # noqa
            _theFileAsStr = safeStr(self.theFile)
            if not os.path.exists(_theFileAsStr):
                txt = "Sorry, the file does not seem to exist: %s" %(_theFileAsStr)
                setDisplayStatus(txt, "R")
                return

            theTitle = "Select location to copy Console Log file to... (CANCEL=ABORT)"
            theFileName = "copy_of_errlog.txt"
            copyToFile = getFileFromFileChooser(toolbox_frame_,     # Parent frame or None
                                                get_home_dir(),     # Starting path
                                                theFileName,        # Default Filename
                                                theTitle,           # Title
                                                False,              # Multi-file selection mode
                                                False,              # True for Open/Load, False for Save
                                                True,               # True = Files, else Dirs
                                                None,               # Load/Save button text, None for defaults
                                                "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=True,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

            if (copyToFile is None) or copyToFile == "":
                txt = "User did not select file location - no copy performed"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return
            elif not safeStr(copyToFile).endswith(".txt"):
                txt = "Sorry - please use a .txt file extension when copying  console log file"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return
            elif ".moneydance" in os.path.dirname(copyToFile):
                txt = "Sorry, please choose a location outside of the  Moneydance location"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return

            if not check_file_writable(copyToFile):
                txt = "Sorry, that file/location does not appear allowed by the operating system!?"
                setDisplayStatus(txt, "R")

            toFile = File(copyToFile)
            try:
                MDIOUtils.copy(self.theFile, toFile)
                myPrint("B", "%s copied to %s" %(_theFileAsStr, copyToFile))
                if os.path.exists(copyToFile):
                    play_the_money_sound()
                    txt = "Console Log file save as requested to: %s" %(copyToFile)
                    setDisplayStatus(txt, "B")
                else:
                    myPrint("B", "ERROR - failed to copy file %s to %s" %(_theFileAsStr, copyToFile))
                    txt = "Sorry, failed to save console log file?!"
                    setDisplayStatus(txt, "R")
            except:
                myPrint("B", "ERROR - failed to copy file %s to %s" %(_theFileAsStr, copyToFile))
                dump_sys_error_to_md_console_and_errorlog()
                txt = "Sorry, failed to save console log file?!"
                setDisplayStatus(txt, "R")

            return

    class DisplayPickleFile(AbstractAction):

        def __init__(self): pass

        # noinspection PyUnusedLocal
        def actionPerformed(self, event):
            if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

            params = []
            for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
                params.append("Key: " + pad(safeStr(key),50) + " Type: " + pad(safeStr(type(GlobalVars.parametersLoadedFromFile[key])), 20) + "Value: " + safeStr(GlobalVars.parametersLoadedFromFile[key]) + "\n")

            params.append("\n<END>")
            params = "".join(params)

            jif = QuickJFrame("StuWareSoftSystems Pickle Parameter File:", params, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

            if not myPopupAskQuestion(jif,
                                      "STUWARESOFTSYSTEMS' SAVED PARAMETERS PICKLE FILE",
                                      "Would you like to RESET/DELETE/EDIT saved parameters?",
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.WARNING_MESSAGE):
                return

            _PICKLEDELALL          = 0
            _PICKLECHGONE          = 1
            _PICKLEDELONE          = 2
            _PICKLEADDONE          = 3

            what = ["PICKLE: DELETE ALL","PICKLE: CHANGE one variable","PICKLE: DELETE one variable", "PICKLE: ADD one variable"]

            while True:

                lAdd = lChg = lDelAll = lDelOne = False
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "Select the type of change you want to make?",
                                                           "STUWARESOFTSYSTEMS' SAVED PARAMETERS PICKLE FILE",
                                                           JOptionPane.WARNING_MESSAGE,
                                                           getMDIcon(None),
                                                           what,
                                                           None)

                if not selectedWhat:
                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()
                    return

                if selectedWhat == what[_PICKLEADDONE]: lAdd = True
                if selectedWhat == what[_PICKLECHGONE]: lChg = True
                if selectedWhat == what[_PICKLEDELONE]: lDelOne = True
                if selectedWhat == what[_PICKLEDELALL]: lDelAll = True

                if lDelAll:
                    GlobalVars.parametersLoadedFromFile = {}
                    txt = "STUWARESOFTSYSTEMS' PARAMETERS SAVED TO PICKLE FILE DELETED/RESET"
                    setDisplayStatus(txt, "DG"); myPrint("B", txt)

                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()
                    return

                text = ""
                if lChg: text = "CHANGE"
                if lDelOne: text = "DELETE"

                if lAdd:
                    addKey = myPopupAskForInput(jif,
                                                "PICKLE: ADD KEY",
                                                "KEY NAME:",
                                                "Carefully enter the name of the key you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                                "",
                                                False,
                                                JOptionPane.WARNING_MESSAGE)

                    if not addKey or len(addKey.strip()) < 1: continue
                    addKey = addKey.strip()

                    if not check_if_key_string_valid(addKey):
                        myPopupInformationBox(jif, "ERROR: Key %s is NOT valid!" % addKey, "PICKLE: ADD", JOptionPane.ERROR_MESSAGE)
                        continue    # back to menu

                    testKeyExists = GlobalVars.parametersLoadedFromFile.get(addKey)

                    if testKeyExists:
                        myPopupInformationBox(jif, "ERROR: Key %s already exists - cannot add - aborting..!" % addKey, "PICKLE: ADD", JOptionPane.ERROR_MESSAGE)
                        continue    # back to menu

                    addValue = myPopupAskForInput(jif,
                                                  "PICKLE: ADD KEY VALUE",
                                                  "KEY VALUE:",
                                                  "Carefully enter the key value you want to add (STRINGS ONLY!):",
                                                  "",
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not addValue or len(addValue.strip()) <1: continue
                    addValue = addValue.strip()

                    if not check_if_key_data_string_valid(addValue):
                        myPopupInformationBox(toolbox_frame_, "ERROR: Key value %s is NOT valid!" % addValue, "PICKLE: ADD ", JOptionPane.ERROR_MESSAGE)
                        continue    # back to menu

                    GlobalVars.parametersLoadedFromFile[addKey] = addValue
                    myPrint("B","@@ PICKLEMODE: key: %s value: %s added @@" %(addKey,addValue))
                    myPopupInformationBox(jif,
                                          "SUCCESS: Key %s added!" % (addKey),
                                          "PICKLE: ADD ",
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                pickleKeys=sorted(GlobalVars.parametersLoadedFromFile.keys())
                # OK, so we are changing or deleting
                if lChg or lDelOne:
                    selectedKey = JOptionPane.showInputDialog(jif,
                                                              "Select the key/setting you want to %s" % (text),
                                                              "PICKLE",
                                                              JOptionPane.WARNING_MESSAGE,
                                                              getMDIcon(None),
                                                              pickleKeys,
                                                              None)
                    if not selectedKey: continue

                    value = GlobalVars.parametersLoadedFromFile.get(selectedKey)
                    chgValue = None

                    if lChg:
                        chgValue = myPopupAskForInput(jif,
                                                      "PICKLE: CHANGE KEY VALUE",
                                                      "KEY VALUE:",
                                                      "Carefully enter the new key value (as type: %s):" %type(value),
                                                      str(value),
                                                      False,
                                                      JOptionPane.WARNING_MESSAGE)

                        if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                        chgValue = chgValue.strip()

                        if isinstance(value, (int, float, bool, list)):
                            try:
                                if isinstance(eval(chgValue), type(value) ):
                                    chgValue = eval(chgValue)
                                else:
                                    myPopupInformationBox(jif,"ERROR: you must match the variable type to %s" %(type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                    continue
                            except:
                                myPopupInformationBox(jif,"ERROR: *EVAL* Could not set Key value %s - type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                continue
                        elif isinstance(value,(str,unicode)):
                            if not check_if_key_data_string_valid(chgValue):
                                myPopupInformationBox(jif,"ERROR: Key value %s is NOT valid!" %chgValue,"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                continue    # back to menu
                        else:
                            myPopupInformationBox(jif,"SORRY: I cannot change Key value %s as it's type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                            continue    # back to menu

                    if lDelOne:
                        GlobalVars.parametersLoadedFromFile.pop(selectedKey)
                    if lChg:
                        try:
                            GlobalVars.parametersLoadedFromFile[selectedKey] = chgValue
                        except:
                            myPopupInformationBox(jif,"ERROR: *set* Could not set Key value %s - type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                            continue

                    if lDelOne:
                        myPrint("B","@@ PICKLEMODE: key: %s DELETED (old value: %s) @@" %(selectedKey,value))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s DELETED (old value: %s)" %(selectedKey,value),
                                              "PICKlE: DELETE",
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        myPrint("B","@@ PICKLERMODE: key: %s CHANGED to %s @@" %(selectedKey,chgValue))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s CHANGED to %s" %(selectedKey,chgValue),
                                              "PICKLE: CHANGE",
                                              JOptionPane.WARNING_MESSAGE)
                    continue


    def can_I_delete_currency():
        myPrint("B", "Analysing whether you can delete a Currency, or show where it's used....")

        if MD_REF.getCurrentAccountBook() is None: return

        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()

        currOutput = ""

        def accountHasCurrency(acct, curr):

            localOutput = ""

            currCount = 0

            if acct is None: return currCount

            for i in range(0,acct.getSubAccountCount()):

                subAcct = acct.getSubAccount(i)
                if subAcct.getCurrencyType() == curr:
                    currCount += 1
                    localOutput += ".. Account: %s Name: %s is using %s\n" %(subAcct.getAccountType(), subAcct.getFullAccountName(), curr)

                local_i, local_str = accountHasCurrency(subAcct, curr)
                currCount += local_i
                localOutput += local_str

                i+=1

            return currCount, localOutput

        currs = []
        securities = []

        for currency in allCurrencies:
            if currency.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                # noqa
                currs.append(currency)
            if currency.getCurrencyType() == CurrencyType.Type.SECURITY:                                                # noqa
                securities.append(currency)

        currs = sorted(currs, key=lambda x: (x.getName().upper()))
        securities = sorted(securities, key=lambda x: (x.getName().upper()))

        selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select Currency", "Select the currency to analyse",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       currs,
                                                       None)
        if selectedCurrency is None:
            txt = "No currency was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        currOutput += "\nYou want me to look for Currency: %s \n" %(selectedCurrency)

        myPrint("B", "Looking for Currency: %s %s" %(selectedCurrency, selectedCurrency.getName()) )                    # noqa

        base = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()

        lFailTests = False
        if selectedCurrency == base:
            lFailTests = True
            currOutput += "\n** Currency is set as the base - Deletion not possible!! **\n\n"

        currOutput += "\nReviewing all Account/Category records for currency...:\n"
        foundCurrCount, outputBuild = accountHasCurrency(MD_REF.getCurrentAccount(), selectedCurrency)
        currOutput += outputBuild
        if foundCurrCount > 0:
            currOutput += "<%s ACCOUNTS / CATS FOUND USING CURRENCY>\n" %(foundCurrCount)
        else:
            currOutput += "<NO ACCOUNTS / CATS FOUND USING CURRENCY>\n"
        currOutput += "\n"

        currOutput += "\nReviewing security records for currency...:\n"
        secCount = 0
        for sec in securities:
            if sec.getRelativeCurrency() == selectedCurrency:
                secCount += 1
                currOutput += "Security: %s is using %s\n" %(sec, selectedCurrency)
        if secCount > 0:
            currOutput += "<%s SECURITIES FOUND USING CURRENCY>\n" %(secCount)
        else:
            currOutput += "<NO SECURITIES FOUND USING CURRENCY>\n"
        currOutput += "\n"

        if foundCurrCount or secCount or lFailTests:
            txt = "Currency %s ** IS BEING USED ** - Deletion not possible!" %(selectedCurrency)
            currOutput += "\n%s\n" %(txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
        else:
            txt = "Currency %s is NOT being used - deletion should be possible...."  %(selectedCurrency)
            currOutput += "\n%s\n" %(txt)
            setDisplayStatus(txt, "B"); myPrint("B", txt)

        currOutput += "\n<END>"

        QuickJFrame("CAN I DELETE A CURRENCY?", currOutput, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def can_I_delete_security():
        myPrint("B", "Script running to analyse whether you can delete a Security, or show where it's used....")

        if MD_REF.getCurrentAccountBook() is None: return

        usageCount = 0
        sumShares = 0

        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()

        securities = []

        for currency in allCurrencies:
            # noinspection PyUnresolvedReferences
            if currency.getCurrencyType() == CurrencyType.Type.SECURITY:
                securities.append(currency)

        securities = sorted(securities, key=lambda x: (x.getName().upper()))

        selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select Security", "Select the security to analyse",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       securities,
                                                       None)
        if selectedSecurity is None:
            txt = "No security was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        output = "\nYou want me to look for Security: %s\n" %(selectedSecurity)

        accountsList = AccountUtil.allMatchesForSearch(book, MyAcctFilter(2))
        output += "Searching through %s security (sub) accounts.." % (len(accountsList)) + "\n"

        for account in accountsList:
            if account.getCurrencyType() == selectedSecurity:
                # noinspection PyUnresolvedReferences
                output += "   >> Security: %s is used in Account: %s - Share holding balance: %s" \
                          % (selectedSecurity, account.getParentAccount().getAccountName(),
                             selectedSecurity.getDoubleValue(account.getBalance())) + "\n"
                # noinspection PyUnresolvedReferences
                sumShares += selectedSecurity.getDoubleValue(account.getBalance())
                usageCount += 1

        if not usageCount:
            output += "   >> Security not found in any accounts.\n"

        output += "\nChecking security for price history...:\n"

        # noinspection PyUnresolvedReferences
        secSnapshots = selectedSecurity.getSnapshots()
        countPriceHistory = secSnapshots.size()
        if countPriceHistory > 0:
            output += "   >> Security has %s historical prices!" % (secSnapshots.size()) + "\n"
        else:
            output += "   >> Security has no historical prices. \n"

        output += " ----------------------------------------------------------------\n"
        if usageCount:
            output += "\nUSAGE FOUND: You are using security: %s in %s accounts!\n... with a share balance of: %s. These would need to be removed before security deletion" \
                      % (selectedSecurity, usageCount, sumShares) + "\n"
            myPrint("J", ">> NO - Security cannot be deleted as it's being used: %s" %(selectedSecurity))

        if countPriceHistory:
            output += "\nPRICE HISTORY FOUND: You have %s price records - If you delete Security then these will be lost..." \
                      % countPriceHistory + "\n"

        if not usageCount and not countPriceHistory:
            txt = "No usage of security %s found! You should be able to safely delete the Security" %(selectedSecurity)
        else:
            txt = "Sorry - usage of Security: %s found - refer to script output for details.." %(selectedSecurity)

        output += "\n%s\n" %(txt)
        setDisplayStatus(txt, "R")

        output += "\n<END>"
        QuickJFrame("CAN I DELETE A SECURITY?", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def list_security_currency_decimal_places():
        myPrint("B", "Script is analysing your (hidden) Currency/Security decimal place settings...........")

        if MD_REF.getCurrentAccountBook() is None: return

        iWarnings = 0
        myLen = 50

        decimalPoint_MD = MD_REF.getPreferences().getDecimalChar()

        currs = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()

        currs = sorted(currs, key=lambda x: safeStr(x.getName()).upper())

        output = "List Currency/Security (hidden) Decimal Places setting and related data:\n" \
                 " =======================================================================\n"

        output += "** NOTE: The hidden 'Decimal Places' (dpc) setting is set when you create a new Currency/Security.\n" \
                  "         - This can not normally be changed once set in the Moneydance menus.\n" \
                  "         - However - Toolbox extension has a menu feature to allow you to do this\n" \
                  "         - For a Currency, the dpc controls the decimal precision of both balances and stored values on transactions\n" \
                  "         - For a Security, the dpc controls ONLY the qty of shares/units held and it does NOT affect the stored dpc of prices/rates.\n" \
                  "\n"

        def get_curr_sec_name(curr_sec):
            if curr_sec.getName() is not None and len(curr_sec.getName().strip()) > 0:
                return curr_sec.getName()
            return (curr_sec.getIDString() + ":" + curr_sec.getIDString())

        def analyse_curr(theCurr, theType):
            output = ""                                                                                                 # noqa
            iWarn = 0
            for sec_curr in theCurr:
                if str(sec_curr.getCurrencyType()) != theType: continue

                foo = str(round(CurrencyUtil.getUserRate(sec_curr, sec_curr.getRelativeCurrency()), 30))
                priceDecimals = min(30, len(foo.split(decimalPoint_MD)[-1]))

                output += pad(get_curr_sec_name(sec_curr),myLen) + "\tDPC: " + \
                          str(sec_curr.getDecimalPlaces()) + \
                          "\t" + \
                          "Relative to: " + safeStr(sec_curr.getRelativeCurrency())[:20].ljust(20, " ") + \
                          "\t" + \
                          "Current rate: " + str(foo)[:20].ljust(20, " ") + \
                          "\tRate dpc: " + str(priceDecimals)

                # if (sec_curr.getDecimalPlaces() < priceDecimals and theType == "SECURITY") and \
                #         not foo.endswith(".0"):
                #     iWarn += 1
                #     output += " ***\n"
                # else:
                #     output += "\n"

                output += "\n"
            return iWarn, output

        output += " ==============\n"
        output += " --- SECURITIES ----\n"
        output += " ==============\n"

        result = analyse_curr(currs, "SECURITY")
        iWarnings += result[0]
        output += result[1]

        output += "\n" \
                  " ==============\n"
        output += " --- CURRENCIES ----\n"
        output += " ==============\n"
        result = analyse_curr(currs, "CURRENCY")
        iWarnings += result[0]
        output += result[1]

        output += "\n" \
                  " ----------------------------------------------------------------"
        output += "\n<END>"

        txt = "DIAG: Currency/Security Decimal Places report executed"
        setDisplayStatus(txt, "DG")

        QuickJFrame("LIST SECURITY / CURRENCY DECIMAL PLACES", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def manually_edit_price_date_field():
        if MD_REF.getCurrentAccountBook() is None: return
        if not (ToolboxMode.isUpdateMode()): return

        currencies = list_security_currency_price_date(autofix=False, justProvideFilter=True)
        if currencies is None:
            txt = "No Currency/Security filter option was selected.."
            setDisplayStatus(txt, "R")
            return

        currs = []
        for curr in currencies:
            currs.append(StoreCurrencySecurity(curr))

        selectedCurrSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Currency/Security to edit the current price hidden 'price_date' field:",
                                                      "Edit price_date - Select CURRENCY/SECURITY",
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      getMDIcon(lAlwaysGetIcon=True),
                                                      currs,
                                                      None)
        if not selectedCurrSec:
            txt = "No Currency/Security was selected.."
            setDisplayStatus(txt, "R")
            return

        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
        if not isRRateCurrencyIssueFixedBuild() and not checkCurrencyRawRatesOK(selectedCurrSec.obj):                                                            # noqa
            txt = "@@ ERROR: Old format Currency record detected (empty relative rate). Please use 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to fix - No changes allowed!"
            setDisplayStatus(txt, "R"); myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        currPriceDate = selectedCurrSec.obj.getLongParameter("price_date", 0L)                                          # noqa

        if currPriceDate > 0:
            theCurrentDatePretty = get_time_stamp_as_nice_text(currPriceDate)
        else:
            theCurrentDatePretty = "NOT SET"

        newestSnapshotDate = 0
        newestSnapshotPrice = 0
        relCurr = selectedCurrSec.obj.getRelativeCurrency()                                                             # noqa
        currentPrice = selectedCurrSec.obj.getRelativeRate()                                                            # noqa
        currSnapshots = selectedCurrSec.obj.getSnapshots()                                                              # noqa
        if len(currSnapshots)>0:
            newestSnapshotDate = currSnapshots[-1].getDateInt()
            newestSnapshotPrice = currSnapshots[-1].getRate()

        if newestSnapshotDate > 0:
            theLatestSnapshotDatePretty = "%s" %(convertStrippedIntDateFormattedText(newestSnapshotDate))
        else:
            theLatestSnapshotDatePretty = "NOT SET"

        if isGoodRate(newestSnapshotPrice):
            txtLatestSnapshotPrice = "%s" %(safeInvertRate(newestSnapshotPrice))
        else:
            txtLatestSnapshotPrice = "NOT SET"

        MyPopUpDialogBox(toolbox_frame_,
                         "FOR INFO: Currency/Security details:",
                         "Current price hidden 'price_date' is currently: %s\n"
                         "(which means: %s)\n"
                         "Latest dated price history date: %s\n"
                         "Current Price: %s\n"
                         "Latest Dated History Price: %s"
                         %(currPriceDate, theCurrentDatePretty, theLatestSnapshotDatePretty,safeInvertRate(currentPrice),txtLatestSnapshotPrice),
                         theTitle="MANUALLY EDIT HIDDEN PRICE_DATE FIELD").go()

        labelUpdateDate = JLabel("Select the new current price hidden 'price_date':")
        user_selectDateStart = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
        if newestSnapshotDate > 0:
            user_selectDateStart.setDateInt(min(newestSnapshotDate,DateUtil.getStrippedDateInt()))
        else:
            user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())

        labelUpdatePrice = JLabel("Choose which current price to use (ie. existing price or latest history price")

        user_selectCurrentPrice = user_selectHistoryPrice = None
        if isGoodRate(newestSnapshotPrice):
            user_selectCurrentPrice = JRadioButton("Keep Current Price: %s" %(safeInvertRate(currentPrice)), True)
            user_selectHistoryPrice = JRadioButton("Switch to Latest History Price: %s" %(safeInvertRate(newestSnapshotPrice)), False)
            bg = ButtonGroup()
            bg.add(user_selectCurrentPrice)
            bg.add(user_selectHistoryPrice)

        datePanel = JPanel(GridLayout(0, 1))
        datePanel.add(labelUpdateDate)
        datePanel.add(user_selectDateStart)
        if isGoodRate(newestSnapshotPrice):
            datePanel.add(JLabel(""))
            datePanel.add(JLabel("----"))
            datePanel.add(labelUpdatePrice)
            datePanel.add(user_selectCurrentPrice)
            datePanel.add(user_selectHistoryPrice)

        options = ["Cancel", "OK"]

        userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                  datePanel,
                                                  "Enter new current price hidden 'price_date' / price/rate fields:",
                                                  JOptionPane.OK_CANCEL_OPTION,
                                                  JOptionPane.QUESTION_MESSAGE,
                                                  getMDIcon(None),
                                                  options,
                                                  options[0])

        if userAction != 1:
            txt = "User cancelled entering a new current price hidden 'price_date' - exiting"
            setDisplayStatus(txt, "R")
            return

        if user_selectDateStart.getDateInt() < 20150101 or user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt():

            if user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt() \
                    and myPopupAskQuestion(toolbox_frame_,"Enter Future Date?","Do you really want to enter a future current price hidden 'price_date'?"):
                pass
            else:
                txt = "User cancelled by entering an invalid hidden price_date..."
                setDisplayStatus(txt, "R")
                return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"CURRENCY/SECURITY - UPDATE 'price_date'",
                                                 "Update the current price hidden 'price_date' field to %s?"%(convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt()))):
            return

        newDate = DateUtil.convertIntDateToLong(user_selectDateStart.getDateInt()).getTime()

        selectedCurrSec.obj.setEditingMode()                                                                            # noqa
        selectedCurrSec.obj.setParameter("price_date", newDate)                                                         # noqa
        if isGoodRate(newestSnapshotPrice) and user_selectHistoryPrice and user_selectHistoryPrice.isSelected():
            selectedCurrSec.obj.setRate(Util.safeRate(newestSnapshotPrice),relCurr)                                     # noqa
        selectedCurrSec.obj.syncItem()                                                                                  # noqa

        _msg = "Edit of current price hidden 'price_date' field for curr/sec: %s successfully set to: %s (%s)" %(selectedCurrSec,newDate,convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt()))
        setDisplayStatus(_msg, "R"); myPrint("B", _msg)

        if isGoodRate(newestSnapshotPrice) and user_selectHistoryPrice and user_selectHistoryPrice.isSelected():
            myPrint("B", "... current price also updated to: %s" %(safeInvertRate(newestSnapshotPrice)))

        logToolboxUpdates("manually_edit_price_date_field", _msg)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,_msg,"Edit current price hidden 'price_date' field",JOptionPane.WARNING_MESSAGE)

    def checkCurrencyRawRatesOK(theCurr):

        # Check of 'rate' disabled as this is a legacy field and I no longer try to fix it.. Not required.. Especially since 2021.2 onwards

        # checkRate = theCurr.getParameter("rate", None)
        # checkRateDouble = theCurr.getDoubleParameter("rate", 0.0)

        # if checkRate is None or not isGoodRate(checkRateDouble):
        #     myPrint("DB", "WARNING: checkCurrencyRawRatesOK() 'rate' check failed on %s - checking stopped here" %(theCurr))
        #     return False

        checkRRate = theCurr.getParameter("rrate", None)
        checkRRateDouble = theCurr.getDoubleParameter("rrate", 0.0)

        if checkRRate is None or not isGoodRate(checkRRateDouble):
            myPrint("DB", "WARNING: checkCurrencyRawRatesOK() 'rrate' check failed on %s - checking stopped here" %(theCurr))
            return False

        return True

    def check_all_currency_raw_rates_ok(filterType=None):

        _currs = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
        for _curr in _currs:
            if filterType and _curr.getCurrencyType() != filterType: continue
            if not checkCurrencyRawRatesOK(_curr):
                return False

        return True

    def list_security_currency_price_date(autofix=False, justProvideFilter=False):
        if justProvideFilter: autofix = False

        if MD_REF.getCurrentAccountBook() is None: return None

        listCurrs = []
        currs_to_fix = []

        lMustRunFixCurrenciesFirst = False

        if not justProvideFilter:
            myPrint("B", "Script is analysing your Currency & Security current price hidden 'price_date' fields...........")

            txt = "Current Price (Hidden) 'price_date' fix"
            if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


        options = ["All (both Currencies & Securities)",
                   "All - Shown on Summary Page Only",
                   "Currencies - All",
                   "Currencies - Shown on Summary Page Only",
                   "Securities - All",
                   "Securities - Shown on Summary Page Only",
                   "Securities - With holdings Only",
                   "All - include OK objects too"]

        displayText = ["REPORT OPTIONS (list objects with error)", "Select your report filters/options"]
        if justProvideFilter:
            displayText = ["EDIT OPTIONS (lists objects with errors)", "Select filters/options for Edit List"]

        selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                       displayText[0], displayText[1],
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options,                                                         # noqa
                                                       None)

        if not selectedOption:
            if justProvideFilter: return None
            txt = "No report option was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        lAll = lSummaryScreenOnly = lCurrencyOnly = lSecurityOnly = lSecurityHoldings = lEverything = False
        optionIndex = options.index(selectedOption)
        if optionIndex in (0,1,7):  lAll = True
        if optionIndex in (2,3):    lCurrencyOnly = True
        if optionIndex in (4,5,6):  lSecurityOnly = True
        if optionIndex in (1,3,5):  lSummaryScreenOnly = True
        if optionIndex == 6:        lSecurityHoldings = True
        if optionIndex == 7:        lEverything = True

        iWarnings = 0

        currs = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
        currs = sorted(currs, key=lambda x: (x.getCurrencyType(), x.getName().upper()))

        if justProvideFilter and lEverything: return currs

        output = "\nDiagnosing your Security / Currency's current price hidden 'price_date' fields (Normally showing errors only)\n" \
                 " ==============================================================================================================\n\n"

        def get_curr_sec_name(curr_sec):
            if curr_sec.getName() is not None and len(curr_sec.getName().strip()) > 0:
                return curr_sec.getName()
            return (curr_sec.getIDString() + ":" + curr_sec.getIDString())

        MD_decimal = MD_REF.getPreferences().getDecimalChar()
        base = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()

        def analyse_curr(theCurr, theType):
            output = ""                                                                                                 # noqa
            iWarn = 0
            _lMustRunFixCurrenciesFirst = False
            nowTimeMS = System.currentTimeMillis()
            intNowTime = DateUtil.convertLongDateToInt(nowTimeMS)

            for sec_curr in theCurr:
                if sec_curr == base: continue
                if sec_curr.getCurrencyType() != theType: continue
                if lSummaryScreenOnly and sec_curr.getHideInUI(): continue

                qtyHeld = 0
                if sec_curr.getCurrencyType() == CurrencyType.Type.SECURITY:                                            # noqa
                    qtyHeld = get_security_holdings(sec_curr)
                    if lSecurityHoldings and qtyHeld == 0: continue

                currPriceDate = sec_curr.getLongParameter("price_date", 0L)

                newestRate = newestSnapshotDate = intLatestSnapDate = 0
                currSnapshots = sec_curr.getSnapshots()
                snap = None
                if len(currSnapshots)>0:
                    snap = currSnapshots[-1]
                    newestRate = snap.getRate()
                    intLatestSnapDate = newestSnapshotDate = snap.getDateInt()

                if newestSnapshotDate > 0:
                    newestSnapshotDate = DateUtil.convertIntDateToLong(newestSnapshotDate)

                lSkip = False
                if currPriceDate < 1:
                    lSkip = True
                else:
                    if newestSnapshotDate > 0:
                        if (DateUtil.convertDateToInt(newestSnapshotDate) <= DateUtil.convertLongDateToInt(nowTimeMS)
                                and DateUtil.convertLongDateToInt(currPriceDate) <= DateUtil.convertLongDateToInt(nowTimeMS)
                                and DateUtil.convertLongDateToInt(currPriceDate) == DateUtil.convertDateToInt(newestSnapshotDate)):
                            lSkip = True
                    else:
                        if DateUtil.convertLongDateToInt(currPriceDate) <= DateUtil.convertLongDateToInt(nowTimeMS):
                            lSkip = True

                if not lEverything and lSkip: continue

                if justProvideFilter:
                    listCurrs.append(sec_curr)
                    continue

                if lEverything and not lSkip:
                    output += "** "

                output += "{}".format(get_curr_sec_name(sec_curr))
                if sec_curr.getCurrencyType() == CurrencyType.Type.SECURITY:                                            # noqa
                    output += " ({}:{})".format(sec_curr.getTickerSymbol(),sec_curr.getIDString())
                    if qtyHeld != 0:
                        output += "\tQty Held: {}".format(sec_curr.formatSemiFancy(qtyHeld, MD_decimal))
                else:
                    output += " ({})".format(sec_curr.getIDString())

                if lSkip:
                    if currPriceDate < 1:
                        niceDate = "NOT SET"
                    else:
                        niceDate = get_time_stamp_as_nice_text(currPriceDate)
                    output += " - OK (price_date = %s)\n\n" %(niceDate)
                    continue

                lUpdateRequired = False
                output += "\nprice_date (%s) = %s\n" %(currPriceDate,get_time_stamp_as_nice_text(currPriceDate))

                if DateUtil.convertLongDateToInt(currPriceDate) > DateUtil.convertLongDateToInt(nowTimeMS):
                    lUpdateRequired = True
                    output += "@@ WARNING: Your current price hidden 'price_date' field is future dated! **\n"

                if DateUtil.convertLongDateToInt(currPriceDate) < DateUtil.convertDateToInt(newestSnapshotDate):
                    output += "@@ WARNING: Your current price hidden 'price_date' field is older than latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                    if DateUtil.convertLongDateToInt(currPriceDate) < DateUtil.convertLongDateToInt(nowTimeMS):
                        lUpdateRequired = True

                if newestSnapshotDate > 0 and (DateUtil.convertDateToInt(newestSnapshotDate) > DateUtil.convertLongDateToInt(nowTimeMS)):
                    output += "@@ WARNING: Your price history date(s) are future dated! **\n"
                    output += "... latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                if newestSnapshotDate > 0 and (DateUtil.convertLongDateToInt(currPriceDate) > DateUtil.convertDateToInt(newestSnapshotDate)):
                    lUpdateRequired = True
                    output += "@@ WARNING: current price hidden 'price_date' field is newer than your latest dated price history date....\n"
                    output += "... latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                if not isGoodRate(sec_curr.getRelativeRate()):
                    output += "@@ WARNING: current price/rate is not a valid number: %s\n" %(sec_curr.getRelativeRate())

                if snap and not isGoodRate(snap.getRate()):
                    output += "@@ WARNING: Latest dated price history price/rate is not a valid number: %s\n" %(snap.getRate())

                if lUpdateRequired and snap and sec_curr.getRelativeRate() != snap.getRate():
                    output +=  "... current price/rate %s, latest dated price history price/rate %s\n" %(safeInvertRate(sec_curr.getRelativeRate()), safeInvertRate(snap.getRate()))

                if lUpdateRequired:
                    # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
                    if not isRRateCurrencyIssueFixedBuild() and not checkCurrencyRawRatesOK(sec_curr):
                        output += "@@@ ERROR: Currency object has an old underlying format (empty 'rate' / 'rrate' fields); please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to fix (skipping....) @@@\n"
                        _lMustRunFixCurrenciesFirst = True
                        lUpdateRequired = False

                iWarn += 1
                output += "\n\n"

                if autofix:
                    if not lSkip and snap and lUpdateRequired and currPriceDate > 0 and intLatestSnapDate > 0:
                        relCurr = sec_curr.getRelativeCurrency()
                        currs_to_fix.append([sec_curr,
                                             DateUtil.convertIntDateToLong(min(intNowTime,intLatestSnapDate)).getTime(),
                                             Util.safeRate(newestRate),
                                             relCurr])

            return iWarn, output, _lMustRunFixCurrenciesFirst

        if lAll or lSecurityOnly:
            output += " ===================\n"
            output += " --- SECURITIES ----\n"
            output += " ===================\n"

            # noinspection PyUnresolvedReferences
            result = analyse_curr(currs, CurrencyType.Type.SECURITY)
            iWarnings += result[0]
            output += result[1]
            if result[2]: lMustRunFixCurrenciesFirst = True

        if lAll or lCurrencyOnly:
            output += " ===================\n"
            output += " --- CURRENCIES ----\n"
            output += " ===================\n"

            # noinspection PyUnresolvedReferences
            result = analyse_curr(currs, CurrencyType.Type.CURRENCY)
            iWarnings += result[0]
            output += result[1]
            if result[2]: lMustRunFixCurrenciesFirst = True

        if justProvideFilter: return listCurrs

        output += " ----------------------------------------------------------------"
        if iWarnings:
            output += "\nYou have %s Warning(s)..\n" % iWarnings
            output += "These are where your current price hidden 'price_date' field is future dated, or newer/older than your latest dated price history date\n"
            if not autofix:
                output += "To Fix a Warning use Update Mode, MENU: FIX: Manually edit a currency/ security's current price hidden 'price_date' field (will also allow you to fix the current price/rate)\n" \
                          "or consider using FIX: Diagnose then fix your currency / security's current price hidden 'price_date' field (along with the current price/rate)\n"
            _msg = "price_date: You have %s Warning(s).. Refer diagnostic file..." %(iWarnings)
            setDisplayStatus(_msg, "R"); myPrint("B", _msg)
        else:
            _msg = "All good, current price hidden 'price_date' looks clean! Congratulations!"
            output += "\n%s\n" %(_msg)
            setDisplayStatus(_msg, "DG"); myPrint("B", _msg)

        output += "\n\n\nReport Parameters:\n"
        output += "All (Both Securities and Currencies): %s\n" %(lAll)
        output += "Securities Only:                      %s\n" %(lSecurityOnly)
        output += "Currencies Only:                      %s\n" %(lCurrencyOnly)
        output += "Shown on Summary Page Only Filter:    %s\n" %(lSummaryScreenOnly)
        output += "Securities with Holdings Only Filter: %s\n" %(lSecurityHoldings)
        output += "All including OK Objects too:         %s\n" %(lEverything)
        output += " ----------------------------------------------------------------\n"

        if not autofix: output += "\n<END>"

        jif = QuickJFrame("DIAGNOSE SECURITY/CURRENCY CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD(S)", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

        if lMustRunFixCurrenciesFirst:
            txt = "@@ ERROR: old format Currency record(s) detected (review output). Consider running Fix relative currencies option @@"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not autofix: return

        if len(currs_to_fix) < 1:
            myPopupInformationBox(jif,"There are no warnings to fix / can be fixed - will exit without changes","AUTOFIX HIDDEN CURRENT PRICE 'PRICE_DATE' FIELD")
            return

        MyPopUpDialogBox(jif,
                         "Proceed to autofix?",
                         "At the next screen you will be asked whether to proceed with the change(s), to backup, and to accept the disclaimer\n"
                         "Clicking YES will fix all the WARNINGS identified/displayed.\n"
                         "It will also then ask you whether you wish to update any Current Prices if they are different from the Last Dated History Price.\n",
                         theTitle="HIDDEN PRICE DATE FIELD AUTOFIX",
                         OKButtonText="NEXT STEP").go()

        if not confirm_backup_confirm_disclaimer(jif, "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELDS",
                                                 "EXECUTE AUTOFIX on %s CURRENCY/SECURITY HIDDEN 'PRICE_DATE' RECORDS?" %(len(currs_to_fix))):
            return

        lUpdatePricesToo = myPopupAskQuestion(jif,"AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELDS","Shall I update the current price(s) to match the latest price history at the same time?")

        jif.dispose()

        myPrint("B","AUTOFIX Currency / Security current price hidden 'price_date' fields running on %s records..." %(len(currs_to_fix)))
        output += "\n\n\nAUTOFIX log....\n ===============\n\n"

        txt = "AUTOFIX: User Response: Update current price to match latest dated history price too: %s" %(lUpdatePricesToo)
        myPrint("B",txt)
        output += ("\n" + txt + "\n\n")

        _CURRS_FIX_CURR = 0
        _CURRS_FIX_DATE = 1
        _CURRS_FIX_NEWRATE = 2
        _CURRS_FIX_RELCURR = 3

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for fix_reqd in currs_to_fix:
            curr = fix_reqd[_CURRS_FIX_CURR]
            newDateLong = fix_reqd[_CURRS_FIX_DATE]
            newRate = fix_reqd[_CURRS_FIX_NEWRATE]
            rCurr = fix_reqd[_CURRS_FIX_RELCURR]
            oldRate = curr.getRelativeRate()

            lUpdateThisPrice = lUpdatePricesToo
            if newRate == 0 or newRate == oldRate or not isGoodRate(newRate):
                lUpdateThisPrice = False

            myPrint("B","")
            myPrint("B", "@@ FIXING: %s (relative curr: %s)." %(curr, rCurr))
            output += ("@@ FIXING: %s (relative curr: %s).\n" %(curr, rCurr))

            myPrint("B", "...Updating current price hidden 'price_date' to %s" %(get_time_stamp_as_nice_text(newDateLong)))
            output += ("...Updating current price hidden 'price_date' to %s\n" %(get_time_stamp_as_nice_text(newDateLong)))

            if lUpdateThisPrice:
                myPrint("B", "...Updating current rate from %s to %s" %(safeInvertRate(oldRate), safeInvertRate(newRate)))
                output += ("...Updating current rate from %s to %s\n" %(safeInvertRate(oldRate), safeInvertRate(newRate)))

            myPrint("B","")
            output += "\n"

            curr.setEditingMode()
            curr.setParameter("price_date", newDateLong)
            if lUpdateThisPrice:
                curr.setRate(Util.safeRate(newRate),rCurr)
            curr.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "AUTOFIX: %s records updated" %(len(currs_to_fix))
        myPrint("B",txt)
        output += txt
        output += "\n<END>\n"

        logToolboxUpdates("list_security_currency_price_date", txt)

        jif = QuickJFrame("AUTOFIX SECURITY/CURRENCY CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD(S)", output,
                          copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lRestartMDAfterClose=True, lWrapText=False, lAutoSize=True).show_the_frame()

        _msg = "AUTOFIX: %s records fixed" %(len(currs_to_fix))
        setDisplayStatus(_msg, "DG")
        disableToolboxButtons()
        play_the_money_sound()
        myPopupInformationBox(jif, _msg, "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD")

        myPopupInformationBox(jif, "RESTART OF MONEYDANCE REQUIRED - MD WILL RESTART AFTER VIEWING THIS OUTPUT",
                              "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD",
                              theMessageType=JOptionPane.ERROR_MESSAGE)

    def read_preferences_file(lSaveFirst=False):

        cf = Common.getPreferencesFile()

        if lSaveFirst:
            MD_REF.savePreferences()

        try:
            st = StreamTable()
            st.readFromFile(str(cf))
            tk = st.getKeyArray()
            tk = sorted(tk)
        except:
            st, tk = None, None
            dump_sys_error_to_md_console_and_errorlog()

        return st,tk

    def check_for_window_display_data(theKey, theValue):

        if not isinstance(theValue, (str,unicode)):                         return False
        if theKey.startswith(GlobalVars.MD_PREFERENCE_KEY_CURRENT_THEME):   return False
        if theKey.startswith("gui.dashboard.item"):                         return False
        if theKey.startswith("gui.font_increment"):                         return False
        if theKey.startswith("gui.new_txn_on_record"):                      return False
        if theKey.startswith("gui.quickdecimal"):                           return False
        if theKey.startswith("gui.register_follows_txns"):                  return False
        if theKey.startswith("gui.show_all_accts_in_popup"):                return False
        if theKey.startswith("gui.source_list_visible"):                    return False

        # Preferences Home Screen options
        if theKey.startswith("gui.home"):                                   return False

        if not (theKey.startswith("ext_mgmt_win")
                or theKey.startswith("security_list")
                or theKey.startswith("curr_list")
                or theKey.startswith("ratioSettings.")
                or theKey.startswith("ol_acct_map_win")
                or theKey.startswith("moneybot_py_divider")
                or theKey.startswith("mbot.loc")
                or theKey.startswith("mbot.size")
                or theKey.startswith("gui.")
                or theKey.endswith("rec_reg.credit")
                or theKey.endswith("rec_reg.debit")
                or "col_widths." in theKey
                or ("sel_" in theKey and theKey.endswith("_filter"))
                or ("custom_filter" in theKey)
                or "sel_inv_view" in theKey):
            return False

        if not ("window" in theKey
                or "win_loc" in theKey
                or "_list_loc" in theKey
                or "_win.loc" in theKey
                or "_report_loc" in theKey
                or "width" in theKey
                or "isopen" in theKey
                or "winloc" in theKey
                or "winsize" in theKey
                or "winsz" in theKey
                or "win.sz" in theKey
                or "divider" in theKey
                or "location" in theKey
                or "size" in theKey
                or "rec_reg.credit" in theKey
                or "rec_reg.debit" in theKey
                or "mbot.loc" in theKey
                or "_expanded" in theKey
                or "_filter" in theKey
                or "maximized" in theKey
                or "sel_inv_view" in theKey):
            return False

        return True

    def check_for_just_locations_window_display_data(theKey, theValue):

        # Assumes you have called check_for_window_display_data() first!

        # Locations are  number x number - e.g. 10x100
        if "x" not in theValue.lower(): return False

        if not ("win_loc" in theKey
                or "_list_loc" in theKey
                or "_win.loc" in theKey
                or "_report_loc" in theKey
                or "winloc" in theKey
                or "location" in theKey
                or "mbot.loc" in theKey):
            return False

        return True

    def check_for_just_sizes_window_display_data(theKey, theValue):

        # Assumes you have called check_for_window_display_data() first!

        # Sizes are  number x number - e.g. 10x100
        if "x" not in theValue.lower(): return False
        if "font" in theValue.lower(): return False

        if not ("win_size" in theKey
                or "size" in theKey
                or "winsize" in theKey
                or "winsz" in theKey
                or "win.sz" in theKey
                or "location" in theKey
                or "mbot.size" in theKey):
            return False

        return True

    # noinspection PyUnusedLocal
    def check_for_just_register_filters_window_display_data(theKey, theValue):

        # Assumes you have called check_for_window_display_data() first!
        if "custom_filter" in theKey: return True
        if  not ("sel_" in theKey and theKey.endswith("_filter") ): return False
        return True

    # noinspection PyUnusedLocal
    def check_for_just_initial_view_filters_window_display_data(theKey, theValue):

        if  not ("sel_" in theKey and theKey.endswith("_view") ):
            return False

        return True

    # copied from Moneydance TxnRegister.class
    def loadMDPreferences(dataObject, preferencesKey, lGetDefaultForObject=True):   # dataObject should always = Account.

        preferencesKey = preferencesKey

        if not preferencesKey:
            dataPrefKey = "col_widths"
        else:
            dataPrefKey = "col_widths." + preferencesKey

        colWidthPrefs = None

        if dataObject:
            colWidthPrefs = dataObject.getPreference(dataPrefKey, None)

        if not lGetDefaultForObject and dataObject and not colWidthPrefs: return None

        if StringUtils.isBlank(colWidthPrefs) and preferencesKey:
            colWidthPrefs = MD_REF.getUI().getPreferences().getSetting(dataPrefKey, None)

        if not colWidthPrefs or StringUtils.isBlank(colWidthPrefs):
            return None

        if not colWidthPrefs.startswith(":"):
            colWidthPrefs = ":" + colWidthPrefs

        params = SyncRecord()
        try:
            if isKotlinCompiledBuild():
                params.readSet(Buffer().writeUtf8(colWidthPrefs))
            else:
                params.readSet(StringReader(colWidthPrefs))
        except IOException:
            myPrint("B", "Error parsing register settings: " + colWidthPrefs + " key=" + preferencesKey)
            return None

        widths = params.getIntArray("cols")                                                     # int[]

        if params.getBoolean("splitreg", False):
            splitReg = True
            splitSz = Dimension(10, Math.max(0, params.getInt("splitsz", 100)))                   # Dimension
        else:
            splitSz = None
            splitReg = False

        ascending = params.getBoolean("ascending", True)
        sortID = TxnSortOrder.fromInt(params.getInt("sort", -1), ascending)                     # TxnSortOrder

        if sortID:
            pass

        oneLineMode = params.getBoolean("oneline", False)                                     # boolean

        position = params.getString("position", params.getString("offset", None))               # String
        if position:
            pass

        position2 = params.getString("position2", params.getString("offset2", None))            # String
        if position2:
            pass

        theUUID = None
        if dataObject: theUUID = dataObject.getUUID()

        if debug:
            myPrint("DB","Object: ", dataObject, theUUID)
            myPrint("DB","Analysing the key: %s" %preferencesKey)
            myPrint("DB",":oneline:", oneLineMode, type(oneLineMode))
            myPrint("DB","splitreg:", splitReg, type(splitReg))
            myPrint("DB","splitsz:", splitSz, type(splitSz))
            myPrint("DB","sort:", sortID, type(sortID))
            myPrint("DB","position:", position, type(position))
            myPrint("DB","ascending:", ascending, type(ascending))
            myPrint("DB","cols:", widths, type(widths))
            myPrint("DB","position2:", position2, type(position2))

        return [oneLineMode, splitReg, splitSz, sortID, position, ascending, widths, position2]

    # def extract_StuWareSoftSystems_version(theVersionToCheck):
    #
    #     _MAJOR = 0
    #     _MINOR = 1
    #
    #     theVersionToCheck = str(theVersionToCheck).strip()
    #
    #     if len(theVersionToCheck) < 1: return [0,0]
    #
    #     if len(theVersionToCheck) == 1: return [int(theVersionToCheck),0]
    #
    #     if "." in theVersionToCheck:
    #         x = theVersionToCheck.split(".")
    #         return [int(x[0]),x[1]]
    #
    #     major = minor = ""
    #
    #     for char in theVersionToCheck:
    #         if (not minor) and (char >= "0" and char <= "9"): # noqa
    #             major += char
    #             continue
    #         minor+=char
    #
    #     if debug:
    #         myPrint("D","Decoded: %s.%s" %(major,minor))
    #
    #     try:
    #         return [int(major),minor]
    #     except:
    #         return [0,0]

#     def check_for_old_StuWareSoftSystems_scripts():
#         lVersionWarning = False
#
#         if not GlobalVars.parametersLoadedFromFile and not GlobalVars.lPickle_version_warning:
#             return
#
#         displayData = "\nStuWareSoftSystems: ALERT INFORMATION ABOUT SCRIPTS:\n\n"
#
#         if GlobalVars.lPickle_version_warning:
#             displayData += "I detected an older (encrypted) version of saved parameter file for use with my Python scripts\n"
#             displayData += ".... but no problem, I have updated / converted it.\n\n"
#
#         _MAJOR = 0
#         _MINOR = 1
#         iCountOldScripts = 0
#
#         if GlobalVars.parametersLoadedFromFile:
#
#             for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
#                 if key.startswith("__") and key != "__Author":
#                     myPrint("DB","Decoding old script versions for key: %s version_build: %s" %(key,GlobalVars.parametersLoadedFromFile[key]))
#                     theVersion = extract_StuWareSoftSystems_version(GlobalVars.parametersLoadedFromFile[key])
#                     if key == "__extract_currency_history_csv":
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key.lower() == "__StockGlance2020".lower():
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key == "__extract_reminders_to_csv":     # Old key - renamed... but see if it's around....
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key == "__extract_reminders_csv":
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key == "__extract_investment_transactions":
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     else: continue
#                     displayData+="ALERT: Script: %s is out of date - you have version_build: %s_%s\n" %(key,theVersion[_MAJOR],theVersion[_MINOR])
#                     myPrint("DB", "Script %s is out of date - PLEASE UPDATE"%key)
#                     iCountOldScripts+=1
#                     lVersionWarning = True
#
#
#         if GlobalVars.lPickle_version_warning or lVersionWarning:
#             displayData+="""
#
# The current versions are available as Extensions from the MD Menu >> Manage Extensions....
#
# NOTE: extract_data is a consolidation of all prior extract scripts - including:
# - stockglance2020.py:
# - extract_reminders_csv.py:
# - extract_currency_history_csv.py:
# - extract_investment_transactions_csv.py:
# - extract_account_registers_csv
#
# Please update any that you use before proceeding....
# """
#
#             jif = QuickJFrame("StuWareSoftSystems - Scripts alert!", displayData, 1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
#
#             txt = "PLEASE UPDATE OLDER VERSIONS OF STUWARESOFTSYSTEMS SCRIPTS!..."
#             setDisplayStatus(txt, "B")
#
#             myPopupInformationBox(jif, "You have %s older StuWareSoftSystems scripts - please upgrade them!" %(iCountOldScripts), "STUWARESOFTSYSTEMS' SCRIPTS", JOptionPane.WARNING_MESSAGE)
#
#         return

    def get_vmoptions_path():

        DEFAULT_NAME = "Moneydance.vmoptions"
        EXTENSION = ".vmoptions"

        grabProgramDir = find_the_program_install_dir()
        if grabProgramDir == "": return ""

        defaultPath = os.path.join(grabProgramDir, DEFAULT_NAME)

        launchName = System.getProperty("exe4j.launchName","")
        if not os.path.exists(launchName): return defaultPath

        baseName = os.path.basename(launchName)
        splitBaseName = os.path.splitext(baseName)

        vmoptionsPath = os.path.join(grabProgramDir, splitBaseName[0] + EXTENSION)
        if not os.path.exists(vmoptionsPath): return defaultPath

        return vmoptionsPath

    def find_the_program_install_dir():

        theDir = ""                                                                                                     # noqa

        if Platform.isOSX():
            # Derive from these - not great, but OK: java.home, java.library.path, sun.boot.library.path

            test = System.getProperty("java.home","").strip()
            _i = test.lower().find(".app/")                                                                             # noqa
            if _i > 0:
                theDir = test[:_i+4]
            else:
                theDir = System.getProperty("install4j.exeDir","").strip()
        else:
            theDir = System.getProperty("install4j.exeDir","").strip()

        if not os.path.exists(theDir):
            theDir = ""

        return theDir

    def get_orphaned_extension():

        extension_prefs = MD_REF.getUI().getPreferences().getTableSetting("gen.fmodules", StreamTable())

        # Get all keys in config dict
        st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
        confirmed_extn_keys = {}
        for theKey in tk:
            if not theKey.lower().startswith("confirmedext."):
                continue    # skip
            confirmed_extn_keys[theKey.split('.')[1].lower().strip()]  = theKey

        outdated = {}
        if float(MD_REF.getBuild()) < 3051:
            # .getOutdatedExtensionIDs() name changed prior to 3051
            x = MD_REF.getOutdatedExtensionIDs()                                                                        # noqa
        else:
            x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
        for y in x: outdated[y.lower().strip()] = True

        ok = {}
        x = MD_REF.getLoadedModules()
        for y in x: ok[str(y.getIDStr()).lower().strip()] = True
        x = MD_REF.getSuppressedExtensionIDs()
        for y in x: ok[str(y).lower().strip()] = True

        orphan_outdated_prefs = {}
        for extn_pref in extension_prefs:
            if not ok.get(extn_pref.lower().strip()) and not outdated.get(extn_pref.lower().strip()):
                orphan_outdated_prefs[extn_pref] = "ORPHAN"
            elif outdated.get(extn_pref.lower().strip()):
                orphan_outdated_prefs[extn_pref] = "OUTDATED"

        orphan_confirmed_extn_keys = {}
        for extn_pref in confirmed_extn_keys:
            if not ok.get(extn_pref.lower().strip()) and not outdated.get(extn_pref.lower().strip()):
                orphan_confirmed_extn_keys[extn_pref] = ["ORPHAN",confirmed_extn_keys.get(extn_pref.lower().strip())]
            elif outdated.get(extn_pref.lower().strip()):
                orphan_confirmed_extn_keys[extn_pref] = ["OUTDATED",confirmed_extn_keys.get(extn_pref.lower().strip())]

        orphan_outdated_files = {}
        extn_files_found = []

        extensionDir = Common.getFeatureModulesDirectory()
        if extensionDir:
            # noinspection PyTypeChecker
            for root, dirs, files in os.walk(extensionDir.getAbsolutePath()):
                for filename in files:
                    for extn in ModuleLoader.FEATURE_MODULE_EXTENSIONS:
                        if filename.endswith("."+extn):
                            # got an Extension
                            extn_files_found.append([os.path.splitext(filename)[0].lower().strip(),filename])
                            pass

        for extn_file in extn_files_found:
            if not ok.get(extn_file[0]):
                if outdated.get(extn_file[0]):
                    orphan_outdated_files[extn_file[0]] = ["OUTDATED",extn_file[1]]
                else:
                    orphan_outdated_files[extn_file[0]] = ["ORPHAN",extn_file[1]]

        myPrint("DB","OK Extensions:", ok)
        myPrint("DB","OUTDATED: Extensions:", outdated)
        myPrint("DB","ORPHAN/OUTDATED Extension Preferences:", orphan_outdated_prefs)
        myPrint("DB","ORPHAN/OUTDATED Extension Files:", orphan_outdated_files)
        return [orphan_outdated_prefs, orphan_outdated_files, orphan_confirmed_extn_keys]

    # noinspection PyUnresolvedReferences
    def diagnose_currencies(lFix=False):

        # MD2017.10 backwards did not use the 'rrate' parameter. It only used 'rate'
        # 'rate' was the raw rate expressed as a factor of the difference in decimal places relative to the base currency.
        # From MD2019 onwards, the 'relative' currency setup changed and 'rrate' was created. 'rrate' stored the actual rate.
        # It was supposed to be the case that MD2019+ would see the missing 'rrate' field and convert the legacy rate in memory
        # Even though new 'rrate' was now in memory (in a variable), the data was not stored back to the parameter 'rrate', and was always missing
        # Once you actually edited a price using Tools/Currencies, then the new 'rrate' parameter would be created...
        # BUT, there is a bug and in fact as well as the new 'rrate' the old 'rate' was changed too. So, backwards compatibility to 2017 was lost.

        # Example: Stock: Price 6.25 Old 'rate' was stored as 16 (2dpc) in MD2017. In MD2019 new 'rrate' is 0.16.
        # Old 'rate' was supposed to always stay as 16, but once edited in MD2019 it became 0.16 too (BUG).
        # This does not matter for MD2019 onwards as it's legacy and ignored.
        # However, if you go back to MD2017, then you will see your Current Price become 625 as 'rate' is now wrong....
        # Also, if you use the edit decimal places function in Toolbox, then you will also have a rate dpc issue if you go back to 2017.

        # There was another bug, in that if you edited any part of the CurrencyType record where the 'rrate' was missing,
        # then .itemWasUpdated() would run and reload the new rate in memory (from 'rrate') which was missing. This then corrupted the rate
        # This was addressed in MD2021.2(3089), and .itemWillSync() was changed so that 'rrate' parameter is set (in memory) if missing.
        # It appears that upon opening a dataset in MD2021.2(3089) onwards, that this change updates all missing rrate parameters in memory.....
        # These in memory changes are not saved by calling .syncIntem(), thus they only exist in memory unless a subsequent update is made and .syncItem() called
        # .... so the change does not exist in trunk or any .txn file until a subsequent change..
        # And so, updating the record in MD2021.2(3089) onwards is not an issue.
        # I'm assuming as these are not sync'd that sync copies must also run the matching MD version and will self-apply the same in memory fixes...

        # Given this knowledge, I have disabled any updates to legacy 'rate', and I now only touch 'rrate'.
        # MD can do whatever it wants (rightly or wrongly to 'rate')
        # I would expect that this fix utility will now only find relative rate errors not rate/rrate errors from MD2021.1(3089)+

        # Other notes:
        # Currencies can only be relative to base (and should be set to None)
        # Securities should be set to Base (as None), or can be relative to another Currency (not Security)
        # Max relative relational depth is SEC>CURR>Base or CURR>Base

        _THIS_METHOD_NAME = "Diagnose currencies / securities (including relative currencies)"
        if lFix: _THIS_METHOD_NAME = "FIX currencies / securities (including relative currencies)"

        PARAM_RATE = "rate"
        PARAM_RRATE = "rrate"
        PARAM_REL_CURR_ID = "rel_curr_id"
        PARAM_RELATIVE_TO_CURRID = "relative_to_currid"

        # reset_relative_currencies.py
        myPrint("B", "Script running to %s ..............." %(_THIS_METHOD_NAME))

        if MD_REF.getCurrentAccountBook() is None: return

        VERBOSE = True
        lFixErrors = lFixWarnings = False
        lCurrencies = lSecurities = True


        def validateCurrencyKeys(theCurr):

            _rCurrByIDs = theCurr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
            if _rCurrByIDs: return True

            _get_rel_curr_id = theCurr.getParameter(PARAM_REL_CURR_ID,None)
            _get_relative_to_currid = theCurr.getParameter(PARAM_RELATIVE_TO_CURRID,None)

            if not _get_rel_curr_id and not _get_relative_to_currid: return True

            return False


        if lFix:
            if not GlobalVars.fixRCurrencyCheck:
                txt = "Sorry, you must run 'DIAG: Diagnose Currencies / Securities' first! - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            elif GlobalVars.fixRCurrencyCheck == 1:
                txt = "'DIAG: Diagnose Currencies / Securities' reported no issues - so I will not run fixes - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            elif GlobalVars.fixRCurrencyCheck == 2:
                pass
            elif GlobalVars.fixRCurrencyCheck != 3:
                txt = "LOGIC ERROR reviewing 'DIAG: Diagnose Currencies / Securities' - so I will not run fixes - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            user_fixOnlyErrors = JRadioButton("Fix only Errors (ignore warnings)?", False)
            user_fixErrorsAndWarnings = JRadioButton("Fix Errors AND warnings?", False)
            bg1 = ButtonGroup()
            bg1.add(user_fixOnlyErrors)
            bg1.add(user_fixErrorsAndWarnings)

            user_fixOnlyCurrencies = JRadioButton("Fix only Currencies?", False)
            user_fixOnlySecurities = JRadioButton("Fix only Securities?", False)
            user_fixBothCurrenciesAndSecurities = JRadioButton("Fix BOTH Currencies AND Securities?", False)
            bg2 = ButtonGroup()
            bg2.add(user_fixOnlyCurrencies)
            bg2.add(user_fixOnlySecurities)
            bg2.add(user_fixBothCurrenciesAndSecurities)

            user_VERBOSE = JCheckBox("Verbose Output?",True)
            userFilters = JPanel(GridLayout(0, 1))

            if GlobalVars.fixRCurrencyCheck != 2:
                userFilters.add(user_fixOnlyErrors)
            userFilters.add(user_fixErrorsAndWarnings)
            userFilters.add(JLabel("-------------"))
            userFilters.add(user_fixOnlyCurrencies)
            userFilters.add(user_fixOnlySecurities)
            userFilters.add(user_fixBothCurrenciesAndSecurities)
            userFilters.add(JLabel("-------------"))
            userFilters.add(user_VERBOSE)

            while True:
                options = ["EXIT", "PROCEED"]
                userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                           userFilters,
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.OK_CANCEL_OPTION,
                                                           JOptionPane.QUESTION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           options, options[0]))
                if userAction != 1:
                    txt = "'%s' - No changes made....." %(_THIS_METHOD_NAME.upper())
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,_THIS_METHOD_NAME,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if not user_fixOnlyErrors.isSelected() and not user_fixErrorsAndWarnings.isSelected():
                    continue
                if not user_fixOnlyCurrencies.isSelected() and not user_fixOnlySecurities.isSelected() and not user_fixBothCurrenciesAndSecurities.isSelected():
                    continue
                break

            del userFilters, bg1, bg2

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "EXECUTE '%s'?" %(_THIS_METHOD_NAME.upper())):
                return

            VERBOSE = user_VERBOSE.isSelected()
            lFixErrors = True
            lFixWarnings = user_fixErrorsAndWarnings.isSelected()
            lCurrencies = (user_fixOnlyCurrencies.isSelected() or user_fixBothCurrenciesAndSecurities.isSelected())
            lSecurities = (user_fixOnlySecurities.isSelected() or user_fixBothCurrenciesAndSecurities.isSelected())

        else:

            txt = "Diagnosing Currencies/Securities"
            if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


        # OK - let's do it!
        GlobalVars.fixRCurrencyCheck = None

        lNeedFixScript = False
        iWarnings = 0

        currencies = MD_REF.getCurrentAccountBook().getCurrencies()
        baseCurr = currencies.getBaseType()

        output = "%s: \n" \
                 " ===================================================\n\n" %(_THIS_METHOD_NAME)

        # Catch any error during update - this would be bad! :-<
        try:
            if lFix:
                output += "FIX MODE:\n" \
                          " ========\n" \
                          "Parameters Selected:\n" \
                          "- Fix Errors: %s\n" \
                          "- Fix Errors and Warnings: %s\n" \
                          "- Fix Currencies: %s\n" \
                          "- Fix Securities: %s\n" \
                          "- VERBOSE: %s\n\n" \
                          % (lFixErrors, lFixWarnings, lCurrencies, lSecurities, VERBOSE)

                MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
                MD_REF.getCurrentAccountBook().setRecalcBalances(False)
                MD_REF.getUI().setSuspendRefresh(True)

            # ##########################################################################################################
            # BASE CURRENCY FIRST
            # ##########################################################################################################
            if not lFix or lCurrencies:
                output += "Analysing the Base currency setup....\n"
                output += "Base currency: %s\n" % baseCurr

                lSyncNeeded = False

                # Relative Rate - should always be 1.0
                if baseCurr.getParameter(PARAM_RRATE, None) is None or not isGoodRate(baseCurr.getDoubleParameter(PARAM_RRATE, 0.0)) or baseCurr.getDoubleParameter(PARAM_RRATE, 0.0) != 1.0:
                    txt = "@@ERROR@@ - base currency '%s' has (new) relative 'rrate' <> 1: %s (whereas legacy 'rate' is set to: %s)" \
                          %(baseCurr, baseCurr.getParameter(PARAM_RRATE, None), baseCurr.getParameter(PARAM_RATE, None))
                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    lNeedFixScript = True
                    if lFix:
                        lSyncNeeded = True
                        baseCurr.setEditingMode()
                        baseCurr.setParameter(PARAM_RATE, 1.0)
                        baseCurr.setParameter(PARAM_RRATE, 1.0)
                        baseCurr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
                        baseCurr.setRate(1.0, None)

                        txt = "@@BASE CURRENCY FIX APPLIED (set 'rrate' to 1.0) @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                if lSyncNeeded:
                    baseCurr.syncItem(); lSyncNeeded = False                                                            # noqa

                if not lNeedFixScript:
                    output += ("Base currency has legacy 'rate' of: %s and new relative 'rrate': of %s >> 'rrate' is correct...\n"
                               % (baseCurr.getParameter(PARAM_RATE, None), baseCurr.getParameter(PARAM_RRATE, None)))

                # Check for price history - should be none on base currency (also now handled by MD launch)
                baseSnapshots = baseCurr.getSnapshots()
                if baseSnapshots.size() > 0:
                    lNeedFixScript = True
                    txt = "ERROR: base currency has %s historical prices! These need to be deleted!" %(baseSnapshots.size())
                    myPrint("J",txt); output += "----\n%s\n----\n" %(txt)
                    for baseSnapshot in baseSnapshots:
                        if lFix:
                            output += "  @@DELETING@@: %s\n" % (baseSnapshot)
                            baseSnapshot.deleteItem()
                        else:
                            if VERBOSE:
                                output += "  snapshot: %s\n" % baseSnapshot
                else:
                    output += "\nBase currency has no historical prices. This is correct\n"

                # Check Root account's currency is base
                root = MD_REF.getCurrentAccountBook().getRootAccount()
                if root.getCurrencyType() != baseCurr:
                    lNeedFixScript = True

                    txt = "Root account's currency: '%s', Base currency: '%s'" %(root.getCurrencyType(), baseCurr)
                    myPrint("J", txt); output += "%s\n" %(txt)

                    txt = "ERROR - The root account's currency is not set to base! This needs correcting!"
                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                    if lFix:
                        root.setCurrencyType(baseCurr); root.syncItem()
                        txt = "@@ROOT ACCOUNT CURRENCY FIX APPLIED (set to base)@@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                else:
                    output += "GOOD, the 'root' account's currency is set to the base currency! Root: '%s', Base: '%s'\n" % (root.getCurrencyType(), baseCurr)


            # Sort the table so that Currencies and Securities are together and by name
            currencies = sorted(currencies, key=lambda x: (x.getCurrencyType(), x.getName().upper()))

            last = None
            lWarning = False
            output += "\nAnalysing the Currency / Security table...\n" \
                      " ===========================================\n"

            for curr in currencies:

                if curr.getCurrencyType() != last:
                    output += "\n\n TYPE: %s\n" \
                              " ========================\n" %(curr.getCurrencyType())
                    last = curr.getCurrencyType()

                if curr.getCurrencyType() == CurrencyType.Type.SECURITY:

                    # ##################################################################################################
                    # SECURITIES
                    # ##################################################################################################
                    if lFix and not lSecurities: continue

                    lSyncNeeded = False

                    if VERBOSE:
                        output += " ----------------------------------------------------------------------------------------\n" \
                                  "Checking security: '%s' (uuid: %s)\n" %(curr, curr.getUUID())

                    get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID,None)
                    get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID,None)

                    rCurr = curr.getRelativeCurrency()
                    rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                    # This might still miss where one of the parameters is set, but the other is not, or where one is 'invalid'.... but let's see
                    if get_relative_to_currid is None and get_rel_curr_id is None:
                        pass    # This is OK, None is fine and means base
                    elif rCurrByIDs is None and rCurr is None:
                        pass    # This is OK, None is fine and means base
                    elif rCurrByIDs is not None and rCurrByIDs != baseCurr and rCurrByIDs.getCurrencyType() == CurrencyType.Type.CURRENCY:
                        pass    # This is OK, non-base currency is OK
                    elif rCurr is not None and rCurr != baseCurr and rCurr.getCurrencyType() == CurrencyType.Type.CURRENCY:
                        pass    # This is OK, non-base currency is OK
                    else:
                        if validateCurrencyKeys(curr):
                            lValidateCurrencies = True
                            txt = "@@ WARNING: '%s' relative_to_currid / rel_curr_id should only be None or NOT your base currency (currently %s : %s)!" %(curr,get_relative_to_currid,get_rel_curr_id)
                        else:
                            lValidateCurrencies = False
                            txt = "@@ WARNING: '%s' The relative currency appears to be missing? Either use Tools>Securities to fix manually, or this fix will reset it to base currency." %(curr)
                        myPrint("J", txt); output += "---\n%s\n" %(txt)
                        if lFix and lFixWarnings:
                            lSyncNeeded = True
                            curr.setEditingMode()
                            curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)  # Force the parameters in regardless!
                            if lValidateCurrencies:
                                txt = "@@SECURITY FIX APPLIED (set relative currency parameters to None) @@"
                            else:
                                txt = "@@SECURITY FIX APPLIED (reset the missing relative currency back to None - PLEASE VERIFY PRICE AND HISTORY IN TOOLS>SECURITIES!) @@"
                            myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                        else:
                            lWarning = True; iWarnings += 1

                    # reset in case I changed these above....
                    get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID,None)
                    get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID,None)
                    rCurr = curr.getRelativeCurrency()
                    rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                    get_rate = curr.getParameter(PARAM_RATE, None)
                    get_rateDbl = curr.getDoubleParameter(PARAM_RATE, 0.0)

                    get_rrate = curr.getParameter(PARAM_RRATE, None)
                    get_rrateDbl = curr.getDoubleParameter(PARAM_RRATE, 0.0)

                    # if get_rate is None or get_rateDbl == 0.0 or not isGoodRate(get_rateDbl):
                    #     txt = "@@ WARNING: '%s' has legacy rate (rate) of ZERO/Invalid" %(curr)
                    #     myPrint("J", txt); output += "----\n%s\n" %(txt)
                    #
                    #     if lFix and lFixWarnings:
                    #         lSyncNeeded = True
                    #         curr.setEditingMode()
                    #         curr.setParameter(PARAM_RATE, 1.0)
                    #         curr.setParameter(PARAM_RRATE, 1.0)
                    #         txt = "@@SECURITY FIX APPLIED (reset both legacy rate and new rrate to 1.0) @@"
                    #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #     else:
                    #         lWarning = True; iWarnings  += 1
                    #
                    if get_rrate is None or get_rrateDbl == 0.0 or not isGoodRate(get_rrateDbl):

                        if rCurr is None or rCurrByIDs is None:
                            isRelativeBase = True
                        elif rCurr == baseCurr or rCurrByIDs == baseCurr:
                            isRelativeBase = True
                        else:
                            isRelativeBase = False

                        if isRelativeBase:  # Relative to base currency
                            newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                            txt = "@@ WARNING: '%s' new relative 'rrate' is set to: %s (whereas legacy 'rate' is currently %s). New 'rrate' should be %s (inverted %s)\n"\
                                  %(curr, get_rrate, get_rate, newRate, safeInvertRate(newRate))
                            myPrint("J", txt); output += "---\n%s\n" %(txt)

                            if isGoodRate(newRate) and lFix and lFixWarnings:
                                lSyncNeeded = True
                                curr.setEditingMode()
                                # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters)...
                                if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                                curr.setParameter(PARAM_RRATE, newRate)
                                curr.setRate(newRate, baseCurr)
                                curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
                                txt = "@@SECURITY FIX APPLIED (reset new 'rrate') @@"
                                myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                            else:
                                if not isGoodRate(newRate) and lFix and lFixWarnings:
                                    txt = "!!SECURITY FIX NOT APPLIED (cannot set 'rrate' to ZERO) !!"
                                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                                lWarning = True; iWarnings  += 1

                        else:  # Relative to another currency....

                            newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                            newRRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, rCurr))

                            txt = "@@ WARNING: '%s' ** Relative Curr is: '%s' ** legacy 'rate' is currently %s, whereas new relative 'rrate' is set to: %s. Should be new 'rrate': %s (inversed: %s)\n"\
                                  %(curr, rCurr, get_rate, get_rrate, newRRate, safeInvertRate(newRRate))
                            myPrint("J", txt); output += "---\n%s\n" %(txt)

                            if isGoodRate(newRRate) and lFix and lFixWarnings:
                                lSyncNeeded = True
                                curr.setEditingMode()
                                # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters...
                                if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                                curr.setParameter(PARAM_RRATE, newRRate)
                                curr.setRate(newRRate, rCurr)
                                txt = "@@SECURITY FIX APPLIED (reset new 'rrate') @@"
                                myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                                # Doing this here so as not to trigger MD to set rrate to 1.0 (bug)
                                if rCurrByIDs is not None \
                                        and rCurrByIDs != baseCurr \
                                        and rCurrByIDs.getCurrencyType() == CurrencyType.Type.CURRENCY \
                                        and (get_relative_to_currid is None or get_rel_curr_id is None):

                                    curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, rCurrByIDs)
                                    txt = "@@EXTRA SECURITY FIX APPLIED (set both relative currency parameters) @@"
                                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                            else:
                                if not isGoodRate(newRRate) and lFix and lFixWarnings:
                                    txt = "@@SECURITY FIX NOT APPLIED (cannot set new 'rrate' to ZERO) !!"
                                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                                lWarning = True; iWarnings  += 1


                    iCountSnapErrors = 0
                    currSnapshots = curr.getSnapshots()
                    for snap in currSnapshots:
                        if not isGoodRate(snap.getRate()):
                            iCountSnapErrors += 1
                    if iCountSnapErrors > 0:
                        output += "\n  ** NOTE: You have %s history records with a zero or infinity price/rate! **\n" %(iCountSnapErrors)

                    if lFix and lSyncNeeded:
                        curr.syncItem()

                    continue

                # ######################################################################################################
                # CURRENCIES
                # ######################################################################################################
                if lFix and not lCurrencies: continue

                lSyncNeeded = False

                if VERBOSE:
                    output += "\n-----------------------------------------------------------------------------------------------" \
                              "\nChecking currency: %s\n" % curr

                get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID, None)
                get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID, None)
                rCurr = curr.getRelativeCurrency()                                                                      # noqa
                rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                if validateCurrencyKeys(curr):
                    lValidateCurrencies = True
                else:
                    lValidateCurrencies = False

                if rCurrByIDs is not None:
                    strEnd = ""
                elif not lValidateCurrencies:
                    strEnd = " - YOU APPEAR TO HAVE A MISSING RELATIVE CURRENCY?"
                else:
                    strEnd = " - None / NOT SET (this is OK and means the Base Rate will be used)"

                if VERBOSE:
                    output += "relative_to_currid: %s, rel_curr_id: %s %s\n" %(get_relative_to_currid, get_rel_curr_id, strEnd)

                if rCurrByIDs is not None or not lValidateCurrencies:
                    if lValidateCurrencies:
                        txt = "@@ WARNING: '%s' relative_to_currid & rel_curr_id should both be set to None (which means use base currency)!" %(curr)
                    else:
                        txt = "@@ WARNING: '%s' You have a missing Relative Currency. This fix can reset it back to base currency." %(curr)
                    myPrint("J", "%s" %(txt)); output += "----\n%s\n----\n" %(txt)

                    if lFix and lFixWarnings:
                        lSyncNeeded = True
                        curr.setEditingMode()
                        curr.setRelativeCurrency(None)  # This converts the snaps too!
                        curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)  # Force the parameters in regardless
                        if lValidateCurrencies:
                            if rCurrByIDs == baseCurr:
                                txt = "@@CURRENCY FIX APPLIED (set both relative currency parameters to None) @@"
                            else:
                                txt = "@@CURRENCY FIX APPLIED (set relative currency parameters to None, rates, price history converted back to base) >> REVIEW CURRENT PRICE & HISTORICAL PRICES IN TOOLS>CURRENCIES! @@"
                        else:
                            txt = "@@CURRENCY FIX APPLIED (missing relative currency reset to base) >> REVIEW CURRENT PRICE & HISTORICAL PRICES IN TOOLS>CURRENCIES! @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    else:
                        lWarning = True; iWarnings += 1

                get_rate = curr.getParameter(PARAM_RATE, None)
                get_rateDbl = curr.getDoubleParameter(PARAM_RATE, 0.0)

                get_rrate = curr.getParameter(PARAM_RRATE, None)
                get_rrateDbl = curr.getDoubleParameter(PARAM_RRATE, 0.0)

                if VERBOSE:
                    output += "Legacy 'rate': %s (inverted: %s)\n" % (get_rate, safeInvertRate(get_rateDbl))

                if get_rate is not None and isGoodRate(get_rateDbl) and get_rrate is not None and isGoodRate(get_rateDbl):

                    if VERBOSE:
                        output += "New relative 'rrate': %s (inverted: %s)\n" % (get_rrate, safeInvertRate(get_rrateDbl))

                elif curr == baseCurr:
                    # Note: We fix base earlier on....
                    pass

                else:

                    # if get_rate is None or get_rateDbl == 0.0 or not isGoodRate(get_rateDbl):
                    #     txt = "@@ WARNING: '%s' has legacy 'rate' of ZERO/Invalid" %(curr)
                    #     myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #
                    #     if lFix and lFixWarnings:
                    #         lSyncNeeded = True
                    #         curr.setEditingMode()
                    #         curr.setParameter(PARAM_RATE, 1.0)
                    #         curr.setParameter(PARAM_RRATE, 1.0)
                    #         txt = "@@CURRENCY FIX APPLIED (reset both 'rate' and 'rrate' to 1.0) @@"
                    #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #     else:
                    #         lWarning = True; iWarnings  += 1
                    #

                    # should always be set and always relative to base (1.0)
                    newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                    txt = "@@ WARNING: '%s' new relative 'rrate' is set to: %s (whereas legacy 'rate' is currently %s). 'rrate' should be %s (inverted %s)" \
                          %(curr, get_rrate, get_rate, newRate, safeInvertRate(newRate))
                    myPrint("J", txt); output += "---\n%s\n---\n" %(txt)

                    if isGoodRate(newRate) and lFix and lFixWarnings:
                        lSyncNeeded = True
                        curr.setEditingMode()
                        # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters...
                        if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                        curr.setParameter(PARAM_RRATE, newRate)
                        curr.setRate(newRate, baseCurr)
                        txt = "@@CURRENCY FIX APPLIED (reset new 'rrate') @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    else:
                        if not isGoodRate(newRate) and lFix and lFixWarnings:
                            txt = "!!CURRENCY FIX NOT APPLIED (cannot set 'rrate' to ZERO) !!"
                            myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                        lWarning = True; iWarnings  += 1

                if lFix and lSyncNeeded:
                    curr.syncItem()

                if not lFix and VERBOSE:
                    output += "  details:\n"
                    output += "\t" + "ID:             %s    (uuid: %s)\n" %(curr.getID(), curr.getUUID())
                    output += "\t" + "Name:           %s\n" %(curr.getName())
                    if curr.getTickerSymbol():
                        output += "\t" + "Ticker:         %s\n" %(curr.getTickerSymbol())
                    output += "\t" + "Curr_ID:        %s\n" %(curr.getIDString())
                    output += "\t" + "Decimal Places: %s\n" %(curr.getDecimalPlaces())
                    if curr.getHideInUI():
                        output += "\t" + "Hide in UI:     %s\n" %(curr.getHideInUI())
                    output += "\t" + "Effective Date: %s\n" %(convertStrippedIntDateFormattedText(curr.getEffectiveDateInt()))
                    if curr.getPrefix():
                        output += "\t" + "Prefix:         %s\n" %(curr.getPrefix())
                    if curr.getSuffix():
                        output += "\t" + "Suffix:         %s\n" %(curr.getSuffix())

                    output += "  pricing history (latest 2 prices):\n"
                    currSnapshots = curr.getSnapshots()
                    if currSnapshots.size() > 0:
                        i = 0
                        for currSnapshot in reversed(currSnapshots):
                            i += 1
                            output += "    snapshot: %s (reversed: %s)\n" % (currSnapshot, currSnapshot.getRate())
                            if i >= 2:
                                break
                    else:
                        if curr != baseCurr:
                            output += "  This currency has no historical prices? Is this correct?\n"
                        else:
                            output += "  Good - This currency has no historical prices...\n"

                    iCountSnapErrors = 0
                    for snap in currSnapshots:
                        if not isGoodRate(snap.getRate()):
                            iCountSnapErrors += 1
                    if iCountSnapErrors > 0:
                        output += "\n  ** NOTE: You have %s history records with a zero or infinity price/rate! **\n" %(iCountSnapErrors)

            output += " ----------------------------------------------------------------\n"

        except:

            txt = ("MAJOR ERROR - '%s' crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()

            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lAlertLevel=2, lWrapText=False, lAutoSize=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:
            if lFix:
                MD_REF.saveCurrentAccount()
                MD_REF.getCurrentAccountBook().setRecalcBalances(True)
                MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        if lFix:
            GlobalVars.fixRCurrencyCheck = None
            myPrint("B", ">> Currency / Security errors / warning - FIXES APPLIED..")
            output += "\nRELEVANT FIXES APPLIED\n\n"
            output += "\nDISCLAIMER: Please verify your data before proceeding\n"

            if lWarning:
                output += "\n@@@@ You still have %s Warning(s)..\n" % iWarnings

            txt = "@@ CURRENCY / SECURITY FIXES APPLIED - Please review diagnostic report for details!"
            msgType = JOptionPane.WARNING_MESSAGE
            statusColor = "R"

            logToolboxUpdates("diagnose_currencies", txt)

            play_the_money_sound()

        else:

            if lNeedFixScript:
                GlobalVars.fixRCurrencyCheck = 3
                txt = ">> Currency / Security errors detected - Consider running the FIX option.."
                myPrint("B", txt); output += "%s\n" %(txt)
                output += "\nERROR: You have Currency / Security errors..\n"
                output += "Consider running the 'FIX CURRENCIES & SECURITIES' option\n"
                output += "DISCLAIMER: Always backup your data before running change scripts and verify the result before continuing...\n"
                txt = "ERROR: You have Currency / Security errors.. Please review diagnostic report!"
                msgType = JOptionPane.ERROR_MESSAGE
                statusColor = "R"

            elif lWarning:
                GlobalVars.fixRCurrencyCheck = 2
                txt = "You have %s Warning(s).." %(iWarnings)
                myPrint("B", txt); output += "%s\n" %(txt)
                output += "These are where your Currency records show a relative currency that's not None...;\n" \
                          "... or where Securities have an incorrect relative currency set..\n"\
                          "... or where a Currency/Security's new 'rrate' (relative rate) is not set, or different to the legacy 'rate'...\n"\
                          "... or where an 'invalid' / 'infinity' / ZERO / Not A Number (NaN) rate / 'rrate' was found\n" \
                          "NOTE: Often these issues are from 'legacy' MD2017 records that need updating to MD2019+ format by adding the 'rrate' field\n" \
                          "      MD2021.2 has fixes built in to address the 'rrate' issues....\n"
                output += "Consider running the 'FIX CURRENCIES & SECURITIES' option\n"
                output += "DISCLAIMER: Always backup your data before running change scripts and verify the result before continuing...\n"
                txt = "ERROR: You have %s Currency / Security warnings.. Please review diagnostic report!" %(iWarnings)
                msgType = JOptionPane.WARNING_MESSAGE
                statusColor = "R"

            else:
                GlobalVars.fixRCurrencyCheck = 1
                txt = "All good, Currencies / Securities look clean! Congratulations!"
                myPrint("J", txt); output += "\n%s\n" %(txt)
                msgType = JOptionPane.INFORMATION_MESSAGE
                statusColor = "DG"

        output += "\n<END>"

        if lFix:
            theTitle = "%s: (FIX ERRORS)" %(_THIS_METHOD_NAME.upper())
        else:
            theTitle = "%s: (LOOK FOR ERRORS)" %(_THIS_METHOD_NAME.upper())

        alertLevel = 0
        if iWarnings: alertLevel = 1
        if lNeedFixScript: alertLevel = 2

        jif = QuickJFrame(theTitle,output,lAlertLevel=alertLevel, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lRestartMDAfterClose=lFix, lAutoSize=True).show_the_frame()

        setDisplayStatus(txt, statusColor)
        play_the_money_sound()
        myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME.upper(), theMessageType=msgType)

        if lFix:
            disableToolboxButtons()
            myPopupInformationBox(jif,"RESTART OF MONEYDANCE REQUIRED - MD WILL RESTART AFTER VIEWING THIS OUTPUT", _THIS_METHOD_NAME.upper(), theMessageType=JOptionPane.ERROR_MESSAGE)

        return output

    class BackupButtonAction(AbstractAction):
        theString = ""

        def __init__(self, theQuestion):
            self.theQuestion = theQuestion

        def actionPerformed(self, event):                                                                               # noqa
            if myPopupAskBackup(toolbox_frame_, self.theQuestion, lReturnTheTruth=True):
                txt = "Backup created as requested.."
                setDisplayStatus(txt, "B")
            else:
                txt = "User declined to create backup.."
                setDisplayStatus(txt, "R")

    def backup_custom_theme_file():

        # noinspection PyUnresolvedReferences
        themeFile = ThemeInfo.customThemeFile

        newFileName = os.path.splitext(themeFile.getName())[0]+get_filename_addition()+os.path.splitext(themeFile.getName())[1]+"_$SAVED$"
        newFile = File(themeFile.getParent(), newFileName)

        try:
            MDIOUtils.copy(themeFile, newFile)
            myPrint("B", "Custom theme file: backup / copied to %s prior to deletion...."%newFileName)
            return True
        except:
            myPrint("B", "Error: Failed to backup/copy custom theme file prior to deletion....")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def backup_local_storage_settings( lSaveFirst=True ):

        if lSaveFirst:
            MD_REF.getCurrentAccountBook().getLocalStorage().save()  # Flush settings to disk before changes

        # I would rather have called LocalStorage() to get the filepath, but it doesn't give the path
        # NOTE  - This backup copy will be encrypted, so you can just put it back to ./safe/settings.
        localStorage_file = File(os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME, "settings"))
        copy_localStorage_filename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(), "settings")

        try:
            newFileName = copy_localStorage_filename+get_filename_addition() + "_$SAVED$"
            newFile = File(newFileName)

            MDIOUtils.copy(localStorage_file, newFile)
            myPrint("DB", "LocalStorage() ./safe/settings copied to %s prior to any changes...." %(newFileName))
            return True

        except:
            myPrint("B","@@ ERROR - failed to copy LocalStorage() ./safe/settings prior to any changes!?")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def backup_config_dict(lSaveFirst=True):

        if lSaveFirst:
            MD_REF.savePreferences()  # Flush settings to disk before copy

        try:
            configFile = Common.getPreferencesFile()
            newFileName = os.path.splitext(configFile.getName())[0]+get_filename_addition()+os.path.splitext(configFile.getName())[1]+"_$SAVED$"
            newFile = File(configFile.getParent(), newFileName)

            MDIOUtils.copy(configFile, newFile)
            myPrint("DB", "config.dict backup/copy made to %s prior to changes...." %(newFileName))
            return True
        except:
            myPrint("B","@@ ERROR - failed to backup/copy config.dict prior to changes!?")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def get_sync_folder(lReturnFileOrURLObject=False):

        if MD_REF.getCurrentAccountBook() is None: return None

        try:
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

            # New feature and Mac only
            if Platform.isOSX() and int(MD_REF.getBuild()) >= GlobalVars.MD_ICLOUD_ENABLED and isinstance(syncMethod, ICloudSyncConfigurer):
                syncF = syncMethod.getSyncFolder()

                p_icloudObject = getFieldByReflection(syncF, "icloud")
                if isinstance(p_icloudObject, ICloudContainer): pass

                syncBaseFolder = invokeMethodByReflection(p_icloudObject, "nativeGetICloudPath", None)
                saveSyncFolder = os.path.join(syncBaseFolder, "Documents", "sync", syncF.getSubpath())

                if os.path.exists(saveSyncFolder):
                    myPrint("DB", "icloud folder found:", saveSyncFolder)
                    return (saveSyncFolder if not lReturnFileOrURLObject else File(saveSyncFolder))

            elif isinstance(syncMethod, DropboxSyncConfigurer):
                syncF = syncMethod.getSyncFolder()
                syncBaseFolder = syncF.toString()                                                                       # noqa
                APIStr = "DropboxAPI:"
                baseURL = "https://www.dropbox.com/home"
                dropboxURL = URL(syncBaseFolder.replace(APIStr, baseURL))
                return (dropboxURL.toString() if not lReturnFileOrURLObject else dropboxURL)

            elif syncMethod is not None and syncMethod.getSyncFolder() is not None:
                syncF = syncMethod.getSyncFolder()
                syncBaseFolder = syncF.getSyncBaseFolder()                                                              # noqa
                saveSyncFolder = os.path.join(syncBaseFolder.getCanonicalPath(), syncF.getSubpath())
                if os.path.exists(saveSyncFolder):
                    myPrint("DB", "sync folder found:", syncBaseFolder)
                    return (saveSyncFolder if not lReturnFileOrURLObject else File(saveSyncFolder))
        except:
            myPrint("B", "ERROR: in .get_sync_folder()")
            dump_sys_error_to_md_console_and_errorlog()

        return None

    def check_for_dropbox_folder():

        try:
            # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
            # MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

            dropboxOption = SyncFolderUtil.configurerForIDFromList("dropbox_folder", syncMethods)

            if (not dropboxOption) or syncMethod.getSyncFolder():
                return True
        except:
            # If there is a problem with Dropbox, .getSyncFolder() will crash....
            return True

        userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
        baseFolder = File(userHomeProperty, "Dropbox")
        dropbox = File(baseFolder, ".moneydancesync")

        # If Dropbox folder does not exist then do nothing
        if not (baseFolder.exists() and baseFolder.isDirectory()):
            return True

        if dropbox.exists() and dropbox.isDirectory():
            return True

        return False

    def tell_me_if_dropbox_folder_exists():

        userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
        baseFolder = File(userHomeProperty, "Dropbox")
        dropbox = File(baseFolder, ".moneydancesync")

        # If Dropbox folder does not exist then do nothing
        if baseFolder.exists() and baseFolder.isDirectory() and dropbox.exists() and dropbox.isDirectory():
            return dropbox.getCanonicalPath()

        return False

    def terminate_script():
        myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")

        try:
            # NOTE - .dispose() - The windowClosed event should set .isActiveInMoneydance False and .removeAppEventListener()
            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(GenericDisposeRunnable(toolbox_frame_))
            else:
                toolbox_frame_.dispose()
        except:
            myPrint("B","Error. Final dispose failed....?")
            dump_sys_error_to_md_console_and_errorlog()

    def getUserSelectedServiceProfile(_theFrame, _theTitle, _theQuestion, lIncludePlaidWhenUnlocked=False):

        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        newServiceList = []
        for sv in serviceList:
            if sv.getTIKServiceID() == "md:plaid":
                if not lIncludePlaidWhenUnlocked:   continue
                if not isToolboxUnlocked():         continue
            newServiceList.append(StoreService(sv))

        service = JOptionPane.showInputDialog(_theFrame,
                                              _theQuestion,
                                              _theTitle,
                                              JOptionPane.INFORMATION_MESSAGE,
                                              getMDIcon(lAlwaysGetIcon=True),
                                              newServiceList,
                                              None)             # type: StoreService

        if not service:
            txt = "%s: - No Service was selected - no changes made.." %(_theTitle)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return None
        return service.getService()

    class StoreUserID():
        def __init__(self, _userID, _password="NOT SET"):
            self.userID = _userID.strip()
            self.password = _password
            self.clientUID = None
            self.accounts = []

        @staticmethod
        def findUserID(findUserID, listOfUserIDs):
            # type: (str, [StoreUserID]) -> StoreUserID
            """
            Static Method to search a [list] of StoreUserID()
            """
            for userIDFromList in listOfUserIDs:
                if findUserID.lower().strip() == userIDFromList.getUserID().lower().strip(): return userIDFromList
            return None

        def setPassword(self, _password):       self.password = _password
        def setClientUID(self, _clientUID):     self.clientUID = _clientUID
        def setAccounts(self, _accounts):       self.accounts = _accounts

        def getUserID(self):    return self.userID
        def getPassword(self):  return self.password
        def getClientUID(self): return self.clientUID
        def getAccounts(self):  return self.accounts

        def __str__(self): return "UserID: %s Password: <%s>" %(self.getUserID(), ("*"*len(self.getPassword())))
        def __repr__(self): return self.__str__()


    def clearOneServiceAuthCache():
        _THIS_METHOD_NAME = "CLEAR AUTHENTICATION FROM ONE SERVICE"

        output = "VIEW ALL CACHED AUTHENTICATION KEYS\n" \
                 " ==================================\n\n"

        lCachePasswords = isCachingPasswords()
        _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
        if len(_auth) > 0:
            keys = sorted(_auth.keys())                                                                                 # noqa
            for theKey in keys:
                value = _auth.get(theKey)                                                                               # noqa
                output += pad("Key:%s" %(theKey),40)+" Value: %s\n" %(value.strip())                                    # noqa
        else:
            if not lCachePasswords: output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
            output += "<NONE>\n"

        output+="\n<END>"
        jif = QuickJFrame("VIEW ALL CACHED AUTHENTICATION KEYS",output,lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        service = getUserSelectedServiceProfile(jif, _THIS_METHOD_NAME, "Select a service clear the Authentication Cache", lIncludePlaidWhenUnlocked=False)  # type: OnlineService
        if not service:
            jif.dispose()
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()       # already within the EDT
            return

        if confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Clear Authentication Password(s) for service:%s?" %(service)):
            # noinspection PyUnresolvedReferences
            service.clearAuthenticationCache()
            MD_REF.getCurrentAccountBook().getLocalStorage().save()

            txt = "%s: Password(s) for %s have been cleared" %(_THIS_METHOD_NAME, service)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            logToolboxUpdates("clearOneServiceAuthCache", txt)

            play_the_money_sound()
            myPopupInformationBox(jif,"Password(s) for %s have been cleared" %(service), _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        jif.dispose()

    def clearAllServicesAuthCache():
        _THIS_METHOD_NAME = "CLEAR ALL SERVICE(S)' AUTHENTICATION"

        output = "VIEW ALL CACHED AUTHENTICATION KEYS\n" \
                 " ==================================\n\n"

        lCachePasswords = isCachingPasswords()
        _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
        if len(_auth) > 0:
            keys = sorted(_auth.keys())                                                                                 # noqa
            for theKey in keys:
                value = _auth.get(theKey)                                                                               # noqa
                output += pad("Key:%s" %(theKey),40)+" Value: %s\n" %(value.strip())                                    # noqa
        else:
            if not lCachePasswords: output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
            output += "<NONE>\n"

        output+="\n<END>"
        jif = QuickJFrame("VIEW ALL EXISTING AUTHENTICATION KEYS",output,lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()       # already within the EDT
            return

        if confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Clear Authentication All Password(s) for **ALL** service(s)?"):
            MD_REF.getUI().getOnlineManager().clearAuthenticationCache()
            MD_REF.getCurrentAccountBook().getLocalStorage().save()

            txt = "%s: **ALL** Password(s) for ALL Services have been cleared" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            logToolboxUpdates("clearAllServicesAuthCache", txt)

            play_the_money_sound()
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        jif.dispose()       # already within the EDT

    class MyOFXAuthInfo(OFXAuthInfo):
        def __init__(self, _user, _pass, _extra, _cookie, _type):
            self.originalCookie = _cookie
            self.newPassword = None
            super(OFXAuthInfo, self).__init__(_user, _pass, _extra, _cookie, _type)                                     # noqa

        def getCookie(self): return self.originalCookie

        def setNewPassword(self, _newPassword):
            self.newPassword = _newPassword

        def getNewPassword(self): return self.newPassword

        def getNewEncodedAuthObj(self):
            return MyOFXAuthInfo(self.getUserId(), self.getNewPassword(), self.getExtraAuth(), self.getCookie(), self.getAuthType())

        @staticmethod
        def fromCacheString(_fromRecord):
            if _fromRecord is None: return None
            params = {}
            StringUtils.parseURLParameters(_fromRecord, params)
            authTypeStr = params.get("type")
            authType = 0
            try: authType = int(authTypeStr)
            except: pass

            return (MyOFXAuthInfo(params.get("userid"),
                                  params.get("pass"),
                                  params.get("extra"),
                                  params.get("cookie"),
                                  authType))


    def editStoredOFXPasswords():
        _THIS_METHOD_NAME = "EDIT OFX STORED PASSWORDS"

        service = getUserSelectedServiceProfile(toolbox_frame_, _THIS_METHOD_NAME, "Select a service to manage a stored Password", lIncludePlaidWhenUnlocked=False)  # type: OnlineService
        if not service: return

        output = "VIEW STORED AUTHENTICATION KEYS FOR SERVICE\n" \
                 " ==========================================\n\n"

        class StoreAuthKeyData:
            def __init__(self, _theKey, _theData):
                self.theKey = _theKey
                self.theData = _theData
                self.authObj = MyOFXAuthInfo.fromCacheString(_theData)
                self.thePassword = self.authObj.getPasswd()
                self.theUserID = self.authObj.getUserId()

            def __str__(self): return "%s User: %s Pswd: %s" %(self.theKey, self.theUserID, self.thePassword)
            def __repr__(self): return self.__str__()

        saveAuthKeys = []
        authKeys = getUpdatedAuthenticationKeys()
        for theAuthKey in sorted(authKeys.keys()):                                                                      # noqa
            if (service.getFIOrg() + "--" + service.getFIId() + "--") in theAuthKey:
                saveAuthKeys.append(StoreAuthKeyData(theAuthKey,authKeys.get(theAuthKey)))                                              # noqa
                tempAuthObj = MyOFXAuthInfo.fromCacheString(authKeys.get(theAuthKey))                                   # noqa
                output += "Key:%s" %(theAuthKey) + " Value: %s (decoded password: %s)\n" %(authKeys.get(theAuthKey), tempAuthObj.getPasswd())                     # noqa
        del authKeys

        if len(saveAuthKeys) < 1:
            txt = "%s: WARNING No stored Authentication records found for this service - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        output+="\n<END>"
        jif = QuickJFrame("VIEW EXISTING AUTHENTICATION KEYS FOR SERVICE",output,lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        selectedAuthKeyRecord = JOptionPane.showInputDialog(jif,
                                                     "Select an Authentication Key to edit",
                                                     _THIS_METHOD_NAME,
                                                     JOptionPane.INFORMATION_MESSAGE,
                                                     getMDIcon(lAlwaysGetIcon=True),
                                                     saveAuthKeys,
                                                     None)      # type: StoreAuthKeyData
        if not selectedAuthKeyRecord:
            txt = "%s: No Authentication Key selected - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if isinstance(selectedAuthKeyRecord, StoreAuthKeyData): pass
        authObj = selectedAuthKeyRecord.authObj

        if authObj is None or authObj.toString() != selectedAuthKeyRecord.theData:
            txt = "%s: ERROR - Failed to decode Authentication key (refer console) - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        newPassword = myPopupAskForInput(jif,
                                         _THIS_METHOD_NAME,
                                         "New password:",
                                         "Enter new password for user %s" %(authObj.getUserId()),
                                         defaultValue=authObj.getPasswd())
        if newPassword is None or newPassword == "" or newPassword == authObj.getPasswd():
            txt = "%s: User did not enter a new password - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Edit password for user %s within this service?" %(authObj.getUserId())):
            txt = "%s: User did not agree to proceed with changes - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()
            return

        authObj.setNewPassword(newPassword)

        MD_REF.getCurrentAccountBook().getLocalStorage().cacheAuthentication(selectedAuthKeyRecord.theKey, authObj.getNewEncodedAuthObj().toCacheString())
        # service.cacheAuthentication(selectedAuthKeyRecord.theKey, authObj.getNewEncodedAuthObj().toCacheString())

        MD_REF.getCurrentAccountBook().getLocalStorage().save()

        txt = "%s: UserID: %s Password set to: %s" %(_THIS_METHOD_NAME, authObj.getUserId(), authObj.getNewPassword())
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        logToolboxUpdates("editStoredOFXPasswords", "UserID: %s Password set to: <**REDACTED**>" %(authObj.getUserId()))

        play_the_money_sound()
        myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
        jif.dispose()

    def my_createNewClientUID():
        # com.moneydance.apps.md.view.gui.DefaultOnlineUIProxy.createNewClientUID()
        _uid = UUID.randomUUID().toString()
        _uid = StringUtils.replaceAll(_uid, "-", "").strip()
        if len(_uid) > 32: _uid = String(_uid).substring(0, 32)
        return _uid

    def manuallyPrimeUSAARootUserIDClientIDs():
        _THIS_METHOD_NAME = "USAA: Manually 'prime' Root UserIDs/ClientUIDs".upper()

        if isMDPlusEnabledBuild() and float(MD_REF.getBuild()) < 4059:
            txt = ("WARNING: You need to upgrade to at least version MD2022.1(4059) for USAA Connections to work properly! - No changes made!")
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt, _THIS_METHOD_NAME,JOptionPane.ERROR_MESSAGE)
            return

        USAA_FI_ID = "67811"
        USAA_FI_ORG = "USAA Federal Savings Bank"
        OLD_TIK_FI_ID = "md:1295"
        USAA_PROFILE_NAME = "USAA Custom Profile (ofx_create_new_usaa_bank_profile_custom.py)"

        NEW_TIK_FI_ID = "md:custom-1295"    # as of 23rd Oct, the 'official' custom profile ID

        authKeyPrefix="ofx.client_uid"
        specificAuthKeyPrefix = authKeyPrefix+"::" + NEW_TIK_FI_ID + "::"
        defaultUserPrefix = authKeyPrefix+"_default_user"+"::" + NEW_TIK_FI_ID

        root = MD_REF.getCurrentAccountBook().getRootAccount()
        rootKeys = list(sorted(root.getParameterKeys()))

        pdfURL = "https://github.com/yogi1967/MoneydancePythonScripts/raw/master/source/useful_scripts/ofx_create_new_usaa_bank_custom_profile.pdf"
        try: Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(pdfURL), None)
        except: pass

        output = "INSTRUCTIONS:\n" \
                 "Read the latest walk through guide: ofx_create_new_usaa_bank_custom_profile.pdf\n" \
                 "Latest: %s\n" \
                 "(url has been copied to the clipboard)\n\n\n" %(pdfURL)

        output += "LIST OF OFX USAA USERIDs/ClientUIDs STORED ON THE ROOT ACCOUNT\n" \
                  " =============================================================\n\n"

        harvestedDefaultUserID = None
        harvestedUserIDList = []
        for i in range(0,len(rootKeys)):
            rk = rootKeys[i]
            rk_value = root.getParameter(rk)
            if rk.startswith(specificAuthKeyPrefix):
                harvestedUID = StoreUserID(rk[len(specificAuthKeyPrefix):])
                output+="Harvested existing authKey %s: ClientUID: %s\n" %(rk,rk_value)
                if harvestedUID.getUserID() != "null":
                    harvestedUID.setClientUID(rk_value)
                    harvestedUserIDList.append(harvestedUID)
            elif rk.startswith(defaultUserPrefix):
                output+="Harvested existing Default UserID: %s\n" %(rk_value)
                harvestedDefaultUserID = rk_value

        if len(harvestedUserIDList)<1: output+="\n<NONE PRE-EXISTING>\n"

        output += "\n<END>"

        jif = QuickJFrame("REVIEW EXISTING USAA USERIDs/ClientUIDs (stored on ROOT) BEFORE CHANGES",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        defaultEntry = ""
        while True:
            userID = myPopupAskForInput(jif, "PRIME USERID/CLIENTUID SUPPLIED BY USAA", "UserID", "Type/Paste the UserID to prime very carefully (this will overwrite existing)", defaultEntry)
            myPrint("DB", "userID entered: %s" %userID)
            if userID is None:
                txt = "ERROR - No userID supplied to prime! Aborting"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
                jif.dispose()
                return
            defaultEntry = userID
            if userID is None or userID == "" or userID == "UserID" or len(userID)<4:
                myPrint("DB", "\n ** ERROR - No valid UserID supplied to prime - try again ** \n")
                continue
            break
        del defaultEntry

        findStoredUser = StoreUserID(userID)
        if len(harvestedUserIDList) > 0:
            foundHarvestedStoredUser = StoreUserID.findUserID(findStoredUser.getUserID(),harvestedUserIDList)    # type: StoreUserID
            if foundHarvestedStoredUser is not None:
                if foundHarvestedStoredUser.getClientUID() is not None:
                    findStoredUser.setClientUID(foundHarvestedStoredUser.getClientUID())
                else:
                    raise Exception("LOGIC ERROR: Found harvested UserID (%s) with no ClientUID?! Aborting" %(findStoredUser))
            del foundHarvestedStoredUser
            myPrint("DB", "UserID entered: %s (Harvested ClientUID: %s)" %(userID, findStoredUser.getClientUID()))
        else:
            myPrint("DB","Skipping matching ClientUID into UserID as did not harvest any UserIDs from USAA root record(s)...")

        myPrint("B","")

        if findStoredUser.getClientUID() is not None:
            defaultEntry = findStoredUser.getClientUID()
        else:
            # defaultEntry = "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn"
            defaultEntry = ""
        del findStoredUser

        while True:
            uuid = myPopupAskForInput(jif, "PRIME CLIENT UUID FOR USERID: %s (SUPPLIED BY USAA)" %(userID),
                                      "PRIME UUID",
                                      "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn\n"
                                      " (Paste your USAA UUID 36 digits 8-4-4-4-12 carefully)", defaultEntry)
            myPrint("DB", "UUID entered: %s" %uuid)
            if uuid is None:
                txt = "ERROR - No uuid entered! Aborting"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
                jif.dispose()
                return
            defaultEntry = uuid
            if (uuid is None or uuid == "" or len(uuid) != 36 or uuid == "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn" or
                    (str(uuid)[8]+str(uuid)[13]+str(uuid)[18]+str(uuid)[23]) != "----"):
                myPrint("DB", "\n ** ERROR - no valid uuid supplied - try again ** \n")
                continue
            break
        del defaultEntry

        lSetDefaultUserID = False
        if myPopupAskQuestion(jif,_THIS_METHOD_NAME, "Do you want to make UserID: %s the DEFAULT (current default: %s)" %(userID, harvestedDefaultUserID)):
            myPrint("DB","UserID: %s will be primed as the default in root (replacing: %s as default)" %(userID, harvestedDefaultUserID))
            lSetDefaultUserID = True

        if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Prime UserID: %s with ClientUID: %s?" %(userID, uuid)):
            txt = "%s: User did not agree to proceed with changes - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        ####################################################################################################################
        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()  # type: [OnlineService]

        deleteServices = []
        for svc in serviceList:
            if svc.getTIKServiceID() == NEW_TIK_FI_ID: continue     # Skip deleting the new custom profile as that will refresh anyway
            if (svc.getTIKServiceID() == OLD_TIK_FI_ID
                    or svc.getServiceId() == ":%s:%s" %(USAA_FI_ORG, USAA_FI_ID)
                    or "USAA" in svc.getFIOrg()
                    or "USAA" in svc.getFIName()):
                myPrint("DB", "Found old USAA service - to potentially delete: %s" %(svc))
                deleteServices.append(svc)

        if len(deleteServices):
            if myPopupAskQuestion(jif, "DELETE EXISTING OLD USAA SERVICE PROFILES", "DELETE %s EXISTING (old) USAA SERVICE PROFILES TOO [optional]?" % (len(deleteServices)), theMessageType=JOptionPane.WARNING_MESSAGE):
                for service in deleteServices:
                    service.clearAuthenticationCache()
                    service.deleteItem()
                    myPrint("B","Deleted existing (old) USAA service profile: %s" %(service))
                MD_REF.getCurrentAccountBook().getLocalStorage().save()
                cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        del serviceList, deleteServices
        ####################################################################################################################

        root.setEditingMode()
        root.setParameter(specificAuthKeyPrefix+userID, uuid)

        if lSetDefaultUserID:
            root.setParameter(defaultUserPrefix, userID)
            root.setParameter(specificAuthKeyPrefix+"null", uuid)

        lOverrideRootUUID = False
        theDefaultUUID = root.getParameter(authKeyPrefix, "")
        if lOverrideRootUUID or theDefaultUUID == "":
            theDefaultUUID = my_createNewClientUID()
            myPrint("B","Overriding Root's default UUID. Was: '%s' >> changing to >> '%s'" %(root.getParameter(authKeyPrefix, ""),theDefaultUUID))
            root.setParameter(authKeyPrefix, theDefaultUUID)
        del theDefaultUUID, lOverrideRootUUID

        root.syncItem()

        txt = "SUCCESS! UserID: %s >> ClientUID primed to: %s (Default: %s)" %(userID, uuid, lSetDefaultUserID)
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        logToolboxUpdates("manuallyPrimeUSAARootUserIDClientIDs", txt)

        play_the_money_sound()
        MyPopUpDialogBox(jif,
                         txt,
                         "Please now return to Moneydance and use Menu: Online>Set up Online Banking\n"
                         "at the select financial institution selection window, please select:\n"
                         "%s" %(USAA_PROFILE_NAME),
                         theTitle=_THIS_METHOD_NAME,
                         OKButtonText="SUCCESS").go()

        jif.dispose()

    def check_OFX_USERID_Key_valid(test_str):
        pattern = r'[^a-zA-Z0-9-_.:]'
        if re.search(pattern, test_str):
            myPrint("DB","OFX UserID Key Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","OFX UserID Key Valid: %r" %(test_str))
            return True

    def check_OFX_USERID_Data_valid(test_str):
        pattern = r'[^a-zA-Z0-9-_.]'
        if re.search(pattern, test_str):
            myPrint("DB","OFX UserID Data Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","OFX UserID Data Valid: %r" %(test_str))
            return True

    def manualEditOfRootUserIDs():
        if MD_REF.getCurrentAccountBook() is None: return

        userIDKeyPrefix="ofx.client_uid"
        root = MD_REF.getCurrentAccountBook().getRootAccount()

        _DELETEONE  = 0
        _DELETEALL  = 1
        _EDITONE    = 2
        _ADDONE     = 3

        what = [
            "Delete One OFX UserID/ClientUID record (from root)",
            "Delete All OFX UserID/ClientUID record(s) (from root)",
            "Edit One OFX UserID/ClientUID record (key and data) (from root)",
            "Add One OFX UserID/ClientUID record (key and data) (from root)"]

        while True:

            lDoIHaveAnyKeys=True

            output = "LIST OF OFX BANK USERIDs/ClientUIDs STORED ON THE ROOT ACCOUNT\n" \
                     " =============================================================\n\n"
            userIDKeys = []
            rootKeys = sorted(root.getParameterKeys())
            for userKey in rootKeys:
                if userKey.startswith(userIDKeyPrefix):
                    userIDKeys.append(userKey)
                    output += "Key: %s Data: %s\n" %(pad(userKey,40), root.getParameter(userKey, None))

            output+="\n<END>"

            if len(userIDKeys) < 1:
                txt = "You have no Bank OFX UserIDs/ClientUIDs stored on the Root Account"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,"OFX BANK UserIDs/ClientUIDs", JOptionPane.WARNING_MESSAGE)
                lDoIHaveAnyKeys = False

            jif = QuickJFrame("REVIEW OFX BANK USERIDs/ClientUIDs (stored on ROOT) BEFORE CHANGES",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

            if lDoIHaveAnyKeys:
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "What you want to do?",
                                                           "OFX USERID/ClientUID MANAGEMENT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           what,
                                                           None)
            else:
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "What you want to do?",
                                                           "OFX USERID/ClientUIDs MANAGEMENT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           [what[_ADDONE]],
                                                           None)

            if not selectedWhat:
                txt = "OFX USERID MANAGEMENT - No option was selected.."
                setDisplayStatus(txt, "R")
                jif.dispose()       # already within the EDT
                return

            lEditOne = lDeleteOne = lDeleteAll = lAddOne = False

            if selectedWhat == what[_EDITONE]:      lEditOne = True
            elif selectedWhat == what[_DELETEONE]:  lDeleteOne = True
            elif selectedWhat == what[_DELETEALL]:  lDeleteAll = True
            elif selectedWhat == what[_ADDONE]:     lAddOne = True
            else:
                jif.dispose()       # already within the EDT
                continue

            do_what=""
            if lDeleteOne:  do_what = "DELETE"
            if lEditOne:    do_what = "EDIT"
            if lDeleteAll:  do_what = "DELETE ALL"
            if lAddOne:     do_what = "ADD ONE"

            selectedUserIDKey = None
            UserIDKeyValue = None

            if lDeleteOne or lEditOne:

                selectedUserIDKey = JOptionPane.showInputDialog(jif,
                                                             "Select a UserID/ClientUIDs to %s" %(do_what),
                                                             "OFX USERID/ClientUIDs MANAGEMENT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             userIDKeys,
                                                             None)
                if not selectedUserIDKey:
                    jif.dispose()       # already within the EDT
                    continue

                UserIDKeyValue = root.getParameter(selectedUserIDKey, None)

            chgKey = None
            chgValue = None
            if lEditOne:
                chgKey = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="EDIT USERID/ClientUID PARAMETER KEY [optional]:",
                                              theFieldDescription="Carefully edit/change the key. (JUST ENTER TO KEEP THE SAME))",
                                              defaultValue=selectedUserIDKey,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)   # type: str

                if not chgKey or len(chgKey.strip()) <1:
                    myPopupInformationBox(jif,"ERROR - The edited key was not specified or blank!","OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue
                chgKey = chgKey.strip()
                if not chgKey.startswith(userIDKeyPrefix) or not check_OFX_USERID_Key_valid(chgKey) \
                        or (chgKey != selectedUserIDKey and root.getParameter(chgKey,None) is not None):
                    myPopupInformationBox(jif,"ERROR - The new key %s was invalid or must start with '%s'" %(chgKey,userIDKeyPrefix),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                chgValue = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="EDIT USERID/ClientUID PARAMETER VALUE:",
                                              theFieldDescription="Carefully edit/change the data. NOTE: There will be little validation...",
                                              defaultValue=UserIDKeyValue,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)    # type: str
                if not chgValue or len(chgValue.strip()) <1:
                    jif.dispose()       # already within the EDT
                    continue
                chgValue = chgValue.strip()
                if not check_OFX_USERID_Key_valid(chgValue):
                    myPopupInformationBox(jif,"ERROR - The changed key data %s was invalid" %(chgValue),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

            if lAddOne:
                chgKey = myPopupAskForInput(jif,
                                            theTitle="OFX USERID/ClientUID MANAGEMENT",
                                            theFieldLabel="ADD NEW USERID/ClientUID PARAMETER KEY:",
                                            theFieldDescription="Carefully complete the new key (must start with '%s')" %(userIDKeyPrefix),
                                            defaultValue=userIDKeyPrefix,
                                            isPassword=False,
                                            theMessageType=JOptionPane.WARNING_MESSAGE)    # type: str

                if not chgKey or len(chgKey.strip()) <1:
                    myPopupInformationBox(jif,"ERROR - The new key was not specified or blank!","OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue
                chgKey = chgKey.strip()
                if not chgKey.startswith(userIDKeyPrefix) or not check_OFX_USERID_Key_valid(chgKey) or root.getParameter(chgKey,None) is not None:
                    myPopupInformationBox(jif,"ERROR - The new key %s was invalid or must start with '%s'" %(chgKey,userIDKeyPrefix),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                chgValue = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="ADD NEW USERID/ClientUID PARAMETER VALUE:",
                                              theFieldDescription="Carefully enter the new data. NOTE: There will be little validation...",
                                              defaultValue=UserIDKeyValue,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)   # type: str
                if not chgValue or len(chgValue.strip()) <1:
                    jif.dispose()       # already within the EDT
                    continue
                chgValue = chgValue.strip()
                if not check_OFX_USERID_Key_valid(chgValue):
                    myPopupInformationBox(jif,"ERROR - The new key data %s was invalid" %(chgValue),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

            if not confirm_backup_confirm_disclaimer(jif,"OFX USERID/ClientUID MANAGEMENT","OFX USERIDs/ClientUIDs %s?" %(do_what)):
                jif.dispose()       # already within the EDT
                return

            if lEditOne:
                if chgKey != selectedUserIDKey:
                    myPrint("B","setting new key %s to %s" %(chgKey,chgValue))
                    myPrint("DB", "NEW pre %s %s" %(chgKey,root.getParameter(chgKey)))

                    root.setEditingMode()

                    root.setParameter(chgKey, chgValue)
                    myPrint("DB", "NEW post %s %s" %(chgKey,root.getParameter(chgKey)))

                    myPrint("B","setting old key %s to None" %(selectedUserIDKey))
                    myPrint("DB", "OLD pre %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                    root.setParameter(selectedUserIDKey,None)

                    root.syncItem()
                    myPrint("DB", "OLD post %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                else:
                    myPrint("DB", "KEYSAME pre %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                    myPrint("B","setting %s to %s" %(selectedUserIDKey,chgValue))
                    root.setParameter(selectedUserIDKey, chgValue)
                    root.syncItem()
                    myPrint("DB", "KEYSAME post %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                txt = "OFX UserID/ClientUID Record key %s now %s changed from %s to %s" %(selectedUserIDKey,chgKey,UserIDKeyValue,chgValue)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("manualEditOfRootUserIDs", txt)

            if lAddOne:
                root.setParameter(chgKey,chgValue)
                root.syncItem()
                txt = "OFX new UserID/ClientUID parameter %s CREATED with data: %s" %(chgKey,chgValue)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("manualEditOfRootUserIDs", txt)

            if lDeleteOne:
                root.setParameter(selectedUserIDKey, None)
                root.syncItem()
                txt = "OFX UserID/ClientUID parameter %s DELETED (was: %s)" %(selectedUserIDKey,UserIDKeyValue)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("manualEditOfRootUserIDs", txt)

            if lDeleteAll:
                for keyToDelete in userIDKeys:
                    root.setParameter(keyToDelete, None)
                    root.syncItem()
                    myPrint("B", "DELETED OFX UserID/ClientUID Parameter %s from ROOT!" %(keyToDelete))
                txt = "ALL OFX UserID/ClientUID records DELETED from ROOT"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("manualEditOfRootUserIDs", txt)

            del userIDKeys
            play_the_money_sound()
            myPopupInformationBox(jif,"Your %s changes have been made and saved!" %(do_what),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.WARNING_MESSAGE)
            jif.dispose()       # already within the EDT
            continue

    def scriptRunner(_runThisScript, _method):

        if MD_EXTENSION_LOADER is None:
            txt = "%s: Sorry - You must be running Toolbox as an extension to run this extra script...." %(_method)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        if GlobalVars.SCRIPT_RUNNING_LOCK.locked():
            txt = "%s: Sorry - a script is already running with an active Lock" %(_method)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        with GlobalVars.SCRIPT_RUNNING_LOCK:
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            py = MD_REF.getPythonInterpreter()
            py.set("toolbox_script_runner", _runThisScript)
            py.getSystemState().setClassLoader(MD_EXTENSION_LOADER)
            py.set("moneydance_extension_loader", MD_EXTENSION_LOADER)

            class ScriptRunnable(Runnable):

                def __init__(self, _context, _python, _runnableScriptStream, _scriptToRun):
                    self.context = _context
                    self.python = _python
                    self.scriptStream = _runnableScriptStream
                    self.scriptToRun = _scriptToRun

                def run(self):  # NOTE: This will not start in the EDT (the same as Moneybot Console)
                    myPrint("B","..About to execfile(%s)" %(self.scriptToRun))
                    self.python.execfile(self.scriptStream,"Toolbox:Executing_Script_%s" %(self.scriptToRun))
                    myPrint("DB", "....I am back from script, within the special Thread().....")
                    self.scriptStream.close()
                    self.context.resetPythonInterpreter(self.python)
                    logToolboxUpdates("scriptRunner", "Executed external script '%s' (this may or may not have updated the Dataset)" %(self.scriptToRun))

            scriptStream = MD_EXTENSION_LOADER.getResourceAsStream("/%s" %(_runThisScript))

            Thread(ScriptRunnable(MD_REF, py, scriptStream, _runThisScript), "toolbox_scriptRunner").start()

            myPrint("DB", ".... post calling Thread().....")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")

        return True

    def editSetupMultipleUserIDs():
        _THIS_METHOD_NAME = "Edit/Setup (multiple) UserIDs / Passwords".upper()

        scriptToRun = "ofx_populate_multiple_userids.py"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute script: %s?" %(scriptToRun)):
            return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    # def createUSAAProfile():
    #     _THIS_METHOD_NAME = "Create USAA OFX Profile".upper()
    #
    #     scriptToRun = "ofx_create_new_usaa_bank_custom_profile.py"
    #
    #     if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute script: %s?" %(scriptToRun)):
    #         return False
    #
    #     return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    class StoreAccountList():
        def __init__(self, obj):
            if isinstance(obj,Account):
                self.obj = obj                          # type: Account
            else:
                self.obj = None

        def __str__(self):
            if self.obj is None:
                return "Invalid Acct Obj or None"
            return "%s : %s" %(self.obj.getAccountType(),self.obj.getFullAccountName())

        def __repr__(self):
            if self.obj is None:
                return "Invalid Acct Obj or None"
            return "%s : %s" %(self.obj.getAccountType(),self.obj.getFullAccountName())

    class StoreTheOnlineTxnList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlineTxnList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.txnCount = obj.getTxnCount()
            else:
                self.txnCount = 0

        def __str__(self):
            return "OnlineTxnList Obj on Acct %s (holding %s Txns)" %(self.acct,self.txnCount)

        def __repr__(self):
            return "OnlineTxnList Obj on Acct %s (holding %s Txns)" %(self.acct,self.txnCount)

    # noinspection PyUnresolvedReferences
    def get_security_holdings(security):
        if security.getCurrencyType() != CurrencyType.Type.SECURITY:
            return 0

        acctHoldings = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(22))
        balance = 0
        for acct in acctHoldings:
            if acct.getCurrencyType() == security:
                balance += acct.getBalance()

        return balance

    class StoreCurrencySecurity():
        def __init__(self, obj):
            if isinstance(obj,CurrencyType):
                self.obj = obj                          # type: CurrencyType
            else:
                self.obj = None
            self.qtyHeld = 0
            # noinspection PyUnresolvedReferences
            if self.obj and self.obj.getCurrencyType() == CurrencyType.Type.SECURITY:
                self.qtyHeld = get_security_holdings(self.obj)
            self.decimal = MD_REF.getPreferences().getDecimalChar()

        def __str__(self):
            if self.obj is None:
                return "Invalid CurrencyType Obj or None"
            if self.qtyHeld == 0:
                return "%s: %s" %(self.obj.getCurrencyType(), self.obj.getName())
            return "%s: %s (%s)" %(self.obj.getCurrencyType(), self.obj.getName(),self.obj.formatSemiFancy(self.qtyHeld,self.decimal))

        def __repr__(self): return self.__str__()

    class StoreAccountSecurity():
        def __init__(self, obj):
            self.obj = obj                                                                                              # type: Account

        def __str__(self):
            # noinspection PyUnresolvedReferences
            if self.obj is None or not isinstance(self.obj, Account) or self.obj.getAccountType() != Account.AccountType.SECURITY:
                return "Invalid Account/Security Obj or None"
            return "%s" %(self.obj.getAccountName())

        def getAccount(self):       return self.obj
        def getAccountName(self):   return self.getAccount().getAccountName()

        def __repr__(self):         return self.__str__()
        def toString(self):         return self.__str__()

    class StoreTheOnlinePayeeList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlinePayeeList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.payeeCount = obj.getPayeeCount()
            else:
                self.payeeCount = 0

        def __str__(self):
            return "OnlinePayeeList Obj on Acct %s (holding %s Payees)" %(self.acct,self.payeeCount)

        def __repr__(self):
            return "OnlinePayeeList Obj on Acct %s (holding %s Payees)" %(self.acct,self.payeeCount)

    class StoreTheOnlinePaymentList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlinePaymentList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.paymentCount = obj.getPaymentCount()
            else:
                self.paymentCount = 0

        def __str__(self):
            return "OnlinePaymentList Obj on Acct %s (holding %s Payments)" %(self.acct,self.paymentCount)

        def __repr__(self):
            return "OnlinePaymentList Obj on Acct %s (holding %s Payments)" %(self.acct,self.paymentCount)

    def OFX_update_OFXLastTxnUpdate():
        """Allows you to update the 'OFX' last update date (not the MD+ dates)"""

        _THIS_METHOD_NAME = "OFX: update OFXLastTxnUpdate date".upper()

        if MD_REF.getCurrentAccountBook() is None: return
        if not (ToolboxMode.isUpdateMode()): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(15))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to alter the OFXLastTxnUpdate date field:",
                                                   "OFX OFXLastTxnUpdate - Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "%s: No Account was selected.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "%s: No OnlineTxnList record found... Exiting.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        # com.infinitekind.moneydance.model.OnlineTxnList
        # setOFXLastTxnUpdate(long date, String connectionID)
        # resetLastUpdateDate(String connectionID)
        # resetLastUpdateDates()

        if isMulti_OFXLastTxnUpdate_build():
            theCurrentDate = theOnlineTxnRecord.obj.getOFXLastTxnUpdate("ofx")
        else:
            theCurrentDate = theOnlineTxnRecord.obj.getOFXLastTxnUpdate()

        if theCurrentDate > 0:
            theCurrentDatePretty = get_time_stamp_as_nice_text(theCurrentDate)
        else:
            if isMDPlusEnabledBuild():
                theCurrentDatePretty = "NOT SET (MD will prompt you for start date)"
            else:
                theCurrentDatePretty = "NOT SET"

        myPopupInformationBox(toolbox_frame_,"OFXLastTxnUpdate is currently: %s (which means: %s)" %(theCurrentDate, theCurrentDatePretty))

        if not isMDPlusEnabledBuild():

            labelUpdateDate = JLabel("Select the new OFXLastTxnUpdate download Date:")
            user_selectDateStart = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
            user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())

            datePanel = JPanel(GridLayout(0, 1))
            datePanel.add(labelUpdateDate)
            datePanel.add(user_selectDateStart)

            options = ["Cancel", "OK"]

            while True:
                userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                          datePanel,
                                                          "Select new Date for the OFXLastTxnUpdate field:",
                                                          JOptionPane.OK_CANCEL_OPTION,
                                                          JOptionPane.QUESTION_MESSAGE,
                                                          getMDIcon(None),
                                                          options,
                                                          options[0])

                if userAction != 1:
                    txt = "OFX: User cancelled entering a new OFXLastTxnUpdate date - exiting"
                    setDisplayStatus(txt, "R")
                    return

                if user_selectDateStart.getDateInt() < 20150101 or user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt():
                    txt = "OFX: User cancelled entering an invalid OFXLastTxnUpdate date..."
                    setDisplayStatus(txt, "R")
                    user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())
                    user_selectDateStart.setForeground(getColorRed())                                                           # noqa
                    continue

                break   # Valid date

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Update the OFXLastTxnUpdate field to %s?" %(convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt()))):
                return

            newDate = DateUtil.convertIntDateToLong(user_selectDateStart.getDateInt()).getTime()
            newDateTxt = convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt())

        else:

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Reset date so that MD Prompts you for start date?"):
                return

            newDate = 0L
            newDateTxt = "RESET SO MD PROMPTS FOR START DATE"

        if isMulti_OFXLastTxnUpdate_build():
            theOnlineTxnRecord.obj.resetLastUpdateDate("")
            theOnlineTxnRecord.obj.setOFXLastTxnUpdate(newDate, "ofx")
        else:
            theOnlineTxnRecord.obj.setOFXLastTxnUpdate(newDate)

        theOnlineTxnRecord.obj.syncItem()

        txt = "OFX alter OFXLastTxnUpdate date for acct: %s successfully set to: %s (%s)" %(selectedAcct, newDate, newDateTxt)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("OFX_update_OFXLastTxnUpdate", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

    def OFX_reset_OFXLastTxnUpdate_dates():
        """Allows you to reset all 'OFX' last update dates (including the MD+ dates) on the record"""

        _THIS_METHOD_NAME = "OFX: reset all OFXLastTxnUpdate dates".upper()

        if MD_REF.getCurrentAccountBook() is None:    return
        if not (ToolboxMode.isUpdateMode()):                    return
        if not isMulti_OFXLastTxnUpdate_build():            return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(15))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to RESET all the OFXLastTxnUpdate dates (OFX & MD+):",
                                                   "OFX OFXLastTxnUpdate - Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "%s: No Account was selected.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "%s: No OnlineTxnList record found... Exiting.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Reset ALL OFXLastTxnUpdate dates?"):
            return

        theOnlineTxnRecord.obj.resetLastUpdateDates()
        theOnlineTxnRecord.obj.syncItem()

        txt = "%s: All OFXLastTxnUpdate dates RESET" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("OFX_reset_OFXLastTxnUpdate_dates", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

    def OFX_removeDownloadedDataFromTxns():
        """Wipes MD+/OFX/QIF hidden data from txns"""

        _THIS_METHOD_NAME = "OFX: Remove MD+/OFX(/QIF) data from downloaded Txns".upper()

        if MD_REF.getCurrentAccountBook() is None: return
        if not (ToolboxMode.isUpdateMode()): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(0))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select Acct to remove (hidden) MD+/OFX(/QIF) data:",
                                                   "Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "%s: No Account was selected.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        if isinstance(selectedAcct, Account): pass

        options = ["Remove the hidden MD+/OFX(/QIF) downloaded data within this Acct",
                   "Disable (rename) the hidden MD+/OFX(/QIF) downloaded data within this Acct"]

        selectedRemoveDisableOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select Remove or Disable option?",
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.WARNING_MESSAGE,
                                                           getMDIcon(None),
                                                           options,
                                                           None)

        if not selectedRemoveDisableOption:
            txt = "%s: User did not select a Remove or Disable option - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Remove/disable hidden MD+/OFX(/QIF) data from selected account?"):
            return

        pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                      "Please wait: executing MD+/OFX(/QIF) hidden data changes....",
                                      theTitle=_THIS_METHOD_NAME.upper(),
                                      lModal=False,
                                      OKButtonText="WAIT")
        pleaseWait.go()

        lRemove  = (options.index(selectedRemoveDisableOption) == 0)

        olTxnRecord = selectedAcct.getDownloadedTxns()
        txns = selectedAcct.getBook().getTransactionSet().getTransactionsForAccount(selectedAcct)
        olTxns = []
        for txn in txns:
            if not txn.wasDownloaded(): continue
            olTxns.append(txn)

        myPrint("B", "Found: %s txns with downloaded data.... Option: '%s' selected" %(len(olTxns), "REMOVE" if lRemove else "DISABLE"))

        MD_REF.saveCurrentAccount()

        if olTxnRecord is not None:
            myPrint("B", "Removing 'OnlineTxnList' record...")
            olTxnRecord.deleteItem()

        QIF_ORIG_DATA_KEY = "qif.orig-txn"

        if len(olTxns) > 0:
            myPrint("B", "Amending transactions......")
            for txn in olTxns:

                pTxn = txn.getParentTxn()
                pTxn.setEditingMode()

                save_fiid = txn.getFIID()
                txn.setFIID(None)

                save_qif_data = txn.getParameter(QIF_ORIG_DATA_KEY, "")
                save_qif_sn = txn.getParameter(AbstractTxn.TAG_QIF_IMPORT_SESSION, "")

                saved_fitid_data = []
                for pKey in list(txn.getParameterKeys()):
                    if (pKey.startswith(AbstractTxn.TAG_FITID_PREFIX)):
                        saved_fitid_data.append([pKey, txn.getParameter(pKey, None)])
                        txn.setParameter(pKey, None)

                if not lRemove:
                    txn.setParameter("DISABLED_" + AbstractTxn.TAG_FI_ID, save_fiid)
                    for fitidKey, fitidValue in saved_fitid_data:
                        txn.setParameter("DISABLED_" + fitidKey, fitidValue)

                    # Now QIF data
                    if save_qif_data != "":
                        txn.setParameter("DISABLED_" + QIF_ORIG_DATA_KEY, save_qif_data)
                        txn.setParameter(QIF_ORIG_DATA_KEY, None)

                    if save_qif_sn != "":
                        txn.setParameter("DISABLED_" + AbstractTxn.TAG_QIF_IMPORT_SESSION, save_qif_sn)
                        txn.setParameter(AbstractTxn.TAG_QIF_IMPORT_SESSION, None)
                else:

                    for pKey in list(txn.getParameterKeys()):
                        if (pKey.startswith("ol.")):
                            txn.setParameter(pKey, None)

                    # Now QIF data
                    txn.setParameter(QIF_ORIG_DATA_KEY, None)
                    txn.setParameter(AbstractTxn.TAG_QIF_IMPORT_SESSION, None)

                pTxn.syncItem()

        MD_REF.saveCurrentAccount()

        pleaseWait.kill()

        whatTxt = "REMOVED" if lRemove else "DISABLED"

        txt = "%s: Option: Data '%s' from %s txns" %(_THIS_METHOD_NAME, whatTxt, len(olTxns))
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("OFX_removeDownloadedDataFromTxns", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)

    def OFX_delete_ALL_saved_online_txns():
        # delete_intermediate_downloaded_transaction_caches.py
        # delete_orphaned_downloaded_txn_lists.py

        # CREATE TEST DATA
        # allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), AcctFilter.NON_CATEGORY_FILTER)
        # for acct in allAccounts:
        #     if "TEST"  != acct.getFullAccountName().upper() and "TEST2"  != acct.getFullAccountName().upper(): continue
        #     print "found: %s" %(acct)
        #     olTxns = acct.getDownloadedTxns()  # Note - this actually creates a new OnlineTxnList object if it didn't exist
        #     for i in range(0,10):
        #         olTxn = olTxns.newTxn()
        #         olTxn.setFIID("qif")
        #         olTxn.setName("Desc1" +str(i))
        #         olTxn.setDatePostedInt(	20200115+i )
        #         olTxn.setAmount( 9999+i )
        #         olTxn.setAllowDuplicateIDs(True)
        #         olTxns.addNewTxn(olTxn)
        #     olTxns.syncItem()
        #     print olTxns.getSyncInfo()
        # END CREATE TEST DATA

        if MD_REF.getCurrentAccountBook() is None: return
        if not (ToolboxMode.isUpdateMode()): return

        # quick check first...
        olTxnLists = MD_REF.getCurrentAccountBook().getItemsWithType("oltxns")
        lAny = False
        for txnList in olTxnLists:
            if txnList.getTxnCount() > 0:
                lAny = True
                break

        if not lAny and not myPopupAskQuestion(toolbox_frame_,"OFX PURGE OnlineTxnList OBJECTS","You don't seem to have any cached Online Txns. Proceed anyway (with general cleanup)?",theMessageType=JOptionPane.WARNING_MESSAGE):
            txt = "OFX PURGE OnlineTxnList OBJECTS. You have no cached Txns - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX PURGE OnlineTxnList OBJECTS","Purge/Clean all Cached OnlineTxnList Txns (very safe to run)?"):
            return

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes....
        SyncerDebug.changeState(debug)

        myPrint("B","Purging / cleaning all OnlineTxnList Cached txns.....")

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), AcctFilter.NON_CATEGORY_FILTER)

        output = "PURGE/CLEAN ALL CACHED OnlineTxnList TXN RECORDS\n" \
                 " ===============================================\n\n"

        output += (" Found %s accounts and %s OnlineTxnList objects\n" % (len(allAccounts), len(olTxnLists)))
        shouldSaveTrunk = False

        # delete all online transactions from all downloaded-transaction-list objects,
        # which includes lists that are no longer associated with accounts
        for txnList in olTxnLists:
            output += ("OnlineTxnList %s    with    %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            if txnList.getTxnCount() > 0:
                myPrint("J", "OnlineTxnList %s - DELETING %s cached txns" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
                shouldSaveTrunk = True
                output += ("   >> DELETING Cached Txns....\n")
                txnList.setEditingMode()
                while txnList.getTxnCount() > 0:
                    txnList.removeTxn(txnList.getTxnCount() - 1)
                txnList.syncItem()
                output += ("   OnlineTxnList %s now has %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))

        output += "\n--------\n\n"

        for acct in allAccounts:
            olTxns = acct.getDownloadedTxns()  # Note - this actually creates a new OnlineTxnList object if it didn't exist
            olTxnsIdx = olTxnLists.indexOf(olTxns)
            if olTxnsIdx >= 0:
                if olTxns.getTxnCount() > 0:    # Note - I think this never finds any, as it will have been caught in the loop above....
                    shouldSaveTrunk = True
                    output += ("Found OnlineTxnList %s at index %s for account %s - DELETING %s cached txns\n"
                          % (pad(olTxns.getUUID(),50), rpad(olTxnsIdx,10), pad(acct.getAccountName(),30), olTxns.getTxnCount()))
                    myPrint("J", "Found OnlineTxnList %s at index %s for account %s - DELETING %s cached txns"
                            % (pad(olTxns.getUUID(),50), rpad(olTxnsIdx,10), pad(acct.getAccountName(),30), olTxns.getTxnCount()))
                    olTxns.setEditingMode()
                    while olTxns.getTxnCount() > 0:
                        olTxns.removeTxn(olTxns.getTxnCount() - 1)
                    olTxns.syncItem()
                    output += ("   OnlineTxnList %s                        >now has %s cached txns\n" % (pad(olTxns.getUUID(),50), rpad(olTxns.getTxnCount(),12)))
                olTxnLists.remove(olTxns)  # This check is OK though.....
            # else:
            #     output+=("@@ OnlineTxnList record NOT FOUND (orphaned), containing %s cached txns\n" % (rpad(olTxns.getTxnCount(),12)))

        output += "\n--------\n\n"

        output += ("Remaining/orphan OnlineTxnList objects to delete:\n")

        for txnList in olTxnLists:
            output += (">> DELETING ORPHAN >> OnlineTxnList %s with %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            myPrint("J", ">> DELETING ORPHAN >> OnlineTxnList %s with %s cached txns" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            txnList.deleteItem()
            shouldSaveTrunk = True

        output += "\n--------\n\n"

        MD_REF.getCurrentAccountBook().logRemovedItems(olTxnLists)

        SyncerDebug.resetState()
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes....

        if shouldSaveTrunk:
            myPrint("J","Purge/Clean ALL OnlineTxnList objects - Saving Trunk file now....")
            output+=("SAVING TRUNK FILE...\n")
            MD_REF.getCurrentAccountBook().saveTrunkFile()
        else:
            myPrint("J","Purge/Clean ALL OnlineTxnList objects - NO CHANGES MADE....")
            output+=("Purge/Clean ALL OnlineTxnList objects - NO CHANGES MADE....\n")

        output+="\n<END>"

        jif = QuickJFrame("OFX PURGE ALL OnlineTxnList OBJECTS",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        txt = "OFX: Purge / Clean ALL OnlineTxnList Objects cached Txns completed..."
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("OFX_delete_ALL_saved_online_txns", txt)

        play_the_money_sound()
        myPopupInformationBox(jif,txt,"OFX PURGE ALL OnlineTxnList",JOptionPane.ERROR_MESSAGE)

    def OFX_delete_saved_online_txns():

        # delete_intermediate_downloaded_transaction_caches.py
        # delete_orphaned_downloaded_txn_lists.py

        if MD_REF.getCurrentAccountBook() is None: return
        if not (ToolboxMode.isUpdateMode()): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(18))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to alter the Online Txn List record:",
                                                   "Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "Delete saved OnlineTxnList txns: No Account was selected.."
            setDisplayStatus(txt, "R")
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "Delete saved OnlineTxnList txns: No OnlineTxnList record found... Exiting.."
            setDisplayStatus(txt, "R")
            return

        saveTxnCount = theOnlineTxnRecord.txnCount

        while True:
            _options=["CHANGE: DELETE All %s Txns stored on this record" %(saveTxnCount),
                      "CHANGE: DELETE the whole OnlineTxnList record"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "What type of change to OnlineTxnList record do you want to make?",
                                                         "OFX CHANGE OnlineTxns",
                                                         JOptionPane.WARNING_MESSAGE,
                                                         getMDIcon(None),
                                                         _options,
                                                         None)

            if not selectedOption:
                txt ="No change for OnlineTxnList record selected - exiting.."
                setDisplayStatus(txt, "R")
                return

            lDeleteAllTxns  = (_options.index(selectedOption) == 0)
            lDeleteRecord   = (_options.index(selectedOption) == 1)

            if lDeleteAllTxns and saveTxnCount < 1: continue

            break

        do_what = ""
        if lDeleteAllTxns: do_what = "Delete all %s stored Txns within the record" %(saveTxnCount)
        if lDeleteRecord:  do_what = "Delete the whole OnlineTxnList record"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX DELETE CHANGE OnlineTxnList","%s?" %(do_what)):
            return

        if lDeleteRecord:
            theOnlineTxnRecord.obj.deleteItem()
            txt = "OFX CHANGE OnlineTxnList whole record for acct: %s successfully deleted: " %(selectedAcct)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("OFX_delete_saved_online_txns", txt)

            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_,txt,"OFX DELETE CHANGE OnlineTxnList", JOptionPane.ERROR_MESSAGE)

        elif lDeleteAllTxns:

            theOnlineTxnRecord.obj.setEditingMode()
            while theOnlineTxnRecord.obj.getTxnCount() > 0:
                theOnlineTxnRecord.obj.removeTxn(theOnlineTxnRecord.obj.getTxnCount() - 1)
            theOnlineTxnRecord.obj.syncItem()

            # for i in reversed(range(0,saveTxnCount)):
            #     theOnlineTxnRecord.obj.removeTxn(i)
            # theOnlineTxnRecord.obj.syncItem()

            txt = "OFX CHANGE OnlineTxnList Record for acct: %s: %s Txns deleted" %(selectedAcct, saveTxnCount)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("OFX_delete_saved_online_txns", txt)

            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_,txt,"OFX DELETE OnlineTxnList Txns",JOptionPane.ERROR_MESSAGE)

    def quick_check_cached_online_txns():
        if MD_REF.getCurrentAccountBook() is None: return

        countCachedAccounts = 0
        countCachedTxns = 0

        myPrint("DB","Quick check looking for Cached OFX Downloaded txns (that shouldn't be there)")
        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(18))
        for acct in accountsListForOlTxns:
            cached = MyGetDownloadedTxns(acct)
            if cached.getTxnCount() > 0:
                myPrint("DB", "Account: %s contains %s cached txns" %(acct,cached.getTxnCount()))
                countCachedAccounts += 1
                countCachedTxns += cached.getTxnCount()

        myPrint("DB","... found: %s accounts containing %s cached txns" %(countCachedAccounts, countCachedTxns))
        return countCachedAccounts, countCachedTxns

    def OFX_authentication_management():
        if MD_REF.getCurrentAccountBook() is None: return

        if not isCachingPasswords():
            myPopupInformationBox(toolbox_frame_,"WARNING: Your system is not setup to cache/store Authentication details!","Manage OFX Authentication",JOptionPane.ERROR_MESSAGE)

        user_clearOneServiceAuthCache = JRadioButton("Clear the Authentication Cache (Passwords) for One Service / Bank Profile", False)
        user_clearOneServiceAuthCache.setToolTipText("Clears all remembered passwords for the OFX Service profile you select - THIS WILL CHANGE DATA!")

        user_clearAllServicesAuthCache = JRadioButton("Clear ALL Authentication Cache (Passwords)", False)
        user_clearAllServicesAuthCache.setToolTipText("Clears all remembered passwords for all OFX Service profiles - THIS WILL CHANGE DATA!")

        user_editSetupMultipleUserIDs = JRadioButton("Edit/Setup (multiple) UserIDs / Passwords (executes a special script)", False)
        user_editSetupMultipleUserIDs.setToolTipText("Allows setup of multiple UserIDs/Passwords on an OFX service profile - executes: ofx_populate_multiple_userids.py")

        user_editStoredOFXPasswords = JRadioButton("Edit stored authentication passwords linked to a working OFX Profile", False)
        user_editStoredOFXPasswords.setToolTipText("Manual edit of remembered OFX passwords linked to an OFX profile...")

        user_manualEditOfRootUserIDs = JRadioButton("Manual Edit of stored Root UserIDs/ClientUIDs", False)
        user_manualEditOfRootUserIDs.setToolTipText("Manual edit of any stored UserID/ClientUID raw record (from root account)")

        userFilters = JPanel(GridLayout(0, 1))

        userFilters.add(user_clearOneServiceAuthCache)
        userFilters.add(user_clearAllServicesAuthCache)
        userFilters.add(user_editSetupMultipleUserIDs)
        userFilters.add(user_editStoredOFXPasswords)
        userFilters.add(user_manualEditOfRootUserIDs)

        setupMenuRadioButtons(userFilters)

        while True:
            options = ["EXIT", "PROCEED"]
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       userFilters,
                                                       "Online Banking (OFX) AUTHENTICATION MANAGEMENT",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))

            if userAction != 1:
                txt = "Online Banking (OFX) AUTHENTICATION MANAGEMENT - No changes made....."
                setDisplayStatus(txt, "B")
                return False

            if user_clearOneServiceAuthCache.isSelected():
                clearOneServiceAuthCache()

            if user_clearAllServicesAuthCache.isSelected():
                clearAllServicesAuthCache()

            if user_editSetupMultipleUserIDs.isSelected():
                if editSetupMultipleUserIDs():
                    return True

            if user_editStoredOFXPasswords.isSelected():
                editStoredOFXPasswords()

            if user_manualEditOfRootUserIDs.isSelected():
                manualEditOfRootUserIDs()

            continue

    def OFX_cookie_management():
        if not ToolboxMode.isUpdateMode(): return

        cookieKey="ofxcookies"

        LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

        _EDITONE = 0
        _DELETEONE = 1
        _DELETEALL = 2

        what = [
            "Edit One OFX Cookie's data",
            "Delete One OFX Cookie",
            "Delete All OFX Cookies"]

        while True:

            allCookieStrings = LS.getStringList(cookieKey)

            # LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
            # LS.put("ofxcookies.0","CBDIdleTimer=1585100844282|false|13|15; path=%2F; domain=google.com")
            # LS.put("ofxcookies.1","HNWPRD=A11; path=%2F; domain=google.com")
            # LS.put("ofxcookies.2","ADRUM_BTs=R:0|s:p; Sun, 10-Jan-2021 20:34:19 MST; path=%2F; domain=vesnc.billy.com")
            # LS.put("ofxcookies.3","ADRUM_BT1=R:0|i:52128|e:20; Tue, 12-Jan-2021 16:24:22 MST; path=%2F; domain=vesnc.apple.com")

            _i = 0
            msgStr=""
            for _i in range(0, len(allCookieStrings)):
                msgStr+="%s\n" %(allCookieStrings.get(_i))
                # print MDCookie.loadFromStorage(allCookieStrings.get(_i))
                _i+=1

            MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Your current cookies are:",
                             theMessage=msgStr,
                             theTitle="OFX COOKIE MANAGEMENT",
                             OKButtonText="CONTINUE").go()

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "What you want to do?",
                                                       "OFX COOKIE MANAGEMENT",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       what,
                                                       None)
            if not selectedWhat:
                txt = "No Cookie action/option was selected!"
                setDisplayStatus(txt, "R")
                return

            lEditOne = lDeleteOne = lDeleteAll = False

            if selectedWhat == what[_EDITONE]: lEditOne=True
            elif selectedWhat == what[_DELETEONE]: lDeleteOne=True
            elif selectedWhat == what[_DELETEALL]: lDeleteAll=True
            else: continue

            do_what=""
            if lDeleteOne: do_what = "DELETE"
            if lEditOne: do_what = "EDIT"
            if lDeleteAll: do_what = "DELETE ALL"

            selectedCookie = None
            selectedCookieIndex = None

            if lDeleteOne or lEditOne:

                selectedCookie = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select a Cookie to %s" %(do_what),
                                                             "OFX COOKIE MANAGEMENT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             allCookieStrings,
                                                             None)
                if not selectedCookie: continue
                selectedCookieIndex = allCookieStrings.indexOf(selectedCookie)

            chgValue = None
            if lEditOne:
                chgValue = myPopupAskForInput(toolbox_frame_,
                                              theTitle="OFX COOKIE MANAGEMENT",
                                              theFieldLabel="EDIT COOKIE VALUE:",
                                              theFieldDescription="Carefully edit/change the data. NOTE: There will be no validation...",
                                              defaultValue=selectedCookie,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)
                if not chgValue or len(chgValue.strip()) <1 or chgValue == selectedCookie: continue
                chgValue = chgValue.strip()

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX BANK MANAGEMENT","OFX COOKIES %s?" %(do_what)):
                continue

            if not backup_local_storage_settings():
                txt = "'OFX COOKIE MANAGEMENT': ERROR making backup of LocalStorage() ./safe/settings - no changes made!"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                return

            if lEditOne:
                allCookieStrings[selectedCookieIndex] = chgValue
                txt = "OFX Cookie %s changed from %s to %s" %(selectedCookieIndex+1,selectedCookie,chgValue)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("OFX_cookie_management", txt)

            if lDeleteOne:
                allCookieStrings.remove(selectedCookieIndex)
                txt = "OFX Cookie %s DELETED (was: %s)" %(selectedCookieIndex+1,selectedCookie)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("OFX_cookie_management", txt)

            if lDeleteAll:
                allCookieStrings.clear()
                txt = "ALL OFX Cookies DELETED"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("OFX_cookie_management", txt)

            myPrint("B","OFX Bank Management: Writing all Cookies back to Local Storage (after: %s)...." %(do_what))
            LS.put(cookieKey, allCookieStrings)
            LS.save()
            myPopupInformationBox(toolbox_frame_,"Your %s changes have been made and saved!" %(do_what),"OFX BANK MANAGEMENT",JOptionPane.WARNING_MESSAGE)
            continue

    # def OFXDEBUGToggle():
    #     key = "ofx.debug.console"
    #     props_ofx_debug = System.getProperty(key, None)
    #
    #     toggleText = "ON"
    #     if (props_ofx_debug is not None and props_ofx_debug!="false"):
    #         toggleText = "OFF"
    #
    #     ask = MyPopUpDialogBox(toolbox_frame_,
    #                            "OFX DEBUG CONSOLE STATUS:",
    #                            'System.getProperty("%s") currently set to: %s\n'%(key,props_ofx_debug),
    #                            theTitle="TOGGLE MONEYDANCE INTERNAL OFX DEBUG",
    #                            lCancelButton=True,OKButtonText="SET to %s" %toggleText)
    #     if not ask.go():
    #         txt = "NO CHANGES MADE TO OFX DEBUG CONSOLE!"
    #         setDisplayStatus(txt, "B")
    #         return
    #
    #     myPrint("B","OFX DEBUG CONSOLE: User requested to toggle System Property '%s' to %s - setting this now...!" %(key,toggleText))
    #     if toggleText == "OFF":
    #         System.clearProperty(key)
    #     else:
    #         System.setProperty(key, "true")
    #
    #     txt = "Internal debug ofx debug console setting turned %s" %(toggleText)
    #     setDisplayStatus(txt, "B")
    #     myPopupInformationBox(toolbox_frame_, txt, "TOGGLE MONEYDANCE INTERNAL OFX DEBUG", JOptionPane.WARNING_MESSAGE)

    # noinspection PyUnresolvedReferences
    def CUSIPFix():
        currID = "curr_id."

        # Credit to: Finite Mobius, LLC / Jason R. Miller" for original code (https://github.com/finitemobius/moneydance-py)
        # change-security-cusip.py
        # Variant of remove_ofx_security_bindings.py

        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
        if not isRRateCurrencyIssueFixedBuild() and not check_all_currency_raw_rates_ok(CurrencyType.Type.SECURITY):
            myPrint("B","@@ Error: failed check_all_currency_raw_rates_ok(SECURITY) check... Exiting CUSIPFix() without any changes...")
            txt = "ERROR: You have old format Security record(s). Consider running 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' option first"
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            setDisplayStatus(txt, "R")
            return

        # Find Securities with CUSIP(s) set...
        dropdownSecs = ArrayList()
        allSecs = ArrayList()
        currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() != CurrencyType.Type.SECURITY: continue
            allSecs.append(curr)
            for key in curr.getParameterKeys():
                if key.startswith(currID):
                    dropdownSecs.add(curr)
                    break

        theSchemes = None
        selectedSecurity = None
        selectedSecurityMoveTo = None
        lReset = lEdit = lMove = lAdd = False

        if len(dropdownSecs)<1:
            x = "You have no existing CUSIP(s); Would you like to add a CUSIP?"
        else:
            x = "You have %s securities with CUSIP(s) set; Would you like to manually add a CUSIP? (No brings up more options)" %(len(dropdownSecs))

        if not myPopupAskQuestion(toolbox_frame_,"FIX CUSIP",x,theMessageType=JOptionPane.WARNING_MESSAGE):
            if len(dropdownSecs)<1:
                txt = "FIX CUSIP - You have no existing CUSIP(s) set on Securities - No changes made..."
                setDisplayStatus(txt, "B")
                return
        else:
            allSecs = sorted(allSecs, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the security to add CUSIP data",
                                                           "FIX CUSIP",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           allSecs,
                                                           None)

            if not selectedSecurity:
                txt = "FIX CUSIP - No Security was selected - no changes made.."
                setDisplayStatus(txt, "B")
                return

            lAdd = True

        if not lAdd:
            dropdownSecs = sorted(dropdownSecs, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the security with CUSIP data to view/change",
                                                           "FIX CUSIP",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           dropdownSecs,
                                                           None)

            if not selectedSecurity:
                txt = "FIX CUSIP - No Security was selected - no changes made.."
                setDisplayStatus(txt, "B")
                return

            del dropdownSecs

            schemeText = ""
            theSchemes = []
            for key in selectedSecurity.getParameterKeys():
                if key.startswith(currID):
                    findScheme = key[len(currID):]
                    theSchemes.append([selectedSecurity,findScheme,selectedSecurity.getIDForScheme(findScheme)])
                    schemeText+="Scheme: %s ID: %s\n" %(findScheme,selectedSecurity.getIDForScheme(findScheme))

            if len(theSchemes) < 1:
                txt = "FIX CUSIP - error iterating keys on %s for CUSIP(s) - NO CHANGES MADE!" %(selectedSecurity)
                setDisplayStatus(txt, "R"); myPrint("B",txt)
                return

            ask = MyPopUpDialogBox(toolbox_frame_,"Showing CUSIP data for Security: %s" %(selectedSecurity),schemeText,theTitle="FIX CUSIP",OKButtonText="NEXT STEP",lCancelButton=True)
            if not ask.go():
                txt = "FIX CUSIP - no changes made.."
                setDisplayStatus(txt, "B")
                return

            options = ["EXIT", "RESET CUSIP(s)", "EDIT ONE CUSIP", "MOVE ALL TO DIFFERENT SECURITY", "ADD NEW CUSIP KEY"]
            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "Select CUSIP Option you want to action",
                                                         "FIX CUSIP",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(lAlwaysGetIcon=True),
                                                         options,
                                                         None)

            if not selectedOption or options.index(selectedOption) == 0:
                txt = "FIX CUSIP - No CUSIP option selected - no changes made.."
                setDisplayStatus(txt, "R")
                return

            if options.index(selectedOption) == 1: lReset = True
            elif options.index(selectedOption) == 2: lEdit = True
            elif options.index(selectedOption) == 3: lMove = True
            elif options.index(selectedOption) == 4: lAdd = True
            else:
                txt = "FIX CUSIP - Unknown option selected - no changes made"
                setDisplayStatus(txt, "R")
                return

            dropdownSecsMoveTo = selectedSecurityMoveTo = None                                                      # noqa

        if lMove:
            dropdownSecsMoveTo = ArrayList()
            currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
            for curr in currencies:
                if curr.getCurrencyType() != CurrencyType.Type.SECURITY: continue                               # noqa
                if curr == selectedSecurity: continue
                dropdownSecsMoveTo.add(curr)

            if len(dropdownSecsMoveTo) < 1:
                txt = "FIX CUSIP - You have no other Securities to move to - No changes made..."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,"FIX CUSIP",JOptionPane.ERROR_MESSAGE)
                return

            dropdownSecsMoveTo = sorted(dropdownSecsMoveTo, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurityMoveTo = JOptionPane.showInputDialog(toolbox_frame_,
                                                                 "Select the security to move the CUSIP data to:",
                                                                 "FIX CUSIP",
                                                                 JOptionPane.INFORMATION_MESSAGE,
                                                                 getMDIcon(lAlwaysGetIcon=True),
                                                                 dropdownSecsMoveTo,
                                                                 None)

            if not selectedSecurityMoveTo:
                txt = "FIX CUSIP - No Move to Security was selected - no changes made.."
                setDisplayStatus(txt, "R")
                return

            lAlreadyHasData = False
            for key in selectedSecurityMoveTo.getParameterKeys():
                if key.startswith(currID):
                    lAlreadyHasData=True
                    break
            if lAlreadyHasData:
                if not myPopupAskQuestion(toolbox_frame_,
                                          "FIX CUSIP",
                                          "Security: %s already has CUSIP data. OK will overwrite matching CUSIP key(s) (Cancel to exit)" %(selectedSecurityMoveTo),
                                          theMessageType=JOptionPane.WARNING_MESSAGE):
                    txt = "FIX CUSIP - Security: %s already has CUSIP data. User asked to Exit..." %(selectedSecurityMoveTo)
                    setDisplayStatus(txt, "R")
                    return
                myPrint("B", "FIX CUSIP - User selected to overwrite existing CUSIP data in Security: %s" %selectedSecurityMoveTo)

        if confirm_backup_confirm_disclaimer(toolbox_frame_,"FIX CUSIP","Are you sure you want to change CUSIP data on security: %s?" %(selectedSecurity)):
            if lReset:
                selectedSecurity.setEditingMode()
                for key in list(selectedSecurity.getParameterKeys()):
                    if key.startswith(currID):
                        findScheme = key[len(currID):]
                        # noinspection PyUnresolvedReferences
                        oldData = selectedSecurity.getIDForScheme(findScheme)
                        # noinspection PyUnresolvedReferences
                        selectedSecurity.setIDForScheme(findScheme, None)
                        myPrint("B","FIX CUSIP: Deleted CUSIP on Security: %s (Was: Scheme: %s ID: %s)" %(selectedSecurity,findScheme,oldData) )
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s Reset/Deleted!" %(selectedSecurity),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lMove:
                selectedSecurity.setEditingMode()
                selectedSecurityMoveTo.setEditingMode()
                for key in list(selectedSecurity.getParameterKeys()):
                    if key.startswith(currID):
                        findScheme = key[len(currID):]
                        moveData = selectedSecurity.getIDForScheme(findScheme)

                        moveToOldData = selectedSecurityMoveTo.getIDForScheme(findScheme)
                        if moveToOldData:
                            myPrint("B", "FIX CUSIP: Overwriting old data on destination security: %s (Was: Scheme: %s ID: %s)" %(selectedSecurityMoveTo,findScheme,moveToOldData))

                        myPrint("B","FIX CUSIP: Moving CUSIP data from %s to %s Scheme: %s ID: %s" %(selectedSecurity, selectedSecurityMoveTo,findScheme,moveData))
                        selectedSecurityMoveTo.setIDForScheme(findScheme, moveData)
                        selectedSecurity.setIDForScheme(findScheme, None)

                selectedSecurity.syncItem()
                selectedSecurityMoveTo.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s Moved to Security: %s!" %(selectedSecurity,selectedSecurityMoveTo),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lEdit:

                listData=[]
                for x in theSchemes:
                    listData.append(x[1])

                selectedSchemeToChange = JOptionPane.showInputDialog(toolbox_frame_,
                                                                     "Select the CUSIP to edit:",
                                                                     "FIX CUSIP",
                                                                     JOptionPane.INFORMATION_MESSAGE,
                                                                     getMDIcon(lAlwaysGetIcon=True),
                                                                     listData,
                                                                     None)

                if not selectedSchemeToChange:
                    txt = "FIX CUSIP - No CUSIP selected to edit - no changes made.."
                    setDisplayStatus(txt, "R")
                    return

                newID = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","ENTER NEW ID DATA:","Enter the new CUSIP data for Security: %s CUSIP: %s"
                                           %(selectedSecurity,selectedSchemeToChange),selectedSecurity.getIDForScheme(selectedSchemeToChange))

                if not newID or newID == selectedSecurity.getIDForScheme(selectedSchemeToChange):
                    txt = "FIX CUSIP - EDIT - new data not entered - no changes made"
                    setDisplayStatus(txt, "R")
                    return

                myPrint("B","FIX CUSIP - EDIT. Changing Security: %s CUSPID: %s from %s to %s"
                        %(selectedSecurity,selectedSchemeToChange,selectedSecurity.getIDForScheme(selectedSchemeToChange),newID))

                selectedSecurity.setIDForScheme(selectedSchemeToChange,newID)
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s CUSIP: %s changed to: %s"
                                      %(selectedSecurity, selectedSchemeToChange,newID),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lAdd:

                newScheme = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","NEW CUSIP Scheme/Key:","Enter Scheme Type to add (normally 'CUSIP'): %s"
                                               %(selectedSecurity), defaultValue="CUSIP")

                if not newScheme or newScheme == "":
                    txt = "FIX CUSIP - EDIT - new CUSIP Scheme Type not entered - no changes made"
                    setDisplayStatus(txt, "R")
                    return

                newID = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","NEW CUSIP ID:","Enter the new CUSIP ID for Scheme Type: %s to add to Security: %s"
                                           %(newScheme,selectedSecurity))

                if not newID or newID == "":
                    txt = "FIX CUSIP - EDIT - new CUSIP ID not entered for new Scheme: %s to add to Security: %s - no changes made" %(newScheme,selectedSecurity)
                    setDisplayStatus(txt, "R")
                    return

                myPrint("B","FIX CUSIP - ADD. Adding CUSIP: %s ID %s to Security: %s"
                        %(newScheme, newID, selectedSecurity))

                selectedSecurity.setIDForScheme(newScheme,newID)
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP Scheme/Key: %s ID: %s added to Security: %s"
                                      %(newScheme, newID, selectedSecurity),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            else:
                txt = "FIX CUSIP - Unknown option selected - no changes made"
                setDisplayStatus(txt, "R")
                return

            txt = "FIX CUSIP - Changes successfully applied to Security: %s" %(selectedSecurity)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("CUSIPFix", txt)
            play_the_money_sound()

    class StoreService():
        def __init__(self, obj):
            if isinstance(obj,OnlineService):
                self.obj = obj                          # type: OnlineService
            else:
                self.obj = None

        def getService(self):
            # type: () -> OnlineService
            return (self.obj)

        def __str__(self):
            if self.obj is None:
                return "Invalid OnlineService Obj or None"
            return "Connection profile: %s (%s)" %(self.obj.getFIName(), self.obj.getTIKServiceID())

        def __repr__(self): return self.__str__()


    def deleteOFXService():
        # remove_one_service.py

        _THIS_METHOD_NAME = "DELETE ONLINE BANKING SERVICE / PROFILE"

        service = getUserSelectedServiceProfile(toolbox_frame_, _THIS_METHOD_NAME, "Select an Online Banking Service / Profile to delete", lIncludePlaidWhenUnlocked=True)  # type: OnlineService
        if not service: return

        if service.getTIKServiceID() == "md:plaid":
            if not myPopupAskQuestion(toolbox_frame_,
                                  _THIS_METHOD_NAME.upper(),
                                  "Are you SURE you want to delete the Moneydance+ profile? - You should NOT normally touch this! (But it should recreate itself)",
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "%s: User declined to delete the Moneydance+ profile (phew) - no changes made.." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                return

            myPrint("B","%s: User confirmed to delete the Moneydance+ Online Banking Profile...." %(_THIS_METHOD_NAME))

        if confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Delete Bank Service/Logon profile %s?" %(service)):
            # noinspection PyUnresolvedReferences
            service.clearAuthenticationCache()
            # noinspection PyUnresolvedReferences
            service.deleteItem()
            LS = MD_REF.getCurrentAccountBook().getLocalStorage()
            LS.save()

            cleanupMissingOnlineBankingLinks(lAutoPurge=True)

            txt = "Online Banking Service / Logon Profile successfully deleted: %s" %(service)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("deleteOFXService", txt)
            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME.upper(), JOptionPane.WARNING_MESSAGE)

    def cleanupMissingOnlineBankingLinks(lAutoPurge=False):
        _THIS_METHOD_NAME = "OFX Cleanup Missing Banking Links"

        PLAID_MAP_KEY = "map.md:plaid:::"

        mappingObject = None
        if isMDPlusEnabledBuild():
            p_osl = OnlineServiceLink.getDeclaredConstructor([String, String, Account])                                 # noqa
            p_osl.setAccessible(True)
            mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")

        ####################################################################################################################
        invalid_olblink_links = []      # New for MD2022 onwards
        invalid_mapping_links = []      # New for MD2022 onwards
        invalidBankingLinks = []
        invalidBillPayLinks = []

        myPrint("B","Searching for Account Online Banking / Bill Pay links with no profile (general cleanup routine)....")
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(26))

        for a in accounts:

            for pk in a.getParameterKeys():
                p_value = a.getParameter(pk, "")
                if pk == "olbfi" and a.getBankingFI() is None and p_value != "":
                    invalidBankingLinks.append(a)
                    myPrint("B","... Found account '%s' with a OFX banking link (to %s), but no service profile exists (thus dead)..." %(a,p_value))

                if pk == "bpfi" and a.getBillPayFI() is None and p_value != "":
                    invalidBillPayLinks.append(a)
                    myPrint("B","... Found account '%s' with a BillPay link (to %s), but no service profile exists (thus dead)..." %(a,p_value))

                if isMDPlusEnabledBuild():
                    if pk.startswith("olblink.") and p_value != "":
                        # link = OnlineServiceLink(pk[len("olblink."):], p_value, a)                                    # noqa
                        link = p_osl.newInstance(pk[len("olblink."):], p_value, a)                                      # noqa
                        if link.getService() is None:
                            invalid_olblink_links.append([a,link.onlineServiceID])
                            myPrint("B","... Found account '%s' with new 'olblink.' link ('%s' : '%s'), but no service profile exists (thus dead)..." %(a,pk, p_value))

        if isMDPlusEnabledBuild(): p_osl.setAccessible(False)

        if mappingObject is not None:
            myPrint("B","Searching for Orphaned mapping links (MD2022 onwards) (general cleanup routine)....")

            acctXRefDict = getAvailAccountsXRefDict()

            for objectKey in mappingObject.getParameterKeys():
                _value = mappingObject.getParameter(objectKey)

                if objectKey.startswith("map.none") or _value == "_none_": continue

                if objectKey.startswith("map."):
                    if objectKey.startswith(PLAID_MAP_KEY):
                        plaid_acct = objectKey[len(PLAID_MAP_KEY):].strip()
                        acctLookup = acctXRefDict.get(plaid_acct)           # type: StoreMDPlusLinkages
                        if acctLookup is None:
                            myPrint("B","...Found dead/orphaned MD+/Plaid mapping link ('%s' : '%s')" %(objectKey, _value))
                            invalid_mapping_links.append(objectKey)

                    mappedAccount = MD_REF.getCurrentAccountBook().getAccountByUUID(_value)
                    if mappedAccount is None:
                        myPrint("B","...Found orphaned mapping link ('%s' : '%s')" %(objectKey, _value))
                        invalid_mapping_links.append(objectKey)

        totalDead = len(invalidBankingLinks) + len(invalidBillPayLinks) + len(invalid_olblink_links) + len(invalid_mapping_links)
        myPrint("B", "%s: WARNING - %s dead banking links (and/or orphaned mapping links) found!" %(_THIS_METHOD_NAME.upper(), totalDead))

        if totalDead < 1:
            txt = "%s: CONGRATULATIONS - I found no Invalid Online Banking Links / Orphaned Mapping links......." %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            if not lAutoPurge:
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt)
            return

        if not lAutoPurge and not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Cleanup (remove) %s missing/dead online banking links?" %(totalDead)):
            return

        for a in invalidBankingLinks:
            a.setBankingFI(None)
            a.syncItem()
            myPrint("B","...removed the dead link Banking link on account %s" %(a))

        for a in invalidBillPayLinks:
            a.setBillPayFI(None)
            a.syncItem()
            myPrint("B","...removed the dead link BillPay link on account %s" %(a))

        for alink in invalid_olblink_links:
            alink[0].setOnlineIDForServiceID(alink[1], None)
            alink[0].syncItem()
            myPrint("B","...removed the dead link 'olblink.' link on account %s" %(alink[0]))

        if mappingObject is not None and len(invalid_mapping_links) > 0:
            mappingObject.setEditingMode()
            for maplink in invalid_mapping_links:
                myPrint("B","...removed the orphaned mapping link: %s : %s" %(maplink, mappingObject.getParameter(maplink)))
                mappingObject.setParameter(maplink, None)
            mappingObject.syncItem()

        del invalidBankingLinks, invalidBillPayLinks, invalid_olblink_links, accounts, invalid_mapping_links, mappingObject
        ####################################################################################################################

        txt = "%s dead/missing Online Banking links successfully removed (review console for details)" %(totalDead)
        myPrint("B", txt)
        logToolboxUpdates("cleanupMissingOnlineBankingLinks", txt)

        if not lAutoPurge:
            setDisplayStatus(txt, "B")
            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME.upper(), JOptionPane.WARNING_MESSAGE)

    class StoreMDPlusLinkages():

        def __init__(self, _svc, _acct_ref, _map_key, _plaidID, _desc):
            self._svc = _svc
            self._acct_ref = _acct_ref
            self._map_key = _map_key
            self._plaidID = _plaidID
            self._desc = _desc

        def getPlaidID(self): return self._plaidID

        def getDesc(self): return self._desc

    def getPlaidService():
        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        for service in serviceList:
            if service.getTIKServiceID() == "md:plaid": return service
        return None

    def getAvailAccountsXRefDict():
        """Searches all Online Banking profiles and builds a x-ref list of Accounts to Plaid Connection refs"""

        mdplus_linkages = {}
        if isMDPlusEnabledBuild():
            service = getPlaidService()     # type: OnlineService
            if service is not None:
                for availAccount in service.getAvailableAccounts():
                    mdplus_linkages[availAccount.getAccountNumber()] = StoreMDPlusLinkages(service,
                                                                       availAccount.getAccountNumber(),
                                                                       availAccount.getMappingKey(),
                                                                       availAccount.getPlaidItemID(),
                                                                       availAccount.getDescription())
        return mdplus_linkages

    def special_toMultilineHumanReadableString(_object, lSkipSecrets=True, sFilterServiceID=None, lRedact=False):
        _output = ""
        if not _object: return _output

        if not sFilterServiceID:
            _output = "Object Parameter Keys:\n" \
                      " ---------------------\n"

        PLAID_MAP_KEY = "map.md:plaid:::"

        acctXRefDict = getAvailAccountsXRefDict() if (_object.getParameter("id", None) == "online_acct_mapping") else {}

        hide_keys = ["mdplus.priv", "mdplus.pub"]
        for objectKey in sorted(_object.getParameterKeys()):
            _value = _object.getParameter(objectKey)

            acctText = ""
            acctXRef = ""

            if sFilterServiceID and not objectKey.startswith("map.%s" %(sFilterServiceID)): continue

            if objectKey.startswith("map."):
                if isMDPlusEnabledBuild() and objectKey.startswith(PLAID_MAP_KEY):
                    plaid_acct = objectKey[len(PLAID_MAP_KEY):].strip()
                    acctLookup = acctXRefDict.get(plaid_acct)           # type: StoreMDPlusLinkages
                    if acctLookup is not None:
                        acctXRef = "(Plaid ref: %s, Desc: %s) " %(acctLookup.getPlaidID(), acctLookup.getDesc())
                    else:
                        acctXRef = "(Orphan) "

                mappedAccount = MD_REF.getCurrentAccountBook().getAccountByUUID(_value)
                acctText = "(%s)" %("Missing Account" if (mappedAccount is None) else mappedAccount.getFullAccountName())

            if lSkipSecrets:
                if objectKey in hide_keys: _value = "****** hidden ****** (length: %s)" %(len(_value))

            if lRedact and not objectKey.startswith(PLAID_MAP_KEY) and ":::" in objectKey:
                redactedKey = objectKey[:objectKey.find(":::")+2] + redactor(objectKey[objectKey.find(":::")+3:])
                objectKey = redactedKey

            _output += "Key: %s %sValue: %s %s\n" %(objectKey, acctXRef, _value, acctText)

        if not sFilterServiceID: _output += " ---------------------\n"
        return _output

    def getUserIDFromEmail(_emailAddress):
        if (_emailAddress is None): return ""
        digest = MessageDigest.getInstance("MD5")
        digest.update(String(String(String(_emailAddress).toLowerCase(Locale.ROOT)).trim()).getBytes(StandardCharsets.UTF_8))
        return StringUtils.encodeHex(digest.digest(), False)

    def getKeyID(_pubKeyHex):
        pubKeyBytes = StringUtils.decodeHex(_pubKeyHex)
        digest = MessageDigest.getInstance("MD5")
        digest.update(pubKeyBytes)
        keyID = StringUtils.encodeHex(digest.digest(), False)
        return keyID

    def getByteArray(syncObj, key):
        result = String(syncObj.get(key))
        return None if result is None else StringUtils.decodeHex(result)

    def decodePrivKey(pubKeyHex, privKeyHex):
        pubKeyBytes = StringUtils.decodeHex(pubKeyHex)
        privKeyBytes = StringUtils.decodeHex(privKeyHex)
        digest = MessageDigest.getInstance("MD5")
        digest.update(pubKeyBytes)
        kf = KeyFactory.getInstance("RSA")
        privkey = kf.generatePrivate(PKCS8EncodedKeySpec(privKeyBytes))
        pubkey = kf.generatePublic(X509EncodedKeySpec(pubKeyBytes))
        if privkey is None or pubkey is None: return None, None
        return pubkey, privkey

    def decrypt(cipherText, pubkey, privkey):                                                                           # noqa
        # noinspection PyUnresolvedReferences
        ENCRYPTION_PARAM_SPEC = OAEPParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec("SHA-256"), PSource.PSpecified.DEFAULT)
        if (FileUtils.byteArraysMatch(String("eparcel").getBytes(StandardCharsets.UTF_8), cipherText, 7)):
            parcel = SyncRecord()
            parcel.readSet(ByteArrayInputStream(cipherText))
            if (not parcel.containsKey("key") or  not parcel.containsKey("payload")):                                   # noqa
                return None  # Invalid encrypted parcel
            cipher1 = Cipher.getInstance("RSA/ECB/OAEPPadding")
            cipher1.init(2, privkey, ENCRYPTION_PARAM_SPEC)
            decryptedKey = cipher1.doFinal(getByteArray(parcel, "key"))
            originalKey = SecretKeySpec(decryptedKey, 0, len(decryptedKey), "AES")
            aesCipher = Cipher.getInstance("AES")
            aesCipher.init(2, originalKey)
            return aesCipher.doFinal(getByteArray(parcel, "payload"))

        cipher = Cipher.getInstance("RSA/ECB/OAEPPadding")
        cipher.init(2, privkey, ENCRYPTION_PARAM_SPEC)
        return cipher.doFinal(cipherText)

    def getLicenseForBook(_book, initIfDoesntExist):

        if not isMDPlusEnabledBuild(): return None

        # com.moneydance.apps.md.controller.MDPlus.getLicenseForBook(AccountBook, boolean) : MDPlus.MDPlusLicense
        # ... Will fail with 'java.lang.Error: java.lang.Error: Attempted security violation' on .getMDPlusLicense()
        # ... as "plusLicense" will not have yet been obtained, and the latter code calls .getLicenseForBook() which prevents Python
        # ... so we either need to get MD to do something which tricks it into setting "plusLicense" in advance.... ;->
        # ... or execute in a new Thread where MD will not detect "Python" at the top of the call stack....

        class GetLicenseForBook(Runnable):
            def __init__(self, theBook, _initIfDoesntExist):
                myPrint("DB", "INITIALISING::getLicenseForBook().GetLicenseForBook()")
                self.book = theBook
                self.initIfDoesntExist = _initIfDoesntExist
                self.plusLicense = None

            def run(self):
                myPrint("DB", "EXECUTING::getLicenseForBook().GetLicenseForBook.run() - will call MDPlus.singleton().getLicenseForBook()")
                self.plusLicense = MDPlus.singleton().getLicenseForBook(self.book, self.initIfDoesntExist)
                myPrint("DB", ">>> Finished executing GetLicenseForBook.run() - result:", self.plusLicense)

            def getResult(self):
                myPrint("DB", "getLicenseForBook().GetLicenseForBook.getResult() is returning:", self.plusLicense)
                return self.plusLicense

        clientGrabber = GetLicenseForBook(_book, initIfDoesntExist)
        t = Thread(clientGrabber, "toolbox_getLicenseForBook")
        t.start()
        t.join()
        return clientGrabber.getResult()

    def getPlaidClient(_plaidConnection):

        if not isMDPlusGetPlaidClientEnabledBuild(): return None

        # if com.moneydance.apps.md.controller.olb.plaid.PlaidConnection.getPlaidClient() is run too 'early',
        # ... then it will fail with 'java.lang.Error: java.lang.Error: Attempted security violation' on .getMDPlusLicense()
        # ... as "plusLicense" will not have yet been obtained, and the latter code calls .getLicenseForBook() which prevents Python
        # ... so we either need to get MD to do something which tricks it into setting "plusLicense" in advance.... ;->
        # ... or execute in a new Thread where MD will not detect "Python" at the top of the call stack....
        # Ref: com.moneydance.apps.md.controller.olb.plaid.PlaidConnection.plusLicense : MDPlus.MDPlusLicense

        class GetPlaidClient(Runnable):
            def __init__(self, thePlaidConnection):
                myPrint("DB", "INITIALISING::getPlaidClient().GetPlaidClient() - Plaid Connection passed:", thePlaidConnection)
                self.plaidConnection = thePlaidConnection
                self.plaidClient = None

            def run(self):
                myPrint("DB", "EXECUTING::getPlaidClient().GetPlaidClient.run()")
                try:
                    self.plaidClient = invokeMethodByReflection(self.plaidConnection, "getPlaidClient", None)
                except NoClassDefFoundError as e:
                    myPrint("B", "Caught error '%s' (expect it's 'HttpLoggingInterceptor') - will retry once more....:" %(e.getMessage()))
                    # Running twice seems to get past the 'NoClassDefFoundError: java.lang.NoClassDefFoundError: okhttp3/logging/HttpLoggingInterceptor' error
                    self.plaidClient = invokeMethodByReflection(self.plaidConnection, "getPlaidClient", None)
                myPrint("DB", ">>> Finished executing GetPlaidClient.run() - result:", self.plaidClient)

            def getResult(self):
                myPrint("DB", "getPlaidClient().GetPlaidClient.getResult() is returning:", self.plaidClient)
                return self.plaidClient

        clientGrabber = GetPlaidClient(_plaidConnection)
        t = Thread(clientGrabber, "toolbox_getPlaidClient")
        t.start()
        t.join()
        return clientGrabber.getResult()

    def UNLOCKMDPlusDiagnostic():

        if not isToolboxUnlocked() or not isMDPlusEnabledBuild(): return

        _THIS_METHOD_NAME = "UNLOCKED Moneydance+ Diagnostics"

        output = "%s:\n %s\n\n" %(_THIS_METHOD_NAME, "-"*len(_THIS_METHOD_NAME))

        licenseObject = getMDPlusLicenseInfoForBook()               # Note: Builds prior to 2006 will return None anyway...
        if licenseObject is None:
            output += "No Moneydance+ License Object found\n".upper()
        else:
            output += "Moneydance+ License Object found... Details:\n"

            mdplus_email = licenseObject.getParameter("mdplus.account_email", None)                                     # noqa
            mdplus_pend_email = licenseObject.getParameter("mdplus.pending_email", None)                                # noqa
            mdplus_signup_status = licenseObject.getParameter("signup_status", None)                                    # noqa
            mdplus_keyRegenDate = licenseObject.getLongParameter("mdplus.date", 0L)                                     # noqa
            mdplus_refreshDate = licenseObject.getLongParameter("mdplus.refresh_date", 0L)                              # noqa
            mdplus_keypairCreated = licenseObject.getLongParameter("mdplus.keypair_created", 0L)                        # noqa
            mdplus_privKeyHex = licenseObject.getParameter("mdplus.priv", None)                                         # noqa
            mdplus_pubKeyHex = licenseObject.getParameter("mdplus.pub", None)                                           # noqa

            output += "Dataset's UUID:          %s\n" %(MD_REF.getCurrentAccountBook().getFileUUID())
            output += "Email:                   %s\n" %(mdplus_email)
            output += "Email's MD5 encoded hex: %s\n" %(getUserIDFromEmail(mdplus_email))
            output += "Pending Email:           %s\n" %(mdplus_pend_email)
            if mdplus_signup_status:    output += "Signup status:           %s\n" %(mdplus_signup_status)
            if mdplus_keyRegenDate:     output += "MD+ date:                %s\n" %(get_time_stamp_as_nice_text(mdplus_keyRegenDate))
            if mdplus_refreshDate:      output += "MD+ refresh date:        %s\n" %(get_time_stamp_as_nice_text(mdplus_refreshDate))
            if mdplus_keypairCreated:   output += "MD+ keypair date:        %s\n" %(get_time_stamp_as_nice_text(mdplus_keypairCreated))
            if mdplus_privKeyHex:       output += "MD+ Private Key (raw):   %s\n" %(mdplus_privKeyHex)
            if mdplus_pubKeyHex:
                output += "MD+ Public Key (raw):    %s\n\n" %(mdplus_pubKeyHex)
                output += "Dataset/license 'KeyID': %s\n" %(getKeyID(mdplus_pubKeyHex))

            statusURL = None
            if mdplus_pubKeyHex and mdplus_email:
                statusURL = ("https://mdplus.infinitekind.com/tik/get_status/%s/%s"
                             %(getUserIDFromEmail(mdplus_email), getKeyID(mdplus_pubKeyHex)))
                output += "\nMD Check Key Status URL:\n%s\n\n" %(statusURL)

            if statusURL:
                output += "\nDATA DOWNLOADED FROM URL:\n"
                pubkey = privkey = None                                                                                 # noqa
                try:
                    grabGson = Gson()
                    url = URL(statusURL)
                    inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
                    status_outerJson = grabGson.fromJson(inx, Map); inx.close()                                         # type: HashMap

                    for o in status_outerJson:
                        output += "Key: %s: Value: %s\n" %(o, status_outerJson.get(o))                                  # noqa

                    status = status_outerJson.getOrDefault("status", "none")                                            # noqa
                    responseMsg = String.valueOf(status_outerJson.getOrDefault("message", ""))                          # noqa

                    pubkey, privkey = decodePrivKey(mdplus_pubKeyHex, mdplus_privKeyHex)

                    userInfo = SyncRecord()
                    userDataObject = status_outerJson.get("user_data")                                                  # noqa
                    userPayloadsJSON = HashMap() if userDataObject is None else userDataObject
                    for payloadKey in userPayloadsJSON.keySet():
                        cipherValue = StringUtils.decodeHex(String.valueOf(userPayloadsJSON.get(payloadKey)))
                        try:
                            accessTokenInfo = SyncRecord()
                            accessTokenInfo.readSet(ByteArrayInputStream(decrypt(cipherValue, pubkey, privkey)))
                            output += "'user_data' User Payload key: %s Decrypted value: %s\n" %(String.valueOf(payloadKey), accessTokenInfo)
                        except:
                            output += "'user_data' unable to decrypt user payload:       %s\n" % (payloadKey)

                    keyDataObject = status_outerJson.get("key_data")                                                    # noqa
                    keyPayloadsJSON = HashMap() if keyDataObject is None else keyDataObject
                    for payloadKey in keyPayloadsJSON.keySet():
                        cipherValue = StringUtils.decodeHex(String.valueOf(keyPayloadsJSON.get(payloadKey)))
                        try:
                            accessTokenInfo = SyncRecord()
                            accessTokenInfo.readSet(ByteArrayInputStream(decrypt(cipherValue, pubkey, privkey)))
                            output += "'key_data' Key Payload key: %s Decrypted value:   %s\n" %(String.valueOf(payloadKey), accessTokenInfo)
                        except:
                            output += "'key_data' unable to decrypt key payload:         %s\n" % (payloadKey)

                    if status_outerJson.containsKey("encrypted"):                                                       # noqa
                        ciphertext = StringUtils.decodeHex(String.valueOf(status_outerJson.get("encrypted")))           # noqa
                        clearbytes = decrypt(ciphertext, pubkey, privkey)
                        userInfo.readSet(ByteArrayInputStream(clearbytes))
                        for ui in userInfo:
                            output += "'encrypted'... Key: %s Value %s\n" %(ui, userInfo.get(ui))                       # noqa

                    output += "<END OF URL DATA>\n\n"
                except:
                    output += "Error downloading, decrypting status data from IK URL...!?\n"
                    output += dump_sys_error_to_md_console_and_errorlog(True)
                    output += "<END OF URL DATA>\n\n"

                finally:
                    del pubkey, privkey

            tokens = MD_REF.getCurrentAccountBook().getLocalStorage().getSublist("access_tokens")
            output += "\n>>Moneydance+ Access Tokens (local storage 'access_tokens')...:\n"
            if len(tokens) > 0:
                for token in tokens:
                    for token_key in token:
                        output += "Key: %s Value: %s\n" %(token_key, token.get(token_key))
            else:
                output += "<NONE>\n"

            mdp_cache = MD_REF.getCurrentAccountBook().getLocalStorage().getSubset("mdp_items")
            output += "\n>>Moneydance+ Plaid Cache (local storage 'mdp_items')...:\n"
            if len(mdp_cache) > 0:
                for cacheItem in mdp_cache:
                    output += "Key: %s Value: %s\n" %(cacheItem, mdp_cache.get(cacheItem))
            else:
                output += "<NONE>\n"
            del mdp_cache

            output += "\n>>Account Mappings Object's PARAMETER KEYS (MD2022 onwards)\n"
            mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")
            if mappingObject is None:
                output += "<NO ACCOUNT MAPPING OBJECT FOUND>\n"
            else:
                output += special_toMultilineHumanReadableString(mappingObject, lSkipSecrets=False)

        output += "\n<END>"
        QuickJFrame(_THIS_METHOD_NAME.upper(),output,lAlertLevel=1,copyToClipboard=False,lWrapText=False).show_the_frame()

        txt = "%s: CONFIDENTIAL Moneydance+ settings displayed... DO NOT SHARE THESE WITH ANYONE" %(_THIS_METHOD_NAME.upper())
        setDisplayStatus(txt, "R"); myPrint("B", txt)

    def export_MDPlus_LicenseObject():
        _THIS_METHOD_NAME = "Export Moneydance+ (Plaid) license (keys) to file"
        _TEST_KEY = "Confidential data: KEYTEST123$"

        licenseObject = getMDPlusLicenseInfoForBook()

        if licenseObject is None:
            myPopupInformationBox(toolbox_frame_,"No Moneydance+ license object found - NO EXPORT PERFORMED!",_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        mdplus_email = licenseObject.getParameter("mdplus.account_email", None)                                         # noqa
        mdplus_pend_email = licenseObject.getParameter("mdplus.pending_email", None)                                    # noqa
        mdplus_signup_status = licenseObject.getParameter("signup_status", None)                                        # noqa
        mdplus_keyRegenDate = licenseObject.getLongParameter("mdplus.date", 0L)                                         # noqa
        mdplus_refreshDate = licenseObject.getLongParameter("mdplus.refresh_date", 0L)                                  # noqa
        mdplus_keypairCreated = licenseObject.getLongParameter("mdplus.keypair_created", 0L)                            # noqa
        mdplus_privKeyHex = licenseObject.getParameter("mdplus.priv", None)                                             # noqa
        mdplus_pubKeyHex = licenseObject.getParameter("mdplus.pub", None)                                               # noqa

        if not mdplus_email or not mdplus_pubKeyHex or not mdplus_privKeyHex or not mdplus_signup_status:
            txt = "No Valid Moneydance+ license object found - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME.upper(),"ALERT: This Exports your confidential MD+(Plaid) private/public keys to an encrypted file. Continue?"):
            return

        theTitle = "Select location to Export your encrypted Moneydance+ license object ... (CANCEL=ABORT)"
        exportFile = getFileFromFileChooser(toolbox_frame_,                                     # Parent frame or None
                                            get_home_dir(),                                     # Starting path
                                            "MoneydancePlus_license_object_CONFIDENTIAL.mdp",   # Default Filename
                                            theTitle,                                           # Title
                                            False,                                              # Multi-file selection mode
                                            False,                                              # True for Open/Load, False for Save
                                            True,                                               # True = Files, else Dirs
                                            "EXPORT",                                           # Load/Save button text, None for defaults
                                            "mdp",                                              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if exportFile is None or exportFile == "": return

        encryptionKey = myPopupAskForInput(toolbox_frame_,
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           theFieldLabel="Encryption password:",
                                           theFieldDescription="Enter any password you like to encrypt the exported data (YOU MUST REMEMBER THIS!)",
                                           isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if encryptionKey is None or encryptionKey == "":
            txt = "Encryption password not entered - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        verifyEncryptionKey = myPopupAskForInput(toolbox_frame_,
                                                theTitle=_THIS_METHOD_NAME.upper(),
                                                theFieldLabel="RE-ENTER the same Encryption password:",
                                                theFieldDescription="REENTER the password to verify it's the same....",
                                                isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if verifyEncryptionKey is None or verifyEncryptionKey == "" or verifyEncryptionKey != encryptionKey:
            txt = "Encryption password not re-entered successfully - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return
        del verifyEncryptionKey

        p_cipher = MDSyncCipher.getDeclaredConstructor([String])                                                        # noqa
        p_cipher.setAccessible(True)
        cipher = p_cipher.newInstance(encryptionKey)
        del encryptionKey

        fout = FileOutputStream(File(exportFile))
        export_encryptedStream = invokeMethodByReflection(cipher, "getEncryptStream", [OutputStream], [fout])

        # Pause the MD+ poller...
        if isMDPlusEnabledBuild():
            myPrint("B", "Pausing MD+")
            plusPoller = MD_REF.getUI().getPlusController()
            invokeMethodByReflection(plusPoller, "pausePolling", None)

        exportMDPlusData = StreamTable()
        exportMDPlusData.put("_TOOLBOX_",_TEST_KEY)
        for object_key in licenseObject.getParameterKeys():
            # encryptedData = String(MDSyncCipher.encryptString(licenseObject.getParameter(object_key), encryptionKey), StandardCharsets.UTF_8)
            theData = licenseObject.getParameter(object_key)
            exportMDPlusData.put(object_key, theData)
            del theData

        MD_REF.saveCurrentAccount()

        try:
            exportMDPlusData.writeTo(export_encryptedStream)
            export_encryptedStream.flush(); export_encryptedStream.close()
            fout.close()
            del cipher, exportMDPlusData, licenseObject

            txt = "Moneydance+ settings encrypted & exported to: %s" %(exportFile)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            logToolboxUpdates("export_MDPlus_LicenseObject", txt)

            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

            txt = "Exported (encrypted) file contains confidential MD+(Plaid) license key data. Use then DELETE file ASAP!"
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR exporting & decrypting Moneydance+ license object to: %s (review console)" %(exportFile)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)

        if isMDPlusEnabledBuild():
            myPrint("B", "Un-pausing MD+")
            plusPoller = MD_REF.getUI().getPlusController()
            invokeMethodByReflection(plusPoller, "resumePolling", None)

    def import_MDPlus_LicenseObject():
        if not isMDPlusEnabledBuild(): return

        _THIS_METHOD_NAME = "Import Moneydance+ (Plaid) license object from file"
        _TEST_KEY = "Confidential data: KEYTEST123$"

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME.upper(), "WARNING: This will overwrite/replace/transplant your MD+(Plaid) license object with data from a file. Continue?"):
            return False

        book = MD_REF.getCurrentAccountBook()

        theTitle = "Select file to Import ('transplant') your Moneydance+ license object from... (CANCEL=ABORT)"
        importFile = getFileFromFileChooser(toolbox_frame_,                                     # Parent frame or None
                                            get_home_dir(),                                     # Starting path
                                            "MoneydancePlus_license_object_CONFIDENTIAL.mdp",   # Default Filename
                                            theTitle,                                           # Title
                                            False,                                              # Multi-file selection mode
                                            True,                                               # True for Open/Load, False for Save
                                            True,                                               # True = Files, else Dirs
                                            "IMPORT",                                           # Load/Save button text, None for defaults
                                            "mdp",                                              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if importFile is None or importFile == "": return False

        encryptionKey = myPopupAskForInput(toolbox_frame_,
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           theFieldLabel="Decryption password:",
                                           theFieldDescription="Enter the encryption password you used when Exporting the data...",
                                           isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if encryptionKey is None or encryptionKey == "":
            txt = "Decryption password not entered - NO IMPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        p_cipher = MDSyncCipher.getDeclaredConstructor([String])                                                        # noqa
        p_cipher.setAccessible(True)
        cipher = p_cipher.newInstance(encryptionKey)
        del encryptionKey

        if isKotlinCompiledBuild():
            fin = Okio.buffer(Okio.source(FileInputStream(File(importFile))))
            import_decryptedStream = invokeMethodByReflection(cipher, "getDecryptStream", [BufferedSource], [fin])
        else:
            fin = FileInputStream(File(importFile))
            import_decryptedStream = invokeMethodByReflection(cipher, "getDecryptStream", [InputStream], [fin])

        try:
            importMDPlusData = StreamTable()
            importMDPlusData.readFrom(import_decryptedStream)
            import_decryptedStream.close(); fin.close()
            del cipher
            myPrint("DB","Import... StreamTable read & decrypted from file: %s" %(importFile))
        except:
            if debug: dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR decrypting IMPORT file >> Wrong password entered? (review console) - NO CHANGES MADE!"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return False

        mdplus_keys = [ "mdplus.account_email",
                        "mdplus.pending_email",
                        "signup_status",
                        "mdplus.date",
                        "mdplus.refresh_date",
                        "mdplus.keypair_created",
                        "mdplus.priv",
                        "mdplus.pub"]

        mdplus_validateKeys = [ "_TOOLBOX_",
                                "mdplus.account_email",
                                "signup_status",
                                "mdplus.priv",
                                "mdplus.pub"]

        mdplus_skipKeys = ["_TOOLBOX_",
                           "id",
                           "obj_type",
                           "ts",
                           "_txnfile"]

        # noinspection PyUnresolvedReferences
        for checkKey in mdplus_validateKeys:

            if not importMDPlusData.get(checkKey):
                myPrint("B","Import validation: Failed checking for key '%s' (missing)" %(checkKey))
                txt = "Import file for Moneydance+ license object INVALID - NO IMPORT PERFORMED!"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
                return False

            if checkKey == "_TOOLBOX_":
                if importMDPlusData.get(checkKey) != _TEST_KEY:
                    txt = "Decryption test failed.. Did you enter the correct password? >> NO IMPORT PERFORMED!"
                    setDisplayStatus(txt, "R"); myPrint("B", txt)
                    myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
                    return
                myPrint("B","Verified that the _TOOLBOX_ Key Test properly decrypted... Proceeding....")

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(), "Import ('transplant') Moneydance+ license object from file & OVERWRITE EXISTING SETTINGS?"):
            return False

        myPrint("B", "... shutting down the md+ controller...")
        shutdownMDPlusPoller()

        preZapMDPlusSettingsFirst = myPopupAskQuestion(toolbox_frame_, _THIS_METHOD_NAME, "Wipe all pre-existing MD+ settings before importing MD+ licence?")

        if preZapMDPlusSettingsFirst:
            zap_MDPlus_Profile(lAutoZap=True)
        else:
            forceMDPlusNameCacheAccessTokensRebuild(lAutoWipe=True)   # Clear the LocalStorage cache.... It will rebuild itself...

        licenseObject = getMDPlusLicenseInfoForBook()

        if licenseObject is not None:
            myPrint("B","Moneydance+ IMPORT.. Existing license object will be overwritten.. Settings were..:\n", special_toMultilineHumanReadableString(licenseObject))
            licenseObject.setEditingMode()
            for key_to_delete in mdplus_keys: licenseObject.setParameter(key_to_delete, None)
        else:
            myPrint("B","Creating new Moneydance+(Plaid) license object....")
            licenseObject = MoneydanceSyncableItem(book)
            licenseObject.setEditingMode()
            licenseObject.setParameter("id", "tik.mdplus-license")
            licenseObject.setParameter("obj_type", "misc")

        for object_key in importMDPlusData:
            if object_key in mdplus_keys:
                licenseObject.setParameter(object_key, importMDPlusData.get(object_key))
                myPrint("B","IMPORT... Setting key %s into MD+ license object..." %(object_key))
            elif object_key in mdplus_skipKeys: pass
            else: myPrint("B","IMPORT.. Ignoring/skipping the setting: '%s', Value: '%s'" %(object_key,importMDPlusData.get(object_key)))

        licenseObject.syncItem()

        myPrint("B", "... Auto-running cleanup of banking links...")
        cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().getLocalStorage().save()

        del importMDPlusData, licenseObject

        myPrint("B", "Deleting Moneydance+ Import file...: %s" %(importFile))
        try: os.remove(importFile)
        except: pass

        txt = "Moneydance+ license object IMPORTED (import file deleted) >> MONEYDANCE WILL NOW RELOAD DATASET/RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("import_MDPlus_LicenseObject", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def zap_MDPlus_Profile(lAutoZap=False):
        _THIS_METHOD_NAME = "Zap Dataset's Moneydance+ (Plaid) settings"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        licenseObject = getMDPlusLicenseInfoForBook()

        # if licenseObject is None:
        #     myPopupInformationBox(toolbox_frame_,"NO Moneydance+ settings/profile found - NO CHANGES MADE!",_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
        #     return False

        if not lAutoZap:
            if isMDPlusLicenseActivated():
                ask = MyPopUpDialogBox(toolbox_frame_,
                                     theStatus="WARNING: Attempting to ZAP MD+ settings when Dataset status is ACTIVATED!?",
                                     theTitle=_THIS_METHOD_NAME.upper(),
                                     theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                                "This dataset has an Activated MD+ License. (You may lose access to your subscription)\n"
                                                "If you ZAP, then your Account linkages will still be stored on the IK/Plaid servers ('Zombies')\n"
                                                "You should use the Online/Setup Moneydance+ menu to Disconnect this dataset's account links (first)\n"
                                                "However, if you have 'transplanted' your MD+ license to other datasets, then it's OK to Zap...\n"
                                                "         (as your account links will be accessible from the other dataset with the same MD+ license)\n"
                                                "NOTE: Running ZAP will not cause any harm, but you will have to setup MD+ / PLaid links again (in this dataset)\n"
                                                "\n",
                                     lCancelButton=True,
                                     OKButtonText="I AGREE - PROCEED",
                                     lAlertLevel=2)

                if not ask.go():
                    txt = "User did not say yes to ZAP an Activated MD+ license - NO CHANGES MADE"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return False
                del ask

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"ZAP this Dataset's Moneydance+ settings/profile & banking links etc (USE WITH CARE)?"):
                return False

            myPrint("B", "User requested to delete all Moneydance+ settings - proceeding....:")

            myPrint("B", "... shutting down the md+ controller...")
            shutdownMDPlusPoller()

        if licenseObject is None:
            myPrint("B", "... No md+ license object found to delete... skipping...")
        else:
            myPrint("B", "... md+ license object's settings before deletion were..:\n", special_toMultilineHumanReadableString(licenseObject))
            licenseObject.deleteItem()

        plaidSettings = getMDPlusPlaidSettings()
        if plaidSettings is None:
            myPrint("B", "... No PlaidSettings object found to delete... skipping...")
        else:
            myPrint("B", "... PlaidSettings object's settings before deletion were..:\n", special_toMultilineHumanReadableString(plaidSettings))
            plaidSettings.deleteItem()

        # Clear the cache.... It will rebuild itself...
        forceMDPlusNameCacheAccessTokensRebuild(lAutoWipe=True)

        myPrint("B", "... Zapping md+ service / logon profile(s) (if exists)...")
        deleteServiceList = []
        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        for sv in serviceList:
            if sv.getTIKServiceID() == "md:plaid": deleteServiceList.append(sv)
        if len(deleteServiceList) > 0: MD_REF.getCurrentAccountBook().logRemovedItems(deleteServiceList)

        PLAID_MAP_KEY = "map.md:plaid:::"
        mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")

        myPrint("B", "... Zapping md+ mapping links (if they exist)...")
        if mappingObject is not None:
            invalid_mapping_links = []
            for objectKey in mappingObject.getParameterKeys():
                if objectKey.startswith(PLAID_MAP_KEY):
                    invalid_mapping_links.append(objectKey)

            if len(invalid_mapping_links) > 0:
                mappingObject.setEditingMode()
                for maplink in invalid_mapping_links: mappingObject.setParameter(maplink, None)
                mappingObject.syncItem()

        if lAutoZap:
            myPrint("B", "... >> All pre-existing moneydance+ settings have been deleted.. (returning to calling function)...")
            return

        myPrint("B", "... Auto-running cleanup of banking links...")
        cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        myPrint("B", "... Saving local storage...")
        storage.save()

        myPrint("B", "... Flushing changes to sync...")
        MD_REF.saveCurrentAccount()

        txt = "All Moneydance+ settings DELETED >> MONEYDANCE WILL NOW RELOAD DATASET/RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("zap_MDPlus_Profile", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def forceMDPlusNameCacheAccessTokensRebuild(lAutoWipe=False):
        _THIS_METHOD_NAME = "Force MD+ name cache & access tokens rebuild"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        if not lAutoWipe:

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Wipe MD+ name cache and access tokens (to force a rebuild)?"):
                return False

            myPrint("B", "User requested to wipe MD+ name cache and access tokens (mdp_items and access_tokens) - proceeding....:")

            myPrint("B", "... shutting down the md+ controller...")
            shutdownMDPlusPoller()

        myPrint("B", "... Zapping md+ 'access_tokens' from local storage (if they exist)...")
        storage.removeSubset("access_tokens")

        myPrint("B", "... Zapping md+ plaid cache 'mdp_items' from local storage (if they exist)...")
        storage.removeSubset("mdp_items")

        if lAutoWipe: return

        myPrint("B", "... Auto-running cleanup of banking links...")
        cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        myPrint("B", "... Saving local storage...")
        storage.save()

        myPrint("B", "... Flushing changes to sync...")
        MD_REF.saveCurrentAccount()

        txt = "MD+ name cache & access tokens have been wiped..! MONEYDANCE WILL NOW RELOAD DATASET/RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("forceMDPlusNameCacheAccessTokensRebuild", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def forceDisconnectMDPlusConnection(lReturnConnectionInfoOnly=False):
        if not isMDPlusEnabledBuild() or not isMDPlusGetPlaidClientEnabledBuild(): return ""

        _THIS_METHOD_NAME = "Force disconnect an MD+ connection".upper()

        output = "%s:\n" \
                 " ========================================\n\n" %(_THIS_METHOD_NAME)

        connectionTxt = "\n\n** WARNING: There was a problem reproducing the md+ connection list - ignore if md+ is not configured **\n\n"

        try:
            book = MD_REF.getCurrentAccountBook()

            service = PlaidConnection.getPlaidService(book)
            if service is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: could not get Plaid Service - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # plaidConnection = PlaidConnection(book, DefaultOnlineUIProxy(MD_REF.getUI(), book, None))
            plusController = MD_REF.getUI().getPlusController()
            if plusController is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: could not get PlusController - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            plaidConnection = plusController.getPlaidConnection()
            if plaidConnection is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: could not get plaidConnection - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            mapping = OnlineAccountMapping(book, service)
            licenseInfo = getMDPlusLicenseInfoForBook()
            if licenseInfo is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: getMDPlusLicenseInfoForBook() returned None - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # noinspection PyUnresolvedReferences
            p_mdpl = MDPlus.MDPlusLicense.getDeclaredConstructor(MoneydanceSyncableItem)
            p_mdpl.setAccessible(True)
            plusLicense = p_mdpl.newInstance(licenseInfo)

            status = None                                                                                               # noqa
            try:
                status = plusLicense.getSignupStatusWithRefreshing()
            except:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: Could not retrieve md+ signup status (perhaps you are offline) - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # noinspection PyUnresolvedReferences
            if status != MDPlus.SignupStatus.ACTIVATED:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: MD+ signup status(%s) is not activated - NO CHANGES MADE" %(status)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # if getFieldByReflection(plaidConnection, "plusLicense") is None: raise Exception("PLEASE WAIT AND TRY AGAIN")

            plaidClient = getPlaidClient(plaidConnection)
            if plaidClient is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: getPlaidClient returned None - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            output += "MD+ signup status returned: %s\n\n" %(status)

            # noinspection PyUnresolvedReferences
            allAccessTokens = [PlaidConnection.ItemAccessInfo(tokenInfo) for tokenInfo in book.getLocalStorage().getSublist("access_tokens")]
            allItems = plaidConnection.getAccessTokensByItemID()    # Duplicates are ignored....

            output += "allAccessTokens:\n"
            for token in allAccessTokens:
                accessToken = invokeMethodByReflection(token, "getAccessToken", [])
                output += "%s %s\n" %(token, accessToken)
            output += "\n"

            accounts = service.getAvailableAccounts()
            output += "getAvailableAccounts: accounts\n"
            for acct in accounts: output += "%s (%s)\n" %(acct.getDescription(), acct.getAccountNumber().strip())
            output += "\n"

            itemsToBanks = {}
            for itemID in allItems.keySet():
                fiID = plaidConnection.getItemInfo(itemID).getStr("inst", "")
                itemsToBanks[itemID] = plaidConnection.getInstitutionInfo(fiID)

            output += "itemsToBanks:\n"
            for item in itemsToBanks: output += "%s <> '%s' (%s)\n" %(item, itemsToBanks[item].getName(), itemsToBanks[item].getID())
            output += "\n"

            sortedItemIDs = sorted(allItems.keySet(), key=lambda sort_x: (itemsToBanks[sort_x].getName()))

            class AccountMappingRow:
                def __init__(self, _itemInfo, _accountInfo, _allAccessTokens=None):
                    self.itemInfo = _itemInfo
                    self.accountInfo = _accountInfo
                    self.allAccessTokens = _allAccessTokens
                def isItemRow(self): return (self.accountInfo is None and self.itemInfo is not None)

            connectionRows = []

            for itemID in sortedItemIDs:
                itemInfo = allItems.get(itemID)
                connectionRows.append(AccountMappingRow(itemInfo, None, [token for token in allAccessTokens if token.getItemID() == itemID]))
                itemAccounts = sorted([olAccount for olAccount in accounts if olAccount.getPlaidItemID() == itemID], key=lambda sort_x: (sort_x.getDisplayName()))
                for acctInfo in itemAccounts:
                    connectionRows.append(AccountMappingRow(itemInfo, acctInfo))

            connectionTxt = "\n" \
                            "MD+ CONNECTIONS (should duplicate Menu>Online>Setup Moneydance+):\n" \
                            " ----------------------------------------------------------------\n"

            class StoreConnectionRow:
                def __init__(self, _connectionRow, _institutionName):
                    self.connectionRow = _connectionRow
                    self.institutionName = _institutionName
                def __str__(self):  return self.institutionName
                def __repr__(self): return self.__str__()
                def toString(self): return self.__str__()

            accountMasks = {}
            connectionRowSelector = []
            for connectionRow in connectionRows:
                if connectionRow.isItemRow():
                    accountMasks.clear()
                    itemInfo = plaidConnection.getItemInfo(connectionRow.itemInfo.getItemID())
                    institutionInfo = plaidConnection.getInstitutionInfo(itemInfo.getStr("inst", ""))
                    institutionName = institutionInfo.getName("no name") + " (%s)" %(connectionRow.itemInfo.getItemID())
                    connectionTxt += "\nConnection: %s\n" %(institutionName)

                    for _token in connectionRow.allAccessTokens:
                        _accessToken = invokeMethodByReflection(_token, "getAccessToken", [])
                        _response = plaidClient.service().accountsGet(AccountsGetRequest(_accessToken)).execute()
                        success = _response.isSuccessful()
                        if success:
                            _accountsResponse = _response.body()
                            status = _accountsResponse.getItem()
                            error = status.getError()
                            if error is None:
                                retrievedAccountsFromPlaid = _accountsResponse.getAccounts()
                                for retrievedAccount in retrievedAccountsFromPlaid:
                                    accountMasks[retrievedAccount.getAccountId()] = retrievedAccount.getMask()

                    if len(connectionRow.allAccessTokens) > 1:
                        connectionTxt += "... Found multiple payloads for this connection:\n"
                        for token in connectionRow.allAccessTokens:
                            connectionTxt += "...... payloadid=%s token=%s\n" %(token.getPayloadID(), invokeMethodByReflection(token, "getAccessToken", []))
                    connectionRowSelector.append(StoreConnectionRow(connectionRow, institutionName))

                else:

                    acctInfo = connectionRow.accountInfo
                    accountNum = acctInfo.getAccountNumber()
                    localAccount = mapping.getAccountForOnlineID(acctInfo.getAccountNumber(), None, False)
                    lastDigits = accountMasks.get(accountNum, None)
                    lastDigits = "" if not lastDigits else "(last digits: ...%s)" %(lastDigits)
                    connectionTxt += "... ACCOUNT MAPPING: '%s'%s <> '%s'(%s)\n" %(acctInfo.getDisplayName(), lastDigits, localAccount, accountNum)
                    for _availAcct in accounts:
                        if _availAcct.getAccountNumber() == accountNum:
                            connectionTxt += "... (Raw Data >> desc: %s, official_name: %s, balance.available: %s, balance.current: %s, balance.limit: %s)\n" \
                                             %(_availAcct.getDescription(), _availAcct.getOfficialName(), _availAcct.getBalanceAvailable(), _availAcct.getBalanceCurrent(), _availAcct.getBalanceLimit())
                            break

            connectionTxt += "\n<END OF REPRODUCED MD+ CONNECTIONS LIST>\n"

            if lReturnConnectionInfoOnly: return connectionTxt

            output += connectionTxt

            if len(connectionRowSelector) < 1:
                txt = "You have no connections available that can be disconnected - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

            ask = MyPopUpDialogBox(jif,
                                 theStatus="WARNING: User requests to force disconnect an MD+ connection",
                                 theTitle=_THIS_METHOD_NAME.upper(),
                                 theMessage="Only attempt this when standard MD menus are not working....!\n"
                                            "Try the MD Menu > Online > Setup Moneydance + > REFRESH and DISCONNECT options first\n",
                                 lCancelButton=True,
                                 OKButtonText="I AGREE - PROCEED",
                                 lAlertLevel=1)

            if not ask.go():
                txt = "User did not say yes force disconnect the selected MD+ connection - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            selectedConnectionRow = JOptionPane.showInputDialog(jif,
                                                       "Select the Connection to force disconnect:",
                                                       "Select CONNECTION",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       connectionRowSelector,
                                                       None)

            if not selectedConnectionRow:
                txt = "User did not select a connection to force disconnect - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            if isinstance(selectedConnectionRow, StoreConnectionRow): pass

            if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME.upper(),"Proceed with force disconnect '%s' md+ connection (USE WITH CARE)?" %(selectedConnectionRow.institutionName)):
                return

            jif.dispose()

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing 'force disconnecting md+ connection' right now..",
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            output += "\n"
            txt = "User requested to force disconnect the '%s' Moneydance+ connection - proceeding....:" %(selectedConnectionRow.institutionName)
            output += "%s\n" %(txt); myPrint("B", txt)

            for token in selectedConnectionRow.connectionRow.allAccessTokens:
                # itemAccessInfo = token.
                accessToken = invokeMethodByReflection(token, "getAccessToken", [])
                response = plaidClient.service().itemRemove(ItemRemoveRequest(accessToken)).execute()
                success = response.isSuccessful()
                if success:
                    txt = "Plaid ItemRemoveRequest(%s) reported SUCCESS (token: %s)!" %(accessToken, token)
                    output += "%s\n" %(txt); myPrint("B", txt)
                else:
                    errorResponse = plaidClient.parseError(response)
                    txt = "Plaid ItemRemoveRequest(%s) FAILED (token: %s) - will continue... (error: %s %s)" %(accessToken, token, errorResponse, errorResponse.getErrorCode())
                    output += "%s\n" %(txt); myPrint("B", txt)

                payloadID = token.getPayloadID()
                if not StringUtils.isBlank(payloadID):
                    plusLicense.deleteKeyPayload(payloadID)
                    txt = "Deleted payloadID: '%s' from plusLicense at server..." %(payloadID)
                    output += "%s\n" %(txt); myPrint("B", txt)
                else:
                    txt = "payloadID: '%s' empty - no delete from server.... will continue...." %(payloadID)
                    output += "%s\n" %(txt); myPrint("B", txt)

                # noinspection PyUnresolvedReferences
                invokeMethodByReflection(plaidConnection, "removeAccessToken", [PlaidConnection.ItemAccessInfo], token)
                txt = "Removed access token from access_tokens cache: %s" %(token)
                output += "%s\n" %(txt); myPrint("B", txt)

            try:
                plaidConnection.updateAccountList()
                txt = "Plaid - called update account list..."
                output += "%s\n" %(txt); myPrint("B", txt)
            except:
                e_type, exc_value, exc_traceback = sys.exc_info()                                                       # noqa
                txt = "Unable to refresh accounts list after removing token(s)! Error was: '%s'" %(exc_value)
                output += "%s\n" %(txt); myPrint("B", txt)
                dump_sys_error_to_md_console_and_errorlog()

            txt = "... Auto-running cleanup of banking links..."
            output += "%s\n" %(txt); myPrint("B", txt)
            cleanupMissingOnlineBankingLinks(lAutoPurge=True)

            MD_REF.getCurrentAccountBook().getLocalStorage().save()
            MD_REF.saveCurrentAccount()

            pleaseWait.kill()

            txt = "Process to force disconnect '%s' MD+ connection completed.." %(selectedConnectionRow.institutionName)
            output += "%s\n" %(txt); myPrint("B", txt)
            setDisplayStatus(txt, "R")
            logToolboxUpdates("forceDisconnectMDPlusConnection", txt)

            output += "\n<END>\n"

            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

            play_the_money_sound()
            myPopupInformationBox(jif,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        except:
            txt = dump_sys_error_to_md_console_and_errorlog(True)
            if lReturnConnectionInfoOnly:
                connectionTxt += "\n\n** WARNING: error occurred when analysing live Paid connections... review console **\n\n".upper()
                return connectionTxt
            output += "\n\nERROR script has crashed - please review console\n".upper()
            output += txt
            QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True, lAlertLevel=2).show_the_frame()

    def forgetOFXImportLink():
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(10))
        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select an account (only these have remembered links)",
                                                      "FORGET OFX banking link",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      accounts.toArray(),
                                                      None)
        if not selectedAccount:
            txt = "'RESET BANKING LINK' No Account was selected - no changes made.."
            setDisplayStatus(txt, "R")
            return

        if confirm_backup_confirm_disclaimer(toolbox_frame_,"RESET BANKING LINK", "Forget OFX banking Import link for Acct: %s?" %(selectedAccount) ):

            selectedAccount.setEditingMode()                                                                # noqa
            selectedAccount.removeParameter("ofx_import_acct_num")                                          # noqa
            selectedAccount.removeParameter("ofx_import_remember_acct_num")                                 # noqa
            selectedAccount.syncItem()                                                                      # noqa

            txt = "Banking Import link on account: %s forgotten!" %(selectedAccount)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("forgetOFXImportLink", txt)

            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_, txt, "RESET BANKING LINK", JOptionPane.WARNING_MESSAGE)

    def download_md_fiscal_setup_for_one_bank(bankID, _jif):

        if GlobalVars.globalSaveFI_data is None or len(GlobalVars.globalSaveFI_data) < 1: return

        FI = GlobalVars.MD_OFX_BANK_SETTINGS_DIR + bankID.strip() + ".dct"
        output = ""
        inx = None

        myPrint("B","######################################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind Servers to download the banking connection profiles for the bank you selected - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","######################################################################################################################################################################")

        _msgPad = 100
        _msg = pad("INFO: Checking Internet (IK servers) for banking profile information...", _msgPad, padChar=".")
        diag = MyPopUpDialogBox(_jif, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
        diag.go()

        try:
            url = URL(FI)
            urlConn = url.openConnection()
            if urlConn is not None:
                rc = urlConn.getResponseCode()                                                                          # noqa
                if rc == 200:
                    inx = BufferedReader(InputStreamReader(urlConn.getInputStream(), "UTF8"))
                    while True:
                        lineofdata = inx.readLine()
                        if lineofdata is None: break
                        output += (lineofdata + "\n")                                                                   # noqa
        except:
            myPrint("B", "ERROR downloading from Moneydance Fiscal Setup profiles link: %s " %(FI))
            output += "\n@@ERROR downloading from Moneydance Fiscal Setup profiles link: %s\n" %(FI)
            output += dump_sys_error_to_md_console_and_errorlog(True)
        finally:
            diag.kill()
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing URL stream %s" %(FI))
                    output+="\n@@Error closing URL stream %s\n" %(FI)
                    output+=dump_sys_error_to_md_console_and_errorlog(True)

        return output

    class FIInfo():
        def __init__(self, info):
            self.info = info
            self.id = info.getStr("id", "")
            self.name = info.getStr("fi_name", "")
            self.lowerName = self.name.lower()
        def __str__(self): return "%s (%s)" %(self.name,self.id)
        def __repr__(self): return "%s (%s)" %(self.name,self.id)

    # noinspection PyUnresolvedReferences
    def download_md_fiscal_setup():

        downloadInfo = StreamTable()

        inx = None
        tagText=""
        wait = None

        if GlobalVars.globalSaveFI_data is None or len(GlobalVars.globalSaveFI_data) < 1:

            wait = MyPopUpDialogBox(toolbox_frame_,"PLEASE WAIT - RETRIEVING FISCAL SETUP DATA...", lModal=False)
            wait.go()

            myPrint("B","###################################################################################################################################################")
            myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind Servers to download the latest banking connection profiles - IT IS NOT SENDING ANY DATA ###")
            myPrint("B","###################################################################################################################################################")

            for theFile in [GlobalVars.MD_OFX_DEBUG_SETTINGS_FILE, GlobalVars.MD_OFX_DEFAULT_SETTINGS_FILE]:
                myPrint("DB", "Attempting to download: %s" %(theFile))

                _msgPad = 100
                _msg = pad("INFO: Checking Internet (IK servers) for banking profile information...", _msgPad, padChar=".")
                diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
                diag.go()

                try:
                    url = URL(theFile)
                    urlConn = url.openConnection()
                    if urlConn is not None:
                        rc = urlConn.getResponseCode()                                                                     # noqa
                        if rc == 200:
                            inx = BufferedReader(InputStreamReader(urlConn.getInputStream(), "UTF8"))
                            downloadInfo.readFrom(inx)
                            myPrint("DB", "Success downloading: %s" %(theFile))
                except:
                    myPrint("B", "ERROR downloading from Moneydance Fiscal Setup profiles link: %s " %(theFile))
                    dump_sys_error_to_md_console_and_errorlog(False)
                finally:
                    diag.kill()
                    if inx:
                        try:
                            inx.close()
                        except:
                            myPrint("B", "Error closing URL stream %s" %(theFile))
                            dump_sys_error_to_md_console_and_errorlog()

                matches = None
                overrideMessage = downloadInfo.getStr("override_msg", None)
                ifNoneAvailableMessage = downloadInfo.getStr("no_fis_msg", None)
                infoMessage = downloadInfo.getStr("extra_msg", None)
                if overrideMessage is not None:
                    tagText = overrideMessage
                else:
                    matchesObj = downloadInfo.get("matches")
                    matches = ArrayList()
                    if isinstance(matchesObj,(StreamVector)):
                        matchesVector = matchesObj
                        for matchObj in matchesVector:
                            if isinstance(matchObj, StreamTable):
                                matches.add(FIInfo(matchObj))
                    matchCount = 0
                    for i in range(0, matches.size()):
                        if matches is None: break
                        match = matches.get(i)
                        minVersion = match.info.getInt("min_version", 0)                                                    # noqa
                        maxVersion = match.info.getInt("max_version", 99999999)                                             # noqa

                        # Mirrors code (ish) from: com.moneydance.apps.md.view.gui.ofxsetup.OFXNewFIPanel.run() Line 294 ("min_version", "max_version)
                        if ((float(MD_REF.getBuild())) < minVersion or (float(MD_REF.getBuild())) > maxVersion):
                            matches.remove(i)
                            # i-=1
                        else:
                            matchCount+=1
                            i+=1
                    if matchCount == 0 and ifNoneAvailableMessage is not None:
                        tagText = ifNoneAvailableMessage
                    elif infoMessage is not None:
                        tagText=infoMessage

                if theFile == GlobalVars.MD_OFX_DEFAULT_SETTINGS_FILE:
                    GlobalVars.globalSaveFI_data = matches
                    GlobalVars.globalSaveFI_data = sorted(GlobalVars.globalSaveFI_data, key=lambda sort_x: (sort_x.lowerName, sort_x.id))
                else:
                    GlobalVars.globalSave_DEBUG_FI_data = matches
                    GlobalVars.globalSave_DEBUG_FI_data = sorted(GlobalVars.globalSave_DEBUG_FI_data, key=lambda sort_x: (sort_x.lowerName, sort_x.id))

        output="Moneydance's Fiscal Institution Initial Dynamic Setup profiles..\n" \
               " ==============================================================\n\n"

        if len(tagText)>0:
            output+="\n%s\n\n" %(tagText)

        miniList=[]
        for bankSetup in GlobalVars.globalSaveFI_data:
            output += "\nName: %s (%s)\n" %(bankSetup.name,bankSetup.id)
            miniList.append(bankSetup.lowerName)
            for element in bankSetup.info:
                if element == "id" or element == "fi_name": continue
                output+=" %s %s\n" %(pad(element+":",30), bankSetup.info.get(element))

        miniListDEBUG = []
        for bankSetup in GlobalVars.globalSave_DEBUG_FI_data: miniListDEBUG.append(bankSetup.lowerName)

        if len(GlobalVars.globalSaveFI_data) < 1: output += "\nNO SETUP FOUND... DID SOMETHING GO WRONG? REVIEW CONSOLE ERROR LOG..!\n\n"

        output += "\n<END>"

        if wait is not None: wait.kill()

        jif = QuickJFrame("VIEW Moneydance's Dynamic / live Fiscal Institution setup profiles", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        if len(miniList) > 0:
            selectedID = JOptionPane.showInputDialog(jif,
                                                     "Select Bank Profile to view specific setup data",
                                                      "VIEW SPECIFIC SETUP DATA",
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      getMDIcon(lAlwaysGetIcon=True),
                                                      GlobalVars.globalSaveFI_data,
                                                      None)
            if selectedID:
                specificText = download_md_fiscal_setup_for_one_bank(selectedID.id, jif)

                output="Moneydance's Fiscal Institution Initial Dynamic Setup profiles..\n" \
                       " ==============================================================\n\n" \
                       "Initial/Default Setup:\n" \
                       " ---------------------\n"

                output += "\nName: %s (%s)\n" %(selectedID.name,selectedID.id)
                for element in selectedID.info:
                    if element == "id" or element == "fi_name": continue

                    extraText = ""
                    if element == "dt_prof_updated": extraText = "(%s)" %(get_time_stamp_as_nice_text(int(selectedID.info.get(element))))
                    output+=" %s %s %s\n" %(pad(element+":",30), selectedID.info.get(element),extraText)

                try:
                    output += "\n\nDEBUG Setup:\n" \
                              " -------------------------\n"
                    for findID in GlobalVars.globalSave_DEBUG_FI_data:
                        if findID.id == selectedID.id:
                            for element in findID.info:
                                if element == "id" or element == "fi_name": continue
                                extraText = ""
                                if element == "dt_prof_updated": extraText="(%s)" %(get_time_stamp_as_nice_text(int(findID.info.get(element))))
                                output += " %s %s %s\n" %(pad(element+":", 30), findID.info.get(element), extraText)
                            break
                except:
                    pass

                output += "\n\nSPECIFIC OVERRIDING Setup:\n" \
                       " -------------------------\n"
                output += specificText
                output += "\n<END>"

                QuickJFrame("VIEW Moneydance's Specific (dynamic) Fiscal Institution setup profiles", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

        txt = "OFX: Moneydance's Dynamic Fiscal Institution Setup profiles have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    def get_the_objects_for_curious_view_and_advanced_edit(objWhat, selectedObjType, titleStr, lForceOneTxn):

        # Yes, I know, repeated from calling function.... EDIT IN BOTH PLACES!
        # You need to edit the below in the sub def function too!!! (sorry ;-> )
        _OBJROOT        =  0
        _OBJACCT        =  1
        _OBJCAT         =  2
        _OBJACCTSEC     =  3
        _OBJCURR        =  4
        _OBJSEC         =  5
        _OBJREMINDERS   =  6
        _REPORT_MEM     =  7
        _GRAPH_MEM      =  8
        _REPORT_DEF     =  9
        _GRAPH_DEF      =  10
        _OBJADDRESSES   =  11
        _OBJOFXONLINE   =  12
        _OBJBYUUID      =  13
        _OBJTRANSACTION =  14
        _OBJSECSUBTYPES =  15
        _OBJMDPLUSLIC   =  16
        _OBJOFXMAPPINGS =  17
        _OBJOFXOLPAYEES =  18
        _OBJOFXOLPAYMNT =  19
        _OBJOFXTXNS     =  20

        lReportDefaultsSelected = False

        def getCurrTable(cType):

            cTable=ArrayList()
            myTable = MD_REF.getCurrentAccountBook().getCurrencies()
            myTable = sorted(myTable, key=lambda sort_x: (sort_x.getCurrencyType(), sort_x.getName().upper()))
            for curr in myTable:
                if curr.getCurrencyType() == cType:
                    cTable.add(curr)
            return cTable

        def getReportsTable(memorized_default_or_all, report_or_graph_or_all):

            theReports = None

            repTable=ArrayList()
            if report_or_graph_or_all == "ALL":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccountBook().getMemorizedItems().getAllItems()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccountBook().getMemorizedItems().getAllMemorizedItems()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccountBook().getMemorizedItems().getAllItems()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            elif report_or_graph_or_all == "REPORT":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccountBook().getMemorizedItems().getAllReports()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccountBook().getMemorizedItems().getMemorizedReports()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccountBook().getMemorizedItems().getAllReports()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            elif report_or_graph_or_all == "GRAPH":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccountBook().getMemorizedItems().getAllGraphs()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccountBook().getMemorizedItems().getMemorizedGraphs()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccountBook().getMemorizedItems().getAllGraphs()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            else:
                assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))

            # For Default return non memorized Items
            for rep in theReports:
                if not rep.isMemorized():
                    repTable.add(rep)

            return repTable

        objects = None
        try:
            if objWhat.index(selectedObjType) == _OBJROOT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(12))
                # The palaver below is to get the list sorted.....
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJACCT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(7))
                # The palaver below is to get the list sorted.....
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJCAT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(8)).toArray()
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJACCTSEC:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(9)).toArray()
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJCURR:
                # noinspection PyUnresolvedReferences
                objects = getCurrTable(CurrencyType.Type.CURRENCY)
            elif objWhat.index(selectedObjType) == _OBJSEC:
                # noinspection PyUnresolvedReferences
                objects = getCurrTable(CurrencyType.Type.SECURITY)
            elif objWhat.index(selectedObjType) == _REPORT_MEM:
                objects = getReportsTable("MEMORIZED", "REPORT")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _GRAPH_MEM:
                objects = getReportsTable("MEMORIZED", "GRAPH")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _REPORT_DEF:
                lReportDefaultsSelected = True
                objects = getReportsTable("DEFAULT", "REPORT")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _GRAPH_DEF:
                lReportDefaultsSelected = True
                objects = getReportsTable("DEFAULT", "GRAPH")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _OBJREMINDERS:
                root = MD_REF.getCurrentAccountBook()
                objects = root.getReminders().getAllReminders()
                objects = sorted(objects, key=lambda x: (x.getDescription().upper()))
            elif objWhat.index(selectedObjType) == _OBJADDRESSES:
                root = MD_REF.getCurrentAccountBook()
                objects = root.getAddresses().getAllEntries()
                objects = sorted(objects, key=lambda x: (x.getName().upper()))
            elif objWhat.index(selectedObjType) == _OBJOFXONLINE:
                objects = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
                objects = sorted(objects, key=lambda x: (x.getFIName().upper()))
            elif objWhat.index(selectedObjType) == _OBJBYUUID:
                pass
            elif objWhat.index(selectedObjType) == _OBJTRANSACTION:
                pass
            elif objWhat.index(selectedObjType) == _OBJSECSUBTYPES:
                item = MD_REF.getCurrentAccountBook().getItemForID("security_subtypes")             # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have a 'security_subtypes' to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif objWhat.index(selectedObjType) == _OBJMDPLUSLIC:
                item = getMDPlusLicenseInfoForBook()                        # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have a Moneydance+ license object to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif objWhat.index(selectedObjType) == _OBJOFXMAPPINGS:
                item = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")           # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have an OFX Account Mappings object to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif (objWhat.index(selectedObjType) == _OBJOFXOLPAYEES
                  or objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT
                  or objWhat.index(selectedObjType) == _OBJOFXTXNS):

                accountsListForOlTxns = None
                if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(15))
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(16))
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(17))

                accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

                selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the Acct to find Online Data about:",
                                                             "Select ACCOUNT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             accountsListForOlTxns,
                                                             None)
                if not selectedAcct:
                    txt = "No Account was selected.."
                    setDisplayStatus(txt, "R")
                    return None, lReportDefaultsSelected

                if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                    objects = [StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                    objects = [StoreTheOnlinePayeeList(MyGetOnlinePayees(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                    objects = [StoreTheOnlinePaymentList(MyGetOnlinePayments(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)

            else:
                return None, lReportDefaultsSelected
        except:
            dump_sys_error_to_md_console_and_errorlog( True )
            return None, lReportDefaultsSelected

        if objWhat.index(selectedObjType) == _OBJTRANSACTION:

            dateStart = 20251231
            dateEnd = 20251231

            dateTxt=""
            if lForceOneTxn:
                labelDateStart = JLabel("Select the Date:")
            else:
                dateTxt="Range "
                labelDateStart = JLabel("Date range start:")
            user_selectDateStart = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
            user_selectDateStart.setDateInt(dateStart)

            labelDateEnd = JLabel("Date range end:")
            user_selectDateEnd = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
            user_selectDateEnd.setDateInt(dateEnd)

            datePanel = JPanel(GridLayout(0, 2))
            datePanel.add(labelDateStart)
            datePanel.add(user_selectDateStart)

            if not lForceOneTxn:
                datePanel.add(labelDateEnd)
                datePanel.add(user_selectDateEnd)

            options = ["Cancel", "OK"]

            while True:
                userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                          datePanel,
                                                          "%s: Select Date %sfor TXNs (less is better)" %(titleStr,dateTxt),
                                                          JOptionPane.OK_CANCEL_OPTION,
                                                          JOptionPane.QUESTION_MESSAGE,
                                                          getMDIcon(None),
                                                          options,
                                                          options[1])

                if userAction != 1:
                    txt = "%s: User cancelled Date Selection for TXN Search" %(titleStr)
                    setDisplayStatus(txt, "R")
                    return None, lReportDefaultsSelected

                if lForceOneTxn:
                    user_selectDateEnd.setDateInt( user_selectDateStart.getDateInt() )

                if user_selectDateStart.getDateInt() <= user_selectDateEnd.getDateInt() \
                        and user_selectDateEnd.getDateInt() >= user_selectDateStart.getDateInt():
                    break   # Valid date range

                user_selectDateStart.setForeground(getColorRed())                                                       # noqa
                user_selectDateEnd.setForeground(getColorRed())                                                         # noqa
                continue   # Loop

            if objWhat.index(selectedObjType) == _OBJTRANSACTION:
                txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactions(
                                            MyTxnSearchFilter(user_selectDateStart.getDateInt(),user_selectDateEnd.getDateInt()))
            else:
                txns = []

            if not txns or txns.getSize() <1:
                txt = "%s: No Transactions Found.."  %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            if not lForceOneTxn:
                if txns.getSize() > 50:
                    txt = "%s:TXN SEARCH FOUND %s TXNs. TOO MANY, WILL ABORT...."%(titleStr,txns.getSize())
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt)
                    return None, lReportDefaultsSelected

            if lForceOneTxn:
                objects=ArrayList()
                for txn in txns:
                    objects.add(txn)
            else:
                objects = txns

        if objWhat.index(selectedObjType) == _OBJBYUUID:
            theUUID = myPopupAskForInput(toolbox_frame_, "GET SINGLE OBJECT BY UUID", "UUID:", "%s: Enter the UUID of the Object to get" %(titleStr), "", False)

            if not theUUID or theUUID == "":
                txt = "%s: No Object UUID was entered.." %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            selectedObject = MD_REF.getCurrentAccountBook().getItemForID(theUUID.strip())
            if selectedObject is None:
                txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
                selectedObject = txnSet.getTxnByID(theUUID.strip())
                if selectedObject is None:
                    selectedObject = TxnUtil.getTxnByID(txnSet, theUUID.strip())

            objects  = [selectedObject]
            if not selectedObject:
                txt = "%s: No Object was found for UUID: %s" %(titleStr,theUUID)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected


        if (objWhat.index(selectedObjType) == _OBJTRANSACTION and not lForceOneTxn):
            pass
        else:
            if len(objects) > 0 and isinstance(objects[0],(ParentTxn,SplitTxn)):

                class StoreTheTxn:
                    def __init__(self, obj):
                        if isinstance(obj,(ParentTxn,SplitTxn)):
                            self.obj = obj
                        else:
                            self.obj = None

                    def __str__(self):
                        MD_decimal = MD_REF.getPreferences().getDecimalChar()
                        if self.obj is None: return "Invalid Txn Obj or None"
                        _txt = "PARENT TXN: "
                        if isinstance(self.obj, SplitTxn): _txt = "SPLIT TXN:  "
                        curr = self.obj.getAccount().getCurrencyType()
                        _txt += "Date: %s " %(convertStrippedIntDateFormattedText(self.obj.getDateInt()))
                        _txt += "%s " %(pad(self.obj.getDescription(),40))
                        _txt += "Value: %s" %(rpad(curr.formatFancy(self.obj.getValue(),MD_decimal),15))
                        return _txt

                    def __repr__(self): return self.__str__()

                storeTheTxns = []
                for storeTxn in objects:
                    storeTheTxns.append( StoreTheTxn(storeTxn))

                selectedObject = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the specific Txn to %s" %(titleStr),
                                                             "Select Specific Txn",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             storeTheTxns,
                                                             None)

                objects  = [selectedObject.obj]                                                                         # noqa

            else:

                selectedObject = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the specific Object to %s" %(titleStr),
                                                             "Select Specific Object",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             objects,
                                                             None)
                objects  = [selectedObject]

            if not selectedObject:
                txt = "%s: No Object was selected.." %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            if (objWhat.index(selectedObjType) == _OBJOFXTXNS
                    or objWhat.index(selectedObjType) == _OBJOFXOLPAYEES
                    or objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT):
                # noinspection PyUnresolvedReferences
                objects = [selectedObject.obj]       # Use my version to prevent creation of default record(s)

        return objects, lReportDefaultsSelected

    def removeInternalFilesSettings():
        thisDataset = MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()

        filesToRemove = []
        for wrapperOrBook in AccountBookUtil.getInternalAccountBooks():                                                 # MD2023.2(5020) fix
            _book = wrapperOrBook if isinstance(wrapperOrBook, AccountBook) else wrapperOrBook.getBook()                # changed in MD2023.2(5020) to return [books]
            internal_filepath = _book.getRootFolder().getCanonicalPath()
            if internal_filepath == thisDataset:
                continue
            filesToRemove.append(internal_filepath)
            del _book

        if len(filesToRemove) < 1:
            txt = "DELETE internal (default location) Dataset(s) from DISK - You have no files to DELETE - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        iFilesOnDiskRemoved = 0

        while True:

            selectedFile = None
            if len(filesToRemove) > 0:
                saveOK = UIManager.get("OptionPane.okButtonText")
                saveCancel = UIManager.get("OptionPane.cancelButtonText")
                UIManager.put("OptionPane.okButtonText", "DELETE DATASET FROM DISK")
                UIManager.put("OptionPane.cancelButtonText", "EXIT")

                selectedFile = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the default/internal location Dataset to DELETE from disk",
                                                           "DELETE FILE FROM DISK",
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           filesToRemove,
                                                           None)

                UIManager.put("OptionPane.okButtonText", saveOK)
                UIManager.put("OptionPane.cancelButtonText", saveCancel)

            if not selectedFile:
                if iFilesOnDiskRemoved < 1:
                    txt = "DELETE FILES/REFERENCES! No changes made"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                else:
                    txt = "DELETE FILES/REFERENCES - %s Dataset(s) DELETED" %(iFilesOnDiskRemoved)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if os.path.exists(selectedFile):
                if not myPopupAskQuestion(toolbox_frame_,
                                      "DELETE FILES/REFERENCES - DISCLAIMER",
                                      "Really DELETE '%s' dataset from disk?" %(selectedFile),
                                      theMessageType=JOptionPane.ERROR_MESSAGE):
                    continue

                filesToRemove.remove(selectedFile)

                try:
                    shutil.rmtree(selectedFile)
                    iFilesOnDiskRemoved += 1
                    txt = "DELETE FILES/REFERENCES: Dataset %s removed from disk" %(selectedFile)
                    setDisplayStatus(txt, "R"); myPrint("B",txt)
                    logToolboxUpdates("removeInternalFilesSettings", txt, onlyLogGenericEntry=True)

                    play_the_money_sound()
                    myPopupInformationBox(toolbox_frame_,
                                          txt,
                                          "DELETE FILES/REFERENCES - DELETE FILE FROM DISK",
                                          JOptionPane.ERROR_MESSAGE)
                except:
                    dump_sys_error_to_md_console_and_errorlog()
                    txt = "ERROR - Dataset %s FAILED TO remove from disk" %(selectedFile)
                    setDisplayStatus(txt, "R"); myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_, txt, "DELETE FILES/REFERENCES - ERROR", JOptionPane.ERROR_MESSAGE)

            continue

    def cleanup_external_files_setting(lAutoPurge=False):
        # type: (bool) -> bool

        myPrint("DB", "In cleanup_external_files_setting()")

        _THIS_METHOD_NAME = "Cleanup External Files Setting".upper()

        if not backup_config_dict(): return False

        prefs = MD_REF.getUI().getPreferences()
        extFiles = prefs.getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, None)
        if extFiles is None or len(extFiles) < 1:
            myPrint("DB", "config.dict holds no '%s' - skipping cleanup routine...." %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES))
            return True

        newExtFiles = StreamVector()
        if isinstance(newExtFiles, Vector): pass

        for externalFilename in extFiles:
            try:
                if externalFilename.endswith(".moneydance"):
                    testWrapper = AccountBookWrapper.wrapperForFolder(File(externalFilename))
                    if testWrapper is not None and testWrapper.getBook().isValid():
                        if AccountBookUtil.isWithinInternalStorage(testWrapper.getBook()):
                            myPrint("DB", "config.dict: '%s': Confirmed exists: '%s' - BUT IS AN INTERNAL FILE - So will remove....." %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilename))
                        else:
                            myPrint("DB", "config.dict: '%s': Confirmed exists: '%s'" %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilename))
                            newExtFiles.add(externalFilename)
                            continue
            except:
                myPrint("B", "Error checking external file ('%s') - aborting checks" %(externalFilename))
                dump_sys_error_to_md_console_and_errorlog()
                return False

            myPrint("DB", "Checking external file >> NOT VALID (will remove): %s" %(externalFilename))

        invalidExtFiles = (extFiles.size() - newExtFiles.size())

        if invalidExtFiles < 1:
            txt = "No invalid/missing 'external' files found in config.dict - no changes made"
            myPrint("DB", txt)
            if not lAutoPurge:
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.INFORMATION_MESSAGE)
            return True

        if not lAutoPurge and not doesUserAcceptDisclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Cleanup (remove) %s missing/invalid external files from config.dict?" %(invalidExtFiles)):
            return False

        myPrint("DB", "Saving new list of %s valid files (%s removed)" %(newExtFiles.size(), (extFiles.size() - newExtFiles.size())))
        prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, newExtFiles)

        txt = "%s invalid/missing 'external' files removed from config.dict (review console for details)" %(invalidExtFiles)
        myPrint("B", txt)
        logToolboxUpdates("cleanup_external_files_setting", txt, onlyLogGenericEntry=True)

        if not lAutoPurge:
            play_the_money_sound()
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        return True

    def removeExternalFilesSettings():
        if MD_REF.getCurrentAccountBook() is None: return

        if not backup_config_dict():
            txt = "Remove files from 'External' (non-default) file list in File/Open - Error backing up config.dict preferences file - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # Just clean up orphans anyway first.....
        cleanup_external_files_setting(lAutoPurge=True)

        prefs = MD_REF.getUI().getPreferences()
        thisDataset = MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()

        externalFilesVector = prefs.getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, StreamVector())

        filesToRemove = []
        for externalFileObj in externalFilesVector:
            if externalFileObj != thisDataset:
                filesToRemove.append(externalFileObj)

        if externalFilesVector is None or len(filesToRemove)<1:
            txt = "Remove files from 'External' (non-default) file list in File/Open - No '%s' files in config.dict to remove - no changes made...." %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, "No 'External' file references in config.dict to remove - NO CHANGES MADE!", theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        iReferencesRemoved = 0
        iFilesOnDiskRemoved = 0

        while True:

            selectedFile = None
            if len(filesToRemove) > 0:
                saveOK = UIManager.get("OptionPane.okButtonText")
                saveCancel = UIManager.get("OptionPane.cancelButtonText")
                UIManager.put("OptionPane.okButtonText", "REMOVE FILE REFERENCE FROM File/Open")
                UIManager.put("OptionPane.cancelButtonText", "EXIT")

                selectedFile = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the 'External' (non-default) file reference to remove",
                                                           "DELETE FILES/REFERENCES - REMOVE DATASET REFERENCE",
                                                           JOptionPane.WARNING_MESSAGE,
                                                           getMDIcon(None),
                                                           filesToRemove,
                                                           None)

                UIManager.put("OptionPane.okButtonText", saveOK)
                UIManager.put("OptionPane.cancelButtonText", saveCancel)

            if not selectedFile:
                if (iReferencesRemoved + iFilesOnDiskRemoved) < 1:
                    txt = "DELETE FILES/REFERENCES - No changes made"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                else:
                    txt = "DELETE FILES/REFERENCES: %s references removed and %s Datasets DELETED" %(iReferencesRemoved, iFilesOnDiskRemoved)
                    setDisplayStatus(txt, "R")
                    logToolboxUpdates("removeExternalFilesSettings", txt, onlyLogGenericEntry=True)
                    myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            iReferencesRemoved += 1
            filesToRemove.remove(selectedFile)

            externalFilesVector.remove(selectedFile)
            prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilesVector)
            MD_REF.savePreferences()
            txt = "Removed reference to file %s from config.dict (and file/open menu if present)" %(selectedFile)
            myPrint("B", txt)
            logToolboxUpdates("removeExternalFilesSettings", txt, onlyLogGenericEntry=True)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE FILES/REFERENCES", JOptionPane.WARNING_MESSAGE)

            if not os.path.exists(selectedFile): continue

            if not myPopupAskQuestion(toolbox_frame_,
                                  "DELETE FILES/REFERENCES",
                                  "Also DELETE '%s' dataset from disk too?" %(selectedFile),
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
                continue

            try:

                shutil.rmtree(selectedFile)
                iFilesOnDiskRemoved+=1

                txt = "DELETE FILES/REFERENCES - Dataset %s removed from disk" %(selectedFile)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("removeExternalFilesSettings", txt, onlyLogGenericEntry=True)
                play_the_money_sound()
                myPopupInformationBox(toolbox_frame_, txt, "DELETE FILES/REFERENCES", theMessageType=JOptionPane.ERROR_MESSAGE)
            except:
                dump_sys_error_to_md_console_and_errorlog()
                txt = "ERROR: Dataset %s FAILED to remove from disk" %(selectedFile)
                myPrint("B",txt)
                myPopupInformationBox(toolbox_frame_, txt, "DELETE FILES/REFERENCES", theMessageType=JOptionPane.WARNING_MESSAGE)

            continue

    class MyMoneydanceEventListener(AppEventListener):

        def __init__(self, theFrame):
            self.alreadyClosed = False
            self.theFrame = theFrame
            self.myModuleID = myModuleID

        def getMyself(self):
            fm = MD_REF.getModuleForID(self.myModuleID)
            if fm is None: return None, None
            try:
                pyObject = getFieldByReflection(fm, "extensionObject")
            except:
                myPrint("DB","Error retrieving my own Python extension object..?")
                dump_sys_error_to_md_console_and_errorlog()
                return None, None

            return fm, pyObject

        def handleEvent(self, appEvent):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))
            myPrint("DB", "I am .handleEvent() within %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
            myPrint("DB","Extension .handleEvent() received command: %s" %(appEvent))

            if self.alreadyClosed:
                myPrint("DB","....I'm actually still here (MD EVENT %s CALLED).. - Ignoring and returning back to MD...." %(appEvent))
                return

            # MD doesn't call .unload() or .cleanup(), so if uninstalled I need to close myself
            fm, pyObject = self.getMyself()
            myPrint("DB", "Checking myself: %s : %s" %(fm, pyObject))
            if (((fm is None and "__file__" not in globals()) or (self.theFrame.isRunTimeExtension and pyObject is None))
                    and appEvent != AppEventManager.APP_EXITING):
                myPrint("B", "@@ ALERT - I've detected that I'm no longer installed as an extension - I will deactivate.. (switching event code to :close)")
                appEvent = "%s:customevent:close" %self.myModuleID

            # I am only closing Toolbox when a new Dataset is opened.. I was calling it on MD Close/Exit, but it seemed to cause an Exception...
            if (appEvent == AppEventManager.FILE_CLOSING
                    or appEvent == AppEventManager.FILE_CLOSED
                    or appEvent == AppEventManager.FILE_OPENING
                    or appEvent == AppEventManager.APP_EXITING):
                myPrint("DB","@@ Ignoring MD handleEvent: %s" %(appEvent))

            elif (appEvent == AppEventManager.FILE_OPENED
                  or (appEvent == AppEventManager.LICENSE_UPDATED and MD_REF.isRegistered())
                  or appEvent == "%s:customevent:close" %(self.myModuleID)):
                if debug:
                    myPrint("DB","MD event %s triggered.... Will call GenericWindowClosingRunnable (via the Swing EDT) to push a WINDOW_CLOSING Event to %s to close itself (while I exit back to MD quickly) ...." %(appEvent, self.myModuleID))
                else:
                    myPrint("B","Moneydance triggered event %s triggered - So I am closing %s now...." %(appEvent, self.myModuleID))
                self.alreadyClosed = True
                try:
                    SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.theFrame))
                    myPrint("DB","Back from calling GenericWindowClosingRunnable to push a WINDOW_CLOSING Event (via the Swing EDT) to %s.... ;-> ** I'm getting out quick! **" %(self.myModuleID))
                except:
                    dump_sys_error_to_md_console_and_errorlog()
                    myPrint("B","@@ ERROR calling GenericWindowClosingRunnable to push  a WINDOW_CLOSING Event (via the Swing EDT) to %s.... :-< ** I'm getting out quick! **" %(self.myModuleID))
                if not debug: myPrint("DB","Returning back to Moneydance after calling for %s to close...." %self.myModuleID)

            # md:file:closing	The Moneydance file is being closed
            # md:file:closed	The Moneydance file has closed
            # md:file:opening	The Moneydance file is being opened
            # md:file:opened	The Moneydance file has opened
            # md:file:presave	The Moneydance file is about to be saved
            # md:file:postsave	The Moneydance file has been saved
            # md:app:exiting	Moneydance is shutting down
            # md:account:select	An account has been selected by the user
            # md:account:root	The root account has been selected
            # md:graphreport	An embedded graph or report has been selected
            # md:viewbudget	One of the budgets has been selected
            # md:viewreminders	One of the reminders has been selected
            # md:licenseupdated	The user has updated the license

    def getUpdatedAuthenticationKeys():

        _storage = SyncRecord()
        _authenticationCache = SyncRecord()

        try:
            LS = MD_REF.getCurrentAccountBook().getLocalStorage()
            LS.save()

            localFile = File(os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME, "settings"))
            if localFile.exists() and localFile.canRead():
                inx = LS.openFileForReading("settings")
                _storage.readSet(inx)
                _authenticationCache = _storage.getSubset("_authentication")
                inx.close()
        except:
            myPrint("B","@@@ ERROR Reading authentication cache from settings @@@")
            dump_sys_error_to_md_console_and_errorlog()

        del _storage
        return _authenticationCache

    def find_nth(haystack, needle, n):
        start = haystack.find(needle)
        while start >= 0 and n > 1:
            start = haystack.find(needle, start+len(needle))
            n -= 1
        return start

    class CuriousViewInternalSettingsButtonAction(AbstractAction):

        def __init__(self, lOFX=False, EDIT_MODE=False):
            self.lOFX = lOFX
            self.EDIT_MODE = EDIT_MODE

        def actionPerformed(self, event):                                                                               # noqa
            if MD_REF.getCurrentAccountBook() is None: return

            output = ""

            _SEARCH   = 0
            _ROOTKEYS = 1
            _BOOKKEYS = 2
            _PREFKEYS = 3
            _ACCTKEYS = 4
            _OBJKEYS  = 5
            _SYNCKEYS = 6
            _BANKKEYS = 7
            _SIZEKEYS = 8
            _OSPROPS  = 9
            _OSENV    = 10

            what = [
                "Search for a key/data (in most places  - but not txns)",
                "Show ROOT Account's Parameter Keys and data",
                "Show Dataset's Local Storage Keys and data (from ./safe/settings)",
                "Show All User Preferences loaded into Memory (from config.dict)",
                "Show Accounts' Parameter's Keys and Data",
                "Show an Obj's settings/data (Acct, Cat, Curr, Security, Reports, Reminders, Addrs, OFX, by UUID, TXNs)",
                "Show All Sync Settings",
                "Show All Online Banking (Searches for OFX) Settings",
                "Show all Settings relating to Window Locations/Sizes/Widths/Sort Order/Filters/Initial Reg View etc..",
                "Show all Java JVM System Properties",
                "Show all Operating System Environment Variables"]

            # You need to edit the below in the sub function and edit function too!!! (sorry ;-> )
            _OBJROOT        =  0
            _OBJACCT        =  1
            _OBJCAT         =  2
            _OBJACCTSEC     =  3
            _OBJCURR        =  4
            _OBJSEC         =  5
            _OBJREMINDERS   =  6
            _REPORT_MEM     =  7
            _GRAPH_MEM      =  8
            _REPORT_DEF     =  9
            _GRAPH_DEF      =  10
            _OBJADDRESSES   =  11
            _OBJOFXONLINE   =  12
            _OBJBYUUID      =  13
            _OBJTRANSACTION =  14
            _OBJSECSUBTYPES =  15
            _OBJMDPLUSLIC   =  16
            _OBJOFXMAPPINGS =  17
            _OBJOFXOLPAYEES =  18
            _OBJOFXOLPAYMNT =  19
            _OBJOFXTXNS     =  20

            objWhat = [                 # Note - I haven't included csnaps/csplit - they don't actually return the map / keys.....
                "ROOT (the master/parent/top-level Account)",
                "Account",
                "Category",
                "Security sub-account",
                "Currency",
                "Security (from Currency Table)",
                "Reminders",
                "Report (Memorized)",
                "Graph (Memorized)",
                "Report (Default)",
                "Graph (Default)",
                "Address Book Entry",
                "Online OFX Services (Bank Logon Profiles)",
                "Object by UUID",
                "Object Transactions (by date)",                    # TransactionSet(ParentTxn) "txn"
                "Security Sub Types",                               # moneydanceSyncableItem    ID:"secsubtypes"
                "Moneydance+ Settings/Profile (MD2022 onwards)",    # moneydanceSyncableItem    ID:"tik.mdplus-license"
                "OFX Account Mappings (MD2022 onwards)"             # moneydanceSyncableItem    ID:"online_acct_mapping"
            ]

            if not self.lOFX:                                   # ... and not self.EDIT_MODE:
                objWhat += [
                    "OFX Online Payees",                         # onlinePayeeList           "olpayees"
                    "OFX Online Payments",                       # onlinePaymentList         "olpmts"
                    "OFX Online Transactions"                    # onlineTxnList             "oltxns"
                ]

            if self.lOFX:
                selectedWhat = what[_BANKKEYS]
            elif self.EDIT_MODE:
                selectedWhat = what[_OBJKEYS]
            else:
                selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the type of Key data you want to view",
                                                           "CURIOUS? VIEW: INTERNAL SETTINGS",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           what,
                                                           None)
                if not selectedWhat:
                    txt = "CURIOUS? VIEW: INTERNAL SETTINGS: No data type was selected to view.."
                    setDisplayStatus(txt, "B")
                    return

            myPrint("J", "CURIOUS? VIEW: INTERNAL SETTINGS. User has requested to view: %s"%selectedWhat)

            lObject = False
            selectedObject = None                                                                                       # noqa
            lReportDefaultsSelected = False

            root = MD_REF.getCurrentAccountBook().getRootAccount()

            searchWhat = ""
            lSearch = lKeys = lKeyData = False
            if selectedWhat == what[_SEARCH]:
                lSearch = True

                selectedSearch = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "SEARCH: Keys or Key Data?",
                                                             "CURIOUS? VIEW: INTERNAL SETTINGS",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             ["Keys","Key Data"],
                                                             None)
                if not selectedSearch:
                    txt = "CURIOUS? VIEW: INTERNAL SETTINGS: No Search type selected"
                    setDisplayStatus(txt, "B")
                    return

                if selectedSearch == "Keys": lKeys = True
                elif selectedSearch == "Key Data": lKeyData = True
                else:
                    raise(Exception("CURIOUS? VIEW: INTERNAL SETTINGS: ERROR: Unknown Search Key type selected!?"))

                searchWhat = myPopupAskForInput(toolbox_frame_, "CURIOUS? VIEW: INTERNAL SETTINGS: SEARCH", "%s:" % selectedSearch, "Enter the (partial) string to search for within %s..." % selectedSearch, "", False)
                if not searchWhat or searchWhat == "":
                    txt = "CURIOUS? VIEW: INTERNAL SETTINGS: No Search data selected"
                    setDisplayStatus(txt, "B")
                    return
                searchWhat=searchWhat.strip()

            if selectedWhat == what[_OBJKEYS]:
                lObject = True

                titleText = "CURIOUS? VIEW: INTERNAL SETTINGS"
                moreText = "VIEW"
                lFindInUpdateMode = False
                if self.EDIT_MODE:
                    titleText = "ADVANCED"
                    lFindInUpdateMode = True
                    moreText = "CHANGE"

                selectedObjType = JOptionPane.showInputDialog(toolbox_frame_,
                                                              "Select the type of Object you want to %s" %(moreText),
                                                              "%s" %(titleText),
                                                              JOptionPane.INFORMATION_MESSAGE,
                                                              getMDIcon(lAlwaysGetIcon=True),
                                                              objWhat,
                                                              None)
                if not selectedObjType:
                    txt = "%s: No Object type was selected.."%(titleText)
                    setDisplayStatus(txt, "B")
                    return

                baseCurr = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()

                objects, lReportDefaultsSelected = get_the_objects_for_curious_view_and_advanced_edit(objWhat, selectedObjType, "%s" % (titleText), lFindInUpdateMode)
                if self.EDIT_MODE:
                    return objects
                else:
                    if objects is None:
                        return

            lSync = lOFX = lSizes = False
            if selectedWhat == what[_SYNCKEYS]: lSync = True
            if selectedWhat == what[_BANKKEYS]: lOFX = True
            if selectedWhat == what[_SIZEKEYS]: lSizes = True

            GlobalVars.redact = False
            if not self.EDIT_MODE and (lSync or lOFX or lSearch
                                       or selectedWhat == what[_ROOTKEYS]
                                       or selectedWhat == what[_BOOKKEYS]
                                       or selectedWhat == what[_ACCTKEYS]):
                GlobalVars.redact = myPopupAskQuestion(toolbox_frame_, "Display data", "Redact confidential information?")

                if GlobalVars.redact:
                    output += "** Confidential data will be redacted **\n"
                else:
                    output += "** WARNING: NO REDACTION >> so confidential data will be visible **\n".upper()

            try:
                if lObject:  # selected object

                    output += "\n ====== SELECTED OBJECT's RAW PARAMETER KEYS ======\n"

                    for selectedObject in objects:                                                                      # noqa
                        # noinspection PyUnresolvedReferences
                        keys=sorted(selectedObject.getParameterKeys())
                        output += "\nObject Type: %s\n" %type(selectedObject)

                        if isinstance(selectedObject, Account):
                            # noinspection PyUnresolvedReferences
                            if selectedObject.getAccountType() == Account.AccountType.ROOT:
                                output += "\n@@OBJECT IS ACCOUNT AND IT IS ROOT\n"
                            else:
                                output += "\nAccount  Type: %s\n" %selectedObject.getAccountType()

                        if isinstance(selectedObject, (ParentTxn,SplitTxn)):
                            output += "Account: %s\n" %selectedObject.getAccount()

                        for theKey in keys:
                            # noinspection PyUnresolvedReferences
                            value = selectedObject.getParameter(theKey)
                            output += pad("Key:%s" %theKey,50)+" Value: '%s'\n" %(value.strip())

                        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                            if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

                        if isinstance(selectedObject, OnlineTxnList):
                            output += "\nMD User Representation of Data Held by this Account/OnlineTxnList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getTxnCount():",50),                        selectedObject.getTxnCount()  )
                            output += "%s %s\n" % (pad("hasOnlineAvailBalance():",50),              selectedObject.hasOnlineAvailBalance()  )
                            output += "%s %s\n" % (pad("getOnlineAvailBalance():",50),              selectedObject.getOnlineAvailBalance()  )
                            output += "%s %s (%s)\n" % (pad("getOnlineAvailBalanceDate():",50),     selectedObject.getOnlineAvailBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineAvailBalanceDate()))  )
                            output += "%s %s\n" % (pad("hasOnlineLedgerBalance():",50),             selectedObject.hasOnlineLedgerBalance()  )
                            output += "%s %s\n" % (pad("getOnlineLedgerBalance():",50),             selectedObject.getOnlineLedgerBalance()  )
                            output += "%s %s (%s)\n" % (pad("getOnlineLedgerBalanceDate():",50),    selectedObject.getOnlineLedgerBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineLedgerBalanceDate()))  )

                            if isMulti_OFXLastTxnUpdate_build():
                                output += "%s %s (%s)\n" % (pad("getMostRecentTxnUpdate():",50),
                                                            selectedObject.getMostRecentTxnUpdate(),
                                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getMostRecentTxnUpdate())))
                                for k in selectedObject.getParameterKeys():
                                    if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                                        value = selectedObject.getLongParameter(k, 0)
                                        output += "... Key: %s %s (%s)\n" %(pad(k,75), value, convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(value)))
                            else:
                                output += "%s %s (%s)\n" % (pad("getOFXLastTxnUpdate():",50),
                                                            selectedObject.getOFXLastTxnUpdate(),
                                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOFXLastTxnUpdate())))

                        if isinstance(selectedObject, OnlinePayeeList):
                            output += "\nMD User Representation of Data Held by this Account/OnlinePayeeList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getPayeeCount():",50),             selectedObject.getPayeeCount()  )

                        if isinstance(selectedObject, OnlinePaymentList):
                            output += "\nMD User Representation of Data Held by this Account/OnlinePaymentList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getPaymentCount():",50),           selectedObject.getPaymentCount()  )

                        if isinstance(selectedObject, Account):
                            try:
                                theCurr = selectedObject.getCurrencyType()
                                output += "\nMD User Representation of Data Held by this Account/Category\n"
                                output += " =============================================================\n"
                                output += "%s %s\n" % (pad("Object's Sync Type:",50),                selectedObject.getSyncItemType()  )
                                output += "%s %s\n" % (pad("Account Name:",50),                      selectedObject.getAccountName()   )
                                if selectedObject.getParentAccount() is not None:
                                    output += "%s %s\n" % (pad("Parent Account Name:",50),           selectedObject.getParentAccount().getAccountName() )
                                output += "%s %s\n" % (pad("Full Account Name:",50),                 selectedObject.getFullAccountName()                )
                                output += "%s %s\n" % (pad("Account Type:",50),                      selectedObject.getAccountType()                    )
                                output += "%s %s\n" % (pad("Account Description:",50),               selectedObject.getAccountDescription()             )
                                output += "%s %s\n" % (pad("Account Start Date:",50),                convertStrippedIntDateFormattedText(selectedObject.getCreationDateInt()))
                                output += "%s %s\n" % (pad("Comment:",50),                           selectedObject.getComment()                        )
                                output += "%s %s\n" % (pad("Account Number (Legacy):",50),           selectedObject.getAccountNum()                     )
                                output += "%s %s\n" % (pad("Account Is Inactive:",50),               selectedObject.getAccountIsInactive()              )
                                output += "%s %s\n" % (pad("Account Or Parent Is Inactive:",50),     selectedObject.getAccountOrParentIsInactive()      )
                                output += "%s %s\n" % (pad("Hidden from Home Screen:",50),           selectedObject.getHideOnHomePage()                 )
                                output += "%s %s\n" % (pad("This Accounts Depth (from top):",50),    selectedObject.getDepth()                          )
                                output += "%s %s\n" % (pad("Parent Accounts back to Root:",50),      selectedObject.getAllAccountNames()                )
                                output += "%s %s\n" % (pad("This Acct's sub accounts:",50),          selectedObject.getSubAccounts()                    )
                                output += "%s %s\n" % (pad("Account Currency:",50),                  selectedObject.getCurrencyType()                   )
                                output += "%s %s\n" % (pad("Count of Sub Accounts:",50),             selectedObject.getSubAccountCount()                )
                                output += "%s %s\n" % (pad("Account Number:",50),                    selectedObject.getBankAccountNumber()              )
                                output += "%s %s\n" % (pad("Bank Name:",50),                         selectedObject.getBankName()                       )
                                output += "%s %s\n" % (pad("Default Category:",50),                  selectedObject.getDefaultCategory()                )
                                if selectedObject.getDefaultTransferAccount():
                                    output += "%s %s\n" % (pad("Default Transfer Acct:",50),         selectedObject.getDefaultTransferAccount()         )
                                output += "%s %s\n" % (pad("Tax related:",50),                       selectedObject.isTaxRelated()                      )
                                if selectedObject.isDeductible():
                                    output += "%s %s\n" % (pad("is Deductible:",50),                 selectedObject.isDeductible()                      )
                                if selectedObject.getTaxCategory():
                                    output += "%s %s\n" % (pad("Tax Category:",50),                 selectedObject.getTaxCategory()                     )

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD:
                                    output += "%s %s\n" % (pad("Card Number:",50),                  selectedObject.getCardNumber()                 )
                                    output += "%s %s\n" % (pad("Card Expiration Month:",50),        selectedObject.getCardExpirationMonth()        )
                                    output += "%s %s\n" % (pad("Card Expiation Year:",50),          selectedObject.getCardExpirationYear()         )
                                    output += "%s %s\n" % (pad("Credit Limit:",50),                 selectedObject.getCreditLimit()                )
                                    output += "%s %s\n" % (pad("APR %:",50),                        selectedObject.getAPRPercent()                 )

                                output += "%s %s\n" % (pad("Transactions within this Account:",50),  selectedObject.getTxnCount()                  )
                                output += "%s %s\n" % (pad("Unconfirmed Transactions:",50),          selectedObject.getUnconfirmedTxnCount()       )

                                if selectedObject.getReminder():
                                    output += "%s %s\n" % (pad("Reminder:",50),                      selectedObject.getReminder()                  )

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.BANK \
                                        or selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD \
                                        or selectedObject.getAccountType() == Account.AccountType.INVESTMENT:
                                    if selectedObject.isOnlineEnabled():
                                        output += "%s %s\n" % (pad("Online Enabled:",50),                selectedObject.isOnlineEnabled()                 )
                                    if selectedObject.isOnlineBankingCandidate():
                                        output += "%s %s\n" % (pad("Online Banking Candidate:",50),      selectedObject.isOnlineBankingCandidate()        )
                                    if selectedObject.isOnlineBillpayCandidate():
                                        output += "%s %s\n" % (pad("Online Bill Pay Candidate:",50),     selectedObject.isOnlineBillpayCandidate()        )
                                    if selectedObject.getBankingFI():
                                        output += "%s %s\n" % (pad("OFX Banking Service:",50),           selectedObject.getBankingFI()                    )
                                    if selectedObject.getBillPayFI():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Service:",50),          selectedObject.getBillPayFI()                    )
                                    if selectedObject.getOFXAccountType():
                                        output += "%s %s\n" % (pad("OFX Account Type:",50),              selectedObject.getOFXAccountType()               )
                                    if selectedObject.getOFXAccountNumber():
                                        output += "%s %s\n" % (pad("OFX Account Number:",50),            selectedObject.getOFXAccountNumber()             )
                                    if selectedObject.getOFXBankID():
                                        output += "%s %s\n" % (pad("OFX Bank ID:",50),                   selectedObject.getOFXBankID()                    )
                                    if selectedObject.getOFXBranchID():
                                        output += "%s %s\n" % (pad("OFX Branch ID:",50),                 selectedObject.getOFXBranchID()                  )
                                    if selectedObject.getOFXBrokerID():
                                        output += "%s %s\n" % (pad("OFX Broker ID:",50),                 selectedObject.getOFXBrokerID()                  )
                                    if selectedObject.getOFXAccountKey():
                                        output += "%s %s\n" % (pad("OFX Account Key:",50),               selectedObject.getOFXAccountKey()                )
                                    if selectedObject.getOFXAccountMsgType():
                                        output += "%s %s\n" % (pad("OFX Acct Message Type:",50),         selectedObject.getOFXAccountMsgType()            )
                                    if selectedObject.getOFXBillPayAccountNumber():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Acct Number:",50),      selectedObject.getOFXBillPayAccountNumber()      )
                                    if selectedObject.getOFXBillPayAccountType():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Acct Type:",50),        selectedObject.getOFXBillPayAccountType()        )
                                    if selectedObject.getOFXBillPayBankID():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Bank ID:",50),          selectedObject.getOFXBillPayBankID()             )

                                output += "%s %s\n" % ( pad("Start Balance:",50),                        theCurr.getDoubleValue(selectedObject.getStartBalance()))
                                if isKotlinCompiledBuild():
                                    output += "%s %s\n" % ( pad("Unadjusted Start Balance:",50),         theCurr.getDoubleValue(selectedObject.getUnadjustedStartBalance()))
                                    output += "%s %s\n" % ( pad("Balance Adjustment:",50),               theCurr.getDoubleValue(selectedObject.getBalanceAdjustment()))
                                output += "%s %s\n" % ( pad("Balance:",50),                              theCurr.getDoubleValue(selectedObject.getBalance()))
                                output += "%s %s\n" % ( pad("Cleared Balance:",50),                      theCurr.getDoubleValue(selectedObject.getClearedBalance()))
                                output += "%s %s\n" % ( pad("Current Balance:",50),                      theCurr.getDoubleValue(selectedObject.getCurrentBalance()))
                                output += "%s %s\n" % ( pad("Confirmed Balance:",50),                    theCurr.getDoubleValue(selectedObject.getConfirmedBalance()))
                                output += "%s %s\n" % ( pad("Reconciling Balance:",50),                  theCurr.getDoubleValue(selectedObject.getReconcilingBalance()))

                                output += "%s %s\n" % ( pad("User Start Balance:",50),                   theCurr.getDoubleValue(selectedObject.getUserStartBalance()))
                                output += "%s %s\n" % ( pad("User Balance:",50),                         theCurr.getDoubleValue(selectedObject.getUserBalance()))
                                output += "%s %s\n" % ( pad("User Cleared Balance:",50),                 theCurr.getDoubleValue(selectedObject.getUserClearedBalance()))
                                output += "%s %s\n" % ( pad("User Confirmed Balance:",50),               theCurr.getDoubleValue(selectedObject.getUserConfirmedBalance()))
                                output += "%s %s\n" % ( pad("User Current Balance:",50),                 theCurr.getDoubleValue(selectedObject.getUserCurrentBalance()))
                                output += "%s %s\n" % ( pad("User Reconciling Balance:",50),             theCurr.getDoubleValue(selectedObject.getUserReconcilingBalance()))

                                output += "%s %s\n" % ( pad("Recursive Start Balance:",50),              theCurr.getDoubleValue(selectedObject.getRecursiveStartBalance()))
                                output += "%s %s\n" % ( pad("Recursive Balance:",50),                    theCurr.getDoubleValue(selectedObject.getRecursiveBalance()))
                                output += "%s %s\n" % ( pad("Recursive Cleared Balance:",50),            theCurr.getDoubleValue(selectedObject.getRecursiveClearedBalance()))
                                output += "%s %s\n" % ( pad("Recursive Current Balance:",50),            theCurr.getDoubleValue(selectedObject.getRecursiveCurrentBalance()))
                                output += "%s %s\n" % ( pad("Recursive Reconciling Balance:",50),        theCurr.getDoubleValue(selectedObject.getRecursiveReconcilingBalance()))

                                output += "%s %s\n" % ( pad("User Recursive Start Balance:",50),         theCurr.getDoubleValue(selectedObject.getRecursiveUserStartBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Balance:",50),               theCurr.getDoubleValue(selectedObject.getRecursiveUserBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Cleared Balance:",50),       theCurr.getDoubleValue(selectedObject.getRecursiveUserClearedBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Current Balance:",50),       theCurr.getDoubleValue(selectedObject.getRecursiveUserCurrentBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Reconciling Balance:",50),   theCurr.getDoubleValue(selectedObject.getRecursiveUserReconcilingBalance()))

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD \
                                        or selectedObject.getAccountType() == Account.AccountType.LOAN:

                                    if selectedObject.getInstitutionName():
                                        output += "%s %s\n" % (pad("Institution Name:",50),               selectedObject.getInstitutionName())
                                    if selectedObject.getInitialPrincipal():
                                        output += "%s %s\n" % (pad("Initial Principle:",50),             selectedObject.getInitialPrincipal())
                                    if selectedObject.getPermanentAPR():
                                        output += "%s %s\n" % (pad("Permanent APR:",50),                  selectedObject.getPermanentAPR())
                                    if selectedObject.getPoints():
                                        output += "%s %s\n" % (pad("%loan added as fee to Principle.:",50),selectedObject.getPoints())
                                    if selectedObject.getPaymentsPerYear():
                                        output += "%s %s\n" % (pad("Payments per year:",50),              selectedObject.getPaymentsPerYear())
                                    if selectedObject.getInterestAccount():
                                        output += "%s %s\n" % (pad("Interest Account:",50),               selectedObject.getInterestAccount())
                                    if selectedObject.getEscrowAccount():
                                        output += "%s %s\n" % (pad("Escrow Account:",50),                selectedObject.getEscrowAccount())
                                    if selectedObject.getEscrowPayment():
                                        output += "%s %s\n" % (pad("Escrow Payment:",50),                selectedObject.getEscrowPayment())
                                    if selectedObject.getInterestRate():
                                        output += "%s %s\n" % (pad("Interest Rate:",50),                 selectedObject.getInterestRate())
                                    if selectedObject.getFixedMonthlyPaymentAmount():
                                        output += "%s %s\n" % (pad("Fixed Payment Amt:",50),             selectedObject.getFixedMonthlyPaymentAmount())
                                    if selectedObject.getRateChangeDate():
                                        output += "%s %s\n" % (pad("Date Rate  Changed:",50),            selectedObject.getRateChangeDate())
                                    if selectedObject.getDebtPaymentAmount():
                                        output += "%s %s\n" % (pad("Val Pmts made to this CC:",50),      selectedObject.getDebtPaymentAmount())
                                    if selectedObject.getDebtPaymentProportion():
                                        output += "%s %s\n" % (pad("%value Pmts made to this cc:",50),   selectedObject.getDebtPaymentProportion())
                                    if selectedObject.getDebtPaymentSpec():
                                        output += "%s %s\n" % (pad("Pmt  Plan Used:",50),                selectedObject.getDebtPaymentSpec())

                                    if selectedObject.getPaymentSchedule():
                                        output += "%s %s\n" % (pad("Payment Schedule:",50),               selectedObject.getPaymentSchedule())
                                    if selectedObject.hasExpiringRate():
                                        output += "%s %s\n" % (pad("Has Expiring Rate:",50),              selectedObject.hasExpiringRate())
                                    if selectedObject.getCalcPmt():
                                        output += "%s %s\n" % (pad("Calc Payment:",50),                   selectedObject.getCalcPmt())

                                if selectedObject.getInvestAccountNumber():
                                    output += "%s %s\n" % (pad("Investment Account Number:",50),          selectedObject.getInvestAccountNumber())

                                if selectedObject.getAnnualFee() != 0:
                                    output += "%s %s\n" % (pad("Annual Fee:",50),                         selectedObject.getAnnualFee())

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.SECURITY:

                                    pAcct = selectedObject.getParentAccount()
                                    pAcctCurr = pAcct.getCurrencyType()

                                    if selectedObject.getUsesAverageCost():
                                        output += "%s %s\n" % (pad("Uses Average Cost:",50),                selectedObject.getUsesAverageCost())

                                    if selectedObject.getBroker():
                                        output += "%s %s\n" % (pad("Broker:",50),                           selectedObject.getBroker())
                                    if selectedObject.getBrokerPhone():
                                        output += "%s %s\n" % (pad("Broker Phone:",50),                     selectedObject.getBrokerPhone())
                                    if selectedObject.getInvstCommissionAcct():
                                        output += "%s %s\n" % (pad("Investment Commission Account",50),     selectedObject.getInvstCommissionAcct())

                                    if selectedObject.getSecurityType():
                                        output += "%s %s\n" % (pad("Security Type:",50),                    unicode(selectedObject.getSecurityType()))
                                    if selectedObject.getSecuritySubType():
                                        output += "%s %s\n" % (pad("Security Sub Type:",50),                selectedObject.getSecuritySubType())

                                    if selectedObject.getSecurityType() == SecurityType.STOCK:
                                        if selectedObject.getDividend() and selectedObject.getDividend() != 0:
                                            output += "%s %s\n" % (pad("Dividend:",50),                     pAcctCurr.format(selectedObject.getDividend(), GlobalVars.decimalCharSep))

                                    if selectedObject.getSecurityType() == SecurityType.MUTUAL: pass

                                    if selectedObject.getSecurityType() == SecurityType.CD:
                                        if selectedObject.getAPR() != 0.0:
                                            output += "%s %s\n" % (pad("CD APR:",50),                       selectedObject.getAPR())
                                        if selectedObject.getCompounding():
                                            output += "%s %s\n" % (pad("CD Compounding:",50),               selectedObject.getCompounding())

                                        numYearsChoice = ["0.5"]
                                        for iYears in range(1, 51): numYearsChoice.append(str(iYears))
                                        output += "%s %s\n" % (pad("Maturity Year (6=six Mnths):",50),      numYearsChoice[-1] if (len(numYearsChoice) < selectedObject.getNumYears()) else numYearsChoice[selectedObject.getNumYears()])

                                    if selectedObject.getSecurityType() == SecurityType.BOND:
                                        bondTypes = [MD_REF.getUI().getStr("gov_bond"), MD_REF.getUI().getStr("mun_bond"), MD_REF.getUI().getStr("corp_bond"), MD_REF.getUI().getStr("zero_bond")]
                                        output += "%s %s\n" % (pad("Bond Type:",50),                        "ERROR" if (selectedObject.getBondType() > len(bondTypes)) else bondTypes[selectedObject.getBondType()])
                                        if selectedObject.getFaceValue() != 0:
                                            output += "%s %s\n" % (pad("Bond face value:",50),              pAcctCurr.format(selectedObject.getFaceValue(), GlobalVars.decimalCharSep))
                                        if selectedObject.getAPR() != 0.0:
                                            output += "%s %s\n" % (pad("Bond APR:",50),                     selectedObject.getAPR())
                                        if (selectedObject.getMaturity() != 0 and selectedObject.getMaturity() != 39600000):
                                            output += "%s %s\n" % (pad("Maturity:",50),                         DateUtil.convertLongDateToInt(selectedObject.getMaturity()))

                                    if selectedObject.getSecurityType() == SecurityType.OPTION:
                                        output += "%s %s\n" % (pad("Option Put/Call:",50),                  "Put" if (selectedObject.getPut()) else "Call")
                                        if selectedObject.getOptionPrice() != 0.0:
                                            output += "%s %s\n" % (pad("Option Price:",50),                 selectedObject.getOptionPrice())
                                        if selectedObject.getStrikePrice() != 0:
                                            output += "%s %s\n" % (pad("Option Strike Price:",50),          pAcctCurr.format(selectedObject.getStrikePrice(), GlobalVars.decimalCharSep))
                                        monthOptions = [MD_REF.getUI().getStr("january"), MD_REF.getUI().getStr("february"), MD_REF.getUI().getStr("march"), MD_REF.getUI().getStr("april"), MD_REF.getUI().getStr("may"), MD_REF.getUI().getStr("june"), MD_REF.getUI().getStr("july"), MD_REF.getUI().getStr("august"), MD_REF.getUI().getStr("september"), MD_REF.getUI().getStr("october"), MD_REF.getUI().getStr("november"), MD_REF.getUI().getStr("december")]
                                        output += "%s %s\n" % (pad("Option Exercise Month:",50),            "ERROR" if (selectedObject.getMonth() > len(monthOptions)) else monthOptions[selectedObject.getMonth()])

                                    if selectedObject.getSecurityType() == SecurityType.OTHER: pass

                                    if selectedObject.getEscrow():
                                        output += "%s %s\n" % (pad("Escrow?:",50),                          selectedObject.getEscrow())

                                    if selectedObject.getExchange():
                                        output += "%s %s\n" % (pad("Trading Platform:",50),                 selectedObject.getExchange())
                            except:
                                output += dump_sys_error_to_md_console_and_errorlog( True )

                        elif isinstance(selectedObject, CurrencyType):
                            try:
                                output += "\nMD User Representation of Data Held by this Currency/Security\n"
                                output += " =============================================================-\n"
                                if selectedObject == baseCurr:                                                              # noqa
                                    output += "THIS IS THE BASE RATE!\n"
                                output += "%s %s\n" % (pad("Sync Item Type:",50),       selectedObject.getSyncItemType()  )
                                output += "%s %s\n" % (pad("Currency Type:",50),        selectedObject.getCurrencyType()  )
                                output += "%s %s\n" % (pad("Name:",50),                 selectedObject.getName()  )
                                output += "%s %s\n" % (pad("Hide in UI?:",50),          selectedObject.getHideInUI()  )
                                output += "%s %s\n" % (pad("ID:",50),                   selectedObject.getID()  )
                                output += "%s %s\n" % (pad("ID String:",50),            selectedObject.getIDString()  )
                                output += "%s %s\n" % (pad("Ticker Symbol:",50),        selectedObject.getTickerSymbol()  )
                                output += "%s %s\n" % (pad("Prefix:",50),               selectedObject.getPrefix()  )
                                output += "%s %s\n" % (pad("Suffix:",50),               selectedObject.getSuffix()  )
                                output += "%s %s\n" % (pad("Decimal Places:",50),       selectedObject.getDecimalPlaces()  )
                                output += "%s %s\n" % (pad("Curr Start Date:",50),      convertStrippedIntDateFormattedText(selectedObject.getEffectiveDateInt())  )

                                for convertTimeStamp in ["price_date"]:
                                    if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

                                snaps = selectedObject.getSnapshots()

                                output += "%s %s\n" % (pad("RATE (to base):",50),           selectedObject.getRate(None)  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getRate(None))  )
                                output += "%s %s\n" % (pad("RATE in terms of Base:",50),    selectedObject.getBaseRate()  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getBaseRate())  )
                                output += "%s %s\n" % (pad("Relative Currency:",50),        selectedObject.getRelativeCurrency()  )
                                output += "%s %s\n" % (pad("Relative Rate:",50),            selectedObject.getRelativeRate()  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getRelativeRate())  )
                                output += "%s %s\n" % (pad("Count Price History:",50),      snaps.size() )
                                output += "%s %s\n" % (pad("Count Stock Splits:",50),       len(selectedObject.getSplits()  ))
                                output += "%s %s\n" % (pad("Daily Change:",50),             selectedObject.getDailyChange()  )
                                output += "%s %s\n" % (pad("Daily Volume:",50),             selectedObject.getDailyVolume()  )

                                output += "\n" \
                                          "Oldest and Newest (max) 5 Price History Records (RAW records) (use 1.0/rate to convert values):\n" \
                                          " ----------------------------------------------------------------------------------------------\n"

                                if snaps.size():
                                    # Put all maps back for snapshots listed.....
                                    dummySyncR = SyncRecord()

                                    iCountSnapsPrinted = iSnap = 0
                                    maxToPrint = min(10, snaps.size())

                                    output += "<-- Oldest (max) 5 records -->>\n"
                                    while iCountSnapsPrinted <= maxToPrint:
                                        snaps[iSnap].itemWillSync(dummySyncR)
                                        output += dummySyncR.toMultilineHumanReadableString()+"---\n"                   # noqa
                                        dummySyncR.clear()                                                              # noqa
                                        iSnap += 1
                                        iCountSnapsPrinted += 1
                                        if iCountSnapsPrinted >= snaps.size() or iSnap >= snaps.size(): break
                                        if iCountSnapsPrinted < 5: continue
                                        if iCountSnapsPrinted == 5:
                                            output += "<-- Newest (max) 5 records -->>\n"
                                            iSnap = max(5, snaps.size() - (maxToPrint-iCountSnapsPrinted))
                                        if iCountSnapsPrinted > 10: break
                                    del dummySyncR
                                del snaps
                                output += "<END>\n"
                            except:
                                output += dump_sys_error_to_md_console_and_errorlog( True )

                        elif isinstance(selectedObject, ReportSpec):

                            if lReportDefaultsSelected:
                                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                                keys=sorted(LS.keys())

                                found_any = False
                                for theKey in keys:
                                    value = LS.get(theKey)
                                    if not theKey.lower().startswith("report_params."+selectedObject.getReportGenerator().getShortID()): continue
                                    if not found_any:
                                        output += "\nDEFAULT REPORT PARAMETERS (SET BY USER):\n"
                                        found_any = True
                                    output += "Key:%s Value: %s\n" % (pad(theKey,70), value.strip())
                        elif isinstance(selectedObject, Reminder):
                            pass
                        elif isinstance(selectedObject, AddressBookEntry):
                            pass
                        elif isinstance(selectedObject, OnlineService):
                            pass

                if selectedWhat == what[_PREFKEYS] or lSync or lOFX or lSizes or lSearch:  # User  Preferences

                    output += "\n ====== USER PREFERENCES LOADED INTO MEMORY (May or may not be quite the same as config.dict) ======\n"

                    # This bit below is really, really cool!!!! But I am not using it as it only gets pre-defined settings from config.dict.
                    # prefs=[]
                    # what_x = MD_REF.getUI().getPreferences()
                    # members = [attr for attr in dir(what_x) if not callable(getattr(what_x, attr)) and not attr.startswith("__")]
                    # for mem in members:
                    #     if not mem.upper() == mem: continue
                    #     try:
                    #         convertKey = getattr(UserPreferences, mem)
                    #     except:
                    #         continue
                    #     if not convertKey or convertKey=="" : continue
                    #     value = MD_REF.getUI().getPreferences().getSetting(getattr(UserPreferences, mem))
                    #     if value: prefs.append([convertKey, mem, value])
                    # prefs =sorted(prefs) # Sort the result (as the input is only a reference to a reference)

                    # As all settings in memory actually come from config.dict (or go back to config.dict) then we look there instead to get the keys
                    st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
                    prefs = sorted(tk)

                    for theKey in prefs:
                        value = st.get(theKey)
                        if lSync and not ("sync" in theKey.lower()): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()): continue
                        if lSizes and not check_for_window_display_data(theKey, value): continue
                        if lSearch:
                            myTestValue = value
                            if not isinstance(myTestValue,(str,unicode)): myTestValue  = repr(myTestValue)  # Force the StreamTable / StreamVector into a string for search comparison
                            # noinspection PyUnresolvedReferences
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in myTestValue.lower()): continue
                        # noinspection PyUnresolvedReferences
                        output += (pad("Key:%s" % (theKey),35)+ " Value: %s\n" %((value)))


                if selectedWhat == what[_ROOTKEYS] or lSync or lOFX or lSizes or lSearch:  # ROOT
                    keys = sorted(root.getParameterKeys())
                    output += '\n ====== ROOT PARAMETER KEYS (Preferences will mostly be in Local Storage) ======\n'
                    authKeyPrefix = "ofx.client_uid"
                    for theKey in keys:
                        value = root.getParameter(theKey)
                        if lSync and ("sync" not in theKey.lower()): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()): continue
                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                        if GlobalVars.redact:
                            if theKey.lower() == "netsync.synckey" or theKey.lower().startswith("netsync.db."): value = "<%s> (hidden)" %(redactor(value))

                        rk_redact = theKey
                        val_redact = value

                        if GlobalVars.redact:
                            if theKey.startswith(authKeyPrefix):
                                findUser = find_nth(theKey, "::", 2)
                                if theKey.startswith("ofx.client_uid_default_user::"):
                                    val_redact = redactor(val_redact)
                                elif findUser > len(authKeyPrefix)+4:
                                    rk_redact = theKey[:findUser+2] + redactor(theKey[findUser+2:])

                        output += pad("Key:%s" %(rk_redact),100)+" Value: %s\n" %(val_redact.strip())

                    if selectedWhat == what[_ROOTKEYS]:
                        output+="\n"
                        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                            if root.getLongParameter(convertTimeStamp, 0) > 0:
                                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),100), get_time_stamp_as_nice_text(root.getLongParameter(convertTimeStamp, 0))  )


                if selectedWhat == what[_BOOKKEYS] or lOFX or lSearch:  # Local Storage - authentication cache

                    output += '\n ====== BOOK>LOCAL STORAGE KEYS - CACHED AUTHENTICATION ======\n'

                    lCachePasswords = isCachingPasswords()

                    _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
                    if len(_auth) > 0:
                        if not lCachePasswords: output += "** NOTE THESE WILL NOT BE SAVED/REMEMBERED WHEN YOU RESTART MD **\n"
                        keys = sorted(_auth.keys())                                                                     # noqa
                        for theKey in keys:
                            value = _auth.get(theKey)                                                                   # noqa
                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue                       # noqa
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue                   # noqa
                            output += pad("Key:%s" %theKey,90)+" Value: %s\n" %(redactAuth(value.strip()))              # noqa
                    else:
                        if not lCachePasswords:
                            output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
                            output += "** Use Menu Online Banking Tools > 'View online banking configuration / connection data (OFX/DC and MD+)' to view specific cached items **\n"
                        output += "<NONE>\n"


                if selectedWhat == what[_BOOKKEYS] or lSync or lOFX or lSizes or lSearch:  # Local Storage

                    output += '\n ====== BOOK>LOCAL STORAGE KEYS ======\n'

                    LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                    keys=sorted(LS.keys())

                    last = None
                    for theKey in keys:
                        value = LS.get(theKey)    # NOTE: .get loses the underlying type and thus becomes a string

                        if theKey.startswith("_authentication"): continue

                        if lSync and "sync" not in theKey.lower(): continue
                        if lSync and "netsync.del_item" in theKey.lower(): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()
                                         or "access_tokens" in theKey.lower() or "mdp_items" in theKey.lower()): continue

                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                        if GlobalVars.redact:
                            if theKey.lower() == "netsync.synckey" or theKey.lower().startswith("netsync.db."): value = "<%s> (hidden)" %(redactor(value))

                        if GlobalVars.redact:
                            if ("._payloadid" in theKey.lower() or ".token" in theKey.lower()): value = "<%s> (hidden)" %(redactor(value))

                        splitKey = theKey.split('.')
                        if splitKey[0] != last:
                            last = splitKey[0]
                            lookupAcct = MD_REF.getCurrentAccountBook().getAccountByUUID(splitKey[0])
                            if lookupAcct:
                                output += ("\n>> Account: %s\n" %(lookupAcct.getFullAccountName()))
                            else:
                                output += "\n"

                        output += pad("Key:%s" %theKey,90)+" Value: %s\n" %(value.strip())

                if selectedWhat == what[_ACCTKEYS] or lSync or lOFX or lSizes or lSearch:  # Accounts (excluding Root)

                    output += "\n ====== ACCOUNTS' PARAMETER KEYS  (Preferences will mostly be in Local Storage) ======\n"
                    accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(5))
                    lastAcct = None
                    for acct in accounts:

                        lPrintedAccountHeading = False

                        if lOFX:
                            if acct != lastAcct:
                                lPrintedAccountHeading = True
                                output += "\n>> Account: %s\n" %acct.getFullAccountName()
                                lastAcct = acct

                            output += "\nSpecific OFX Data:\n"
                            if (acct.canDownloadTxns() and not acct.getAccountIsInactive()):
                                output += pad(">> Can Download Txns:",50)+safeStr(acct.canDownloadTxns() and not acct.getAccountIsInactive())+"\n"

                            if acct.getOFXAccountNumber() is not None and acct.getOFXAccountNumber() != "":
                                output += pad(">> OFX Account Number:",50)+redactor(safeStr(acct.getOFXAccountNumber()))+"\n"

                            if isMDPlusEnabledBuild():
                                gbs = acct.getBankingServices()
                                if gbs.size() > 0:
                                    if isMDPlusUniqueBankingServicesEnabledBuild():
                                        for bs in gbs:
                                            output += pad(">> Banking Service found (out of %s):" %(gbs.size()),50)+safeStr(bs.getService())+"\n"
                                    else:
                                        # Sean advised that always take the first item (there are duplicates in the list, but it is sorted)
                                        output += pad(">> Banking Services first candidate:",50)+safeStr(gbs[0].getService())+"\n"

                            if acct.getBankingFI() is not None:
                                output += pad(">> Bank Service/Logon profile (getBankingFI()):",50)+safeStr(acct.getBankingFI())+"\n"
                                if my_get_account_key(acct):
                                    output += pad(">> (Account Key):",50)+safeStr(my_get_account_key(acct))+"\n"

                            if acct.getBillPayFI() is not None:
                                output += pad(">> BillPay Service/Logon profile:",50)+safeStr(acct.getBillPayFI())+"\n"
                                if my_get_account_key(acct):
                                    output += pad(">> (Account Key):",50)+safeStr(my_get_account_key(acct))+"\n"

                            getOnlineData = MyGetDownloadedTxns(acct)

                            if getOnlineData is not None:
                                lFoundExtra_ofx_last_txn_update = False
                                ofx_last_txn_update_keys = []
                                for k in getOnlineData.getParameterKeys():
                                    if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                                        ofx_last_txn_update_keys.append(k)
                                        lFoundExtra_ofx_last_txn_update = True

                                if (lFoundExtra_ofx_last_txn_update
                                        or getOnlineData.getParameter(GlobalVars.Strings.OFX_LAST_TXN_UPDATE, None) is not None
                                        or getOnlineData.getParameter("ol.availbal", None) is not None
                                        or getOnlineData.getParameter("ol.ledgerbal", None) is not None):
                                    output += (">> OnlineTxnList data:\n")
                                    for _k in sorted(getOnlineData.getParameterKeys()):
                                        _v = getOnlineData.getParameter(_k)
                                        for checkKey in ["ol.availbal", "ol.ledgerbal"]:
                                            if checkKey == _k:
                                                _v = redactor(_v.strip())
                                                break
                                        output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())

                                    for convertTimeStamp in ["ts", "ol.ledgerbalasof"]: ofx_last_txn_update_keys.append(convertTimeStamp)

                                    for convertTimeStamp in ofx_last_txn_update_keys:
                                        if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                            output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),90), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0)))

                            getOnlineData = MyGetOnlinePayees(acct)
                            if getOnlineData is not None:
                                output += (">> OnlinePayees data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", GlobalVars.Strings.OFX_LAST_TXN_UPDATE, "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            getOnlineData = MyGetOnlinePayments(acct)
                            if getOnlineData is not None:
                                output += (">> OnlinePayments data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", GlobalVars.Strings.OFX_LAST_TXN_UPDATE, "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            output += "\n"

                        keys = sorted(acct.getParameterKeys())
                        for theKey in keys:

                            value = acct.getParameter(theKey)
                            if lSync and not ("sync" in theKey.lower()): continue
                            if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()
                                             or "olblink." in theKey.lower()
                                             or "olbfi" in theKey.lower()
                                             or "bpfi" in theKey.lower()): continue
                            if lSizes and not check_for_window_display_data(theKey, value): continue
                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                            if GlobalVars.redact:
                                if theKey.lower() == "netsync.synckey" or theKey.lower().startswith("netsync.db."): value = "<%s> (hidden)" %(redactor(value))

                            if GlobalVars.redact:
                                for checkKey in ["bank_account_number", "ofx_account_number", "ofx_bank_id", "ofx_import_acct_num", "olblink."]:
                                    if checkKey in theKey.lower():
                                        value = "<%s> (hidden >> disable redaction to view)" %(redactor(value))
                                        break

                            if lOFX and value.strip() == "": continue

                            if not lPrintedAccountHeading:
                                if acct != lastAcct:
                                    lPrintedAccountHeading = True
                                    output += "\n>> Account: %s\n" %acct.getFullAccountName()
                                    lastAcct = acct

                            output += pad("Key:%s" %(theKey),50)+" Value: %s\n" %(value.strip())

                        if selectedWhat == what[_ACCTKEYS]:
                            output+="\n"
                            for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                                if acct.getLongParameter(convertTimeStamp, 0) > 0:
                                    output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(acct.getLongParameter(convertTimeStamp, 0))  )

                if lOFX or lSearch:
                    output += "\n ========= OFX Online Banking Service's PARAMETER KEYS =========\n"
                    output += "\n (NOTE: More information will be in view bank service / login profiles)\n"

                    lastService = None
                    services = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
                    for service in services:
                        keys = sorted(service.getParameterKeys())
                        for theKey in keys:

                            value = service.getParameter(theKey)

                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                            if service != lastService:
                                output += "\nOFX SERVICE: %s\n" %service
                                output += " -------------------------------------------\n"
                                lastService = service

                            if GlobalVars.redact:
                                for checkKey in ["balance", "account_num", "branch_id", "routing_num", "so_user_id"]:
                                    if checkKey in theKey:
                                        value = redactor(value, ("balance" in theKey))
                                        break

                            output += pad("Key:%s" %(theKey), 50)+ " Value: %s\n" %(value)

                if lOFX:
                    output += "\n ========= Moneydance+ license object's PARAMETER KEYS (MD2022 onwards) =========\n"
                    licenseObject = getMDPlusLicenseInfoForBook()
                    if licenseObject is None:
                        output += "<NO LICENSE OBJECT FOUND>\n"
                    else:
                        output += special_toMultilineHumanReadableString(licenseObject, lSkipSecrets=GlobalVars.redact, lRedact=GlobalVars.redact)
                        del licenseObject

                    output += "\n ========= OFX Account Mappings Object's PARAMETER KEYS (MD2022 onwards) =========\n"
                    mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")
                    if mappingObject is None:
                        output += "<NO ACCOUNT MAPPING OBJECT FOUND>\n"
                    else:
                        output += special_toMultilineHumanReadableString(mappingObject, lSkipSecrets=GlobalVars.redact, lRedact=GlobalVars.redact)
                        del mappingObject

                if selectedWhat == what[_OSPROPS]:  # System.Properties

                    output += "\n ====== (Java JVM) System.Properties.....======\n"

                    props = sorted(System.getProperties())
                    for prop in props:
                        output += pad("Property:%s" %prop,50)+ " Value: %s\n"%(System.getProperty(prop))

                if selectedWhat == what[_OSENV]:    # Environment variables

                    output += "\n ====== Operating System Environment Variables.....======\n"

                    for k, v in os.environ.items():
                        output += pad("Variable: %s" %k,50)+ " Value: %s\n" %(v)

            except:
                output += dump_sys_error_to_md_console_and_errorlog( True )

            output += "<END>\n"

            jif = QuickJFrame("Curious? View Internal Settings...: %s" % selectedWhat, output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

            if self.lOFX:
                txt = "OFX: Your OFX Bank related settings have been searched and displayed...."
                setDisplayStatus(txt, "B")
                return jif
            else:
                txt = "I hope you enjoyed Curiously Viewing Internal Settings...: %s" %(selectedWhat)
                setDisplayStatus(txt, "DG")

    def prune_internal_backups(lStartup=False):
        myPrint("B", "Auto-prune is enabled.... auto-pruning internal backups of config.dict and settings now.....")

        try:

            backup_extn = "_$SAVED$"

            backup_localStorage_path = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath())
            backup_config_path = os.path.dirname(Common.getPreferencesFile().getCanonicalPath())
            # backup_custom_theme_path = os.path.dirname(ThemeInfo.customThemeFile.getCanonicalPath())

            settingsFile = "settings"
            # backup_localStorage_filename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(), "settings")
            # configFile = Common.getPreferencesFile().getName()
            # themeFile = ThemeInfo.customThemeFile.getName()

            themeFiles = []
            configFiles = []
            settingsFiles = []

            iCountConfig = iCountSettings = iCountTheme = 0

            for _path in [backup_localStorage_path, backup_config_path]:
                for _file in os.listdir(_path):
                    filepath = os.path.join(_path, _file)
                    if _file.startswith(settingsFile) and _file.endswith(backup_extn):
                        settingsFiles.append(filepath)
                        iCountSettings+=1
                    elif _file.startswith("config-") and _file.endswith(".dict"+backup_extn):
                        configFiles.append(filepath)
                        iCountConfig+=1
                    elif _file.startswith("custom_theme-") and _file.endswith(".properties"+backup_extn):
                        themeFiles.append(filepath)
                        iCountTheme+=1
                    else:
                        pass

            myPrint("DB", "Found %s settings backup files" %(iCountSettings))
            myPrint("DB", "Found %s config.dict backup files" %(iCountConfig))
            myPrint("DB", "Found %s custom themes backup files" %(iCountTheme))

            settingsFiles = sorted(settingsFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)
            configFiles = sorted(configFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)
            themeFiles = sorted(themeFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)

            files_to_keep = 5
            days_to_look_back = 5

            lookBack = datetime.datetime.today() - datetime.timedelta(days=(days_to_look_back+1))

            myPrint("DB", "Look-back cutoff date for auto-prune internal backup files set to: %s " %(get_time_stamp_as_nice_text(lookBack)))

            iDeletedConfig = iDeletedThemes = iDeletedSettings = 0

            iErrors=0
            for filelist in [settingsFiles, configFiles, themeFiles]:
                iRecords=0
                for _fp in filelist:
                    iRecords += 1
                    if iRecords <= files_to_keep:
                        myPrint("D", "skipping-keeping %s files: %s %s" %(files_to_keep,datetime.datetime.fromtimestamp(os.path.getmtime(_fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),_fp))
                        continue
                    file_ts = datetime.datetime.fromtimestamp(os.path.getmtime(_fp))
                    if file_ts >= lookBack:
                        myPrint("D","skipping < %s days: %s %s" %(days_to_look_back, file_ts.strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),_fp))
                        continue
                    myPrint("DB", "DELETING: %s %s" %(file_ts.strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),_fp))
                    if "settings" in _fp:
                        iDeletedSettings+=1
                    elif "config-" in _fp:
                        iDeletedConfig+=1
                    elif "custom_theme-" in _fp:
                        iDeletedThemes+=1
                    try:
                        os.remove(_fp)
                    except:
                        iErrors+=1
                        myPrint("B","@ERROR deleting file: %s - skipping and moving on....." %(_fp))
                        dump_sys_error_to_md_console_and_errorlog()
        except:
            txt = "@@ ERROR auto-pruning internal backup files... continuing....."
            setDisplayStatus(txt, "R"); myPrint("B",txt)
            dump_sys_error_to_md_console_and_errorlog()
            return

        del themeFiles
        del configFiles
        del settingsFiles

        myPrint("J","Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..."
                %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors))

        if not lStartup:
            txt = "Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..." %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors)
            setDisplayStatus(txt, "R")

        if iErrors:
            myPopupInformationBox(toolbox_frame_, "Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..."
                                  %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors),
                                  "AUTO-PRUNE INTERNAL BACKUPS",
                                  JOptionPane.ERROR_MESSAGE)

    class ViewFileButtonAction(AbstractAction):

        class CloseAction(AbstractAction):

            def __init__(self, the_frame):
                self.theFrame = the_frame

            # noinspection PyUnusedLocal
            def actionPerformed(self, event):
                myPrint("DB", "Inner View File Frame shutting down....")
                self.theFrame.dispose()     # Listener will already be on the EDT
                return

        def __init__(self, theFile, displayText):
            self.theFile = theFile
            self.displayText = displayText

        def actionPerformed(self, event):                                                                               # noqa
            x = safeStr(self.theFile)

            myPrint("DB", "User requested to view " + self.displayText + " file...")
            if not os.path.exists(x):
                txt = "Sorry - " + self.displayText + " file does not exist or is not available to view!?: " + x
                setDisplayStatus(txt, "R")
                return

            try:
                with open(x, "r") as myFile:
                    displayFile = myFile.readlines()

                # If VMOptions, stick a "'" at the beginning for clipboard to Excel to work OK
                if GlobalVars.lCopyAllToClipBoard_TB and x.lower().endswith(".vmoptions"):
                    newDisplayFile=[]
                    for line in displayFile:
                        line ="'"+line
                        newDisplayFile.append(line)
                    displayFile = newDisplayFile
                else:
                    displayFile.append("\n<END>")

                displayFile = ''.join(displayFile)
            except:
                displayFile = "Sorry - error opening file...."
                dump_sys_error_to_md_console_and_errorlog()

            if x.lower().endswith(".vmoptions"):
                vmoptionsPath = get_vmoptions_path()
                displayFile += """
-------------------------------------------------------------------------------------------------------------------------------------------
<INSTRUCTIONS - MEMORY>
======================
You can allow for more memory by editing the '%s' file and set it to increase the amount of memory that
Moneydance is allowed to use. To achieve this you can try the following:

Navigate to the '%s' file, located in the folder where Moneydance is installed:

If you open that file with Notepad or any other text editor, you'll see some instructions for how to change it.
Close Moneydance first!

The basic recommendation is to changing the -Xmx1024m setting to -Xmx2048m which doubles the amount of memory that Moneydance is allowed to use.
You can give it more if you wish, E.g.: you make it -Xmx3072m, for optimal results.

NOTE: The limit is set deliberately low to enable it to work with computers having very small amounts of RAM.

""" %(vmoptionsPath, vmoptionsPath)                                                                                     # noqa

                windowsExtra = """
-----
Windows location: '%s'

In Windows - due to permissions, you will need to do this:
In the 'Type here to Search' box on the Windows 10 Toolbar, type CMD (do not press enter)
When Command Prompt appears, click Run as Administrator
Click yes/agree to allow this app to make changes to this device / grant administrator permissions
notepad "%s" (and press enter)
edit the file and change the -Xmx1024 setting
ctrl-s to save and then exit Notepad
exit
restart Moneydance
-------------------------------------------------------------------------------------------------------------------------------------------
""" %(vmoptionsPath, vmoptionsPath)                                                                                     # noqa

                linuxExtra = """
<INSTRUCTIONS - Linux and High Resolution Screens>
=================================================
When running Linux on a computer with a high resolution display, some distributions will let you adjust the "scaling" of 
the interface to provide clearer graphics at a larger size. If you use scaling on your Linux desktop but the contents of
the Moneydance window appears very small then you may need to adjust Moneydance's scaling.

To change the scaling, open '%s' with a text editor (as per instructions below) add the following two
lines to the bottom of the file:

-Dsun.java2d.uiScale=2
-Dsun.java2d.uiScale.enabled=true

>>PLEASE NOTE: that as of this writing, non-integer scales (for example, 1.2) are not supported.
refer: https://infinitekind.tenderapp.com/kb/linux/linux-and-hidpi-high-resolution-screens

-----
Linux file location: '%s'

In Linux - due to permissions, you will need to do this:
a) Either edit in Terminal using sudo before the command (e.g. sudo vi '%s') , or;

b) You ideally need to be able to open files as root via a right click.
- This assumes you are on a Debian based system
1. Open the Terminal
2. Type sudo su and press enter. Provide your password and press enter
3. Then type apt-get install -y nautilus-admin and press enter
4. Now type nautilus -q and press enter
5. Finally type exit and press enter, and close the terminal window
6. All set. Now when you want to open a file as root, simply right click the FOLDER and select Open as Root (or Administrator).

So, now find the /Opt folder, right click on the Moneydance FOLDER, Open as Root. Enter your password. Now you can edit the '%s' file....
>> Note: You may need to logoff and then login to see the changes!

now after saving the file, restart Moneydance
-------------------------------------------------------------------------------------------------------------------------------------------
""" %(vmoptionsPath, vmoptionsPath, vmoptionsPath, vmoptionsPath)                                                       # noqa

                if Platform.isWindows():
                    displayFile += windowsExtra
                elif Platform.isUnix():
                    displayFile += linuxExtra
                try:
                    MD_REF.getPlatformHelper().openDirectory(self.theFile)
                except: pass
                time.sleep(0.5)

            jif = QuickJFrame("View " + self.displayText + " file: " + x, displayFile, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
            jif.toFront()

    def reportAccountNumbers(lEditAlternativeAccountNumbers=False):

        if lEditAlternativeAccountNumbers:
            _THIS_METHOD_NAME = "Add alternative account numbers"
        else:
            _THIS_METHOD_NAME = "Report of Accounts and bank/account number information"

        TOOLBOX_IGNORE = "<toolbox ignore>"
        ALTERNATIVE_ACCT_PARAM = "toolbox_alternative_bank_account_number"

        if lEditAlternativeAccountNumbers:
            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Proceed and edit alternative account numbers?"):
                return

            includedAccountTypes = [Account.AccountType.BANK,                                                           # noqa
                                    Account.AccountType.CREDIT_CARD,                                                    # noqa
                                    Account.AccountType.INVESTMENT,                                                     # noqa
                                    Account.AccountType.ASSET,                                                          # noqa
                                    Account.AccountType.LIABILITY,                                                      # noqa
                                    Account.AccountType.LOAN                                                            # noqa
                                    ]

            class StoreAltAccountList():
                def __init__(self, obj): self.obj = obj

                def getAlternativeAccount(self): return self.obj.getParameter(ALTERNATIVE_ACCT_PARAM, "")

                def __str__(self):
                    # return "%s : %s %s" %(self.obj.getAccountType(), self.obj.getFullAccountName(), "" if StringUtils.isBlank(self.getAlternativeAccount()) else "(alt: %s)" %(self.getAlternativeAccount()))

                    bigText = "%s : %s" %(self.obj.getAccountType(), self.obj.getFullAccountName())
                    moreBigText = "%s" %("" if StringUtils.isBlank(self.getAlternativeAccount()) else " (alt: %s)" %(self.getAlternativeAccount()))

                    return wrap_HTML_multi_color(bigText, moreBigText, _secondaryColor=getColorRed())

                def __repr__(self): return self.__str__()
                def toString(self): return self.__str__()

            allAccounts = [StoreAltAccountList(acct) for acct in AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), AcctFilter.ALL_ACCOUNTS_FILTER) if acct.getAccountType() in includedAccountTypes]
            allAccounts = sorted(allAccounts, key=lambda sort_x: (sort_x.obj.getAccountType(), sort_x.obj.getFullAccountName().upper()))

            while True:

                selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select Account to edit the alternative account number",
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           allAccounts,
                                                           None)
                if not selectedAcct: break

                selectedAcct = selectedAcct.obj                                                                         # noqa
                if isinstance(selectedAcct, Account): pass

                currentAlternative = selectedAcct.getParameter(ALTERNATIVE_ACCT_PARAM, "")

                newAlternative = myPopupAskForInput(toolbox_frame_,
                                                          theTitle=_THIS_METHOD_NAME,
                                                          theFieldLabel="ALTERNATIVE NUMBER:",
                                                          theFieldDescription="Enter an alternative account number (blank will remove)",
                                                          defaultValue=currentAlternative)

                if newAlternative is None: continue


                if selectedAcct.getAccountType() == Account.AccountType.CREDIT_CARD:                                    # noqa
                    md_accountNumber = selectedAcct.getCardNumber()
                elif selectedAcct.getAccountType() == Account.AccountType.INVESTMENT:                                   # noqa
                    md_accountNumber = selectedAcct.getInvestAccountNumber()
                else:
                    md_accountNumber = selectedAcct.getBankAccountNumber()      # Not all account Types have account numbers!


                newAlternative = newAlternative.strip()
                selectedAcct.setParameter(ALTERNATIVE_ACCT_PARAM, None if StringUtils.isBlank(newAlternative) else newAlternative)
                txt = "Account: '%s' Alt Acct Number set to: '%s' (MD ref: '%s')" %(selectedAcct.getAccountName(), newAlternative, md_accountNumber)
                selectedAcct.syncItem()
                setDisplayStatus(txt, "B"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
                logToolboxUpdates("reportAccountNumbers", txt)
                continue

            return


        input_includeBankAccounts = JCheckBox("include account type: Bank?",                                            GlobalVars.saveSettings_reportAccountNumbers.get("input_includeBankAccounts",       True))
        input_includeCCAccounts = JCheckBox("include account type: Credit Card?",                                       GlobalVars.saveSettings_reportAccountNumbers.get("input_includeCCAccounts",         True))
        input_includeInvestmentAccounts = JCheckBox("include account type: Investment?",                                GlobalVars.saveSettings_reportAccountNumbers.get("input_includeInvestmentAccounts", True))
        input_includeAssetAccounts = JCheckBox("include account type: Asset?",                                          GlobalVars.saveSettings_reportAccountNumbers.get("input_includeAssetAccounts",      True))
        input_includeLiabilityAccounts = JCheckBox("include account type: Liability?",                                  GlobalVars.saveSettings_reportAccountNumbers.get("input_includeLiabilityAccounts",  True))
        input_includeLoanAccounts = JCheckBox("include account type: Loan?",                                            GlobalVars.saveSettings_reportAccountNumbers.get("input_includeLoanAccounts",       True))

        input_includeBalance = JCheckBox("include account balance(s)?",                                                 GlobalVars.saveSettings_reportAccountNumbers.get("input_includeBalance",            True))
        input_includeGrandTotalBalance = JCheckBox("include grand total (of listed account's balances)?",               GlobalVars.saveSettings_reportAccountNumbers.get("input_includeGrandTotalBalance",  False))

        # balanceTypes = ["Balance", "Current Balance", "Cleared Balance"]
        balanceTypes = ["Balance", "Current Balance"]                                                                   # Cleared Balance is probably useless
        selectedBalanceType = GlobalVars.saveSettings_reportAccountNumbers.get("input_balanceType", "NOT FOUND")
        if selectedBalanceType not in balanceTypes: selectedBalanceType = balanceTypes[0]
        input_balanceType = JComboBox(balanceTypes)
        input_balanceType.setSelectedItem(selectedBalanceType)

        input_excludeNetWorthNO = JCheckBox("exclude accounts with shouldBeIncludedInNetWorth set to NO",               GlobalVars.saveSettings_reportAccountNumbers.get("input_excludeNetWorthNO",         False))
        input_includeZeroBalance = JCheckBox("include accounts with zero balance?",                                     GlobalVars.saveSettings_reportAccountNumbers.get("input_includeZeroBalance",        True))
        input_showZeroBalanceAsBlank = JCheckBox("show zero balances as blank?",                                        GlobalVars.saveSettings_reportAccountNumbers.get("input_showZeroBalanceAsBlank",    True))
        input_includeWhenDetailsMissing = JCheckBox("include when Account number/sort/routing details missing?",        GlobalVars.saveSettings_reportAccountNumbers.get("input_includeWhenDetailsMissing", True))
        input_includeHiddenHomePage = JCheckBox("include when 'Hide on summary page (if balance is zero) selected'?",   GlobalVars.saveSettings_reportAccountNumbers.get("input_includeHiddenHomePage",     True))
        input_includeInactive = JCheckBox("include inactive accounts?",                                                 GlobalVars.saveSettings_reportAccountNumbers.get("input_includeInactive",           False))
        input_includeComments = JCheckBox("include comments on report?",                                                GlobalVars.saveSettings_reportAccountNumbers.get("input_includeComments",           False))
        input_includeToolboxIgnore = JCheckBox("include when '%s' found inside comments?" %(TOOLBOX_IGNORE),            GlobalVars.saveSettings_reportAccountNumbers.get("input_includeToolboxIgnore",      False))
        input_includeCCExpiryDates = JCheckBox("include Credit Card expiry dates?",                                     GlobalVars.saveSettings_reportAccountNumbers.get("input_includeCCExpiryDates",      False))
        input_includeFileOpenDetails = JCheckBox("include Moneydance 'Master' password and confidential file details?", GlobalVars.saveSettings_reportAccountNumbers.get("input_includeFileOpenDetails",    False))

        lbl_secretText = JLabel("Enter secret text to include on this report (will not get saved anywhere):")
        input_includeSecretText = JTextArea(GlobalVars.saveSettings_reportAccountNumbers.get("input_includeSecretText", ""), 7, 0)
        # input_includeSecretText = JTextArea(GlobalVars.saveSettings_reportAccountNumbers.get("input_includeSecretText", ""))
        input_includeSecretText.setEditable(True)
        input_includeSecretText.setLineWrap(True)
        input_includeSecretText.setWrapStyleWord(False)
        input_includeSecretText.setOpaque(True)

        allAccountTypes = [input_includeBankAccounts, input_includeCCAccounts, input_includeInvestmentAccounts, input_includeAssetAccounts, input_includeLiabilityAccounts, input_includeLoanAccounts]

        userFilters = JPanel(GridBagLayout())

        onCol = 0
        onRow = 0
        li = ri = 5
        userFilters.add(JLabel("Select account types to include:"), GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west()); onRow += 1
        for comp in allAccountTypes:
            userFilters.add(comp, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                                   onRow += 1
        userFilters.add(JLabel(""), GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                                 onRow += 1
        userFilters.add(JLabel("Select report options:"), GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());           onRow += 1
        userFilters.add(input_includeBalance, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                       onRow += 1
        userFilters.add(input_balanceType, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                          onRow += 1
        userFilters.add(input_includeZeroBalance, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                   onRow += 1
        userFilters.add(input_showZeroBalanceAsBlank, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());               onRow += 1
        userFilters.add(input_includeGrandTotalBalance, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());             onRow += 1
        userFilters.add(input_excludeNetWorthNO, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                    onRow += 1
        userFilters.add(input_includeWhenDetailsMissing, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());            onRow += 1
        userFilters.add(input_includeHiddenHomePage, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                onRow += 1
        userFilters.add(input_includeInactive, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                      onRow += 1
        userFilters.add(input_includeToolboxIgnore, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                 onRow += 1
        userFilters.add(input_includeCCExpiryDates, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                 onRow += 1
        userFilters.add(input_includeComments, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                      onRow += 1
        userFilters.add(input_includeFileOpenDetails, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());               onRow += 1
        userFilters.add(JLabel("---"), GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                              onRow += 1
        userFilters.add(lbl_secretText, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(li).rightInset(ri).west());                             onRow += 1

        userFilters.add(input_includeSecretText, GridC.getc(onCol, onRow).wx(0.1).wy(0.0005).leftInset(li).rightInset(ri).west().fillboth());                      onRow += 1

        rowHeight = 24

        while True:
            options = ["EXIT", "REPORT"]
            jsp = MyJScrollPaneForJOptionPane(userFilters, 750, (rowHeight * (onRow+7)))
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       jsp,
                                                       _THIS_METHOD_NAME.upper(),
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))
            if userAction != 1:
                txt = "USER QUIT REPORT"
                setDisplayStatus(txt, "B")
                # myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            selectedAccountTypes = False
            for jcb in allAccountTypes:
                if jcb.isSelected():
                    selectedAccountTypes = True
                    break
            if not selectedAccountTypes: continue
            break

        includedAccountTypes = []
        if input_includeBankAccounts.isSelected():          includedAccountTypes.append(Account.AccountType.BANK)           # noqa
        if input_includeCCAccounts.isSelected():            includedAccountTypes.append(Account.AccountType.CREDIT_CARD)    # noqa
        if input_includeInvestmentAccounts.isSelected():    includedAccountTypes.append(Account.AccountType.INVESTMENT)     # noqa
        if input_includeAssetAccounts.isSelected():         includedAccountTypes.append(Account.AccountType.ASSET)          # noqa
        if input_includeLiabilityAccounts.isSelected():     includedAccountTypes.append(Account.AccountType.LIABILITY)      # noqa
        if input_includeLoanAccounts.isSelected():          includedAccountTypes.append(Account.AccountType.LOAN)           # noqa

        allAccounts = [acct for acct in AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), AcctFilter.ALL_ACCOUNTS_FILTER) if acct.getAccountType() in includedAccountTypes]
        allAccounts = sorted(allAccounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        iCountOFXAccounts = 0
        iCountMDPlusAccounts = 0

        output = "Report of accounts and bank/account number information:\n" \
                 " ------------------------------------------------------\n\n"

        date = datetime.datetime.today()
        baseCurr = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()
        output += "Base currency: %s %s(%s) - report as of: %s\n\n" %(baseCurr, baseCurr.getIDString(),baseCurr.getPrefix(), date.strftime(convertMDShortDateFormat_strftimeFormat()))

        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        colWidths = [13, 12, 10, 8, 5, 0, 0, 15, 13, 7, 9]

        grandTotalTxt = ""
        lFoundNWFlags = False

        for i in [0, 1]:

            grandTotal = 0

            if i == 1:
                colWidths[1] = 0        # Account Description should never get set...!?
                colWidths[3] = colWidths[3] if (input_includeBalance.isSelected() or input_includeGrandTotalBalance.isSelected()) else 0
                colWidths[9] = colWidths[9] if input_includeCCExpiryDates.isSelected() else 0
                colWidths[10] = colWidths[10] if input_includeComments.isSelected() else 0

                output += "%s %s %s %s %s   %s %s %s %s %s %s\n" %(
                    pad("Account name:", colWidths[0]),
                    pad("Description:", colWidths[1]),
                    pad("Bank name:", colWidths[2]),
                    rpad("Balance:", colWidths[3]),
                    pad("Cncy:", colWidths[4]),
                    pad("", colWidths[5]),
                    pad("", colWidths[6]),
                    pad("Account number:", colWidths[7]),
                    pad("Sort/Routing:", colWidths[8]),
                    pad("Expiry:", colWidths[9]),
                    pad("Comments:", colWidths[10])
                )

                output += "%s %s %s %s %s   %s %s %s %s %s %s\n" %(
                    pad("", colWidths[0], "-"),
                    pad("", colWidths[1], "-"),
                    pad("", colWidths[2], "-"),
                    rpad("", colWidths[3], "-"),
                    pad("", colWidths[4], "-"),
                    pad("", colWidths[5], " "),
                    pad("", colWidths[6], " "),
                    pad("", colWidths[7], "-"),
                    pad("", colWidths[8], "-"),
                    pad("", colWidths[9], "-"),
                    pad("", colWidths[10], "-")
                )

            lastAccountType = None

            for acct in allAccounts:

                if input_balanceType.getSelectedItem() == balanceTypes[1]:
                    xBal = acct.getRecursiveCurrentBalance() if acct.getAccountType() == Account.AccountType.INVESTMENT else acct.getCurrentBalance()       # noqa
                # elif input_balanceType.getSelectedItem() == balanceTypes[2]:
                #     xBal = acct.getRecursiveClearedBalance() if acct.getAccountType() == Account.AccountType.INVESTMENT else acct.getClearedBalance()       # noqa
                else:
                    xBal = acct.getRecursiveBalance() if acct.getAccountType() == Account.AccountType.INVESTMENT else acct.getBalance()                     # noqa

                if not input_includeInactive.isSelected():
                    if (acct.getAccountOrParentIsInactive()): continue

                if not input_includeHiddenHomePage.isSelected():
                    if (acct.getHideOnHomePage() and xBal == 0): continue

                if not input_includeZeroBalance.isSelected():
                    if xBal == 0: continue

                if input_excludeNetWorthNO.isSelected() and not acct.getBooleanParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, True):
                    continue

                if not input_includeToolboxIgnore.isSelected():
                    if TOOLBOX_IGNORE in acct.getComment().lower().strip(): continue

                hiddenTxt = ""
                if acct.getAccountOrParentIsInactive(): hiddenTxt += "I"
                if acct.getHideOnHomePage() and xBal == 0: hiddenTxt += "H"

                if not acct.getBooleanParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, True):
                    lFoundNWFlags = True
                    hiddenTxt += "N"

                depth = (acct.getDepth() - 1)
                extraPad = "" if (depth == 0) else " "
                accountNameTxt = ("." * depth) + extraPad + acct.getAccountName()

                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.CREDIT_CARD:
                    accountNumberTxt = acct.getCardNumber()
                elif acct.getAccountType() == Account.AccountType.INVESTMENT:
                    accountNumberTxt = acct.getInvestAccountNumber()
                else:
                    accountNumberTxt = acct.getBankAccountNumber()      # Not all account Types have account numbers!

                alt_account = acct.getParameter(ALTERNATIVE_ACCT_PARAM, "")
                if not StringUtils.isBlank(alt_account):
                    accountNumberTxt += " (alt: '%s')" %(alt_account)

                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.INVESTMENT:
                    bankNameTxt = acct.getInstitutionName()
                else:
                    bankNameTxt = acct.getBankName()

                currTxt = "" if acct.getCurrencyType() is baseCurr else acct.getCurrencyType().getIDString()
                commentsTxt = acct.getComment().strip().replace("\n", "|").replace(TOOLBOX_IGNORE, "")
                xBalTxt = "" if (xBal == 0 and input_showZeroBalanceAsBlank.isSelected()) else acct.getCurrencyType().formatFancy(xBal, MD_decimal)

                if not input_includeBalance.isSelected(): xBalTxt = ""

                grandTotalTxt = ""
                if input_includeGrandTotalBalance.isSelected():
                    grandTotal += CurrencyUtil.convertValue(xBal, acct.getCurrencyType(), baseCurr)
                    grandTotalTxt = baseCurr.formatFancy(grandTotal, MD_decimal)

                # noinspection PyUnresolvedReferences
                if (acct.getAccountType() == Account.AccountType.CREDIT_CARD and input_includeCCExpiryDates.isSelected()
                        and (str(acct.getCardExpirationMonth()) + "*" + str(acct.getCardExpirationYear()) != "1*2000")):
                    expiryTxt = "%s/%s" %(rpad(acct.getCardExpirationMonth(), 2, "0"), acct.getCardExpirationYear())
                else:
                    expiryTxt = ""

                if not input_includeWhenDetailsMissing.isSelected():
                    if (accountNumberTxt.strip() + acct.getOFXBankID().strip()) == "": continue

                downloadEnabledTxt = ""
                if acct.canDownloadTxns():
                    if not isMDPlusEnabledBuild():
                        if i > 0: iCountOFXAccounts += 1
                        downloadEnabledTxt = ">"
                    else:
                        for link in acct.getBankingServices():
                            service = link.getService()
                            if service is not None and service.canDownloadTransactionsForAccount(acct):
                                if service.isMoneydancePlusService():
                                    if "+" not in downloadEnabledTxt:
                                        if i > 0: iCountMDPlusAccounts += 1
                                        downloadEnabledTxt += "+"
                                else:
                                    if ">" not in downloadEnabledTxt:
                                        if i > 0: iCountOFXAccounts += 1
                                        downloadEnabledTxt += ">"

                if i == 0:
                    colWidths[0] = max(colWidths[0], len(accountNameTxt))
                    colWidths[1] = max(colWidths[1], len(acct.getAccountDescription()))
                    colWidths[2] = max(colWidths[2], len(bankNameTxt))
                    colWidths[3] = max(colWidths[3], len(xBalTxt), len(grandTotalTxt))
                    colWidths[4] = max(colWidths[4], len(currTxt))
                    colWidths[5] = max(colWidths[5], len(hiddenTxt))
                    colWidths[6] = max(colWidths[6], len(downloadEnabledTxt))
                    colWidths[7] = max(colWidths[7], len(accountNumberTxt))
                    colWidths[8] = max(colWidths[8], len(acct.getOFXBankID()))
                    colWidths[9] = max(colWidths[9], len(expiryTxt))
                    colWidths[10] = max(colWidths[10], len(commentsTxt))
                    continue

                if acct.getAccountType() != lastAccountType:
                    outputTxt = "%s ACCOUNTS:" %(acct.getAccountType())
                    output += "\n%s\n%s\n" %(outputTxt, "-"*len(outputTxt))
                    lastAccountType = acct.getAccountType()

                output += "%s %s %s %s %s   %s %s %s %s %s %s\n" %(
                    pad(accountNameTxt, colWidths[0]),
                    pad(acct.getAccountDescription(), colWidths[1]),
                    pad(bankNameTxt, colWidths[2]),
                    rpad(xBalTxt, colWidths[3]),
                    pad(currTxt, colWidths[4]),
                    pad(hiddenTxt, colWidths[5]),
                    pad(downloadEnabledTxt, colWidths[6]),
                    pad(accountNumberTxt, colWidths[7]),
                    pad(acct.getOFXBankID(), colWidths[8]),
                    pad(expiryTxt, colWidths[9]),
                    pad(commentsTxt, colWidths[10]))

        if input_includeGrandTotalBalance.isSelected():
            output += "%s %s %s %s\n" %(
                pad("", colWidths[0], " "),
                pad("", colWidths[1], " "),
                pad("", colWidths[2], " "),
                rpad("", colWidths[3], "=")
            )
            currTxt = "%s(%s)" %(baseCurr.getIDString(),baseCurr.getPrefix())

            output += "%s %s %s %s %s - (Grand Total of accounts shown)\n\n" %(
                pad("", colWidths[0]),
                pad("", colWidths[1]),
                pad("", colWidths[2]),
                rpad(grandTotalTxt, colWidths[3]),
                currTxt)

        output += "\n----------------------------------------------------------------------------------------------------------------------------\n"

        if input_includeBalance.isSelected() or input_includeGrandTotalBalance.isSelected():
            output += "**Balance type: %s\n" %(input_balanceType.getSelectedItem())

        if input_includeInactive.isSelected():
            output += "**KEY: 'I' = Account is Inactive...\n"

        if input_includeHiddenHomePage.isSelected():
            output += "**KEY: 'H' = Account is hidden on Home/Summary page...\n"

        if lFoundNWFlags:
            output += "**KEY: 'N' = Account is normally hidden from MD home screen NetWorth report...\n"

        if iCountOFXAccounts > 0 or iCountMDPlusAccounts > 0:
            if iCountMDPlusAccounts > 0:
                output += "**KEY: '+' = MD+ enabled account (%s in total)'\n" %(iCountMDPlusAccounts)

            if iCountOFXAccounts > 0:
                output += "**KEY: '>' = OFX enabled account (%s in total)'\n" %(iCountOFXAccounts)

            output += "\n WARNING: Take care when editing 'Account number' or 'Sort/Routing' on OFX enabled accounts (MD+ accounts should be OK to change)....!\n"

        if input_includeFileOpenDetails.isSelected():
            MD_enc = MD_REF.getCurrentAccounts().getEncryptionKey()
            MD_syn = MD_REF.getCurrentAccounts().getSyncEncryptionPassword()

            MD_enc = "<not set>" if (MD_enc is None or MD_enc == "") else "'%s'" %(MD_enc)
            MD_syn = "<not set>" if (MD_syn is None or MD_syn == "") else "'%s'" %(MD_syn)

            syncMethodTxt, color = getSyncMethodText()

            keyInfo = loadKeyFile()
            datasetKey = keyInfo.getString(u"key", None)
            datasetKey = "<?NOT FOUND?>" if (datasetKey is None or datasetKey == "") else "'%s'" %(datasetKey)

            licenseKey = "<not found>"
            licenseInfo = MD_REF.getLicenseInfo()
            if licenseInfo is not None and licenseInfo.isRegistered():
                licenseKey = "'%s'" %(licenseInfo.getLicenseKey())

            output += "\n----------------------------------------------------------------------------------------------------------------------------\n"
            output += "Confidential details needed to open Moneydance dataset:\n".upper()
            output += "- Location of dataset: '%s'\n" %(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath())
            output += "- This application: '%s' Version: %s(%s) - License key: %s\n" %(find_the_program_install_dir(), MD_REF.getVersion(), MD_REF.getBuild(), licenseKey)
            output += "- Master password used to open this dataset: %s\n" %(MD_enc)
            output += "- Syncing: %s - Sync password: %s\n" %(syncMethodTxt, MD_syn)
            output += "- Encrypted (secret) cryptographic KEY used for dataset encryption seed:       %s\n" %(datasetKey)
            if GlobalVars.EXTRA_CODE_INITIALISED:
                output += "- Actual (secret) decrypted cryptographic-key(s) used for encryption: Dataset: '%s', Sync: '%s'\n" %(advanced_show_encryption_keys(justReturnKeys=True))
            output += "(review Menu: 'Advanced Options' > 'Show your encryption keys, and the Moneydance encryption methodology' for more details)\n"


        secretTxt = input_includeSecretText.getText()
        if not StringUtils.isBlank(secretTxt):
            output += "\n\n" \
                      "**********************************\n"
            output += "SECRET TEXT:\n" \
                      "%s\n" %(secretTxt)
            output += "**********************************\n"
        del secretTxt

        output += "\n<END>"

        GlobalVars.saveSettings_reportAccountNumbers["input_includeBankAccounts"]           = input_includeBankAccounts.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeCCAccounts"]             = input_includeCCAccounts.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeInvestmentAccounts"]     = input_includeInvestmentAccounts.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeAssetAccounts"]          = input_includeAssetAccounts.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeLiabilityAccounts"]      = input_includeLiabilityAccounts.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeLoanAccounts"]           = input_includeLoanAccounts.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeBalance"]                = input_includeBalance.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeGrandTotalBalance"]      = input_includeGrandTotalBalance.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_balanceType"]                   = input_balanceType.getSelectedItem()
        GlobalVars.saveSettings_reportAccountNumbers["input_excludeNetWorthNO"]             = input_excludeNetWorthNO.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeZeroBalance"]            = input_includeZeroBalance.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_showZeroBalanceAsBlank"]        = input_showZeroBalanceAsBlank.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeWhenDetailsMissing"]     = input_includeWhenDetailsMissing.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeHiddenHomePage"]         = input_includeHiddenHomePage.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeInactive"]               = input_includeInactive.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeComments"]               = input_includeComments.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeToolboxIgnore"]          = input_includeToolboxIgnore.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeCCExpiryDates"]          = input_includeCCExpiryDates.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeFileOpenDetails"]        = input_includeFileOpenDetails.isSelected()
        GlobalVars.saveSettings_reportAccountNumbers["input_includeSecretText"]             = input_includeSecretText.getText()

        QuickJFrame(_THIS_METHOD_NAME.upper(), output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()


    def view_shouldBeIncludedInNetWorth_settings():
        if MD_REF.getCurrentAccountBook() is None: return

        _THIS_METHOD_NAME = "View Accounts' shouldBeIncludedInNetWorth() settings"

        output = "\n" \
                 "%s:\n" \
                 " ======================================================\n\n" %(_THIS_METHOD_NAME.upper())

        output += "Moneydance predefines rules to include/exclude Accounts in the Home Summary Page NetWorthView widget, & also the Titlebar NW instant graph\n" \
                  "- If the Account or Parent is Inactive, then it's excluded\n" \
                  "- ROOT and Income/Expense Categories are excluded\n" \
                  "- Then it checks for a hidden Account setting >> You can set this in Toolbox Update Mode\n" \
                  "- You cannot force include an account into these, you can only force exclude accounts....\n" \
                  "\n" \
                  "Other NetWorth rules for information:\n" \
                  "- NW Reports / Graphs are based on transactions up to the date you specify; uses Price history data for balance valuations\n" \
                  "- The Top title bar NW Graph's cutoff date can be changed: 'All Dates' includes future Balances; uses Price history data for balance valuations\n" \
                  "- The Home Screen View NW widget total ALWAYS uses Current Balance(s) - so future balances are excluded; uses Current Price\n" \
                  "\n\n"

        output += "%s %s %s %s\n" %(pad("Account Name",50),
                                    pad("Account Type",20),
                                    pad("shouldBeIncludedInNetWorth()",30),
                                    pad("Override Setting",20))

        output += "%s %s %s %s\n" %("-"*50,
                                    "-"*20,
                                    "-"*30,
                                    "-"*20)

        output += "\n"

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(25))
        allAccounts = sorted(allAccounts, key=lambda x: (x.getAccountType(), x.getFullAccountName().upper()))

        for acct in allAccounts:
            output += "%s %s %s %s\n" %(pad(acct.getFullAccountName(),50),
                                        pad(str(acct.getAccountType()),20),
                                        pad(str(acct.shouldBeIncludedInNetWorth()),30),
                                        ("NOT SET" if (not acct.getParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, None)) else (str(acct.getBooleanParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, True)))))
        output += "\n<END>"

        txt = "%s: - Displaying NetWorth Settings" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "B")
        QuickJFrame(_THIS_METHOD_NAME.upper(), output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def edit_shouldBeIncludedInNetWorth_settings():
        if MD_REF.getCurrentAccountBook() is None: return

        _THIS_METHOD_NAME = "EDIT an Account's shouldBeIncludedInNetWorth() setting"

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(25))
        allAccounts = sorted(allAccounts, key=lambda x: (x.getAccountType(), x.getFullAccountName().upper()))

        newAccounts = []
        for acct in allAccounts: newAccounts.append(StoreAccountList(acct))
        del allAccounts

        lPresentedBackupDisclaimer = False
        iCountChanges = 0

        while True:

            selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Acct edit the shouldBeIncludedInNetWorth() setting",
                                                       _THIS_METHOD_NAME.upper(),
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       newAccounts,
                                                       None)
            if not selectedAcct: break

            selectedAcct = selectedAcct.obj       # type: Account                                                       # noqa

            currentNWsettingBool = selectedAcct.getBooleanParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, True)

            options = ["YES - Include", "NO - Exclude"]
            if currentNWsettingBool:
                current = options[0]
            else:
                current = options[1]

            selectedIncludeInNW = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select whether to include/exclude this account in the default NW Home Screen Widget & Titlebar Graph",
                                                       _THIS_METHOD_NAME.upper()+" for: %s" %(selectedAcct.getAccountName()),
                                                       JOptionPane.WARNING_MESSAGE,
                                                       getMDIcon(None),
                                                       options,
                                                       current)
            if not selectedIncludeInNW: continue

            if not lPresentedBackupDisclaimer:
                if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "Change 'include in NW' to '%s'?" %(selectedIncludeInNW)):
                    return
                lPresentedBackupDisclaimer = True

            if options.index(selectedIncludeInNW) == 0:
                # Include selected
                selectedAcct.setParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, None)
            else:
                # Exclude selected
                selectedAcct.setParameter(GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, False)

            selectedAcct.syncItem()
            iCountChanges += 1

            txt = "%s: Account: '%s' Parameter: '%s' set to %s" %(_THIS_METHOD_NAME, selectedAcct, GlobalVars.Strings.MD_KEY_PARAM_APPLIES_TO_NW, selectedIncludeInNW)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            logToolboxUpdates("edit_shouldBeIncludedInNetWorth_settings", txt)
            myPopupInformationBox(toolbox_frame_,txt)

            continue

        if iCountChanges:
            txt = "%s: Updated the NW setting in %s Account(s)!" %(_THIS_METHOD_NAME, iCountChanges)
        else:
            txt = "%s: No Accounts changed" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

    def zero_bal_categories(lFix):
        if lFix:
            myPrint("DB","User requested to Inactivate Zero Balance Categories!")

        if lFix:
            myPrint("B", "Script running to Analyse your Active Categories for Zero Balance...............")
        else:
            myPrint("B", "Script running to de-activate your Categories with Zero Balance...............")

        if MD_REF.getCurrentAccountBook() is None: return

        output = ""
        output += "Analysing your categories for Zero Balances....\n\n"

        baseCurr = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()


        # ==========================================
        # Search reminders first
        root = MD_REF.getCurrentAccountBook()
        rems = root.getReminders().getAllReminders()

        listOfRems = {}

        for rem in rems:
            remType = rem.getReminderType()  # NOTE or TRANSACTION

            if str(remType) != 'TRANSACTION': continue

            lastDate = rem.getLastDateInt()
            if not lastDate:
                pass    # No end date set, so proceed
            else:
                remDate = rem.getNextOccurance(lastDate)    # Stop at enddate
                if not remDate: continue    # Expired so skip

                if not remDate >= DateUtil.getStrippedDateInt(): continue
                # Right, got one!

            desc = rem.getDescription()

            txnParent = rem.getTransaction()

            for index2 in range(0, int(txnParent.getOtherTxnCount())):
                splitDesc = txnParent.getOtherTxn(index2).getDescription()
                acct = txnParent.getAccount()
                cat = txnParent.getOtherTxn(index2).getAccount()
                catValue = baseCurr.getDoubleValue(txnParent.getOtherTxn(index2).getValue()) * -1

                if catValue:
                    theReminder = [acct, cat, catValue, desc, splitDesc]
                    listOfRems[cat] = theReminder

        # ==========================================


        # Now the Categories
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(4))    # This returns active and inactive accounts
        accounts = sorted(accounts, key=lambda x: (x.getAccountType(), safeStr(x.getFullAccountName()).upper()))

        categoriesToInactivate = {}

        output += "LISTING ACTIVE CATEGORIES WITH ZERO BALANCES:\n\n"

        # Run 1 - get the initial list
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0
                    # and cat.getRecursiveReconcilingBalance() == 0
            ):
                if listOfRems.get(cat):     # Found a reminder!
                    pass
                else:
                    categoriesToInactivate[cat] = True

        # Run 2 - filter out parents.... if we are retaining any sub cats
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if not categoriesToInactivate.get(cat):     # Select categories that we are not deactivating

                # Look for its parents in the list of Cats to deactivate
                parentCats = cat.getPath()
                for theParent in parentCats:
                    if categoriesToInactivate.get(theParent):   # Found a parent - so don't deactivate it!
                        categoriesToInactivate[theParent] = False

        last = None
        iCountForInactivation = 0
        sortedCategoriesToInactivate=sorted(list(categoriesToInactivate), key=lambda x: (x.getAccountType(),x.getFullAccountName()) )

        # for cat in categoriesToInactivate.keys():
        for cat in sortedCategoriesToInactivate:
            if categoriesToInactivate.get(cat):
                iCountForInactivation += 1

                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "Category: %s has Zero Balances\n" % pad(cat.getFullAccountName(), 100)
            else:
                output += "Category: %s ** But cannot be deactivated as it's the Parent of an active Category **\n" % pad(cat.getFullAccountName(),100)


        output += " -------------------------------------------------------------------------------------------------\n"
        output += ("You have %s categories with Zero Balances - these can be made Inactive using Update Mode......\n" % iCountForInactivation).upper()
        output += " --------------------------------------------------------------------------------------------------\n\n"

        output += "LISTING ACTIVE CATEGORIES WITH ZERO BALANCES - BUT WITH FUTURE REMINDERS PRESENT:\n\n"

        output += pad("Category Name", 78)
        output += " " + pad("Account", 20)
        output += " " + pad("Reminder Description", 35)
        output += " " + rpad("Rem Amount", 12)
        output += " " + pad("Split Desc", 35)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        last = None
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0
                    # and cat.getRecursiveReconcilingBalance() == 0
            ):
                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                foundRem = listOfRems.get(cat)
                if foundRem:    # Found a reminder!
                    output += "Category: %s Reminder Details: " % pad(cat.getFullAccountName(),50)
                    output += pad(foundRem[0].getAccountName(),20)+" "
                    output += pad(foundRem[3],35)+" "
                    output += rpad(foundRem[2],12)+" "
                    output += pad(foundRem[4],35)+"\n"

        output += " ----------------------------------------------------------------------------------------------------------\n"


        output += "\n\nLISTING INACTIVE CATEGORIES WITH ZERO BALANCES:\n\n"

        ii=0
        last = None
        for cat in accounts:
            if not cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0 ):  # and cat.getRecursiveReconcilingBalance() == 0


                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "Inactive Category: %s has Zero Balances\n" % pad(cat.getFullAccountName(), 100)
                ii += 1

        if not ii:
            output += "<NONE FOUND>\n\n"

        output += " -------------------------------------------------------------------------------------------------\n"

        output += "LISTING ACTIVE CATEGORIES WITH BALANCES:\n\n"

        output += pad("Category Name", 85)
        output += " " + rpad("Balance", 12)
        # output += " " + rpad("ClrdBal", 12)
        # output += " " + rpad("ConfBal", 12)
        output += " " + rpad("CurrBal", 12)
        # output += " " + rpad("RecBal", 12)
        output += " " + rpad("RcrsBal", 12)
        # output += " " + rpad("RcrsClrdBal", 12)
        output += " " + rpad("RcrsCurrBal", 12)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        ii = 0
        last = None
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if not (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0):     # and cat.getRecursiveReconcilingBalance() == 0
                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "%s" % pad(cat.getFullAccountName(), 85)

                mult = 1
                # noinspection PyUnresolvedReferences
                if cat.getAccountType() == Account.AccountType.EXPENSE: mult = -1

                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserClearedBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserConfirmedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserReconcilingBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserClearedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserReconcilingBalance()*-1), 12)
                output += "\n"
                ii+=1
        if not ii:
            output += "<NONE FOUND>\n\n"

        output += " ---------------------------------------------------------------------------\n\n"

        output += "LISTING INACTIVE CATEGORIES WITH BALANCES:\n\n"

        output += pad("Category Name", 85)
        output += " " + rpad("Balance", 12)
        # output += " " + rpad("ClrdBal", 12)
        # output += " " + rpad("ConfBal", 12)
        output += " " + rpad("CurrBal", 12)
        # output += " " + rpad("RecBal", 12)
        output += " " + rpad("RcrsBal", 12)
        # output += " " + rpad("RcrsClrdBal", 12)
        output += " " + rpad("RcrsCurrBal", 12)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        ii = 0
        last = None
        for cat in accounts:
            if not cat.getAccountOrParentIsInactive(): continue
            if not (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0):       # and cat.getRecursiveReconcilingBalance() == 0

                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "%s" % pad(cat.getFullAccountName(), 85)

                mult = 1
                # noinspection PyUnresolvedReferences
                if cat.getAccountType() == Account.AccountType.EXPENSE: mult = -1

                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserClearedBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserConfirmedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserReconcilingBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserClearedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserReconcilingBalance()*mult), 12)
                output += "\n"
                ii += 1

        if not ii:
            output += "<NONE FOUND>\n\n"

        output += " ---------------------------------------------------------------------------\n\n"

        output += "\nLEGEND:\n"
        output += "** NOTE: The Balances shown on a Parent Category in any section may not be the sum of its Child Categories shown in the same section.\n"
        output += "         The calculation matches the Moneydance Tools>Categories method and will include the balances(s) from all its Child Categories whether active, inactive or otherwise....\n\n"
        output += "Balance = Account Balance\n"
        # output += "ClrdBal = Cleared Balance (Normally Zero on a Category). Balance excluding uncleared or reconciling txns\n"
        # output += "ConfBal = Confirmed Balance (The Balance less any unconfirmed Online / Downloaded Bank txns\n"
        output += "CurrBal = Current Balance\n"
        # output += "RecBal = Reconciling Balance (Normally Zero on a Category)\n"
        output += "RcrsBal = Recursive (through all sub categories) Account Balance (Note: may contain balances from inactive sub-categories as per Moneydance)\n"
        # output += "RcrsClrdBal = Recursive (through all sub categories) Cleared Balance (Normally Zero on a Category)\n"
        output += "RcrsCurrBal = Recursive (through all sub categories) Current Balance (Note: may contain balances from inactive sub-categories as per Moneydance)\n"
        # output += "RcrsRecBal = Recursive (through all sub categories) Reconciling Balance (Normally Zero on a Category)\n"
        output += " ---------------------------------------------------------------------------\n\n"
        output += "<END>"

        if lFix:
            output += "\nDISCLAIMER: Author takes no responsibility if you decide to execute the Inactivate Zero Balance Category fix function!\n"

        if not lFix:
            jif = QuickJFrame("View your Active Categories with Zero Balances....", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        else:
            jif = QuickJFrame("View your Active Categories with Zero Balances.... CLICK OK WHEN READY TO PROCEED", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        myPrint("J", "There are %s Active Categories with Zero Balances that could be Inactivated!" % iCountForInactivation)

        if not lFix:
            txt = "VIEW ZERO BALANCE CATEGORIES: YOU HAVE %s Zero Balance Categories..." %(iCountForInactivation)
            setDisplayStatus(txt, "DG")
            myPopupInformationBox(jif, txt, "ZERO BALANCE CATEGORIES", JOptionPane.INFORMATION_MESSAGE)
            return

        if iCountForInactivation < 1:
            txt = "FIX ZERO BALANCE CATEGORIES: You have no Zero Balance Categories to fix - no fixes applied..."
            setDisplayStatus(txt, "DG")
            myPopupInformationBox(jif, txt, "ZERO BALANCE CATEGORIES", JOptionPane.INFORMATION_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(jif, "FIX - INACTIVATE ZERO BALANCE CATEGORIES", "Inactivate these %s Zero Balance Categories?" %(iCountForInactivation)):
            return

        # OK - so we are fixing...!
        myPrint("B", ">> User selected to Inactivate %s Zero Balance Categories!?" %(iCountForInactivation))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for cat in categoriesToInactivate.keys():
            if categoriesToInactivate.get(cat):
                myPrint("B", "Cat: " + cat.getFullAccountName() + " with Zero Balances, Set to INACTIVE!")
                cat.setAccountIsInactive(True)
                cat.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "FIX - %s Categories with Zero Balances made Inactive as requested!" %(iCountForInactivation)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("zero_bal_categories", txt)
        play_the_money_sound()
        myPopupInformationBox(jif, txt, "INACTIVATE ZERO BALANCE CATEGORIES", JOptionPane.WARNING_MESSAGE)

    def fix_account_parent():

        # fix_account_parent.py (and old check_root_structure.py)
        myPrint("B", "Diagnosing INVALID Parent Accounts....")

        book = MD_REF.getCurrentAccountBook()
        root = book.getRootAccount()
        allAccounts = book.getItemsWithType(Account.SYNCABLE_TYPE_VALUE)


        def validate_path(check_acct):
            _acct = check_acct
            iterations = 0
            while True:
                # noinspection PyUnresolvedReferences
                if _acct.getAccountType() == Account.AccountType.ROOT:      return True
                if _acct is None:                                           return False
                if iterations > 100:                                        return False
                iterations += 1
                _acct = _acct.getParentAccount()
                continue


        output = "FIX ACCOUNT(s)' INVALID PARENT ACCOUNTS:\n" \
                 " ========================================\n\n"

        def check_fix_accounts(lFix=False):

            iErrors = 0
            textFixed = ""

            for acct in allAccounts:

                # skip root
                # noinspection PyUnresolvedReferences
                if acct == root or acct.getAccountType() == Account.AccountType.ROOT: continue

                parent = acct.getParentAccount()
                if ((parent is None or parent == acct)
                        or (parent is not None and parent != root and not validate_path(acct))):
                    iErrors += 1
                    if lFix:
                        myPrint("B","Resetting parent account for %s to root" %(acct.getAccountName()))
                        textFixed+=("Resetting parent account for %s to root\n" %(acct.getAccountName()))
                        acct.setParentAccount(root)
                        acct.syncItem()
                    else:
                        myPrint("B", "@@ ERROR - NEEDS RESET - Account: %s\n" % acct.getAccountName())
                        textFixed+="NEEDS RESET - Account: %s\n" % acct.getAccountName()

            return iErrors, textFixed

        iCountErrors, x =  check_fix_accounts(lFix=False)
        output += x

        if iCountErrors < 1:
            txt = "'FIX: Account(s)'s Invalid Parent - CONGRATULATIONS - I found no Invalid parents......."
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        myPrint("B","FIX - Account(s)' Invalid Parent Accounts - found %s errors..." %(iCountErrors))

        jif=QuickJFrame("VIEW ACCOUNT(s) WITH INVALID PARENT ACCOUNTS", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        if not confirm_backup_confirm_disclaimer(jif, "FIX ACCOUNT(S)' INVALID PARENTS","FIX %s Acct(s)'s Invalid Parent Accts?" %(iCountErrors)):
            return

        jif.dispose()       # already within the EDT
        myPrint("B", "User accepted disclaimer to FIX Account(s)' Invalid Parent Accounts. Proceeding.....")

        output += "\n\nRUNNING FIX ON PARENT ACCOUNTS\n" \
                  " -------------------------------\n\n"

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes...
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        iCountErrors, x = check_fix_accounts(lFix=True)
        output += x
        output += "\n<END>"

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)
        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccountBook().notifyAccountModified(root)

        txt = "FIXED %s invalid Parent Accounts" %(iCountErrors)
        setDisplayStatus(txt, "DG"); myPrint("B", txt)
        logToolboxUpdates("fix_account_parent", txt)

        jif = QuickJFrame("VIEW ACCOUNT(s) WITH INVALID PARENT ACCOUNTS", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        play_the_money_sound()
        myPopupInformationBox(jif,txt, "FIX INVALID PARENT ACCOUNTS", JOptionPane.WARNING_MESSAGE)

    def fix_root_account_name():
        bookName = MD_REF.getCurrentAccountBook().getName().strip()
        root = MD_REF.getCurrentAccountBook().getRootAccount()
        rootName = root.getAccountName().strip()

        if rootName == bookName:
            myPopupInformationBox(toolbox_frame_,
                                  "The name of your Root Account is already the same as your Dataset(or 'Book'): %s" % (bookName),
                                  "RENAME ROOT ACCOUNT",
                                  JOptionPane.INFORMATION_MESSAGE)
            txt = "No changed applied as your Root Account name is already the same as your Dataset ('Book') name: %s" %(bookName)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B", "User requested to fix Root Account Name")
        myPrint("B", "Dataset's ('Book') Name: ", bookName)
        myPrint("B", "Root's Account Name: ", rootName)

        MyPopUpDialogBox(toolbox_frame_,
                         "RENAME ROOT ACCOUNT",
                         "Your Dataset ('book') name is: %s (this is the name that will be used)\nYour Root Account name is: %s" %(bookName,rootName),
                         theTitle="RENAME ROOT ACCOUNT").go()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "RENAME ROOT ACCOUNT", "rename your Root Account to: %s?" %(bookName)):
            return

        myPrint("B", "User accepted disclaimer to reset Root Account Name. Proceeding.....")
        # Flush all in memory settings to config.dict file on disk
        MD_REF.savePreferences()

        root.setAccountName(bookName)
        root.syncItem()

        MD_REF.getCurrentAccountBook().notifyAccountModified(root)

        txt = "Root Account Name changed to : %s" %(bookName)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("fix_root_account_name", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, "RENAME ROOT", JOptionPane.WARNING_MESSAGE)

    # noinspection PyUnresolvedReferences
    def force_change_account_type():
        # set_account_type.py
        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change an Account's Type?",
                             theTitle="FORCE CHANGE TYPE",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have have created an Account with the wrong Type\n"
                                        "This fix will NOT attempt to check that the Acct has Txns that are valid in the new Account Type.\n"
                                        "It simply changes the Type set on the account to the new Type.\n"
                                        "You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change an Account's type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to FORCE change its Type",
                                                      "FORCE CHANGE ACCOUNT's TYPE",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList
        if not selectedAccount:
            txt = "User did not Select an Account to FORCE change its Type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        if selectedAccount.getAccountType() == Account.AccountType.ROOT:
            if not myPopupAskQuestion(toolbox_frame_,"FORCE CHANGE ACCOUNT TYPE","THIS ACCOUNT IS ROOT (SPECIAL). DO YOU REALLY WANT TO CHANGE IT'S TYPE (Normally a bad idea!) ?", theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "User Aborted change of Root's Account Type (phew!) - no changes made"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

        possTypes = Account.AccountType.values()
        possTypes.remove(Account.AccountType.ROOT)
        possTypes.remove(Account.AccountType.SECURITY)
        if selectedAccount.getAccountType() in possTypes:
            possTypes.remove(selectedAccount.getAccountType())

        selectedType = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the new Account Type",
                                                   "FORCE CHANGE ACCOUNT's TYPE",
                                                   JOptionPane.WARNING_MESSAGE,
                                                   getMDIcon(None),
                                                   possTypes,
                                                   None)  # type: Account.AccountType
        if not selectedType:
            txt = "User did not Select a new Account Type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if selectedType == Account.AccountType.ROOT:
            if not myPopupAskQuestion(toolbox_frame_,"FORCE CHANGE ACCOUNT TYPE","DO YOU REALLY WANT TO CHANGE TO ROOT (Normally a bad idea!)?", theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "User Aborted change Account to type Root (phew!) - no changes made"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change this Account's Type?",
                             theTitle="FORCE CHANGE TYPE",
                             theMessage="Account: %s\n"
                                        "Old Type: %s\n"
                                        "New Type: %s\n"
                                        %(selectedAccount.getFullAccountName(), selectedAccount.getAccountType(),selectedType),  # noqa
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User aborted the FORCE change to an Account's type - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE TYPE", "FORCE CHANGE ACCOUNT %s TYPE to %s" %(selectedAccount.getFullAccountName(),selectedType)):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Type of Account: %s from: %s to %s - APPLYING UPDATE NOW...."
                %(selectedAccount.getFullAccountName(),selectedAccount.getAccountType(),selectedType))                  # noqa

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        selectedAccount.setAccountType(selectedType)                                                                    # noqa
        selectedAccount.syncItem()                                                                                      # noqa

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccountBook().notifyAccountModified(root)

        txt = "The Account: %s has been changed to Type: %s - PLEASE REVIEW & THEN MANUALLY RESTART MD" %(selectedAccount.getAccountName(),selectedAccount.getAccountType())  # noqa
        setDisplayStatus(txt, "R")
        logToolboxUpdates("force_change_account_type", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

    def force_change_account_cat_currency():
        # force_change_account_currency.py
        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change an Account's / Category's Currency?",
                             theTitle="FORCE CHANGE CURRENCY",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have duplicated Currencies and you want to move\n"
                                        "transactions from one account to another, but the system prevents you unless they are the same currency\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "set on the account / category to the new currency. You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change an Account's / Category's currency - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        currencies = []
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                       # noqa
                currencies.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account / Category to FORCE change currency",
                                                      "FORCE CHANGE ACCOUNT's / CATEGORY's CURRENCY",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList
        if not selectedAccount:
            txt = "User did not Select an Account / Category to FORCE change currency - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account
        if isinstance(selectedAccount, Account): pass

        # noinspection PyUnresolvedReferences
        currencies.remove(selectedAccount.getCurrencyType())

        selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Old Currency: %s >> Select the new currency for the account/Category" %(selectedAccount.getCurrencyType()),                    # noqa
                                                       "FORCE CHANGE ACCOUNT's / CATEGORY's CURRENCY",
                                                       JOptionPane.ERROR_MESSAGE,
                                                       getMDIcon(None),
                                                       currencies,
                                                       None)  # type: CurrencyType
        if not selectedCurrency:
            txt = "User did not Select an new currency for Account / Category FORCE change - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change this Account's / Category's Currency?",
                             theTitle="FORCE CHANGE CURRENCY",
                             theMessage="Account: %s\n"
                                        "Old Currency: %s\n"
                                        "New Currency: %s\n"
                                        %(selectedAccount.getFullAccountName(), selectedAccount.getCurrencyType(),selectedCurrency),
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User aborted the FORCE change to an Account's / Category's currency - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE CURRENCY", "FORCE CHANGE ACCOUNT / CATEGORY %s CURRENCY" %(selectedAccount.getFullAccountName())):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Currency of Account/Category: %s from: %s to %s - APPLYING UPDATE NOW...."
                %(selectedAccount.getFullAccountName(),selectedAccount.getCurrencyType(),selectedCurrency))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        selectedAccount.setCurrencyType(selectedCurrency)
        selectedAccount.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccountBook().notifyAccountModified(root)

        txt = "Account/Category: %s has been changed to Curr: %s - PLEASE REVIEW & THEN MANUALLY RESTART MD WHEN FINISHED"\
              %(selectedAccount.getAccountName(),selectedAccount.getCurrencyType())
        setDisplayStatus(txt, "R")
        logToolboxUpdates("force_change_account_cat_currency", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

    def force_change_all_accounts_categories_currencies():
        # force_change_all_currencies.py
        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change ALL Accounts' / Categories' Currencies?",
                             theTitle="FORCE CHANGE ALL ACCOUNTS' / CATEGORYS' CURRENCIES",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have a missing currency, or need to change them all\n"
                                        "This fix will not touch the ROOT account nor Security sub-accounts (which are stocks/shares)\n"
                                        "... it will include categories, along with all other account types...\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "set on all accounts to the new currency. You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change ALL Accounts' / Categories' currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        currencies = []
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                       # noqa
                currencies.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))

        if len(currencies) < 1:
            myPrint("B", "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES - Creating new currency record!")
            selectedCurrency = CurrencyType(book.getCurrencies())       # Creates a new CT object
            selectedCurrency.setEditingMode()
            selectedCurrency.setName("NEW CURRENCY - PLEASE EDIT ME LATER")
            selectedCurrency.setIDString("AAA")
            selectedCurrency.setDecimalPlaces(2)
            selectedCurrency.syncItem()
            myPrint("B", "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES - Creating new currency: %s" %(selectedCurrency))
            myPopupInformationBox(toolbox_frame_,"FYI - I have created a new Currency %s for you (Edit it later)" %(selectedCurrency),
                                  "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES")
        else:
            selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select a currency to assign to *ALL* accounts/categories",
                                                           "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES",
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedCurrency:
            txt = "User did not Select a new currency for FORCE change ALL Accounts' / Categories' Currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES", "FORCE CHANGE ALL %s ACCTS' / CATS' CURRENCIES TO %s?" %(len(accounts),selectedCurrency)):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Currency of ALL %s Accounts / Categories to %s - APPLYING UPDATE NOW...."
                %(len(accounts),selectedCurrency))     # noqa

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        accountsChanged = 0
        for account in accounts:
            if account.getAccountType() == Account.AccountType.ROOT:                                                    # noqa
                continue
            if account.getAccountType() == Account.AccountType.SECURITY:                                                # noqa
                continue
            if account.getCurrencyType() == selectedCurrency:
                continue

            myPrint("B","Setting account / category %s to currency %s" %(account, selectedCurrency))
            account.setCurrencyType(selectedCurrency)
            account.syncItem()
            accountsChanged += 1

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccountBook().notifyAccountModified(root)

        txt = "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES: %s Accts / Cats changed to curr: %s - MONEYDANCE WILL NOW RESTART - PLEASE REVIEW RESULTS" %(accountsChanged,selectedCurrency)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("force_change_all_accounts_categories_currencies", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def force_change_accounts_cats_from_to_currency():
        _THIS_METHOD_NAME = "FORCE CHANGE ACCTs / CATs FROM / TO CURRENCY"

        # force_change_all_currencies.py
        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change Accounts / Categories FROM / TO Currency?",
                             theTitle=_THIS_METHOD_NAME,
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenarios is where you have a duplicate currency and want to change to the right one\n"
                                        "PLEASE ENSURE THE FROM's and TO's Currency rates are essentially the same before you start!\n"
                                        "This fix will not touch the ROOT account nor Security sub-accounts (which are stocks/shares)\n"
                                        "... it will include categories, along with all other account types...\n"
                                        "You will be asked if you also want to include Security records on the from/to switch to...\n"
                                        "... (you can switch security records manually if you prefer)...\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "...set on all accounts to the new currency. You should carefully review your data afterwards and revert\n"
                                        "...to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to %s - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        includeSecurities = myPopupAskQuestion(toolbox_frame_, _THIS_METHOD_NAME.upper(),  "Include Security records in the FROM/TO currency switch too?")

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(19))
        allAccounts = sorted(allAccounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        currencies = []
        securities = []
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                       # noqa
                currencies.append(c)
            if c.getCurrencyType() == CurrencyType.Type.SECURITY:                                                       # noqa
                securities.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))
        securities = sorted(securities, key=lambda sort_x: (sort_x.getName().upper()))

        if len(currencies) < 2:
            txt = "%s: Not enough currencies exist - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedFromCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the FROM currency (that you want to remove from accts/cats)",
                                                           _THIS_METHOD_NAME,
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedFromCurrency:
            txt = "User did not Select the old FROM currency for '%s' - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if isinstance(selectedFromCurrency, CurrencyType): pass

        currencies.remove(selectedFromCurrency)

        selectedToCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the TO currency (that you store on your accts/cats)",
                                                           _THIS_METHOD_NAME,
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedToCurrency:
            txt = "User did not Select the new TO currency for '%s' - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if isinstance(selectedToCurrency, CurrencyType): pass

        replaceAccts = []
        for acct in allAccounts:
            if acct.getCurrencyType() == selectedFromCurrency:
                replaceAccts.append(acct)

        replaceSecurities = []
        if includeSecurities:
            for sec in securities:
                if sec.getRelativeCurrency() == selectedFromCurrency:
                    replaceSecurities.append(sec)

        if (len(replaceAccts) + len(replaceSecurities)) < 1:
            txt = "%s: No accounts / Securities found with the old currency: %s - no changes made" %(_THIS_METHOD_NAME, selectedFromCurrency)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "SWITCH FROM CURRENCY %s TO %s ON %s ACCTS / CATS & %s SECURITIES?"
                                                                                    %(selectedFromCurrency, selectedToCurrency, len(replaceAccts), len(replaceSecurities))):
            return

        myPrint("B","%s: @@ User requested to replace currency %s with %s on %s Accounts/Categories & %s Securities - APPLYING UPDATE NOW...."
                %(_THIS_METHOD_NAME, selectedFromCurrency, selectedToCurrency, len(replaceAccts), len(replaceSecurities)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for acct in replaceAccts:
            myPrint("B","Setting account / category '%s' currency to: %s" %(acct, selectedToCurrency))
            acct.setCurrencyType(selectedToCurrency)
            acct.syncItem()

        for sec in replaceSecurities:
            if sec.getRelativeCurrency() == selectedFromCurrency:
                myPrint("B","Setting security '%s' relative currency to: %s" %(sec, selectedToCurrency))
                sec.setRelativeCurrency(selectedToCurrency)
                sec.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccountBook().notifyAccountModified(root)

        txt = ("%s: %s Accts / Cats, and %s Securities, changed from curr: %s to %s - MD WILL RESTART - PLEASE REVIEW RESULTS"
               %(_THIS_METHOD_NAME, len(replaceAccts), len(replaceSecurities), selectedFromCurrency, selectedToCurrency))

        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("force_change_accounts_cats_from_to_currency", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def toggle_security_zero_shares_inactive():
        _THIS_METHOD_NAME = "TOGGLE SECURITY ZERO SHARES INACTIVE"
        output = "%s:\n" \
                 " ===================================\n\n" %(_THIS_METHOD_NAME)

        class TSZSIAcctFilter(AcctFilter):
            def __init__(self): pass
            def matches(self, _acct):
                if _acct.getAccountType() == Account.AccountType.SECURITY:                                              # noqa
                    if _acct.getAccountIsInactive(): return True
                    if _acct.getBalance() == 0: return True
                return False

        class TSZSIStoreAccountList():
            def __init__(self, obj):
                self.obj = obj
                self.newAccountIsInactive = None
            def getAccount(self): return self.obj
            def getBalance(self): return self.getAccount().getBalance()
            def getDisplayBalance(self): return self.getAccount().getCurrencyType().getDoubleValue(self.getBalance())
            def getAccountIsInactive(self): return self.getAccount().getAccountIsInactive()
            def getNewAccountIsInactive(self): return self.newAccountIsInactive
            def setNewAccountIsInactive(self, newAccountIsInactive):
                if self.getAccountIsInactive() != newAccountIsInactive: self.newAccountIsInactive = newAccountIsInactive
            def __str__(self):
                _txt =  "%s : (share bal: %s) - %s" %(self.getAccount().getFullAccountName(), self.getDisplayBalance(), "INACTIVE" if (self.getAccountIsInactive()) else "Active", )
                return _txt if not self.getAccountIsInactive() else wrap_HTML_italics(_txt)
            def __repr__(self): return self.__str__()
            def toString(self): return self.__str__()

        class TSZSISelectAction(AbstractAction):

            def __init__(self, _jlst, _preSelectList):
                # type: (JList, []) -> None
                self.jlst = _jlst
                self.preSelectList = _preSelectList

            def actionPerformed(self, event):
                if event.getActionCommand().lower() == "select all":
                    end = self.jlst.getModel().getSize() - 1
                    if end >= 0:  self.jlst.setSelectionInterval(0, end)
                elif event.getActionCommand().lower() == "clear selection":
                    self.jlst.clearSelection()
                elif event.getActionCommand().lower() == "reload original":
                    self.jlst.setSelectedIndices(self.preSelectList)
                else: raise Exception("ERROR: TSZSISelectAction.actionPerformed() passed unknown event: '%s'" %(event.getActionCommand()))

        class MyJListRenderer(DefaultListCellRenderer):

            def __init__(self):
                super(DefaultListCellRenderer, self).__init__()                                                             # noqa

            def getListCellRendererComponent(self, thelist, value, index, isSelected, cellHasFocus):
                lightLightGray = Color.LIGHT_GRAY
                c = super(MyJListRenderer, self).getListCellRendererComponent(thelist, value, index, isSelected, cellHasFocus) # noqa
                # c.setBackground(self.getBackground() if index % 2 == 0 else lightLightGray)
                c.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, lightLightGray))        # Create a line separator between accounts
                return c

        class MyDefaultListSelectionModel(DefaultListSelectionModel):
            # Change the selector - so not to deselect items when selecting others...
            def __init__(self):
                super(DefaultListSelectionModel, self).__init__()                                                       # noqa

            def setSelectionInterval(self, start, end):
                if (start != end):
                    super(MyDefaultListSelectionModel, self).setSelectionInterval(start, end)                           # noqa
                elif self.isSelectedIndex(start):
                    self.removeSelectionInterval(start, end)
                else:
                    self.addSelectionInterval(start, end)

        listOfAccountsForJList = [TSZSIStoreAccountList(_acct) for _acct in sorted(AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), TSZSIAcctFilter()), key=lambda sort_x: (sort_x.getFullAccountName().lower()))]
        if len(listOfAccountsForJList) < 1:
            txt = "No securities with zero balance or an inactive account flag found - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        jlst = JList([])
        jlst.setBackground(MD_REF.getUI().getColors().listBackground)
        jlst.setCellRenderer(MyJListRenderer())
        jlst.setFixedCellHeight(jlst.getFixedCellHeight()+25)
        jlst.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION)
        jlst.setSelectionModel(MyDefaultListSelectionModel())
        jlst.setListData(listOfAccountsForJList)

        jlstIndex = 0
        preSelectList = []
        for acctObj in listOfAccountsForJList:
            if acctObj.getAccountIsInactive(): preSelectList.append(jlstIndex)
            jlstIndex += 1
        jlst.setSelectedIndices(preSelectList)

        helpTextLbl = JLabel("<html>** HELP: Only security accounts with a zero share balance (or where already inactive) are listed<br>"
                              "Highlighted rows are inactive. Select / deselect rows to toggle the status and click PROCEED **</html>")
        helpTextLbl.setForeground(getColorBlue())

        onRow = 0; onCol = 0

        pnl = JPanel(GridBagLayout())
        pnl.add(helpTextLbl, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(0).rightInset(0).topInset(0).fillboth())

        selectAllBtn = JButton("Select all")
        selectNoneBtn = JButton("Clear selection")
        reloadBtn = JButton("Reload original")

        btnPnl = JPanel(GridBagLayout())

        TSZSIListener = TSZSISelectAction(jlst, preSelectList)
        onCol = 0
        for btn in [selectAllBtn, selectNoneBtn, reloadBtn]:
            btn.addActionListener(TSZSIListener)
            btnPnl.add(btn, GridC.getc(onCol, 0).wx(0.1).wy(0.1).leftInset(0).rightInset(0).topInset(0).fillboth())
            onCol += 1

        onRow += 1; onCol = 0
        pnl.add(btnPnl, GridC.getc(onCol, onRow).wx(0.1).wy(0.1).leftInset(0).rightInset(0).topInset(5).fillboth()); onRow += 1

        onRow += 1; onCol = 0
        pnl.add(MyJScrollPaneForJOptionPane(jlst,1000,650), GridC.getc(onCol, onRow).wx(9.0).wy(9.0).leftInset(0).rightInset(0).topInset(5).fillboth()); onRow += 1

        options = ["EXIT", "PROCEED"]
        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                   pnl,
                                                   "%s: TOGGLE SECURITY's ACTIVE/INACTIVE STATUS" %(_THIS_METHOD_NAME),
                                                   JOptionPane.OK_CANCEL_OPTION,
                                                   JOptionPane.QUESTION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   options, options[0]))
        if userAction != 1:
            txt = "User aborted toggle security active/inactive status screen - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        selectedSecObjs = jlst.getSelectedValuesList()
        for secObj in listOfAccountsForJList:
            secObj.setNewAccountIsInactive(False if secObj not in selectedSecObjs else True)

        changeList = []
        for secObj in listOfAccountsForJList:
            if secObj.getNewAccountIsInactive() is not None:
                output += "Requested to change status: Security: %s (share balance: %s), old inactive: %s, new inactive: %s\n"\
                          %(secObj.getAccount().getFullAccountName(), secObj.getBalance(), secObj.getAccountIsInactive(), secObj.getNewAccountIsInactive())
                changeList.append(secObj)
        output += "\n<END>"

        if len(changeList) < 1:
            txt = "No changes detected / requested to inactive account flags - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        ask = MyPopUpDialogBox(toolbox_frame_,
                             theTitle=_THIS_METHOD_NAME,
                             theStatus="Change the active/inactive account status on %s Investment Securities?" %(len(changeList)),
                             theMessage=output,
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED")

        if not ask.go():
            txt = "User did not say yes to %s - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "TOGGLE THE ACTIVE/INACTIVE ACCOUNT STATUS ON %s Investment Security Accounts?" %(len(changeList))):
            return

        myPrint("B","%s: @@ User requested to change the active/inactive account status on %s investment security accounts - APPLYING UPDATE NOW...." %(_THIS_METHOD_NAME, len(changeList)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        for secObj in changeList:
            secObj.getAccount().setAccountIsInactive(secObj.getNewAccountIsInactive())
            secObj.getAccount().syncItem()
            myPrint("B", "CHANGED Investment Security Account '%s' - AccountIsInactive status is now '%s'" %(secObj.getAccount().getFullAccountName(), secObj.getAccountIsInactive()))
        MD_REF.saveCurrentAccount()

        txt = "%s: The active/inactive account status was changed on %s investment security accounts...." %(_THIS_METHOD_NAME, len(changeList))
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("toggle_security_zero_shares_inactive", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)


    def fix_invalid_relative_currency_rates():
        if MD_REF.getCurrentAccountBook() is None: return

        txt = "fix_invalid_relative_currency_rates"
        if not perform_qer_quote_loader_check(toolbox_frame_, txt): return

        book = MD_REF.getCurrentAccountBook()
        currencies = book.getCurrencies().getAllCurrencies()
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getCurrencyType(),sort_x.getName().upper()))

        output=u"FIX INVALID RELATIVE CURRENCIES\n" \
               u" ==============================\n\n"

        upperLimit = 9999999999

        output += u"** Wild rates set to %s <= (rate) >= %s\n" %((1.0 / upperLimit), upperLimit)

        iErrors = 0
        for curr in currencies:
            if not isGoodRate(curr.getRelativeRate()) or curr.getRelativeRate() <= (1.0 / upperLimit) or curr.getRelativeRate() >= upperLimit:
                iErrors += 1
                output += u"Invalid - Type: %s Name: %s Relative Rate: %s\n" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20))

        if iErrors < 1:
            txt = u"FIX INVALID REL CURR RATES: You have no relative rates <= %s or >= %s to fix - NO CHANGES MADE" %((1.0 / upperLimit),upperLimit)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, u"FIX INVALID REL CURR RATES")
            return

        jif = QuickJFrame(u"FIX INVALID RELATIVE CURRENCIES",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        # force_change_account_currency.py
        ask = MyPopUpDialogBox(jif,
                             theStatus=u"Are you sure you want to FIX these %s INVALID RELATIVE CURRENCIES?" %iErrors,
                             theTitle=u"FIX INVALID RELATIVE CURRENCIES",
                             theMessage=u"Do not proceed unless you know you want to do this....!\n"
                                        u"This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the relative rate(s)\n"
                                        u"You should carefully review your data afterwards and revert to a backup if you are not happy with the results....\n",
                             lCancelButton=True,
                             OKButtonText=u"I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = u"User did not say yes to fix invalid relative currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(jif, u"FIX INVALID RELATIVE CURR RATES", u"FIX %s INVALID RELATIVE CURRENCY RATES" %(iErrors)):
            return

        jif.dispose()       # already within the EDT

        myPrint(u"B",u"@@ User requested to fix %s invalid relative currency rates - APPLYING UPDATE NOW...." %(iErrors) )

        output += u"\n\n APPLYING FIXES\n" \
                  u" ==============\n\n"

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for curr in currencies:
            if not isGoodRate(curr.getRelativeRate()) or curr.getRelativeRate() <= (1.0 / upperLimit) or curr.getRelativeRate() >= upperLimit:
                output += u"FIXING >> Invalid - Type: %s Name: %s Relative Rate: %s - RESET TO 1.0\n" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20))

                myPrint(u"B", u"FIXING >> Invalid - Type: %s Name: %s Relative Rate: %s - RESET TO 1.0" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20)))

                curr.setRelativeRate(1.0)
                curr.syncItem()

        myPrint(u"P", output)

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        output += "\n<END"

        jif = QuickJFrame(u"FIX INVALID RELATIVE CURRENCIES", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lRestartMDAfterClose=True).show_the_frame()

        txt = u"%s Invalid Currency relative rates reset to 1.0 - MD WILL RESTART AFTER VIEWING THIS OUTPUT" %(iErrors)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates(u"fix_invalid_relative_currency_rates", txt)
        disableToolboxButtons()
        play_the_money_sound()
        myPopupInformationBox(jif,txt, u"FIX INVALID RELATIVE CURRENCIES", theMessageType=JOptionPane.ERROR_MESSAGE)

    def fix_invalid_price_history():
        if MD_REF.getCurrentAccountBook() is None: return

        txt = "Fix Invalid Price History Records"
        if not perform_qer_quote_loader_check(toolbox_frame_, txt): return

        output="FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES\n" \
               " ===================================================\n\n"

        upperLimit = 9999999999

        output += "** Wild rates set to %s <= (rate) >= %s\n" %((1.0 / upperLimit), upperLimit)

        allSnaps = MD_REF.getCurrentAccountBook().getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE)
        output += "\nFound price history records (snaps): %s" %(len(allSnaps))

        iGood = 0
        badSnaps = []
        output += "\n.. scanning snaps for 'wild' rates....\n"

        for snap in allSnaps:
            snapRate = snap.getRate()
            if not isGoodRate(snapRate) or snapRate <= (1.0 / upperLimit) or snapRate >= upperLimit:
                badSnaps.append(snap)
            else:
                iGood += 1

        if len(badSnaps) < 1:
            txt = "CONGRATULATIONS >> No snaps with 'wild' rates (out of %s good found) found! No changes made!" %(iGood)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        badSnaps = sorted(badSnaps, key=lambda sort_x: (sort_x.getParameter("curr", None),sort_x.getDateInt()))
        for badSnap in badSnaps:
            output += "Invalid rate found: %s\n" %(badSnap)

        output += "\n\n--------------------------------------\n"
        output += "Good snaps: %s\n" %(iGood)

        txt = "Bad snaps with 'wild' rates found: %s" %(len(badSnaps))
        myPrint("B", txt); output += "%s\n" %(txt)

        jif = QuickJFrame("FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        ask = MyPopUpDialogBox(jif,
                             theStatus="Are you sure you want to DELETE these %s INVALID PRICE HISTORY RECORDS?" %(len(badSnaps)),
                             theTitle="FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",
                             theMessage="Do not proceed unless you know you want to do this....!\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply deletes the invalid rate(s)",
                             lCancelButton=True,
                             OKButtonText="I AGREE - DELETE",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to delete %s invalid price history records - no changes made" %(len(badSnaps))
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(jif,
                                                 "DELETE INVALID PRICE HISTORY RECORDS WITH 'WILD' RATES",
                                                 "DELETE %s INVALID PRICE HISTORY RECORDS" %(len(badSnaps))):
            return
        jif.dispose()       # already within the EDT


        txt = "@@ User requested to delete %s invalid price history with 'wild' rates - DELETING NOW...." %(len(badSnaps))
        myPrint("B", txt); output += "%s\n\n" %(txt)

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        SyncerDebug.changeState(debug)

        output += "Logging snaps with 'wild' rates for deletion....\n"
        MD_REF.getCurrentAccountBook().logRemovedItems(badSnaps)

        SyncerDebug.resetState()
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        output += "Flushing dataset changes in memory back to disk....\n"
        MD_REF.getCurrentAccountBook().saveTrunkFile()

        txt = "%s snaps with 'wild' rates DELETED." %(len(badSnaps))
        myPrint("B", txt); output += "%s\n\n" %(txt)
        logToolboxUpdates("fix_invalid_price_history", txt)

        output += "\n<END>"

        setDisplayStatus(txt, "R")
        play_the_money_sound()
        jif = QuickJFrame("FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

    def reverse_txn_amounts():
        # reverse_txn_amounts.py
        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to REVERSE Transaction amounts on an Account's Transactions (between two dates)?",
                             theTitle="REVERSE TRANSACTIONAL AMOUNTS",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you perhaps imported transactions with the wrong +/- sign\n"
                                        "..or perhaps you  have changed an account's type\n"
                                        "This fix will not touch the ROOT account nor Investment/Security sub-accounts (which are stocks/shares)\n"
                                        "You should carefully review your data afterwards and revert to a backup if you are not happy with the results....",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to REVERSE TXN AMOUNTS - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(20))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to REVERSE Transactional Amounts",
                                                      "REVERSE ACCOUNT's TXN AMOUNTS",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList

        if not selectedAccount:
            txt = "User did not Select an Account to REVERSE Transactional Amounts - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        dateField = JDateField(MD_REF.getUI())
        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select Starting Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select start date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        startDate = dateField.getDateInt()

        dateField.gotoToday()

        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select Ending Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select end date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        endDate = dateField.getDateInt()

        txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
        txns = txnSet.iterableTxns()

        iTxnsFound = 0
        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue
            acct = txn.getAccount()
            if not acct == selectedAccount: continue
            iTxnsFound += 1

        if iTxnsFound < 1:
            txt = "REVERSE TXN AMOUNTS - Sorry - no transactions found - NO CHANGES MADE"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "REVERSE ACCT TXN AMOUNTS", "ACCOUNT %s - REVERSE %s Txns' amounts between %s - %s?"
                                                                                             %(selectedAccount,iTxnsFound,convertStrippedIntDateFormattedText(startDate),convertStrippedIntDateFormattedText(endDate))):
            return

        myPrint("B","@@ User requested to REVERSE the (%s) Txn Amounts on Account %s between %s to %s - APPLYING UPDATE NOW...." %(iTxnsFound, selectedAccount, convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue
            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            myPrint("B","Reversing the amount on %s" %(txn))
            ptxn = txn.getParentTxn()

            ptxn.setEditingMode()

            if ptxn == txn:             # this is the parent part of the txn
                myPrint("B", "  - is a parent, changing each split")
                for splitIdx in range(0, txn.getSplitCount()):
                    txn.getSplit(splitIdx).negateAmount()
            else:
                myPrint("B", "  - is a split")
                txn.negateAmount()

            ptxn.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "REVERSE %s Txns Amounts on Account %s between %s - %s COMPLETED - PLEASE REVIEW" %(iTxnsFound,selectedAccount,convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate))
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("reverse_txn_amounts", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)

    def reverse_txn_exchange_rates_by_account_and_date():
        # reverse_txn_exchange_rates_by_account_and_date.py

        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to REVERSE Exchange Rates on an Account's Transactions (between two dates)?",
                             theTitle="REVERSE TRANSACTIONAL EXCHANGE RATES",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you perhaps imported transactions with the fx rates inversed \n"
                                        "This fix will not touch the Currency price history...!\n"
                                        "This fix will not touch the ROOT account nor Investment/Security sub-accounts (which are stocks/shares)\n"
                                        "You should carefully review your data afterwards and revert to a backup if you are not happy with the results....",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to REVERSE TXN EXCHANGE RATES - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(20))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to REVERSE Transactional Exchange Rates",
                                                      "REVERSE ACCOUNT's TXN EXCHANGE RATES",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList

        if not selectedAccount:
            txt = "User did not select an Account to REVERSE Transactional Exchange Rates - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        dateField = JDateField(MD_REF.getUI())
        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select STARTING Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select start date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        startDate = dateField.getDateInt()

        dateField.gotoToday()

        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select ENDING Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select end date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        endDate = dateField.getDateInt()

        txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
        txns = txnSet.iterableTxns()

        iTxnsFound = 0

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue

            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            if isinstance(txn, ParentTxn):   # Parent
                for splitNum in range(0, txn.getSplitCount()):
                    split = txn.getSplit(splitNum)
                    if split.getAmount() != split.getValue():
                        iTxnsFound += 1
                        break
            else:                           # Split
                if txn.getAmount() != txn.getValue():
                    iTxnsFound += 1

        if iTxnsFound < 1:
            txt = "REVERSE TXN EXCHANGE RATES - Sorry - no transactions found (with fx) - NO CHANGES MADE"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "REVERSE ACCT TXN EXCHANGE RATES", "ACCOUNT %s - REVERSE %s Txns' exchange rates between %s - %s?"
                                                                                                    %(selectedAccount,iTxnsFound,convertStrippedIntDateFormattedText(startDate),convertStrippedIntDateFormattedText(endDate))):
            return

        myPrint("B","@@ User requested to REVERSE the (%s) Txn Exchange Rates on Account %s between %s to %s - APPLYING UPDATE NOW...."
                %(iTxnsFound, selectedAccount, convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue

            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            ptxn = txn.getParentTxn()
            needsSync = False

            if ptxn == txn:
                for splitNum in range(0, txn.getSplitCount()):
                    split = txn.getSplit(splitNum)
                    if split.getAmount() != split.getValue():
                        if not needsSync:
                            myPrint("B","Reversing exchange rate on %s" %(txn))
                            myPrint("B", "  - is a parent, changing each split")
                            ptxn.setEditingMode()
                        needsSync = True
                        parentVal = split.getParentValue()
                        rate = split.getRate()
                        split.setParentAmount(safeInvertRate(rate), parentVal)
            else:
                split = txn
                if split.getAmount() != split.getValue():
                    myPrint("B","Reversing exchange rate on %s" %(txn))
                    myPrint("B", "  - This is a split - changing...")
                    if not needsSync:
                        ptxn.setEditingMode()
                    needsSync = True
                    parentVal = split.getParentValue()
                    rate = split.getRate()
                    split.setParentAmount(safeInvertRate(rate), parentVal)

            if needsSync:
                ptxn.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "REVERSE %s Txns Exchange Rates on Account %s between %s - %s COMPLETED - PLEASE REVIEW"\
              %(iTxnsFound,selectedAccount,convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate))
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("reverse_txn_exchange_rates_by_account_and_date", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)

    def isSplitTxnAccountAssignedRoot(_txn, _fix=False, _accounts=None, _fixAcctType=None):
        if _fix and (_accounts is None or _fixAcctType is None):
            raise Exception("ERROR: isTxnAccountAssignedRoot() Fix, _accounts and _fixAcctType must NOT be None")
        acct = _txn.getAccount()
        # noinspection PyUnresolvedReferences
        assignedRoot = (acct is not None and acct.getAccountType() == Account.AccountType.ROOT)
        if assignedRoot and _fix:
            if _txn.getParameter("invest.splittype", "") == "sec":
                myPrint("B", "NOT FIXING: 'security' transaction assigned to root account:", _txn, "FIX MANUALLY")
            else:
                fixAccount = _accounts.getAccount(_fixAcctType)
                myPrint("B", "FIXING: transaction assigned to root account:", _txn, "Assigning to:", fixAccount)
                _txn.setAccount(fixAccount)
        return assignedRoot

    def isTxnAccountAssignedRoot(_txn, _fix=False, _accounts=None):
        if _fix and _accounts is None: raise Exception("ERROR: isTxnAccountAssignedRoot() Fix, _accounts must not be None")
        if not isinstance(_txn, ParentTxn) or _txn.getOtherTxnCount() < 1: return False
        # noinspection PyUnresolvedReferences
        isTxnAssignedRoot = isSplitTxnAccountAssignedRoot(_txn,
                                                          _fix,
                                                          _accounts,
                                                          (Account.AccountType.INVESTMENT if (isInvestmentTxn(_txn)) else Account.AccountType.BANK))
        for i in range(0, _txn.getOtherTxnCount()):
            # noinspection PyUnresolvedReferences
            if isSplitTxnAccountAssignedRoot(_txn.getOtherTxn(i), _fix, _accounts, Account.AccountType.EXPENSE):
                isTxnAssignedRoot = True
        return isTxnAssignedRoot

    def isInvestmentTxn(_txn):
        if not isinstance(_txn, ParentTxn) or _txn.getOtherTxnCount() < 1: return False
        # noinspection PyUnresolvedReferences
        if _txn.getAccount() is not None and _txn.getAccount().getAccountType() == Account.AccountType.INVESTMENT: return True
        if _txn.getParameter("invest.txntype", None) is not None: return True
        if _txn.getParameter("xfer_type", None) is not None: return True
        for i in range(0, _txn.getOtherTxnCount()):
            split = _txn.getOtherTxn(i)
            if split.getParameter("invest.splittype", None) is not None: return True
        return False

    def checkForTxnsAssignedRoot(lFix=False, accounts=None):
        if lFix and accounts is None: raise Exception("ERROR: checkForTxnsAssignedRoot() Fix, accounts must not be None")
        _countValid = _countAssignedRoot = _countInvestmentAssignedRoot = 0
        txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
        for txn in txnSet:
            if not isinstance(txn, ParentTxn): continue
            if isTxnAccountAssignedRoot(txn, lFix, accounts):
                _countAssignedRoot += 1
                if isInvestmentTxn(txn):
                    _countInvestmentAssignedRoot += 1
                if lFix: txn.syncItem()
            else:
                _countValid += 1
        return _countValid, _countAssignedRoot, _countInvestmentAssignedRoot

    def detect_fix_txns_assigned_root():
        _THIS_METHOD_NAME = "DETECT / FIX TXNS ASSIGNED TO 'ROOT'"
        PARAMETER_KEY = "toolbox_detect_fix_txns_assigned_root"

        countValid, countAssignedRoot, countInvestmentAssignedRoot = checkForTxnsAssignedRoot()

        if countAssignedRoot < 1:
            myPopupInformationBox(toolbox_frame_, "You have no transactions assigned to 'root' account - no changes made", _THIS_METHOD_NAME)
            return

        # if detect_non_hier_sec_acct_or_orphan_txns() > 0:
        #     txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
        #     setDisplayStatus(txt, "R")
        #     myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
        #     return

        book = MD_REF.getCurrentAccountBook()

        # myPopupInformationBox(toolbox_frame_, "WARNING: %s txns assigned to 'root' out of %s parent txns (%s are Investments)" %(countAssignedRoot, countValid, countInvestmentAssignedRoot), _THIS_METHOD_NAME)

        txt = "WARNING: %s txns assigned to 'root' out of %s parent txns [%s are Investment(s)]" %(countAssignedRoot, countValid, countInvestmentAssignedRoot)
        diagPanel = JPanel(GridLayout(0, 1))
        diagPanel.add(JLabel(txt))
        _options = ["Cancel", "VIEW REGISTER(s)", "AUTO-FIX"]

        userResponse = JOptionPane.showOptionDialog(toolbox_frame_,
                                                  diagPanel,
                                                  _THIS_METHOD_NAME.upper(),
                                                  JOptionPane.OK_CANCEL_OPTION,
                                                  JOptionPane.QUESTION_MESSAGE,
                                                  getMDIcon(None),
                                                  _options,
                                                  _options[0])

        if userResponse < 1:
            txt = "%s: User did not select option - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt)
            return

        if userResponse == 1:
            # View REGISTER
            # prefs = MD_REF.getPreferences(); twoLines = prefs.getBoolSetting("gui.two_line_transactions", False)

            class MyTxnAcctSearch(TxnSearch):
                def __init__(self, lAll=True, lInvestments=False):
                    self.lAll = lAll
                    self.lInvestments = lInvestments

                def matches(self, _txn):
                    assignedRoot = isTxnAccountAssignedRoot(_txn)
                    if not assignedRoot or self.lAll: return assignedRoot
                    foundInvestment = isInvestmentTxn(_txn)
                    if (not self.lInvestments and not foundInvestment) or (self.lInvestments and foundInvestment):
                        return assignedRoot
                    return False

                def matchesAll(self): return False

            offset = 75
            w, h = 1200, 500
            toolboxLocation = toolbox_frame_.getLocation()
            toolboxLocation.x += offset; toolboxLocation.y += offset

            if (countAssignedRoot - countInvestmentAssignedRoot) > 0:
                popupTxnRegister = MyPopupRegister("TRANSACTIONS INCORRECTLY ASSIGNED TO ROOT (non Investments)",
                                                   TxnRegisterType,
                                                   MyTxnAcctSearch(lAll=False, lInvestments=False),
                                                   parent=toolbox_frame_,
                                                   editableRegister=True,
                                                   modal=False)


                AwtUtil.setupWindow(popupTxnRegister, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                toolboxLocation.x += offset; toolboxLocation.y += offset
                popupTxnRegister.setVisible(True)

            if countInvestmentAssignedRoot > 0:
                popupInvestTxnRegister = MyPopupRegister("INVESTMENT TRANSACTIONS INCORRECTLY ASSIGNED TO ROOT",
                                                         InvestRegisterType,
                                                         MyTxnAcctSearch(lAll=False, lInvestments=True),
                                                         parent=toolbox_frame_,
                                                         editableRegister=debug,
                                                         modal=False)
                AwtUtil.setupWindow(popupInvestTxnRegister, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                toolboxLocation.x += offset; toolboxLocation.y += offset
                popupInvestTxnRegister.setVisible(True)

            txt = "%s: Txns Assigned to Root displayed in Register(s) so that user can view/amend" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            return

        # AUTOFIX ###############################################
        if not confirm_backup_confirm_disclaimer(toolbox_frame_,
                                                 _THIS_METHOD_NAME,
                                                 "AUTO-FIX %s txns assigned to 'root' account?" %(countAssignedRoot)):
            return

        class HoldAutoFixAccounts:
            accountName = "* TOOLBOX: %s (DELETE AFTER USE/WHEN EMPTY) **" %(_THIS_METHOD_NAME)

            def __init__(self): self.accounts = {}

            def getAccount(self, accountType):
                if accountType not in self.accounts:
                    newAccount = Account.makeAccount(book, accountType, book.getRootAccount())
                    newAccount.setAccountName(HoldAutoFixAccounts.accountName + " (%s)" %(accountType))
                    newAccount.setAccountDescription("DUMMY ACCOUNT..... PLEASE REVIEW AND FIX THESE TXNS (DELETE WHEN EMPTY)")
                    # noinspection PyUnresolvedReferences
                    if accountType == Account.AccountType.INVESTMENT:
                        newAccount.setPreference("sel_inv_view", "sec_register_view")
                        newAccount.setParameter("gen.asked_to_add_security", True)
                    newAccount.setParameter(PARAMETER_KEY, True)
                    newAccount.syncItem()
                    myPrint("B", "%s: Made account:" %(_THIS_METHOD_NAME), newAccount)
                    self.accounts[accountType] = newAccount
                return self.accounts[accountType]

        holdAutoFixAccounts = HoldAutoFixAccounts()
        checkForTxnsAssignedRoot(lFix=True, accounts=holdAutoFixAccounts)

        fix_non_hier_sec_acct_txns(autofix=True)

        extraSecurityText = ""
        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            extraSecurityText = "\nERROR - Cross-linked (or Orphaned) security txns detected..\n" \
                                ".....I've already run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)'\n" \
                                ".....>> NEEDS MANUAL INVESTIGATION'\n"

        txt = "%s: AUTO-FIX applied to %s Parent txns [%s investment txn(s)]" %(_THIS_METHOD_NAME, countAssignedRoot, countInvestmentAssignedRoot)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("detect_fix_txns_assigned_root", txt)
        play_the_money_sound()
        MyPopUpDialogBox(toolbox_frame_,
                         theStatus=txt,
                         theMessage="Please review console and also the contents of NEW temporary accounts/categories\n"
                                    "Go to Menu Tools>Accounts / Tools>Categories and look for: '%s'\n"
                                    "You will need to reassign these Accounts/Categories as needed\n"
                                    "... There may be up to 1 Bank Account, 1 Investment Account, 1 Expense Category\n"
                                    "%s"
                                    %(HoldAutoFixAccounts.accountName, extraSecurityText),
                         theTitle=_THIS_METHOD_NAME).go()

        try:
            # OK, let's show the new accounts/registers to the user.....
            offset = 75
            w, h = 1150, 650
            toolboxLocation = toolbox_frame_.getLocation()
            toolboxLocation.x += offset; toolboxLocation.y += offset

            for acctT in holdAutoFixAccounts.accounts:
                selectAccount = holdAutoFixAccounts.accounts[acctT]

                # mf = MainFrame(MD_REF.getUI(), MD_REF.getCurrentAccountBook())
                # mf.selectAccount(selectAccount)
                # if isinstance(mf, JFrame): pass
                # mf.setExtendedState(JFrame.NORMAL)
                # AwtUtil.setupWindow(mf, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                # toolboxLocation.x += offset; toolboxLocation.y += offset
                # mf.setVisible(True)

                class MyTxnAcctSearch(TxnSearch):
                    def __init__(self, account):
                        self.account = account

                    def matches(self, _txn):
                        if _txn.getAccount() == self.account: return True
                        return False

                    def matchesAll(self): return False

                # noinspection PyUnresolvedReferences
                popupTxnRegister = MyPopupRegister("TRANSACTIONS REASSIGNED TO NEW ACCOUNT: %s" %(selectAccount),
                                                   InvestRegisterType if (selectAccount.getAccountType() == Account.AccountType.INVESTMENT) else TxnRegisterType,
                                                   MyTxnAcctSearch(selectAccount),
                                                   parent=toolbox_frame_,
                                                   editableRegister=True,
                                                   modal=False)

                AwtUtil.setupWindow(popupTxnRegister, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                toolboxLocation.x += offset; toolboxLocation.y += offset
                popupTxnRegister.setVisible(True)

        except: pass

    def thin_price_history():
        # based on: price_history_thinner.py
        # (also includes elements from 2017_remove_orphaned_currency_history_entries.py)

        if MD_REF.getCurrentAccountBook() is None: return
        if MD_REF.getCurrentAccountBook().getSyncer() is None: return
        if MD_REF.getCurrentAccountBook().getSyncer().getSyncedDocument() is None: return

        txt = "Purge/Thin Price History"
        if not perform_qer_quote_loader_check(toolbox_frame_, txt): return

        # prune historical exchange rates and price history from the given currency
        # this thins price history older than a year by keeping no more than one price per week
        # prices within the last year (or the age_limit_days parameter) are not removed

        totalChangesMade = 0

        diagDisplay = "DIAGNOSE CURRENCY PRICE HISTORY (csnaps)\n"
        diagDisplay += " =======================================\n\n"

        def objects_by_type():
            text = "Objects by type summary:\n"
            objectTypes = [ CurrencyType.SYNCABLE_TYPE_VALUE, CurrencySnapshot.SYNCABLE_TYPE_VALUE, CurrencySplit.SYNCABLE_TYPE_VALUE]
            for objectType in objectTypes:
                xx = ""
                if objectType == CurrencyType.SYNCABLE_TYPE_VALUE: xx = " (Currency/Security records)"                     # noqa
                if objectType == CurrencySnapshot.SYNCABLE_TYPE_VALUE: xx = " (Currency/Security price history records)"   # noqa
                if objectType == CurrencySplit.SYNCABLE_TYPE_VALUE: xx = " (Security Stock Split records)"                 # noqa
                objects = MD_REF.getCurrentAccountBook().getItemsWithType(objectType)
                text+="  %s: %s %s\n"%(pad(objectType, 9), rpad(len(objects), 12), xx)
            text += "\n"
            return text

        diagDisplay += objects_by_type()

        def hunt_down_orphans():
            # Hunt down the poor little orphans...!
            orphanSnaps = totalSnaps = 0                                                                                # noqa
            text = ""
            saveRawSnaps = {}
            for mdItem in MD_REF.getRootAccount().getBook().getSyncer().getSyncedDocument().allItems():
                if not (isinstance(mdItem, MoneydanceSyncableItem)): continue
                if mdItem.getParameter("obj_type", None) != CurrencySnapshot.SYNCABLE_TYPE_VALUE: continue
                saveRawSnaps[mdItem.getParameter("id")] = mdItem
            _currencies = MD_REF.getCurrentAccountBook().getCurrencies()
            for _curr in _currencies:
                snapshots = _curr.getSnapshots()
                for snap in snapshots:
                    saveRawSnaps.pop(snap.getParameter("id"))

            oList = []
            if len(saveRawSnaps) > 0:
                lAllValid = True
                for _value in saveRawSnaps.values():
                    if not _value.getCurrencyParameter(None, "curr", None): lAllValid=False
                    oList.append(_value)
                if lAllValid:
                    # Sort and make pretty for Derek ;->
                    oList = sorted(oList, key=lambda sort_x: (sort_x.getCurrencyParameter(None, "curr", None).getCurrencyType(),sort_x.getParameter("curr", None),sort_x.getDateInt()))

                _last = None
                for _x in oList:
                    orphanSnaps += 1
                    chk = _x.getCurrencyParameter(None, "curr", None)
                    if chk: chk = _x.getCurrencyParameter(None, "curr", None).getCurrencyType()
                    if _last != chk:
                        text+=" \n%s:\n" %(chk)
                        _last = chk
                    if debug:
                        text+=" >> Orp/Dup: %s %s\n" %(_x.getUUID(),_x)
                    else:
                        text+=" >> Orp/Dup: %s\n" %(_x)

            for snap in MD_REF.getCurrentAccountBook().getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE):
                totalSnaps += 1
                if snap.getParameter("curr", None) is None or MD_REF.getCurrentAccountBook().getItemForID(snap.getParameter("curr", None)) is None:
                    if not saveRawSnaps.get(snap.getParameter("id",None)):
                        orphanSnaps += 1
                        saveRawSnaps[snap.getParameter("id")] = snap
                        if debug:
                            text+=" >> Orp (no Curr): %s %s\n" %(snap.getUUID(), snap)
                        else:
                            text+=" >> Orp (no Curr): %s\n" %(snap)
                        oList.append(snap)

            if orphanSnaps:
                text+="\nWARNING: %s of %s currency or security snapshots were orphans/duplicates/stranded (or had no Currency link)\n" %(orphanSnaps, totalSnaps)
                text+="(NOTE: The system 'hides' duplicate price history records for the same currency/date.....)   \n"
            else:
                text+="No price history snapshot orphans/duplicates detected!\n"

            del saveRawSnaps

            oList = sorted(oList, key=lambda sort_x: (sort_x.getParameter("curr", None),sort_x.getDateInt()))

            return text, orphanSnaps, oList

        txt, orphanSnaps, orphans_to_delete = hunt_down_orphans()
        diagDisplay += txt

        def snaps_by_currency():
            text = ""
            _currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
            _currencies = sorted(_currencies, key=lambda sort_x: (sort_x.getName().upper()))
            lastC = None
            # noinspection PyUnresolvedReferences
            iAll = iCurrs = iSecs = 0
            for theCType in [CurrencyType.Type.CURRENCY, CurrencyType.Type.SECURITY]:                                   # noqa
                for _currency in _currencies:
                    if _currency.getCurrencyType() != theCType: continue
                    iAll += 1
                    if _currency.getCurrencyType() == CurrencyType.Type.CURRENCY: iCurrs+=1                             # noqa
                    if _currency.getCurrencyType() == CurrencyType.Type.SECURITY: iSecs+=1                              # noqa
                    if lastC != _currency.getCurrencyType():
                        text += "\n%s:\n" % _currency.getCurrencyType()
                        lastC = _currency.getCurrencyType()
                    _snapshots = _currency.getSnapshots()
                    text += "  %s (snapshots: %s, splits: %s)\n" %(pad(_currency.getName(), 45), rpad(_snapshots.size(),10), rpad(_currency.getSplits().size(),10))

            text += "\n-----\nTotal Curr/Sec listed: %s Currencies: %s Securities: %s\n" %(iAll,iCurrs,iSecs)

            return text

        diagDisplay += snaps_by_currency()

        def does_base_has_snaps(lDelete=False, lVerbose=True):

            baseCurr = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()
            baseSnapshots = baseCurr.getSnapshots()

            iCountBaseSnapsDeleted = 0
            text = ""
            if baseSnapshots.size() > 0:
                text += "ERROR: base currency %s has %s historical prices! These should be deleted!" % (baseCurr, baseSnapshots.size())
                if lDelete and not lVerbose: myPrint("J","@@ Deleting all snapshots from base Currency @@")
                for baseSnapshot in baseSnapshots:
                    if lDelete:
                        if lVerbose:
                            text += "  @@DELETING@@: %s\n" %(baseSnapshot)
                            myPrint("J","Deleting Base Currency snapshot: %s" %(baseSnapshot))
                        baseSnapshot.deleteItem()
                        iCountBaseSnapsDeleted+=1
                    else:
                        if lVerbose:
                            text += "  snapshot: %s\n" %(baseSnapshot)
            else:
                text += "\n\nBase currency %s has NO historical prices! These is correct!\n\n" % (baseCurr)

            return text, iCountBaseSnapsDeleted

        x, y = does_base_has_snaps()
        diagDisplay += x

        jif = QuickJFrame("Price History Analysis", diagDisplay,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()


        if orphanSnaps > 0:
            MyPopUpDialogBox(jif,
                             "YOU HAVE ORPHAN/STRANDED Price History Records - READ THIS FIRST",
                             theMessage="These are either 'Orphaned' records with no Currency linkage;\n"
                                        "or they are duplicated records (i.e. multiple records with the same date due to a MD bug/flaw)..\n"
                                        "These are 'stranded' / hidden from view. Once you delete the visible record, any Orphan on the same date will reappear\n"
                                        "BEST PRACTICE (after reviewing the Simulation Log) is as follows:\n"
                                        "1. Select 'Only Delete Orphans Mode' and ALL Currencies and ALL Securities. Then Execute\n"
                                        "2. Exit and restart Moneydance (as MD's cache needs refreshing)\n"
                                        "3. Come back here and then choose your desired Purge/Thin mode (if required - optional)\n"
                                        "If you don't follow this sequence, then as you purge, previously hidden records will start appearing\n"
                                        "..(inside or outside the purge/thin window date range you selected)\n"
                                        "(NOTE: Any 'Orphans' that start appearing are harmless, it means they've become visible)",
                             theTitle="THIN/PURGE PRICE HISTORY",
                             OKButtonText="ACKNOWLEDGE",lAlertLevel=1).go()

        saveColor = JLabel("TEST").getForeground()

        # prune historical exchange rates and price history from the given currency
        # this thins price history older than a year by keeping no more than one price per week
        # prices within the last year (or the age_limit_days parameter) are not removed

        dropdownCurrs = ArrayList()
        dropdownSecs = ArrayList()
        currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() == CurrencyType.Type.CURRENCY: dropdownCurrs.add(curr)                            # noqa
            if curr.getCurrencyType() == CurrencyType.Type.SECURITY: dropdownSecs.add(curr)                             # noqa
        dropdownCurrs = sorted(dropdownCurrs, key=lambda sort_x: (sort_x.getName().upper()))
        dropdownSecs = sorted(dropdownSecs, key=lambda sort_x: (sort_x.getName().upper()))
        dropdownCurrs.insert(0,"<EXCLUDE Currencies>")
        dropdownCurrs.insert(0,"<ALL Currencies>")
        dropdownSecs.insert(0,"<EXCLUDE Securities>")
        dropdownSecs.insert(0,"<ALL Securities>")
        del currencies

        label_simulate = JLabel("Simulate with no changes?")
        user_simulate = JCheckBox("(Uncheck to make changes)", True)
        user_simulate.setName("user_simulate")

        purgeStrings = ["<DO NOTHING>",
                        "Thin Mode (Thin older than cutoff)",
                        "Purge Mode (Delete all older than cutoff)",
                        "Only Delete Orphans Mode (No Purge/Thin, just Delete Orphans)"]

        if MD_REF.getCurrentAccountBook().getCurrencies().getBaseType().getSnapshots().size()>0:
            purgeStrings.append("Only Delete Base Records (No Purge/Thin, just Delete Base Records)")

        labelPurgeOrThinMode = JLabel("Select the mode of operation:")
        user_purgeOrThinMode = JComboBox(purgeStrings)
        user_purgeOrThinMode.setName("user_purgeOrThinMode")
        user_purgeOrThinMode.setSelectedIndex(0)

        label_age_limit_days = JLabel("Thin/Purge records older than how many days? (1 to 1825 days)")
        user_age_limit_days = JTextField(5)
        user_age_limit_days.setDocument(JTextFieldLimitYN(5, False, "CURR"))
        user_age_limit_days.setText("")
        user_age_limit_days.setName("user_age_limit_days")
        user_age_limit_days.setEnabled(False)

        label_max_days_between_thinned = JLabel("When Thinning, keep no more than one price per x days? (1 to 31 days)")
        user_max_days_between_thinned = JTextField(3)
        user_max_days_between_thinned.setDocument(JTextFieldLimitYN(3, False, "CURR"))
        user_max_days_between_thinned.setText("")
        user_max_days_between_thinned.setName("user_max_days_between_thinned")
        user_max_days_between_thinned.setEnabled(False)

        label_includeCurrencies = JLabel("Thin/purge Currencies (All/Exclude/Select)?")
        user_includeCurrencies = JComboBox(dropdownCurrs)
        user_includeCurrencies.setSelectedIndex(1)
        user_includeCurrencies.setName("user_includeCurrencies")
        user_includeCurrencies.setEnabled(False)

        label_includeSecurities = JLabel("Thin/purge Securities (All/Exclude/Select)?")
        user_includeSecurities = JComboBox(dropdownSecs)
        user_includeSecurities.setSelectedIndex(1)
        user_includeSecurities.setName("user_includeSecurities")
        user_includeSecurities.setEnabled(False)

        labelPurgeOrphans = JLabel("While Purging/Thinning, also delete any/all Orphan/duplicate Snapshots found?")
        user_purgeOrphans = JCheckBox("(will only delete Orphans matching your ^^Curr/Sec^^ filters above)", False)
        user_purgeOrphans.setEnabled( orphanSnaps>0 )
        user_purgeOrphans.setName("user_purgeOrphans")
        user_purgeOrphans.setEnabled(False)

        labelPurgeBase = JLabel("While Purging/Thinning, also delete all Snapshots found on Base Currency?")
        user_purgeBase = JCheckBox("(will delete all Base Currency snapshots)", False)
        user_purgeBase.setEnabled(MD_REF.getCurrentAccountBook().getCurrencies().getBaseType().getSnapshots().size()>0 )
        user_purgeBase.setName("user_purgeBase")
        user_purgeBase.setEnabled(False)

        labelSaveTrunk = JLabel("Consolidate into new Trunk File after mass thin/purge process?")
        user_SaveTrunk = JCheckBox("(compacts/rewrites Dataset (trunk file) & clears *.mdtxn files)", False)
        user_SaveTrunk.setName("user_SaveTrunk")
        user_SaveTrunk.setEnabled(False)

        labelVERBOSE = JLabel("VERBOSE mode = Extra logfile output on all steps?")
        user_VERBOSE = JCheckBox("", False)
        user_VERBOSE.setName("user_VERBOSE")
        user_VERBOSE.setEnabled(False)

        labelSTATUS = JLabel("")
        labelSTATUS2 = JLabel("")

        userFilters = JPanel(GridLayout(0, 2))

        class PanelAction(AbstractAction):

            def __init__(self, thePanel, iOrphs):
                self.thePanel = thePanel
                self.iOrphs = iOrphs

            def actionPerformed(self, event):                                                                           # noqa
                the_simulate = None
                the_purgeOrThinMode = None
                the_age_limit_days = None
                the_max_days_between_thinned = None
                the_includeCurrencies = None
                the_includeSecurities = None
                the_purgeOrphans = None
                the_purgeBase = None
                the_SaveTrunk = None
                the_VERBOSE = None
                saveDropDownStateToo = None

                _components = self.thePanel.getComponents()
                for _theComponent in _components:

                    if isinstance(_theComponent, (JComboBox, JTextField, JCheckBox, JButton)):
                        if event.getSource().getName() == _theComponent.getName():
                            if _theComponent.getName() == "user_purgeOrThinMode": the_purgeOrThinMode  = _theComponent

                        if _theComponent.getName() == "user_purgeOrThinMode": saveDropDownStateToo  = _theComponent
                        if _theComponent.getName() == "user_simulate": the_simulate  = _theComponent
                        if _theComponent.getName() == "user_includeCurrencies": the_includeCurrencies  = _theComponent
                        if _theComponent.getName() == "user_includeSecurities": the_includeSecurities  = _theComponent
                        if _theComponent.getName() == "user_purgeOrphans": the_purgeOrphans  = _theComponent
                        if _theComponent.getName() == "user_purgeBase": the_purgeBase  = _theComponent
                        if _theComponent.getName() == "user_age_limit_days": the_age_limit_days  = _theComponent
                        if _theComponent.getName() == "user_max_days_between_thinned": the_max_days_between_thinned  = _theComponent
                        if _theComponent.getName() == "user_SaveTrunk": the_SaveTrunk  = _theComponent
                        if _theComponent.getName() == "user_VERBOSE": the_VERBOSE  = _theComponent

                if the_simulate:
                    if not the_simulate.isSelected():
                        if saveDropDownStateToo.getSelectedIndex() > 0:
                            the_SaveTrunk.setEnabled(True)
                        else:
                            the_SaveTrunk.setEnabled(False)
                            the_SaveTrunk.setSelected(False)
                    else:
                        the_SaveTrunk.setEnabled(False)
                        the_SaveTrunk.setSelected(False)

                # noinspection PyUnresolvedReferences
                if the_purgeOrThinMode:
                    if the_purgeOrThinMode.getSelectedItem().lower().startswith("<DO NOTHING>".lower()):        # noqa
                        the_age_limit_days.setEnabled(False)
                        the_max_days_between_thinned.setEnabled(False)
                        the_includeCurrencies.setEnabled(False)
                        the_includeSecurities.setEnabled(False)
                        the_purgeOrphans.setEnabled(False)
                        the_purgeBase.setEnabled(False)
                        the_SaveTrunk.setEnabled(False)
                        the_VERBOSE.setEnabled(False)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Thin Mode".lower()):         # noqa
                        the_age_limit_days.setEnabled(True)
                        the_age_limit_days.setText("90")
                        the_max_days_between_thinned.setEnabled(True)
                        the_max_days_between_thinned.setText("7")
                        the_includeCurrencies.setEnabled(True)
                        the_includeSecurities.setEnabled(True)
                        the_purgeOrphans.setEnabled(self.iOrphs>0)
                        the_purgeBase.setEnabled(MD_REF.getCurrentAccountBook().getCurrencies().getBaseType().getSnapshots().size()>0)
                        the_SaveTrunk.setEnabled(True)
                        the_VERBOSE.setEnabled(True)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Purge Mode".lower()):        # noqa
                        the_age_limit_days.setEnabled(True)
                        the_age_limit_days.setText("730")
                        the_max_days_between_thinned.setText("")
                        the_max_days_between_thinned.setEnabled(False)
                        the_includeCurrencies.setEnabled(True)
                        the_includeSecurities.setEnabled(True)
                        the_purgeOrphans.setEnabled(self.iOrphs>0)
                        the_purgeBase.setEnabled(MD_REF.getCurrentAccountBook().getCurrencies().getBaseType().getSnapshots().size()>0)
                        the_SaveTrunk.setEnabled(True)
                        the_VERBOSE.setEnabled(True)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Only Delete Orphans".lower()):  # noqa
                        if self.iOrphs>0:
                            the_age_limit_days.setEnabled(False)
                            the_age_limit_days.setText("")
                            the_max_days_between_thinned.setText("")
                            the_max_days_between_thinned.setEnabled(False)
                            the_includeCurrencies.setEnabled(True)
                            the_includeCurrencies.setSelectedIndex(1)
                            the_includeSecurities.setEnabled(True)
                            the_includeSecurities.setSelectedIndex(1)
                            the_purgeOrphans.setEnabled(False)
                            the_purgeOrphans.setSelected(False)
                            the_purgeBase.setEnabled(False)
                            the_purgeBase.setSelected(False)
                            the_VERBOSE.setEnabled(True)
                            if not(the_simulate.isSelected()):
                                the_SaveTrunk.setEnabled(True)
                        else:
                            the_purgeOrThinMode.setSelectedIndex(0)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Only Delete Base Records".lower()):  # noqa
                        if MD_REF.getCurrentAccountBook().getCurrencies().getBaseType().getSnapshots().size()>0:
                            the_age_limit_days.setEnabled(False)
                            the_age_limit_days.setText("")
                            the_max_days_between_thinned.setText("")
                            the_max_days_between_thinned.setEnabled(False)
                            the_includeCurrencies.setEnabled(False)
                            the_includeCurrencies.setSelectedIndex(1)
                            the_includeSecurities.setEnabled(False)
                            the_includeSecurities.setSelectedIndex(1)
                            the_purgeOrphans.setEnabled(False)
                            the_purgeOrphans.setSelected(False)
                            the_purgeBase.setEnabled(False)
                            the_purgeBase.setSelected(False)
                            the_VERBOSE.setEnabled(True)
                            if not(the_simulate.isSelected()):
                                the_SaveTrunk.setEnabled(True)
                        else:
                            the_purgeOrThinMode.setSelectedIndex(0)

                return

        userFilters.add(label_simulate)
        userFilters.add(user_simulate)
        userFilters.add(labelPurgeOrThinMode)
        userFilters.add(user_purgeOrThinMode)
        userFilters.add(label_age_limit_days)
        userFilters.add(user_age_limit_days)
        userFilters.add(label_max_days_between_thinned)
        userFilters.add(user_max_days_between_thinned)
        userFilters.add(label_includeCurrencies)
        userFilters.add(user_includeCurrencies)
        userFilters.add(label_includeSecurities)
        userFilters.add(user_includeSecurities)
        userFilters.add(labelPurgeOrphans)
        userFilters.add(user_purgeOrphans)
        userFilters.add(labelPurgeBase)
        userFilters.add(user_purgeBase)
        userFilters.add(labelSaveTrunk)
        userFilters.add(user_SaveTrunk)
        userFilters.add(labelVERBOSE)
        userFilters.add(user_VERBOSE)
        userFilters.add(labelSTATUS)
        userFilters.add(labelSTATUS2)

        components = userFilters.getComponents()
        for theComponent in components:
            if isinstance(theComponent, (JComboBox,JTextField,JCheckBox)):
                theComponent.addActionListener(PanelAction( userFilters, orphanSnaps))

        while True:
            options = ["EXIT", "PROCEED"]
            userAction = (JOptionPane.showOptionDialog(jif,
                                                       userFilters,
                                                       "THIN PRICE HISTORY",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))
            if userAction != 1:
                txt = "THIN PRICE HISTORY - No changes made....."
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            lDoNOTHING = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 0
            lThinMode = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 1
            lPurgeMode = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 2
            purgeOrphansONLY = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 3
            purgeBaseONLY = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 4

            simulate = user_simulate.isSelected()
            age_limit_days = user_age_limit_days.getText()
            max_days_between_thinned = user_max_days_between_thinned.getText()
            purgeOrphans = user_purgeOrphans.isSelected()
            purgeBase = user_purgeBase.isSelected()
            confirmedSaveTrunk = user_SaveTrunk.isSelected()
            VERBOSE = user_VERBOSE.isSelected()

            if isinstance(user_includeCurrencies.getSelectedItem(),(str,unicode)):
                if str(user_includeCurrencies.getSelectedItem()).startswith("<ALL"):
                    includeCurrencies=True
                elif str(user_includeCurrencies.getSelectedItem()).startswith("<EXCL"):
                    includeCurrencies=False
                else:
                    raise(Exception("THIN PRICE HISTORY INCLUDE CURRENCIES PARAMETER ERROR"))
            elif isinstance(user_includeCurrencies.getSelectedItem(),(CurrencyType)):
                includeCurrencies = user_includeCurrencies.getSelectedItem()
            else:
                raise(Exception("THIN PRICE HISTORY INCLUDE CURRENCIES PARAMETER ERROR2"))

            if isinstance(user_includeSecurities.getSelectedItem(),(str,unicode)):
                if str(user_includeSecurities.getSelectedItem()).startswith("<ALL"):
                    includeSecurities=True
                elif str(user_includeSecurities.getSelectedItem()).startswith("<EXCL"):
                    includeSecurities=False
                else:
                    raise(Exception("THIN PRICE HISTORY INCLUDE SECURITIES PARAMETER ERROR"))
            elif isinstance(user_includeSecurities.getSelectedItem(),(CurrencyType)):
                includeSecurities = user_includeSecurities.getSelectedItem()
            else:
                raise(Exception("THIN PRICE HISTORY INCLUDE SECURITIES PARAMETER ERROR2"))

            paramError=False
            labelSTATUS.setText("")
            labelSTATUS.setForeground(getColorRed())

            if lDoNOTHING:
                labelSTATUS.setText("ERROR: I CANNOT DO NOTHING? PLEASE CHOOSE AN OPTION!")
                continue

            if lThinMode or lPurgeMode:
                # noinspection PyChainedComparsons
                if not StringUtils.isInteger(age_limit_days) or not (int(age_limit_days) >0 and int(age_limit_days) <= (365*5)):        # noqa
                    user_age_limit_days.setForeground(getColorRed())
                    labelSTATUS.setText("ERROR: age limit days parameter must be between 0 and 1825 (5 years)")
                    paramError=True
                else:
                    age_limit_days=int(age_limit_days)
                    user_age_limit_days.setForeground(saveColor)
            else:
                age_limit_days=0

            if lThinMode:
                # noinspection PyChainedComparsons
                if not StringUtils.isInteger(max_days_between_thinned) or not (int(max_days_between_thinned) >0 and int(max_days_between_thinned) <= (31)):   # noqa
                    user_max_days_between_thinned.setForeground(getColorRed())
                    labelSTATUS.setText("ERROR: max days between dates parameter must be between 0 and 31")
                    paramError=True
                else:
                    max_days_between_thinned=int(max_days_between_thinned)
                    user_max_days_between_thinned.setForeground(saveColor)
            else:
                max_days_between_thinned = 0

            if purgeOrphans and purgeOrphansONLY:
                user_purgeOrphans.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: you cannot select both purge Orphans and purge ONLY orphans")
                paramError = True
            else:
                user_purgeOrphans.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if (purgeOrphans or purgeOrphansONLY) and orphanSnaps < 1:
                user_purgeOrphans.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: You have no Orphan records to purge - please deselect these options")
                paramError = True
            else:
                user_purgeOrphans.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if purgeBase and purgeBaseONLY:
                user_purgeBase.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: you cannot select both delete Base records and delete ONLY base records")
                paramError = True
            else:
                user_purgeBase.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if (purgeBase or purgeBaseONLY) and MD_REF.getCurrentAccountBook().getCurrencies().getBaseType().getSnapshots().size() < 1:
                user_purgeBase.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: You have no Base Currency snapshot records to delete - please deselect these options")
                paramError = True
            else:
                user_purgeBase.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if not includeCurrencies and not includeSecurities and (lThinMode or lPurgeMode or purgeOrphansONLY):
                user_includeSecurities.setForeground(getColorRed())
                user_includeCurrencies.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: Please select Security(s) / Currency(s) to process/filter...")
                paramError = True
            else:
                user_includeSecurities.setForeground(saveColor)
                user_includeCurrencies.setForeground(saveColor)

            if (includeCurrencies or includeSecurities) and (purgeBaseONLY):
                user_includeSecurities.setForeground(getColorRed())
                user_includeCurrencies.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: Delete Base Currency records IGNORES filters. Please Deselect Security(s) / Currency(s) filter(s)...")
                paramError = True
            else:
                user_includeSecurities.setForeground(saveColor)
                user_includeCurrencies.setForeground(saveColor)

            if paramError: continue

            break

        components = userFilters.getComponents()
        for theComponent in components:
            if isinstance(theComponent, (JComboBox,JTextField, JCheckBox)):
                for al in theComponent.getActionListeners():
                    theComponent.removeActionListener(al)
        del userFilters

        if lDoNOTHING: raise Exception("ERROR: Why is lDoNOTHING set?")

        if not simulate:
            if not confirm_backup_confirm_disclaimer(jif, "THIN PRICE HISTORY", "Thin Price History?"):
                return

        jif.dispose()       # already within the EDT

        myPrint("B","THIN PRICE HISTORY - User choose parameters: "
                    "Simulate: %s "
                    "Thin Mode: %s "
                    "Purge Mode: %s "
                    "age_limit_days: %s "
                    "max_days_between_thinned: %s "
                    "includeCurrencies: %s "
                    "includeSecurities: %s "
                    "purgeOrphans: %s "
                    "purgeOrphansONLY: %s "
                    "purgeBase: %s"
                    "purgeBaseONLY: %s"
                    "SaveTrunk: %s"
                    "verbose: %s"
                %(simulate, lThinMode, lPurgeMode, age_limit_days, max_days_between_thinned, includeCurrencies, includeSecurities, purgeOrphans, purgeOrphansONLY, purgeBase, purgeBaseONLY, confirmedSaveTrunk,  VERBOSE))

        del orphanSnaps

        def prune_snapshots(_curr, THINMODE, age_limit_days, max_days_between_thinned, lDelete=False, lVerbose=False):        # noqa

            if THINMODE: ThnTxt="THIN"
            else: ThnTxt="PURGE"

            age_limit_date = DateUtil.incrementDate(DateUtil.getStrippedDateInt(), 0, 0, -(age_limit_days))
            text = "\n>%s: %s'ing snapshots older than %s\n" %(_curr, ThnTxt, convertStrippedIntDateFormattedText(age_limit_date))
            text += "  %s BEFORE %s (snapshots: %s, splits: %s)\n"%(_curr, ThnTxt, _curr.getSnapshots().size(), _curr.getSplits().size())
            _snapshots = _curr.getSnapshots()
            old_snapshots = []
            countChanges  = 0
            saveFirstSnapPreserved = None
            for snapshot in _snapshots:
                if snapshot.getDateInt() < age_limit_date:
                    if len(old_snapshots)+1 >= len(_snapshots):
                        text += "  > NOTE: Preserving the newest and last Price History record (so you always have 1): %s\n" %snapshot
                        saveFirstSnapPreserved = snapshot.getDateInt()
                    else:
                        old_snapshots.append(snapshot)
                else:
                    if saveFirstSnapPreserved is None:
                        saveFirstSnapPreserved = snapshot.getDateInt()

            if saveFirstSnapPreserved is None:
                myPrint("B","@@ LOGIC ERROR why saveFirstSnapPreserved == None?")
                saveFirstSnapPreserved = age_limit_date

            last_date = 0
            text += "  %s snapshot(s) are older than cutoff date and eligible to be %s'd'..\n" %(len(old_snapshots),ThnTxt)
            num_thinned = 0
            # This presumes the data is presented oldest, to newest, which the inbuilt comparator/sort seems to do...

            # for snapshot in old_snapshots:
            for _i in range(0, len(old_snapshots)):
                snapshot = old_snapshots[_i]
                snap_date = snapshot.getDateInt()

                if _i+1 < len(old_snapshots):                        # not at end of the records
                    safetyDate = old_snapshots[_i + 1].getDateInt()    # take a peek at the next record..
                else:
                    safetyDate = saveFirstSnapPreserved

                if (not THINMODE) \
                        or (THINMODE and DateUtil.calculateDaysBetween(last_date, snap_date) < max_days_between_thinned
                            and DateUtil.calculateDaysBetween(last_date, safetyDate) < max_days_between_thinned+1):  # This ensures there's no huge leap to the next date......
                    if lVerbose:
                        text += "    *** delete snapshot dated %s\n" %(convertStrippedIntDateFormattedText(snap_date))
                    num_thinned += 1
                    if lDelete:
                        if lVerbose:
                            myPrint("B","%s PRICE HISTORY: Deleting snapshot: %s" %(ThnTxt,repr(snapshot)))
                        countChanges += 1
                        snapshot.deleteItem()
                else:
                    # don't thin this snapshot, and set the last seen date to it
                    if  lVerbose:
                        text += "    > Not deleting snapshot dated %s (preserving 1 per interval specified)\n" %(convertStrippedIntDateFormattedText(snap_date))
                    last_date = snap_date
                _i+=1

            if len(old_snapshots):
                text += "  >> %s'd %s of %s eligible (old) snapshots (%s percent) from %s\n"%(ThnTxt, num_thinned, len(old_snapshots), 100*num_thinned/len(old_snapshots), _curr.getName())
                text += "  >> %s'd %s of %s total snapshots          (%s percent) from %s\n"%(ThnTxt, num_thinned, len(_snapshots), 100*num_thinned/len(_snapshots), _curr.getName())
            else:
                text += "  >> No old snapshots %s'd from %s\n" %(ThnTxt, _curr.getName())

            return text, countChanges

        def prune_all_snapshots(THIN_MODE, age_limit_days, max_days_between_thinned, incCurrencies, incSecurities, lVerbose=False, lDelete=False):       # noqa
            countTheChanges = 0
            _currs = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
            lastC = None
            text = ""

            if THIN_MODE: Thn_Txt = "THIN"
            else: Thn_Txt = "PURGE"

            theList = []
            if incCurrencies: theList.append(CurrencyType.Type.CURRENCY)                                                # noqa
            if incSecurities: theList.append(CurrencyType.Type.SECURITY)                                                # noqa

            for theCType in theList:

                for _curr in _currs:

                    if _curr.getCurrencyType() != theCType: continue

                    if (_curr.getCurrencyType() == CurrencyType.Type.CURRENCY                                           # noqa
                            and incCurrencies and isinstance(incCurrencies,(CurrencyType)) and _curr != incCurrencies):
                        continue
                    if (_curr.getCurrencyType() == CurrencyType.Type.SECURITY                                           # noqa
                            and incSecurities and isinstance(incSecurities,(CurrencyType)) and _curr != incSecurities):
                        continue

                    if lastC != _curr.getCurrencyType():
                        text+="\n%s:\n" %_curr.getCurrencyType()
                        lastC = _curr.getCurrencyType()

                    _snaps = _curr.getSnapshots()
                    if _snaps.size() >= 1:
                        _txt, _i = prune_snapshots(_curr, THIN_MODE, age_limit_days, max_days_between_thinned, lDelete, lVerbose)
                        text += _txt
                        countTheChanges += _i
                        _snaps = _curr.getSnapshots()
                        text += "  %s AFTER %s (snapshots: %s, splits: %s)\n"%(_curr, Thn_Txt, _snaps.size(), _curr.getSplits().size())
            return text, countTheChanges

        def prune_orphans(_orphans, incCurrencies, incSecurities, lVerbose=False, lDelete=False):

            iPurgeCount=0

            _orphanSnaps = len(_orphans)
            text = "\nReviewing 'orphan' (or duplicates/stranded) snaps...:\n"

            theList = []                                                                                                # noqa
            theList.append(None)
            if incCurrencies: theList.append(CurrencyType.Type.CURRENCY)                                                # noqa
            if incSecurities: theList.append(CurrencyType.Type.SECURITY)                                                # noqa

            filteredOrphanList=[]
            for theCType in theList:
                for _o in _orphans:
                    theCurr = _o.getCurrencyParameter(None, "curr", None)

                    if theCType is None:
                        if theCurr is not None: continue
                    else:
                        if theCurr.getCurrencyType() != theCType: continue

                    if theCurr:
                        if (theCurr.getCurrencyType() == CurrencyType.Type.CURRENCY                                                  # noqa
                                and incCurrencies and isinstance(incCurrencies,(CurrencyType)) and theCurr != incCurrencies):
                            continue
                        if (theCurr.getCurrencyType() == CurrencyType.Type.SECURITY                                                   # noqa
                                and incSecurities and isinstance(incSecurities,(CurrencyType)) and theCurr != incSecurities):
                            continue
                    filteredOrphanList.append(_o)

            del _orphans

            if len(filteredOrphanList) < 1:
                text += "\nNo *filtered* currency or security snapshots were 'orphans' (duplicates/stranded)\n\n"
            else:
                text += "\n%s *filtered* currency or security snapshots were 'orphans' (duplicates/stranded)\n\n"%(len(filteredOrphanList))
                if lDelete:
                    myPrint("B","Logging 'orphan' snaps for deletion....")
                    text += "Logging 'orphan' snaps for deletion....\n"
                    if lVerbose:
                        for _o in filteredOrphanList:
                            text += "Logging 'Orphan' to delete: %s\n" %(repr(_o))
                            myPrint("B","Logging 'Orphan' to delete: %s" %(repr(_o)))
                    MD_REF.getCurrentAccountBook().logRemovedItems(filteredOrphanList)
                    iPurgeCount += len(filteredOrphanList)
                else:
                    if lVerbose:
                        for _o in filteredOrphanList: text += "  'Orphan' found: %s\n" %(_o)
                    text += "\nSimulation so no 'orphan' snaps will be deleted....\n"
            del filteredOrphanList

            return text, iPurgeCount

        if lThinMode: ThnPurgeTxt="THIN"
        elif lPurgeMode: ThnPurgeTxt="PURGE"
        elif purgeOrphansONLY: ThnPurgeTxt="PURGE ORPHANS"
        elif purgeBaseONLY: ThnPurgeTxt="PURGE BASE CURRENCY RECORDS"
        else: ThnPurgeTxt="THIN/PURGE"

        if simulate: x = "SIMULATE"
        else: x = "DATABASE UPDATE"

        purgingMsg = MyPopUpDialogBox(toolbox_frame_,
                                      "Please wait: Processing your %s request (%s).." %(ThnPurgeTxt,x),
                                      theTitle="FIX - Thin/Purge",
                                      lModal=False, OKButtonText="WAIT")
        purgingMsg.go()

        diagDisplay += "\n\n *** EXECUTING %s PRICE HISTORY ***\n" %(ThnPurgeTxt)
        diagDisplay += "\nUser choose parameters:\n" \
                       " >> Simulate:                 %s\n" \
                       " >> Purge Mode:               %s\n" \
                       " >> Thin Mode:                %s\n" \
                       " >> age_limit_days:           %s (%s)\n" \
                       " >> max_days_between_thinned: %s\n" \
                       " >> includeCurrencies:        %s\n" \
                       " >> includeSecurities:        %s\n" \
                       " >> purgeOrphans:             %s\n" \
                       " >> purgeOrphansONLY:         %s\n" \
                       " >> purgeBase:                %s\n" \
                       " >> purgeBaseONLY:            %s\n" \
                       " >> confirmedSaveTrunk:       %s\n" \
                       " >> VERBOSE:                  %s\n" \
                       %(simulate,
                         lPurgeMode,
                         lThinMode,
                         age_limit_days,
                         convertStrippedIntDateFormattedText(DateUtil.incrementDate(DateUtil.getStrippedDateInt(), 0, 0, -(age_limit_days))),
                         max_days_between_thinned,
                         includeCurrencies,
                         includeSecurities,
                         purgeOrphans,
                         purgeOrphansONLY,
                         purgeBase,
                         purgeBaseONLY,
                         confirmedSaveTrunk,
                         VERBOSE)

        diagDisplay+="\n%s PRICE HISTORY\n" \
                     " =================\n" %(ThnPurgeTxt)

        if not simulate:
            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
            MD_REF.getCurrentAccountBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)
            SyncerDebug.changeState(debug)

        if simulate:
            diagDisplay += "\n ** SIMULATION MODE - NO CHANGES MADE ** \n"
        else:
            diagDisplay += "\n ** %s MODE - CHANGES BEING MADE! ** \n" %(ThnPurgeTxt)

        if purgeOrphans or purgeOrphansONLY:
            x,i = prune_orphans(orphans_to_delete, includeCurrencies, includeSecurities, lVerbose=VERBOSE, lDelete=(not simulate))
            diagDisplay += x
            totalChangesMade += i

        if purgeBase or purgeBaseONLY:
            x,i = does_base_has_snaps(lDelete=(not simulate), lVerbose=VERBOSE)
            diagDisplay += x
            totalChangesMade += i

        if lPurgeMode or lThinMode:  # Mutually exclusive!
            txt, i = prune_all_snapshots(lThinMode, age_limit_days, max_days_between_thinned, includeCurrencies, includeSecurities, lVerbose=VERBOSE, lDelete=(not simulate))
            diagDisplay += txt
            totalChangesMade += i

        if not simulate:
            SyncerDebug.resetState()
            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccountBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        if confirmedSaveTrunk:
            if not simulate:
                if totalChangesMade > 0:
                    myPrint("B","%s PRICE HISTORY: Calling saveTrunkFile()...." %(ThnPurgeTxt))
                    diagDisplay += "\n\n ======\nSaving Trunk File.....\n ======\n\n"
                    MD_REF.getCurrentAccountBook().saveTrunkFile()
                else:
                    myPrint("B","%s PRICE HISTORY: No changes made - so NOT Calling saveTrunkFile()...." %(ThnPurgeTxt))
                    diagDisplay += "No changes made, so **NOT** Saving Trunk File.....\n"
            else:
                diagDisplay += "Simulation mode >> (Not) Saving Trunk File.....\n"

        purgingMsg.kill()

        diagDisplay+="\n\n ANALYSIS AFTER %s:\n" %(ThnPurgeTxt)
        diagDisplay+=" ==============================\n"

        diagDisplay += objects_by_type()

        diagDisplay += snaps_by_currency()

        diagDisplay+="\n"

        if simulate:
            x = "SIMULATION MODE ONLY"
        else:
            x = "UPDATE/%s MODE" %(ThnPurgeTxt)

        if totalChangesMade > 0:
            diagDisplay += ("\n\n *** %s changes were made! ***\n\n" %(totalChangesMade)).upper()
        else:
            diagDisplay += "\n\n *** no changes were made! ***\n\n".upper()

        diagDisplay+="\n%s PRICE HISTORY in %s COMPLETED!\n" %(ThnPurgeTxt, x)
        diagDisplay+="\n<END>"

        txt = "%s PRICE HISTORY - %s >> Successfully executed (%s changes made)" %(ThnPurgeTxt, x, totalChangesMade)
        setDisplayStatus(txt, "R"); myPrint("B", txt)

        jif = QuickJFrame("Price History Analysis", diagDisplay, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False,
                          lRestartMDAfterClose=(not simulate and totalChangesMade > 0)).show_the_frame()
        if simulate:
            MyPopUpDialogBox(jif, "%s PRICE HISTORY - %s >> Successfully executed" %(ThnPurgeTxt,x),"",theTitle="THIN/PRUNE PRICE HISTORY").go()
        else:
            logToolboxUpdates("thin_price_history", txt)
            if (not simulate and totalChangesMade > 0): disableToolboxButtons()

            if totalChangesMade > 0:
                play_the_money_sound()
                MyPopUpDialogBox(jif,
                                 "%s PRICE HISTORY - %s >> Successfully executed %s changes - MD WILL RESTART AFTER VIEWING THIS OUTPUT" %(ThnPurgeTxt,x,totalChangesMade),
                                 theTitle="THIN/PRUNE PRICE HISTORY").go()
            else:
                MyPopUpDialogBox(jif,
                                 "%s PRICE HISTORY - %s >> Successfully executed - NO CHANGES NECESSARY / MADE" %(ThnPurgeTxt,x),
                                 theTitle="THIN/PRUNE PRICE HISTORY").go()

    def extract_attachments():
        _THIS_METHOD_NAME = "EXTRACT ATTACHMENTS"

        ask = MyPopUpDialogBox(toolbox_frame_,"EXTRACT ATTACHMENTS - For Your Information",
                             "This will extract all your attachments to a directory....\n"
                             "There is also an extension which will extract attachments alongside your Investment or Bank Account Registers\n"
                             ">> Extension: 'Extract Data' available from MD menu >> Manage Extensions\n"
                             "Please select a directory to extract attachments to...\n"
                             "I will create a sub-directory called 'EXTRACT_MD_ATTACHMENTS-x' (I will append a unique number)",
                             theTitle=_THIS_METHOD_NAME,
                             OKButtonText="PROCEED", lCancelButton=True)
        if not ask.go(): return

        while True:
            lExit = False

            _theTitle = "Select location to Extract Attachments to... (CANCEL=ABORT)"
            theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                                get_home_dir(),         # Starting path
                                                None,                   # Default Filename
                                                _theTitle,              # Title
                                                False,                  # Multi-file selection mode
                                                True,                   # True for Open/Load, False for Save
                                                False,                  # True = Files, else Dirs
                                                "EXTRACT ATTACHMENTS",  # Load/Save button text, None for defaults
                                                None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=False,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

            if theDir is None or theDir == "":
                _txt = "%s: User did not select Extract Directory to put attachments... Aborting" %(_THIS_METHOD_NAME)
                myPopupInformationBox(None, _txt)
                lExit = True
                break

            if not os.path.exists(theDir):
                myPopupInformationBox(None, "ERROR - the folder does not exist?", _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
                continue

            theDir = os.path.join(theDir,"EXTRACT_MD_ATTACHMENTS-%s" %(UUID.randomUUID().toString()))
            if os.path.exists(theDir):
                myPopupInformationBox(None, "SORRY - the folder %s already exists... I need to create it myself...", _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
                continue

            break

        iSkip = 0
        iCountAttachments = 0
        textLog = "\n%s:\n" \
                  " ===================\n\n" %(_THIS_METHOD_NAME)

        textLog += "Base extract folder: %s%s\n\n" %(theDir, os.path.sep)
        textRecords = []

        if not lExit and theDir is not None:
            exportFolder = theDir

            txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()

            File(exportFolder).mkdirs()

            myPrint("B", "Will export all attachments to %s"%(exportFolder))

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: extracting attachments..",
                                          theTitle=_THIS_METHOD_NAME,
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            for txn in txnSet.iterableTxns():
                for attachKey in txn.getAttachmentKeys():
                    iCountAttachments+=1
                    attachTag = txn.getAttachmentTag(attachKey)
                    txnDate = txn.getDateInt()
                    attachFile = File(attachTag).getName()
                    attachFolder = os.path.join(exportFolder,"ACCT-TYPE-%s"%(txn.getAccount().getAccountType()),"ACCT-%s" %(txn.getAccount().getAccountName()))
                    File(attachFolder).mkdirs()
                    outputPath = os.path.join(attachFolder, "{:04d}-{:02d}-{:02d}-{}-{}".format(txnDate/10000, (txnDate/100)%100,  txnDate%100, str(iCountAttachments).zfill(5), attachFile))
                    if os.path.exists(outputPath):
                        iSkip += 1
                        myPrint("B", "Error - path: %s already exists... SKIPPING THIS ONE!" %outputPath)
                        textLog += ("Error - path: %s already exists... SKIPPING THIS ONE!\n" %outputPath)
                    else:
                        myPrint("P", "Exporting attachment [%s]" %(os.path.basename(outputPath)))
                        try:
                            outStream = FileOutputStream(File(outputPath))
                            inStream = convertBufferedSourceToInputStream(MD_REF.getCurrentAccountBook().getLocalStorage().openFileForReading(attachTag))
                            MDIOUtils.copyStream(inStream, outStream)
                            outStream.close()
                            inStream.close()
                            textRecords.append([txn.getAccount().getAccountType(), txn.getAccount().getAccountName(), txn.getDateInt(),
                                                "%s %s %s %s %s .%s\n"
                                                %(pad(str(txn.getAccount().getAccountType()),15),pad(txn.getAccount().getAccountName(),30),convertStrippedIntDateFormattedText(txn.getDateInt()),rpad(txn.getValue()/100.0,10),pad(txn.getDescription(),20),outputPath[len(exportFolder):])])
                        except:
                            txt = "Error extracting file - will SKIP : %s" %(outputPath)
                            myPrint("B", txt)
                            textLog += ("%s\n" %(txt))
                            iSkip += 1

            textRecords = sorted(textRecords, key=lambda _sort: (_sort[0], _sort[1], _sort[2]))
            for r in textRecords:
                textLog += r[3]

            if iSkip: textLog += "\nERRORS/SKIPPED: %s (review console log for details)\n" %(iSkip)

            textLog += "\n<END>"

            try:
                log = open(os.path.join(exportFolder,"Extract_Attachments_LOG.txt"), "w")
                log.write(textLog)
                log.close()
            except: pass

            pleaseWait.kill()

            txt = "%s: FINISHED: %s attachments extracted (%s skipped)..." %(_THIS_METHOD_NAME,iCountAttachments,iSkip)
            setDisplayStatus(txt, "B"); myPrint("B", txt)

            logToolboxUpdates("extract_attachments", txt)
            play_the_money_sound()

            if iSkip < 1:
                myPopupInformationBox(toolbox_frame_,"%s attachments extracted.." %(iCountAttachments), theTitle=_THIS_METHOD_NAME)
            else:
                myPopupInformationBox(toolbox_frame_,"%s attachments extracted.. AND YOU HAD %s Missing/Errors?" %(iCountAttachments,iSkip),theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

            try: MD_REF.getPlatformHelper().openDirectory(File(exportFolder))
            except: pass

        else:
            txt = "%s: NO ATTACHMENTS EXTRACTED!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)

        return

    def diagnose_attachments(lFix=False):
        if MD_REF.getCurrentAccountBook() is None: return

        if lFix:
            MyPopUpDialogBox(toolbox_frame_,
                             "NOTE: You already have Syncing disabled - Good!\n"
                             "There is a flaw in Moneydance Syncing as regards attachments when Syncing is ON\n"
                             "Deleted attachments will keep re-appearing as they Syncronise from Sync/Dropbox/Secondary machines\n"
                             "You have to disable Sync, manually delete your sync Folder/Data, then delete the Orphans (using this tool)\n"
                             "Then re-enable Sync, Wait for Sync to complete, then re-enable Sync on secondary devices...\n"
                             "<GOOD LUCK!>",
                             theTitle="ATTACHMENT ANALYSIS & DELETION OF ORPHANS",
                             lModal=True,OKButtonText="ACKNOWLEDGE")

        scanningMsg = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching Database and filesystem for attachments..",
                                       theTitle="ATTACHMENT(S) SEARCH",
                                       lModal=False, OKButtonText="WAIT")
        scanningMsg.go()

        myPrint("P", "Scanning database for attachment data..")
        book = MD_REF.getCurrentAccountBook()

        attachmentList = {}
        attachmentLocations = {}

        iObjectsScanned = 0
        iTxnsScanned = 0

        iTxnsWithAttachments = 0
        iAttachmentsFound = 0
        iAttachmentsNotInLS = 0
        iDuplicateKeys = 0
        attachmentsNotInLS = []

        diagDisplay = "ANALYSIS OF ATTACHMENTS\n\n"

        attachmentFullPath = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME, MD_REF.getCurrentAccountBook().getAttachmentsFolder())

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()

        txnSet = book.getTransactionSet()
        for _mdItem in txnSet.iterableTxns():

            iObjectsScanned += 1

            iTxnsScanned += 1

            if not (_mdItem.hasAttachments() or len(_mdItem.getAttachmentKeys())>0): continue

            iTxnsWithAttachments += 1
            x = "Found Record with %s Attachment(s): %s" %(len(_mdItem.getAttachmentKeys()),_mdItem)
            if debug: diagDisplay += (x + "\n")

            if attachmentList.get(_mdItem.getUUID()):
                iDuplicateKeys += 1
                x="@@ Error %s already exists in my attachment list...!?" %_mdItem.getUUID()
                myPrint("DB", x)
                if debug: diagDisplay+=(x+"\n")

            attachmentList[_mdItem.getUUID()] = [
                _mdItem.getUUID(),
                _mdItem.getAccount().getAccountName(),
                _mdItem.getAccount().getAccountType(),
                _mdItem.getDateInt(),
                _mdItem.getValue(),
                _mdItem.getAttachmentKeys()
            ]
            x = "Attachment keys: %s" %_mdItem.getAttachmentKeys()
            if debug: diagDisplay += ( x + "\n")

            for _key in _mdItem.getAttachmentKeys():
                iAttachmentsFound += 1
                if attachmentLocations.get(_mdItem.getAttachmentTag(_key)):
                    iDuplicateKeys += 1
                    x="@@ Error %s already exists in my attachment location list...!?" %_mdItem.getUUID()
                    myPrint("B", )
                    if debug: diagDisplay += (x + "\n")

                attachmentLocations[_mdItem.getAttachmentTag(_key)] = [
                    _mdItem.getAttachmentTag(_key),
                    _key,
                    _mdItem.getUUID(),
                    LS.exists(_mdItem.getAttachmentTag(_key))
                ]
                if not LS.exists(_mdItem.getAttachmentTag(_key)):
                    iAttachmentsNotInLS += 1
                    attachmentsNotInLS.append([
                        _mdItem.getUUID(),
                        _mdItem.getAccount().getAccountName(),
                        _mdItem.getAccount().getAccountType(),
                        _mdItem.getDateInt(),
                        _mdItem.getValue(),
                        _mdItem.getAttachmentKeys()
                    ])

                    x = "@@ Error - Attachment for Txn DOES NOT EXIST! - Attachment tag: %s" %_mdItem.getAttachmentTag(_key)
                    myPrint("B", x)
                    diagDisplay += (x + "\n")
                else:
                    x = "Attachment tag: %s" %_mdItem.getAttachmentTag(_key)
                    if debug: diagDisplay += (x + "\n")


        # Now scan the file system for attachments
        myPrint("P", "Now scanning attachment directory(s) and files...:")

        attachmentsRawListFound = []

        typesFound = {}

        for root, dirs, files in os.walk(attachmentFullPath):

            for name in files:
                theFile = os.path.join(root,name)[len(attachmentFullPath)-len(MD_REF.getCurrentAccountBook().getAttachmentsFolder()):]
                byteSize = os.path.getsize(os.path.join(root,name))
                modified = datetime.datetime.fromtimestamp(os.path.getmtime(os.path.join(root,name))).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True))
                attachmentsRawListFound.append([theFile, byteSize, modified, os.path.join(root,name)])
                theExtension = os.path.splitext(theFile)[1].lower()

                iCountExtensions = 0
                iBytes = 0
                if typesFound.get(theExtension):
                    iCountExtensions = typesFound.get(theExtension)[1]
                    iBytes = typesFound.get(theExtension)[2]
                typesFound[theExtension] = [theExtension, iCountExtensions+1, iBytes+byteSize ]

                x = "Found Attachment File: %s" %(theFile)
                if debug: diagDisplay += (x + "\n")

        # Now match file system to the list from the database
        iOrphans = 0
        iOrphanBytes = 0

        orphanList = []

        for fileDetails in attachmentsRawListFound:
            deriveTheKey = fileDetails[0]
            deriveTheBytes = fileDetails[1]
            deriveTheModified = fileDetails[2]
            deriveRawPath = fileDetails[3]
            if attachmentLocations.get(deriveTheKey.replace(os.path.sep, "/")):
                x = "Attachment file system link found in Moneydance database"
                if debug: diagDisplay += (x + "\n")
            else:
                x = "Error: Attachment filesystem link missing in Moneydance database: %s" %deriveTheKey
                myPrint("DB", x)
                if debug: diagDisplay += (x + "\n")
                iOrphans += 1
                iOrphanBytes += deriveTheBytes
                if lFix:
                    orphanList.append([deriveTheKey, deriveTheBytes, deriveTheModified, deriveRawPath])
                else:
                    orphanList.append([deriveTheKey, deriveTheBytes, deriveTheModified])

        msgStr = ""

        myPrint("P", "\n"*5)

        x = " ---------------------------------"
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")

        x = "Objects scanned: %s" %iObjectsScanned
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")

        x = "Transactions scanned: %s" %iTxnsScanned
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")
        x="Transactions with attachments: %s" %iTxnsWithAttachments
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")
        x = "Total Attachments referenced in Moneydance database (a txn may have multi-attachments): %s" %iAttachmentsFound
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")
        x = "Attachments missing from Local Storage: %s" %iAttachmentsNotInLS
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")
        x = "Total Attachments found in file system: %s (difference %s)" %(len(attachmentsRawListFound),len(attachmentsRawListFound)-iAttachmentsFound)
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n")

        myPrint("P", "\n"*1)

        x = "Attachment extensions found: %s" %len(typesFound)
        myPrint("B", x)
        diagDisplay += ("\n" + x + "\n")

        iTotalBytes = 0
        sortedExtensions = sorted(typesFound.values(), key=lambda _x: (_x[2]), reverse=True)

        for x in sortedExtensions:
            iTotalBytes += x[2]

            x = "Extension: %s Number: %s Size: %sMB" %(pad(x[0],6),rpad(x[1],12),rpad(round(x[2]/(1000.0 * 1000.0),2),12))
            myPrint("B", x)
            diagDisplay += (x + "\n")

        x = "Attachments on disk are taking: %sMB" %(round(iTotalBytes/(1000.0 * 1000.0),2))
        myPrint("B", x)
        diagDisplay += (x + "\n")
        msgStr += (x + "\n")
        x = " ---------------------------------"
        myPrint("B", x)
        msgStr += (x + "\n")
        diagDisplay += (x + "\n\n")

        lErrors = False
        if iAttachmentsNotInLS:
            x = "@@ ERROR: You have %s missing attachment(s) referenced on Moneydance Txns!" %(iAttachmentsNotInLS)
            msgStr += x + "\n"
            diagDisplay += (x + "\n\n")
            myPrint("P", "")
            setDisplayStatus(x.upper(), "R"); myPrint("B", x)
            lErrors = True
            attachmentsNotInLS = sorted(attachmentsNotInLS, key=lambda _x: (_x[3]), reverse=False)
            for theOrphanRecord in attachmentsNotInLS:
                x = "Attachment is missing from this Txn: AcctType: %s Account: %s Date: %s Value: %s AttachKey: %s" %(theOrphanRecord[1],
                                                                                                                     theOrphanRecord[2],
                                                                                                                     convertStrippedIntDateFormattedText(theOrphanRecord[3]),
                                                                                                                     theOrphanRecord[4],
                                                                                                                     theOrphanRecord[5])
                myPrint("B", x)
                diagDisplay += (x + "\n")
            diagDisplay += "\n"

        if iOrphans:
            x = "@@ ERROR: %s Orphan attachment(s) found, taking up %sMBs" %(iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2))
            msgStr += x + "\n"
            diagDisplay += (x + "\n\n")
            myPrint("P", "")
            setDisplayStatus(x.upper(), "R"); myPrint("B", x)
            x = "Base Attachment Directory is: %s" %os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME,"")
            myPrint("B", x)
            diagDisplay += (x + "\n")
            lErrors = True
            orphanList = sorted(orphanList, key=lambda _x: (_x[2]), reverse=False)

            for theOrphanRecord in orphanList:

                try:
                    x = "Orphaned Attachment >> Txn Size: %sKB Modified %s for file: %s" %(rpad(round(theOrphanRecord[1]/(1000.0),1),6),
                                                                                         pad(theOrphanRecord[2],19),
                                                                                         theOrphanRecord[0])
                    diagDisplay += (x + "\n")
                    myPrint("B", x)

                except:
                    diagDisplay += dump_sys_error_to_md_console_and_errorlog(True)
                    diagDisplay += "REVIEW MD MENU>HELP>CONSOLE WINDOW FOR DETAILS\n\n"
                    myPrint("B", "@@ record causing issue was.....:")
                    myPrint("B", theOrphanRecord)
                    myPrint("B", "... will continue.....")

        if not lErrors:
            x = "Congratulations! - No orphan attachments detected!".upper()
            diagDisplay += (x + "\n")
            setDisplayStatus(x.upper(), "B"); myPrint("B", x)

        if iAttachmentsFound:
            diagDisplay += "\n\nLISTING VALID ATTACHMENTS FOR REFERENCE\n"
            diagDisplay += " ======================================\n"
            x = "\nBase Attachment Directory is: %s" %os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME, "")
            diagDisplay += (x + "\n-----------\n")

            for validLocation in attachmentLocations:
                locationRecord = attachmentLocations[validLocation]
                record = attachmentList[locationRecord[2]]
                try:
                    diagDisplay+="AT: %s ACT: %s DT: %s Val: %s FILE: %s\n" \
                                 %(pad(repr(record[2]),12),
                                   pad(safeStr(record[1]),20),       # Avoid utf-8 issue!
                                   convertStrippedIntDateFormattedText(record[3]),
                                   rpad(record[4]/100.0,10),
                                   validLocation)

                except:
                    diagDisplay += dump_sys_error_to_md_console_and_errorlog(True)
                    diagDisplay += "REVIEW MD MENU>HELP>CONSOLE WINDOW FOR DETAILS\n\n"
                    myPrint("B", "@@ record causing issue was.....:")
                    myPrint("B", locationRecord)
                    myPrint("B", record)
                    myPrint("B", "... will continue.....")

        if not lFix or not iOrphans: diagDisplay+='\n<END>'

        scanningMsg.kill()

        jif = QuickJFrame("ATTACHMENT ANALYSIS",diagDisplay,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        if iOrphans:
            if lFix:
                theMsg = MyPopUpDialogBox(jif,
                                       "You have %s Orphan attachment(s) found, taking up %sMBs" % (iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2)),
                                          msgStr,
                                          theTitle="ORPHANED ATTACHMENTS",
                                          lCancelButton=False,
                                          OKButtonText="OK",
                                          lAlertLevel=1)
            else:
                theMsg = MyPopUpDialogBox(jif,
                                       "You have %s Orphan attachment(s) found, taking up %sMBs" % (iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2)),
                                          msgStr +"CLICK TO VIEW ORPHANS, or CANCEL TO EXIT",
                                          theTitle="ORPHANED ATTACHMENTS",
                                          lCancelButton=True,
                                          OKButtonText="CLICK TO VIEW",
                                          lAlertLevel=1)
        elif iAttachmentsNotInLS:
            theMsg = MyPopUpDialogBox(jif,
                                   "You have %s missing attachment(s) referenced on Moneydance Txns!" % (iAttachmentsNotInLS),
                                      msgStr,
                                      theTitle="MISSING ATTACHMENTS",
                                      lCancelButton=False,
                                      OKButtonText="OK",
                                      lAlertLevel=1)

        if lErrors:
            pass
        else:
            theMsg = MyPopUpDialogBox(jif,
                                      x,
                                      msgStr,
                                      theTitle="ATTACHMENTS STATUS",
                                      lCancelButton=False,
                                      OKButtonText="OK",
                                      lAlertLevel=0)

        myPrint("P", "\n"*2)

        if iOrphans and not lFix:
            if theMsg.go():                                                                                             # noqa
                while True:
                    selectedOrphan = JOptionPane.showInputDialog(jif,
                                                                 "Select an Orphan to View",
                                                                 "VIEW ORPHAN (Escape or Cancel to exit)",
                                                                 JOptionPane.WARNING_MESSAGE,
                                                                 getMDIcon(None),
                                                                 orphanList,
                                                                 None)
                    if not selectedOrphan:
                        break

                    try:
                        tmpDir = File(MD_REF.getCurrentAccountBook().getRootFolder(), "tmp")
                        tmpDir.mkdirs()
                        attachFileName = (File(tmpDir, selectedOrphan[0])).getName()                                    # noqa
                        tmpFile = File.createTempFile(str(System.currentTimeMillis()), attachFileName, tmpDir)
                        tmpFile.deleteOnExit()
                        fout = FileOutputStream(tmpFile)
                        LS.readFile(selectedOrphan[0], fout)                                                            # noqa
                        fout.close()
                        Desktop.getDesktop().open(tmpFile)

                    except:
                        myPrint("B","Sorry, could not open attachment file....: %s" %selectedOrphan[0])                 # noqa

        else:
            theMsg.go()                                                                                                 # noqa

        if lFix and not iOrphans:

            myPopupInformationBox(jif, "YOU HAVE NO ORPHANS TO DELETE - NO ACTION TAKEN!")

        elif lFix:

            if confirm_backup_confirm_disclaimer(jif, "ATTACHMENTS - DELETE ORPHANS",
                                                     "Delete %s Orphan attachments from Disk?" %(iOrphans)):

                myPrint("B", "USER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH DELETION OF %s Orphan attachments from disk." %(iOrphans))

                jif.dispose()

                diagDisplay += ("\n\n"
                                "DELETING ORPHANS FROM DISK\n"
                                " =========================\n")

                for theOrphanRecord in orphanList:

                    try:
                        os.remove(theOrphanRecord[3])
                        x = "DELETED ORPHAN: %s" %(theOrphanRecord[3])
                        myPrint("B", x)
                        diagDisplay += (x + "\n")
                    except:
                        x = "@@ FAILED TO DELETE ORPHAN: %s" %(theOrphanRecord[3])
                        myPrint("B", x)
                        diagDisplay += (x + "\n")

                diagDisplay += ("Now removing empty attachment folder structures from disk......")
                if removeEmptyDirs(attachmentFullPath):
                    diagDisplay += ("Success")
                else:
                    diagDisplay += ("Hit an error (review console log)")

                diagDisplay+=("\n\n<END>\n")
                jif = QuickJFrame("ATTACHMENT ANALYSIS & ORPHAN DELETION", diagDisplay, lAlertLevel=1, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lJumpToEnd=True).show_the_frame()
                txt = "%s Orphan Attachments deleted from disk" %(iOrphans)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("diagnose_attachments", txt)
                play_the_money_sound()
                myPopupInformationBox(jif, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            else:
                jif.dispose()
                txt = "User declined disclaimer - no orphans deleted!"
                diagDisplay += ("\n" + txt + "\n" + "<END>\n")
                setDisplayStatus(txt, "R"); myPrint("B",txt)
                jif = QuickJFrame("ATTACHMENT ANALYSIS & ORPHAN DELETION",diagDisplay,lAlertLevel=1, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False,lJumpToEnd=True).show_the_frame()
                myPopupInformationBox(jif, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)

        toolbox_frame_.toFront()
        jif.toFront()

    # noinspection PyUnresolvedReferences
    def detect_fix_nonlinked_investment_security_records():
        if MD_REF.getCurrentAccountBook() is None: return

        nonLinkedSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(24))

        if len(nonLinkedSecurityAccounts) < 1:
            txt = "Congratulations - No Investment Security Accounts not properly linked to a Security Master were detected - No changes made!"
            setDisplayStatus(txt, "B"); myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        for badLink in nonLinkedSecurityAccounts:
            myPrint("B","Improperly linked Security (Sub Account): %s" %(badLink))

        selectedSecSubAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Security that's not properly linked to it's master'",
                                                      "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      nonLinkedSecurityAccounts,
                                                      None)

        if not selectedSecSubAcct:
            txt = "User did not select any of the %s improperly linked Security(s) to fix - no changes made" %(len(nonLinkedSecurityAccounts))
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        securities = []
        currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
        for currSec in currencies:
            if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                        # noqa
            securities.append(currSec)
        securities = sorted(securities, key=lambda sort_x: (sort_x.getName().upper()))

        if len(securities) < 1:
            txt = "ERROR - You seem to have no Security Master records to link to - Create one first (Tools>Securities) - No changes made!"
            setDisplayStatus(txt, "B"); myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        targetSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                    "Select the target Security to link to this record",
                                                    "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                    JOptionPane.INFORMATION_MESSAGE,
                                                    getMDIcon(None),
                                                    securities,
                                                    None)

        if not targetSecurity:
            txt = "User did not select a target Security - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                 "Reassign Security '%s' to Security Master: '%s'?" %(selectedSecSubAcct, targetSecurity)):
            return

        myPrint("B", "USER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH Reassign Security '%s' to Security Master '%s'?" %(selectedSecSubAcct, targetSecurity))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        selectedSecSubAcct.setEditingMode()
        selectedSecSubAcct.setCurrencyType(targetSecurity)
        selectedSecSubAcct.syncItem()

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "Fix/reassign Security (Sub Account) completed. Now reports '%s'. Please Check results" %(selectedSecSubAcct)
        setDisplayStatus(txt, "DG"); myPrint("B", txt)
        logToolboxUpdates("detect_fix_nonlinked_investment_security_records", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

    def fix_invalidLotRecords():
        if MD_REF.getCurrentAccountBook() is None: return

        PARAMETER_KEY = "toolbox_fix_invalid_lots"
        PARAMETER_KEY_COST_BASIS = "cost_basis"
        PARAMETER_KEY_OLD_COST_BASIS = ".old_cost_basis"

        _THIS_METHOD_NAME = "Detect and fix (wipe) LOT records"

        myPrint("B", "Entering function: '%s'" %(_THIS_METHOD_NAME.upper()))

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        allSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(2))
        if len(allSecurityAccounts) < 1:
            txt = "No Securities exist within Investment Accounts to check - No changes made!"
            setDisplayStatus(txt, "B"); myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        # Based on: com.infinitekind.moneydance.model.TxnUtil.parseCostBasisTag(SplitTxn)
        def parseCostBasisTag(_txn):
            """Returns the Cost Basis Lot Matching Tags without validating the UUID data first"""

            if not isinstance(_txn, SplitTxn): return None
            tags = _txn.getParameter(PARAMETER_KEY_COST_BASIS, None)
            if tags is None or len(tags) < 1: return None
            splitTags = tags.split(";")

            rtnTagList = {}
            for eachTagString in splitTags:
                if eachTagString is None or len(eachTagString) < 1: continue
                splitLine = eachTagString.split(":")
                uuid = splitLine[0]
                qty = Long.valueOf(Long.parseLong(splitLine[1]))
                rtnTagList[uuid] = qty
            return rtnTagList

        output = "%s:\n\n" %(_THIS_METHOD_NAME.upper())

        _msgPad = 100
        _msg = pad("Please wait: Analysing Security Accounts", _msgPad, padChar=".")
        diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
        diag.go()

        securityTxnsToFix = {}
        lLotErrors = False

        output += ("\nValidating the 'Cost Basis' on all Security Sub Accounts%s:\n"
                   %(" (valid security accounts will not be listed unless debug enabled)" if not debug else ""))

        myPrint("DB", "Validating the 'Cost Basis' on all Security Sub Accounts...:")

        for secAcct in allSecurityAccounts:

            _msg = pad("Please wait: Checking security account: '%s'" %(secAcct), _msgPad, padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            secTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

            if InvestUtil.isCostBasisValid(secAcct):
                txt = "... '%s' Cost Basis reports as valid" %(secAcct)
                if debug:
                    myPrint("DB", txt)
                    output += "%s\n" %(txt)
            else:
                txt = "... '%s' Cost Basis reports as INVALID" %(secAcct)
                myPrint("DB", txt)
                output += "%s\n" %(txt)

            for secTxn in secTxns:

                newTags = {}
                lAnyTagChanges = False

                # cbTags = TxnUtil.parseCostBasisTag(secTxn)    # This will only provide tags where the txn(s) by uuid actually still exist in the entire MD TxnSet
                cbTags = parseCostBasisTag(secTxn)              # This will provide all tags set on the record irrespective of whether they exist or not.

                if cbTags is None: continue
                for txnID in cbTags:
                    if TxnUtil.getTxnByID(secTxns, txnID) is not None:
                        newTags[txnID] = cbTags[txnID]
                    else:
                        lLotErrors = True
                        lAnyTagChanges = True   # Essentially we skipped this tag and didn't add it to the dictionary...
                        output += "... ERROR: Buy (id: %s) matched to sale (id: %s) dated: %s missing/invalid?\n" %(txnID,secTxn.getUUID(), convertStrippedIntDateFormattedText(secTxn.getDateInt()))

                if lAnyTagChanges:
                    securityTxnsToFix[secTxn] = newTags

        myPrint("DB", "Finished validating the cost basis.....")

        diag.kill()

        if not lLotErrors:
            txt = "Congratulations. No Buy/Sell matched LOT errors detected"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        output += "\n*** %s Buy/Sell matched LOT ERRORS EXIST ***\n" %(len(securityTxnsToFix))
        ask = MyPopUpDialogBox(toolbox_frame_,
                               "%s: %s Buy/Sell matched LOT errors exist..\n"
                               "This utility will wipe the invalid LOT data from these records\n"
                               "(You can then manually edit the LOT data afterwards using the LOT matching window)\n"
                               "REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE FIX" %(_THIS_METHOD_NAME, len(securityTxnsToFix)),
                               output,
                               theTitle=_THIS_METHOD_NAME.upper(),
                               lCancelButton=True,
                               OKButtonText="PROCEED")
        if not ask.go():
            _txt = "%s: - User Aborted - No changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(_txt, "R"); myPrint("B", _txt)
            _jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(_jif, _txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "Wipe invalid matched Buy/Sell LOT data?"):
            return

        output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH FIX OF INVALID LOT MATCHING DATA.....\n\n"

        _msg = pad("Please wait: Fixing transactions...", _msgPad,padChar=".")
        diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
        diag.go()

        output += "Fixing Lot Matching data identified above for %s txns...:\n\n" %(len(securityTxnsToFix))
        for secTxn in securityTxnsToFix:
            newTag = ""
            cbTags = securityTxnsToFix[secTxn]
            for txnID in cbTags:
                newTag += "{}:{};".format(txnID,cbTags[txnID])

            pTxn = secTxn.getParentTxn()
            pTxn.setEditingMode()

            if debug: secTxn.setParameter(PARAMETER_KEY+PARAMETER_KEY_OLD_COST_BASIS,secTxn.getParameter(PARAMETER_KEY_COST_BASIS, None))
            secTxn.setParameter(PARAMETER_KEY_COST_BASIS, newTag)
            pTxn.syncItem()

        output += ("\nValidating the 'Cost Basis' on all Security Sub Accounts (AFTER THE FIX)%s:\n"
                   %(" (valid security accounts will not be listed unless debug enabled)" if not debug else ""))

        for secAcct in allSecurityAccounts:

            _msg = pad("Please wait: Validating cost basis on security account: '%s'" %(secAcct), _msgPad, padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            if InvestUtil.isCostBasisValid(secAcct):
                if debug: output += "... '%s' Cost Basis reports as valid\n" %(secAcct)
            else:
                output += "... '%s' Cost Basis reports as INVALID (you may need to manually edit / review MATCHED LOTs)\n" %(secAcct)

        diag.kill()

        output += "\n\n%s transactions corrected (invalid LOT data has been wiped)...\n\n" %(len(securityTxnsToFix))
        jif = QuickJFrame(_THIS_METHOD_NAME,output, lWrapText=False, lJumpToEnd=True, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "%s: Completed. Please Check results and manually address any Buy/Sell LOT matching that needs to be resolved" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "DG"); myPrint("B", txt)
        logToolboxUpdates("fix_invalidLotRecords", txt)
        play_the_money_sound()
        myPopupInformationBox(jif, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)

    # noinspection PyUnresolvedReferences
    def edit_security_decimal_places():
        _THIS_METHOD_NAME = "Edit a Security's Decimal Places setting"

        if MD_REF.getCurrentAccountBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_security_dpc"
        PARAMETER_KEY_DATA = ".old_data"
        PARAMETER_KEY_COST_BASIS = ".old_cost_basis"

        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output = "%s:\n" \
                 " ========================================\n\n" \
                 "The Decimal Places setting on a security relates only to the qty of shares on transactions, the stock holding qty balance, and related LOT Control records.\n" \
                 "...the (max) decimal precision is set by the user when a Security is first created. It is subsequently hidden and not editable in standard MD.\n" \
                 "...This function allows you to change it. Related records will be properly updated.\n\n" \
                 "NOTE: The decimal places setting was used to store the price/rate prior to MD2019 (as a factor compared to the base currency dpc)\n" \
                 "      So, if you are using MD2019 or later, then this is not issue for you\n" \
                 "      If you want to revert back to MD2017 or earlier, then please do not use this utility to change a security dpc setting.\n" \
                 "      (Also note, that if you revert to MD2017 you will probably have to check the rates/prices anyway, due to an unrelated MD bug.....)\n\n" \
                 "" %(_THIS_METHOD_NAME)

        myPrint("B", "%s: Analysing..." %(_THIS_METHOD_NAME))

        try:

            if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

            class StoreSecurity:
                def __init__(self, _obj):
                    self.obj = _obj

                def getSecurity(self):  return self.obj

                def __str__(self):  return "Decimal Places: %s >> %s" %(rpad(self.obj.getDecimalPlaces(),2),self.obj)

                def __repr__(self): return self.__str__()


            # Sweep One - gather the potential targets by duplicate Ticker Symbol....
            allSecurities = []
            currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
            for currSec in currencies:
                if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue
                allSecurities.append(StoreSecurity(currSec))
            del currencies
            allSecurities = sorted(allSecurities, key=lambda x: (x.getSecurity().getName().upper()))

            securityToEdit = JOptionPane.showInputDialog(toolbox_frame_,
                                                        "Select Security to edit Decimal Places",
                                                        _THIS_METHOD_NAME.upper(),
                                                        JOptionPane.WARNING_MESSAGE,
                                                        getMDIcon(None),
                                                        allSecurities,
                                                        None)                                                           # type: StoreSecurity

            if not securityToEdit:
                txt = "%s: No Security selected.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            securityToEdit = securityToEdit.getSecurity()
            output += "\n" \
                      "Security: %s was selected to edit.\n" \
                      "Current Decimal Places set to: %s\n" %(securityToEdit, securityToEdit.getDecimalPlaces())

            while True:
                dp_limit = 16
                dp_current = str(securityToEdit.getDecimalPlaces())
                newDecimal = myPopupAskForInput(toolbox_frame_,
                                                _THIS_METHOD_NAME,
                                                "New Decimal Places:",
                                                "Enter the new Decimal Places setting (0-%s allowed, currently %s)" % (dp_limit, dp_current),
                                                defaultValue=dp_current)

                if newDecimal is not None and not StringUtils.isInteger(newDecimal):
                    continue

                if newDecimal is None or int(newDecimal) == securityToEdit.getDecimalPlaces():
                    txt = "%s: No new decimal places selected.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if int(newDecimal) >= 0 and int(newDecimal) <= dp_limit:
                    newDecimal = int(newDecimal)
                    break

                continue

            newMaxNumber = None
            if newDecimal > securityToEdit.getDecimalPlaces() and newDecimal > 8:
                maxNumberStr = str(Long.MAX_VALUE)
                maxDigits = len(maxNumberStr)
                oldWholeDigitsMax = maxDigits - securityToEdit.getDecimalPlaces()
                newWholeDigitsMax = maxDigits - newDecimal
                # oldMaxWholeNumber = maxNumberStr[:oldWholeDigitsMax]
                # newMaxWholeNumber = maxNumberStr[:newWholeDigitsMax]
                # oldMaxFractional = maxNumberStr[oldWholeDigitsMax:]
                # newMaxFractional = maxNumberStr[newWholeDigitsMax:]
                oldMaxNumber = "%s.%s" %(maxNumberStr[:oldWholeDigitsMax], maxNumberStr[oldWholeDigitsMax:])
                newMaxNumber = "%s.%s" %(maxNumberStr[:newWholeDigitsMax], maxNumberStr[newWholeDigitsMax:])
                if not myPopupAskQuestion(toolbox_frame_,
                                          _THIS_METHOD_NAME.upper(),
                                          "WARNING: at %s dpc, new maximum number is: '%s' - OK?"
                                          %(newDecimal, newMaxNumber)):
                    txt = "%s: User aborted.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return
                output += "\n" \
                          "** User accepted warning that at %s decimals, the maximum number that MD can store is '%s' (was: '%s')! **\n\n" %(newDecimal, newMaxNumber, oldMaxNumber)
                del maxDigits, oldWholeDigitsMax, newWholeDigitsMax, oldMaxNumber

            # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
            allInvestmentSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(22))

            iTotalTxns = 0
            iTotalBalance = 0
            lUsingLotControl = False
            securitySubAccountsNeedChanging = []
            output += "\nSearching for related Investment Account Security holdings, transactions, balances etc...:\n"

            lAnyCostBasisErrorsFound = [False]

            for secAcct in allInvestmentSecurityAccounts:
                if secAcct.getCurrencyType() == securityToEdit:
                    securitySubAccountsNeedChanging.append(secAcct)

                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

                    lFoundCostBasisTags = False
                    for txn in txns:
                        if txn.getParameter("cost_basis", None) is not None:
                            lFoundCostBasisTags = lUsingLotControl = True
                            break

                    if lFoundCostBasisTags:
                        output += "... WARNING: LOT CONTROLLED RECORDS using Cost Basis Tags found ***\n"

                    if not InvestUtil.isCostBasisValid(secAcct):
                        lAnyCostBasisErrorsFound[0] = True
                        output += "... WARNING: INVALID COST BASIS / LOT CONTROL DETECTED! ***\n"

                    iTotalTxns += txns.getSize()
                    bal = securityToEdit.getDoubleValue(secAcct.getBalance())
                    iTotalBalance += bal
                    output += "... %s Txns: %s Balance: %s\n" %(pad(secAcct.getFullAccountName(),50),rpad(txns.getSize(),12),rpad(bal,12))
                    if secAcct.getStartBalance() != 0:
                        txt = "*** ERROR: %s has a starting balance of %s - SHOULD BE ZERO - Will abort! ***" %(secAcct, secAcct.getStartBalance())
                        myPrint("B", txt); output += "\n%s\n\n" %(txt)
                        raise Exception(txt)
                    del txns

            del allInvestmentSecurityAccounts

            output += "\n" \
                      "Investment Account Security records found: %s\n" \
                      "Related Transactions found: %s\n" \
                      "Total security balance: %s\n\n" \
                      %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance)

            if lUsingLotControl:
                output += "\n*** WARNING: LOT CONTROLLED RECORDS using Cost Basis Tags found ***\n\n"

            if lAnyCostBasisErrorsFound[0]:
                output += "\n*** WARNING: INVALID LOT CONTROL / COST BASIS RECORDS BEFORE ANY CHANGES WERE DETECTED ***\n\n"
            else:
                output += "\nNOTE: No Invalid Lot Control/Cost Basis records were detected before any changes made....\n\n"

            jif = QuickJFrame(("%s: Accounts, Txns, Balance Analysis" %(_THIS_METHOD_NAME)).upper(), output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

            if (iTotalBalance + iTotalTxns + len(securitySubAccountsNeedChanging)) == 0:
                txt = "NOTE - No related accounts, txns, balances were found for this security!"
                output += "\n*** %s ***\n" %(txt)
                myPopupInformationBox(jif, txt, _THIS_METHOD_NAME)

            elif lAnyCostBasisErrorsFound[0]:
                myPopupInformationBox(jif,
                                      "%s Accounts, %s Txns, Balance %s found ** NOTE: INVALID LOT CONTROL / COST BASIS RECORDS DETECTED! **"
                                      %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance),
                                      _THIS_METHOD_NAME)
            else:
                myPopupInformationBox(jif,
                                      "NOTE: %s Accounts, %s Txns, Balance %s found" %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance),
                                      _THIS_METHOD_NAME)


            if not myPopupAskQuestion(jif,
                                  _THIS_METHOD_NAME.upper(),
                                  "CONFIRM you want to change Decimals from %s to %s?" %(securityToEdit.getDecimalPlaces(),newDecimal)):
                txt = "%s: User aborted.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            jif.dispose()

            txt = "New Decimal Places %s for %s selected (currently: %s) " %(newDecimal, securityToEdit, securityToEdit.getDecimalPlaces())
            myPrint("B", txt); output += "\n%s\n" %(txt)

            decimalAdjustmentMethod = "expand"
            jif = QuickJFrame(("%s: Decimal Strategy" %(_THIS_METHOD_NAME)).upper(), output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

            if newDecimal < securityToEdit.getDecimalPlaces():

                options = ["Round lost fractional balances up/down (round)",
                           "Truncate / lose / chop lost fractional balances (floor)",
                           "Always round up lost fractional balances (ceiling)"]


                selectedDecimalStrategy = JOptionPane.showInputDialog(jif,
                                                                   "Select the Decimal REDUCTION Strategy?",
                                                                   _THIS_METHOD_NAME.upper(),
                                                                   JOptionPane.WARNING_MESSAGE,
                                                                   getMDIcon(None),
                                                                   options,
                                                                   None)

                if not selectedDecimalStrategy:
                    txt = "%s: User did not select a Decimal Reduction Strategy for the edit - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return


                if options.index(selectedDecimalStrategy) == 0:    decimalAdjustmentMethod = "round"
                elif options.index(selectedDecimalStrategy) == 1:  decimalAdjustmentMethod = "floor"
                else:                                              decimalAdjustmentMethod = "ceiling"
                del options

                output += "\n** Decimal Reduction Strategy selected: '%s' (Fractional balances might be affected) **\n\n" %(decimalAdjustmentMethod)

                if lUsingLotControl:

                    ask = MyPopUpDialogBox(jif,
                                           "%s: WARNING. Lot Controlled Records in use, and reduction of dpc requested!" %(_THIS_METHOD_NAME),
                                           "You are using LOT Controlled Records (with cost basis tags) that link sells to buys\n"
                                           "You have also requested to reduce decimal precision\n"
                                           "This will probably lose fractional share balances\n"
                                           "This utility can apply the same maths to the Lot Controlled allocations, but it may be fractionally wrong\n"
                                           "You can/may review and fix these later.... Your choice....",
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           lCancelButton=True,
                                           OKButtonText="PROCEED")
                    if not ask.go():
                        txt = "%s: User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                        setDisplayStatus(txt, "R"); myPrint("B",txt)
                        jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME), output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
                        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                        return

                    txt = "** User agreed to reduce decimal precision and accept that LOT Controlled records might be fractionally wrong.... **"
                    myPrint("B",txt); output += "\n\n%s\n\n" %(txt)

            else:
                output += "\nDecimal Strategy selected: %s (Increased so no loss of decimal precision)\n\n" %(decimalAdjustmentMethod)
                txt = "DECIMAL INCREASE STRATEGY: You are increasing the number of decimal places; so no decimal precision will be lost.."
                output += "\n%s\n" %(txt)
                myPopupInformationBox(jif, txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

                if newDecimal > 8:
                    output += "\n\n *** HOWEVER, you have accepted that at %s decimal places, the maximum number that MD can store is '%s'\n\n" %(newDecimal, newMaxNumber)

                if lUsingLotControl:
                    output += "\n\n *** NOTE: LOT CONTROLLED RECORDS using Cost Basis Tags found - As you are increasing the decimal precision, no fractional losses should occur ***\n\n"

            jif.dispose()


            ask = MyPopUpDialogBox(toolbox_frame_,
                                   "%s: REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE DECIMAL EDIT" %(_THIS_METHOD_NAME),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s... User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R"); myPrint("B",txt)
                jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME), output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE %s DECIMAL PLACE EDIT FROM %s to %s?" %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)):
                return

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH DECIMAL PLACE EDIT of %s FROM %s to %s.....\n\n" %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)

            output += "\n"

        except:
            txt = ("MINOR ERROR - %s: crashed before any update actions. Please review output and console" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing %s right now.." %(_THIS_METHOD_NAME),
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the merge..
            MD_REF.getCurrentAccountBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            # Do this first, so that the 'internal' MD maths on the txn edits work with the new dpc settings.....
            txt = "** Updating %s Security Master to new Decimal Places (was %s >> to %s) setting..." %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)
            myPrint("B", txt); output += "\n%s\n\n" %(txt)

            oldDecimal = securityToEdit.getDecimalPlaces()

            def calculateNewShares(oldValue):

                if newDecimal > oldDecimal:
                    _newShares = oldValue * Math.pow(10.0, (newDecimal - oldDecimal))
                else:

                    if oldValue < 0.0:
                        neg = True
                    else:
                        neg = False

                    if decimalAdjustmentMethod == "round":
                        _newShares = Math.round(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    elif decimalAdjustmentMethod == "floor":
                        _newShares = Math.floor(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    elif decimalAdjustmentMethod == "ceiling":
                        _newShares = Math.ceil(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    else:
                        raise Exception("ERROR: Bad Decimal Strategy detected '%s'?!" %(decimalAdjustmentMethod))

                    if neg: _newShares *= -1.0

                _newShares = int(_newShares)
                return _newShares


            securityToEdit.setEditingMode()
            securityToEdit.setDecimalPlaces(newDecimal)
            securityToEdit.setParameter(PARAMETER_KEY,True)
            securityToEdit.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_decimal_places:%s}" %(oldDecimal))
            securityToEdit.syncItem()

            # Now for Txns..    .
            if len(securitySubAccountsNeedChanging) > 0:
                txt = "Now editing all relevant txns change decimal precision ....:"
                myPrint("B", txt); output += "\n\n%s\n\n" %(txt)

                for secAcct in securitySubAccountsNeedChanging:
                    txt = "Updating %s..." %(secAcct)
                    myPrint("B",txt); output += "%s\n" %(txt)

                    parentAccount = secAcct.getParentAccount()

                    secAcct.setParameter(PARAMETER_KEY,True)
                    secAcct.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_decimal_places:%s}" %(oldDecimal))

                    secAcct.syncItem()

                    txnsToEdit = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

                    if txnsToEdit.getSize() < 1:
                        txt = ".... has no transactions to update..."
                        output += "%s\n" %(txt)
                    else:
                        txt = ".... Updating %s transactions: %s" %(secAcct, txnsToEdit.getSize())
                        myPrint("B",txt); output += "%s\n" %(txt)

                        txnsToEdit = sorted(txnsToEdit, key=lambda _x: (_x.getDateInt()))

                        for txn in txnsToEdit:

                            if not isinstance(txn, SplitTxn):       # Should never happen..... ;->
                                raise Exception("Error: found a non-split: %s" %(txn))

                            pTxn = txn.getParentTxn()

                            lEditingMode = False

                            # Look for and fix any Lot Control records at the same time.... Risky business!
                            if txn.getParameter("cost_basis", None) is not None:
                                cbTags = TxnUtil.parseCostBasisTag(txn)
                                if cbTags is not None:
                                    lAnyTagChanges = False
                                    totalOldSharesBUYS = totalNewSharesBUYS =0
                                    for txnID in cbTags:
                                        oldShareValue = cbTags[txnID]
                                        if oldShareValue == 0: continue
                                        totalOldSharesBUYS += oldShareValue
                                        newShares = calculateNewShares(oldShareValue)
                                        totalNewSharesBUYS += newShares
                                        cbTags[txnID] = newShares
                                        lAnyTagChanges = True

                                    if lAnyTagChanges:
                                        newTag = ""
                                        for txnID in cbTags:
                                            newTag += "{}:{};".format(txnID,cbTags[txnID])
                                        pTxn.setEditingMode()
                                        lEditingMode = True

                                        if debug:
                                            txn.setParameter(PARAMETER_KEY+PARAMETER_KEY_COST_BASIS,txn.getParameter("cost_basis", None))

                                        txn.setParameter("cost_basis", newTag)
                                        output += ".. %s %s ** Updated Lot Control: (Old BUYS: %s New BUYS: %s)**\n" %(
                                                                                                    convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                                                                    pad(pTxn.getInvestTxnType().getIDString(),12),
                                                                                                    totalOldSharesBUYS,
                                                                                                    totalNewSharesBUYS)

                            # get the current raw data
                            splitShares = txn.getValue()
                            splitParentShareValue = txn.getAmount() * -1
                            old_samt = txn.getParameter("samt", None)
                            old_pamt = txn.getParameter("pamt", None)

                            if splitShares == 0:
                                output += ".. %s %s %s Val: %s - Skipping as ZERO shares...\n" %(
                                                               convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                               pad(pTxn.getInvestTxnType().getIDString(),12),
                                                               pad(pTxn.getDescription()+pTxn.getMemo(),40),
                                                               rpad(parentAccount.getCurrencyType().formatFancy(-splitParentShareValue,MD_decimal),12))

                                if lEditingMode:
                                    pTxn.syncItem()  # Left over from the cost basis change above....

                                continue

                            newShares = calculateNewShares(splitShares)

                            if splitParentShareValue == 0:
                                price = 0.0
                            else:
                                price = (1.0 * splitParentShareValue) / (1.0 * splitShares)     # force floating point conversion

                                # Taken from MD code.....
                                price = CurrencyTable.getRawRate(secAcct.getCurrencyType(), parentAccount.getCurrencyType(), 1.0 / price)

                            pTxn.setEditingMode()
                            txn.setParameter(PARAMETER_KEY,True)

                            if debug:
                                txn.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_samt:%s,old_pamt:%s}" %(old_samt, old_pamt))

                            # newShares = adjusted, long. Price = recalculated, double, splitParentShareValue = unchanged, long
                            txn.setAmount(newShares, price, splitParentShareValue)
                            # txn.setParameter("samt", newShares)
                            pTxn.syncItem()

                            output += ".. %s %s %s Val: %s Old Raw Shrs: %s New Raw Shrs: %s New Shrs: %s\n" %(
                                                           convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                           pad(pTxn.getInvestTxnType().getIDString(),12),
                                                           pad(pTxn.getDescription()+pTxn.getMemo(),40),
                                                           rpad(parentAccount.getCurrencyType().formatFancy(-splitParentShareValue,MD_decimal),12),
                                                           rpad(splitShares,12),
                                                           rpad(newShares,12),
                                                           rpad(secAcct.getCurrencyType().formatFancy(txn.getValue(),MD_decimal),25))

                            # Fail safe...!
                            if txn.getParameter("pamt", "ERROR") != old_pamt:
                                raise Exception("ERROR: Txn's new pamt(%s) != old pamt(%s) - review console..." %(txn.getParameter("pamt", "ERROR"),old_pamt))

                            continue

                    output += "----\n"
                    del txnsToEdit

                output += "\n>> Txn decimal places update completed.....\n\n"

            output += "\n>> Update of decimal places completed..\n\n"

        except:

            txt = ("MAJOR ERROR - %s crashed. Please review output, console, and RESTORE YOUR DATASET!"%(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output, lAlertLevel=2, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset after %s changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es).." %(_THIS_METHOD_NAME))
            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccountBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # OK - Main update is done....

            lAnyCostBasisErrorsFound = [False]

            if len(securitySubAccountsNeedChanging) > 0:
                output += "\n\nSTATISTICS AFTER EDIT DECIMAL ACTIONS COMPLETED...\n\n"

                for secAcct in securitySubAccountsNeedChanging:
                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct).getSize()
                    bal = securityToEdit.getDoubleValue(secAcct.getBalance())
                    output += "... %s Txns: %s Balance: %s\n" %(pad(secAcct.getFullAccountName(),50),rpad(txns,12),rpad(bal,12))

                    if not InvestUtil.isCostBasisValid(secAcct):
                        lAnyCostBasisErrorsFound[0] = True
                        output += "   ... WARNING: INVALID COST BASIS / LOT CONTROL DETECTED AFTER UPDATE ***\n"

            if lAnyCostBasisErrorsFound[0]:
                output += "\n\n*** WARNING: INVALID COST BASIS / LOT CONTROL RECORDS WERE DETECTED AFTER UPDATE ***\n"
            else:
                output += "\nNOTE: No Invalid Lot Control/Cost Basis records were detected after the changes were made....\n\n"

            del securitySubAccountsNeedChanging

            output += "\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and %s) back to disk....." %(_THIS_METHOD_NAME),
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccountBook().saveTrunkFile()
                pleaseWait.kill()

            if newDecimal < oldDecimal and lUsingLotControl:
                output += "\n\n *** WARNING - PLEASE REVIEW YOUR LOT CONTROL ALLOCATIONS BUYS to SELLS as fractional losses / mismatches may have occurred! ***\n\n"
                txt = "%s Completed with WARNINGS - review log, check the results & LOT Controlled BUY/SELL Allocations, then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.WARNING_MESSAGE; optionColor = "R"
            elif lAnyCostBasisErrorsFound[0]:
                output += "\n\n *** WARNING - PLEASE REVIEW YOUR LOT CONTROL ALLOCATIONS BUYS to SELLS as LOT CONTROL/COST BASIS ERRORS WERE DETECTED! ***\n\n"
                txt = "%s Completed with WARNINGS - review log, check the results & LOT Controlled BUY/SELL Allocations (Errors Detected), then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.WARNING_MESSAGE; optionColor = "R"
            else:
                txt = "%s successfully completed - please review log, check the results, then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.INFORMATION_MESSAGE; optionColor = "DG"

            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES & THEN RESTART MONEYDANCE ***\n\n"
            output += "\n<END>"

            logToolboxUpdates("edit_security_decimal_places", txt)

        except:
            txt = ("ERROR - %s crashed after the edit actions. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame(txt, output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        setDisplayStatus(txt, optionColor)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionMessage)

    def fix_duplicate_securities_within_same_investment_account():
        if MD_REF.getCurrentAccountBook() is None: return

        _THIS_METHOD_NAME = "Repair duplicate Securities:".upper()

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_duplicate_security_fix"

        book = MD_REF.getCurrentAccountBook()
        allAccounts = AccountUtil.allMatchesForSearch(book, AcctFilter.ALL_ACCOUNTS_FILTER)

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        class CaptureIllogicalAccount:
            def __init__(self, investmentAccount):
                self.investmentAccount = investmentAccount
                self.illogicalSecurities = {}

        output = "%s\n" \
                 " --------------------------------------\n\n" %(_THIS_METHOD_NAME)

        allInvestmentAccounts = []
        for acct in allAccounts:
            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.INVESTMENT:
                allInvestmentAccounts.append(acct)

        allSecurityAccounts = []
        for acct in allAccounts:
            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.SECURITY:
                allSecurityAccounts.append(acct)

        illogicalInvestmentAccounts = []

        for acct in allInvestmentAccounts:
            output += ("\nAnalysing Investment Account: %s\n" %(acct))
            captureIllogicalAccount = CaptureIllogicalAccount(acct)
            storeSecurityAcctsByCurrency = {}
            subAccts = acct.getSubAccounts()
            for subAcct in subAccts:
                # noinspection PyUnresolvedReferences
                if subAcct.getAccountType() != Account.AccountType.SECURITY:
                    raise Exception("ERROR: Found non Security sub account:", subAcct.getFullAccountName())
                secCurr = subAcct.getCurrencyType()
                storeSecurityAcctsByCurrency[secCurr] = storeSecurityAcctsByCurrency.get(secCurr, 0) + 1

            lFoundIllogical = False
            for secCurr in storeSecurityAcctsByCurrency:
                appearances = storeSecurityAcctsByCurrency[secCurr]
                flag = (" "*5) if (appearances <= 1) else ("*"*5)
                output += ("... %s Security '%s' appears: %s times...\n" %(flag, secCurr, appearances))

                if appearances > 1:
                    lFoundIllogical = True
                    captureIllogicalAccount.illogicalSecurities[secCurr] = []
                    subAccts = acct.getSubAccounts()
                    for subAcct in subAccts:
                        if subAcct.getCurrencyType() == secCurr:
                            captureIllogicalAccount.illogicalSecurities[secCurr].append(subAcct)

            if lFoundIllogical: illogicalInvestmentAccounts.append(captureIllogicalAccount)

        output += ("\n")

        if len(illogicalInvestmentAccounts) < 1:
            txt = "CONGRATULATIONS - No duplicated Securities within Investment Account(s) found"
            output += ("%s\n" %(txt))
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            jif = QuickJFrame(_THIS_METHOD_NAME, output).show_the_frame()
            myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        lCostBasisFlagWarning = False

        output += ("@@@ ERROR - found %s duplicated securities with investment account(s)...!\n\n" %(len(illogicalInvestmentAccounts)))
        for captureIllogicalAccount in illogicalInvestmentAccounts:
            output += ("\nInvestment Account: %s\n" %(captureIllogicalAccount.investmentAccount))
            for secCurr in captureIllogicalAccount.illogicalSecurities:
                output += ("... Security: %s\n" %(secCurr))

                lUsesAverageCost = None
                lUsesAverageCostDifferent = False
                for subAcct in captureIllogicalAccount.illogicalSecurities[secCurr]:
                    if lUsesAverageCost is None: lUsesAverageCost = subAcct.getUsesAverageCost()
                    if lUsesAverageCost != subAcct.getUsesAverageCost():
                        lUsesAverageCostDifferent = True
                        lCostBasisFlagWarning = True

                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(subAcct)
                    output += ("...... Sub security account (%s): %s Txn count: %s %s\n" %(subAcct.getUUID(), subAcct.getAccountName(), txns.getSize(),
                                                                                           "" if not lUsesAverageCostDifferent else "(WARNING: Cost Basis Flags different (Avg Cst vs Lot Control)"))

        txt = ("@@@@ FIX REQUIRED!!! @@@@")
        output += ("\n\n%s\n\n" %(txt))

        jif = QuickJFrame(txt, output, lJumpToEnd=True, lWrapText=False).show_the_frame()
        myPopupInformationBox(jif, "WARNING: %s duplicated securities found within investment account(s)!" %(len(illogicalInvestmentAccounts)),
                              theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)

        if not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME.upper(),
                                                 "EXECUTE FIX/MERGE OF %s DUPLICATED SECURITIES WITHIN INVESTMENT ACCOUNT(s)?" %(len(illogicalInvestmentAccounts))):
            return

        jif.dispose()

        output += "\nPROCEEDING TO FIX\n\n"

        accountsToDelete = []

        for captureIllogicalAccount in illogicalInvestmentAccounts:
            output += ("\nFIXING Investment Account: %s\n" %(captureIllogicalAccount.investmentAccount))
            for secCurr in captureIllogicalAccount.illogicalSecurities:
                output += ("... Security: %s\n" %(secCurr))

                acctToKeep = captureIllogicalAccount.illogicalSecurities[secCurr][0]
                for subAcct in list(captureIllogicalAccount.illogicalSecurities[secCurr]):
                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(subAcct)
                    if subAcct == acctToKeep:
                        output += ("...... Keeping sub security account (%s) as the primary for: %s (with: %s txns) Cost Basis: '%s'\n" %(subAcct.getUUID(), subAcct.getAccountName(), txns.getSize(),
                                                                                                                                          "Average Cost" if (subAcct.getUsesAverageCost()) else "LOT Control"))
                        continue
                    output += ("...... FIXING Sub security account (%s): %s - changing %s transactions (note: this security/subacct used Cost Basis: '%s')\n" %(subAcct.getUUID(), subAcct.getAccountName(), txns.getSize(),
                                                                                                                                                                "Average Cost" if (subAcct.getUsesAverageCost()) else "LOT Control"))
                    for txn in txns:
                        pTxn = txn.getParentTxn()
                        pTxn.setEditingMode()
                        txn.setAccount(acctToKeep)
                        txn.setParameter(PARAMETER_KEY, True)
                        pTxn.syncItem()
                    accountsToDelete.append(subAcct)

                    InvestUtil.getCostBasis(subAcct)
                    if not InvestUtil.isCostBasisValid(subAcct):
                        output += ("......... Cost Basis reports as 'invalid' please manually review\n")

        output += "\n"
        for subAcct in accountsToDelete:
            txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(subAcct)
            if txns.getSize() != 0:
                txt = "ERROR: Something's gone wrong! Resulting txn count should be ZERO! Acct: %s (CONSIDER RESTORE!)" %(subAcct)
                output += "%s\n" %(txt)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                jif = QuickJFrame(_THIS_METHOD_NAME, output).show_the_frame()
                myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
                return
            output += "......... will delete old (empty) sub security account: %s\n" %(subAcct)

        if lCostBasisFlagWarning:
            output += ("\n\nWARNING - you had Cost Basis (Average Cost Basis vs LOT Control) flag differences. Please review these settings (and update your LOT matching if appropriate)\n\n")

        MD_REF.getCurrentAccountBook().logRemovedItems(accountsToDelete)
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "SUCCESS / FINISHED - Please review your investment portfolios"
        output += "\n%s\n" %(txt)
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        logToolboxUpdates("fix_duplicate_securities_within_same_investment_account", txt)
        play_the_money_sound()
        jif = QuickJFrame(_THIS_METHOD_NAME, output, lJumpToEnd=True, lWrapText=False).show_the_frame()
        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

    # noinspection PyUnresolvedReferences
    def merge_duplicate_securities():
        if MD_REF.getCurrentAccountBook() is None: return

        _THIS_METHOD_NAME = "Merge 'Duplicate' Securities (by 'ticker')"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_security_merge"
        PARAM_CURRID = "curr_id."

        today = Calendar.getInstance()                                                                                  # noqa
        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output = "%s:\n" \
                 " ============================================================\n\n" %(_THIS_METHOD_NAME)

        myPrint("B", "%s: Analysing..." %(_THIS_METHOD_NAME))

        try:

            base = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()

            # Sweep One - gather the potential targets by duplicate Ticker Symbol....
            dup_securities = OrderedDict()
            securities = []
            currencies = sorted(MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies(),
                                key=lambda x: (x.getCurrencyType(), x.getName().upper(), x.getTickerSymbol(), x.getIDString()))

            for currSec in currencies:
                if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                    # noqa
                securities.append(currSec)
                theTicker = currSec.getTickerSymbol().strip().upper()
                if theTicker is None or theTicker == "" or len(theTicker) < 1: continue
                getDup = dup_securities.get(theTicker)
                if getDup is not None:
                    getDup[0] += 1
                    getDup[1].append(currSec)
                else:
                    getDup = [1, [currSec]]
                dup_securities[theTicker] = getDup
            del currencies

            def compareSplits(splitsOne, splitsTwo):
                if len(splitsOne) < 1 and len(splitsTwo) < 1:   return True
                if len(splitsOne) != len(splitsTwo):            return False
                splitsOne = sorted(splitsOne, key=lambda sort_x: (sort_x.getDateInt()))
                splitsTwo = sorted(splitsTwo, key=lambda sort_x: (sort_x.getDateInt()))

                for i in range(0,len(splitsOne)):
                    s1 = splitsOne[i]
                    s2 = splitsTwo[i]
                    if s1.getDateInt() != s2.getDateInt():        return False
                    if s1.getSplitRatio() != s2.getSplitRatio():  return False
                    # if s1.getNewShares() != s2.getNewShares():    return False
                    # if s1.getOldShares() != s2.getOldShares():    return False

                return True

            try: myPrint("DB","%s: Initial candidates found %s %s" %(_THIS_METHOD_NAME, len(dup_securities), dup_securities))
            except: pass

            # Sweep Two - start validating the data found
            lShowOutput = False
            removeList = []

            output +=   "Performing analysis and validation of potential 'duplicate' Securities.\n\n" \
                        "The following data can be edited in MD Menu > Tools>Securities (** except 'Decimal Places' where you will need to use Toolbox to edit)\n\n" \
                        "The check / validation rules are:\n" \
                        "- Find potential 'duplicates' where Securities' 'Ticker' Symbols are the same/match (cannot be blank); then Duplicate Security's...:\n" \
                        "... ID must be short and DIFFERENT (so you can identify them in this process). Examples: use '^APPL1', '^APPL2', '^APPL3'.. to merge 3 Apple Stocks\n" \
                        "....(^^Close this window and use Tools>Securities>EDIT and change the Security ID for each duplicate and then re-run this function again)\n" \
                        "...'Currency' must match\n" \
                        "...'Current Price' must match\n" \
                        "...'Prefix' & 'Suffix' must match\n" \
                        "...'Splits' data must match\n" \
                        "... hidden 'Decimal Places' setting must match **\n" \
                        "- NOTE: Security Name is not matched, but you can select the Security to become the 'master', that has right details, as part of the process\n" \
                        "\n" \
                        " -------------------------------------------------------------------------------------------------------------------------------------------------\n\n"

            def getSecurityNameAndID(theSec, theLen=None):

                theName = theSec.getName()
                if theLen: theName = theName[:theLen]+".."
                return "%s(ID: %s)" %(theName,theSec.getIDString())


            class StoreSecurity:
                def __init__(self, _obj):
                    self.obj = _obj                         # type: CurrencyType

                def getSecurity(self): return self.obj      # type: CurrencyType

                def getDisplayString(self, _security, _short=False):

                    if _short:
                        return ("%s:ID %s:rate %s:dpc %s:%s:%s:(%s price recs)"
                                % (_security.getName()[:35]+"..",
                                   _security.getIDString(),
                                   safeInvertRate(_security.getRelativeRate()),
                                   _security.getDecimalPlaces(),
                                   _security.getPrefix(),
                                   _security.getSuffix(),
                                   _security.getSnapshots().size()))

                    return ("%s:Ticker %s:ID %s:rate %s:dpc %s:%s:%s:(%s price history recs)"
                            % (_security.getName(),
                               _security.getTickerSymbol(),
                               _security.getIDString(),
                               safeInvertRate(_security.getRelativeRate()),
                               _security.getDecimalPlaces(),
                               _security.getPrefix(),
                               _security.getSuffix(),
                               _security.getSnapshots().size()))

                def shortDisplay(self):
                    return (self.getDisplayString(self.getSecurity(),True))

                def __str__(self): return (self.getDisplayString(self.getSecurity()))[:200]

                def __repr__(self): return self.__str__()

            for dup in dup_securities:
                getDup = dup_securities.get(dup)
                if getDup[0] < 2:
                    removeList.append(dup)
                    continue

                highestSnapCount = 0
                primaryCurr = getDup[1][0]
                for scanDup in getDup[1]:
                    getSnaps = scanDup.getSnapshots()
                    if getSnaps.size() > highestSnapCount:
                        highestSnapCount = getSnaps.size()
                        primaryCurr = scanDup

                getDup[1].remove(primaryCurr)
                getDup[1].insert(0, primaryCurr)

                foundIDs = [primaryCurr.getIDString().strip().lower()]

                lFailChecks = False
                primarySplits = primaryCurr.getSplits()
                output += "Verifying potential 'duplicates': %s(Ticker: %s Master ID: %s) (has %s price history records)\n"\
                          %(primaryCurr.getName(),dup,primaryCurr.getIDString(),highestSnapCount)

                for scanDup in getDup[1]:

                    if scanDup == primaryCurr: continue     # You can't check against yourself...!

                    _tempSec = StoreSecurity(scanDup)
                    _len = 95

                    getDupID = scanDup.getIDString().strip().lower()
                    txt = " --- (Validating ID: %s)\n" \
                          "... '%s' NOTE: has %s price history records" %(scanDup.getIDString(), pad(_tempSec.shortDisplay(),_len), scanDup.getSnapshots().size())
                    output += "%s\n" %(txt)

                    if getDupID in foundIDs:
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as using identical ID                   %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getIDString(),primaryCurr.getIDString())
                        myPrint("DB",txt); output += "%s\n" %(txt)
                    else:
                        foundIDs.append(getDupID)

                    if scanDup.getRelativeCurrency() != primaryCurr.getRelativeCurrency():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not using the same relative currency %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getRelativeCurrency().getName(),primaryCurr.getRelativeCurrency().getName())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getDecimalPlaces() != primaryCurr.getDecimalPlaces():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same decimal places          %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getDecimalPlaces(),primaryCurr.getDecimalPlaces())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getRelativeRate() != primaryCurr.getRelativeRate():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same 'Current Prices'        %s vs %s" %(pad(_tempSec.shortDisplay(),_len),safeInvertRate(scanDup.getRelativeRate()),safeInvertRate(primaryCurr.getRelativeRate()))
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getPrefix()+scanDup.getSuffix() != primaryCurr.getPrefix()+primaryCurr.getSuffix():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same prefix/suffix           %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getPrefix()+":"+scanDup.getSuffix(),primaryCurr.getPrefix()+":"+primaryCurr.getSuffix())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    thisSplits = scanDup.getSplits()
                    if not compareSplits(primarySplits, thisSplits):
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not all have the same splits..." %(pad(_tempSec.shortDisplay(),_len))
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    output += "\n"
                    del _tempSec

                if lFailChecks:
                    txt = "... *** Failed checks - removing candidate....."
                    myPrint("DB",txt); output += "%s\n" %(txt)
                    removeList.append(dup)
                else:
                    txt = "... *** PASSED checks - will include as candidate for merging....."
                    myPrint("DB",txt); output += "%s\n" %(txt)

                output += "\n"

            for remove_ticker in removeList:
                del dup_securities[remove_ticker]
            del removeList

            try: myPrint("DB","%s: After validation, found %s %s" %(_THIS_METHOD_NAME, len(dup_securities), dup_securities))
            except: pass

            if len(securities) < 2 or len(dup_securities) < 1:
                output += "\n" \
                          "Use MD Menu > Tools>Securities to make changes necessary for Securities to 'qualify' for merging....\n" \
                          "Ensure you use a DIFFERENT ID for each duplicate - e.g. ^APPL1, ^APPL2, ^APPL3 for Apple (for example)...\n" \
                          "** except for decimal places differences. Use Toolbox 'MENU: Currency & Security tools > FIX: Edit a Security's (hidden) Decimal Place setting'\n" \
                          "\n"
                if lShowOutput:
                    txt = "%s: Not enough Securities / no valid duplicate Tickers found (refer report on screen for details) - NO CHANGES MADE" %(_THIS_METHOD_NAME)
                else:
                    txt = "%s: Not enough Securities / no duplicate Tickers found - NO CHANGES MADE" %(_THIS_METHOD_NAME)
                myPrint("B",txt); output += "\n%s\n" %(txt)
                setDisplayStatus(txt, "R")
                output += "\n<END>"
                if lShowOutput:
                    jif=QuickJFrame(txt, output, lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
                    myPopupInformationBox(jif,txt)
                else:
                    myPopupInformationBox(toolbox_frame_,txt)
                return
            del lShowOutput


            txt = _THIS_METHOD_NAME
            if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


            class StoreTickerData:
                def __init__(self, _theTicker, numberCandidates, listSecurityCandidates):
                    self.theTicker = _theTicker
                    self.numberCandidates = numberCandidates
                    self.listSecurityCandidates = listSecurityCandidates        # type: [CurrencyType]
                    self.primarySecurity = self.listSecurityCandidates[0]

                def getTicker(self):
                    return (self.theTicker)

                def getName(self):
                    return (self.primarySecurity.getName())

                def getSecurityList(self):
                    return (self.listSecurityCandidates)

                def getSecurityListWithoutPrimary(self):
                    listAccts = []
                    for acct in self.listSecurityCandidates:
                        if acct == self.getPrimarySecurity(): continue
                        listAccts.append(acct)
                    return (listAccts)

                def getPrimarySecurity(self):
                    return (self.primarySecurity)

                def setPrimarySecurity(self, theSecurity):
                    self.primarySecurity = theSecurity

                def getDisplayString(self, _security):
                    return ("%s:Ticker %s:ID %s:rate %s:dpc %s:%s:%s:(%s price history recs)"
                            % (_security.getName(),
                               self.theTicker,
                               _security.getIDString(),
                               safeInvertRate(_security.getRelativeRate()),
                               _security.getDecimalPlaces(),
                               _security.getPrefix(),
                               _security.getSuffix(),
                               _security.getSnapshots().size()))

                def __str__(self): return (self.getDisplayString(self.getPrimarySecurity()))[:200]

                def __repr__(self): return self.__str__()

            listDuplicateTickers = []
            output += "\nFinal list of 'duplicate' candidates...:\n"

            for dup in dup_securities:
                theDupDetails = dup_securities[dup]
                listDuplicateTickers.append(StoreTickerData(dup,theDupDetails[0],theDupDetails[1]))
                txt = ".. %s found for Ticker: '%s'" %(theDupDetails[0],dup)
                myPrint("DB",txt); output += "%s\n" %(txt)
                for theDups in theDupDetails[1]:
                    txt = "         - Name: %s ID: %s Rate: %s Dpc: %s Prx:Sfx: %s (Price History records: %s)"\
                          %(pad(theDups.getName(),30),
                            pad(theDups.getIDString(),20),
                            rpad(safeInvertRate(theDups.getRelativeRate()),12),
                            rpad(theDups.getDecimalPlaces(),2),
                            pad(theDups.getPrefix()+":"+theDups.getSuffix(),20),
                            rpad(theDups.getSnapshots().size(),12))
                    myPrint("DB",txt); output += "%s\n" %(txt)
                output += "\n"
            del dup_securities

            output += "\n"

            jif = QuickJFrame("%s: Candidates" %(_THIS_METHOD_NAME),output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

            tickerToMerge = JOptionPane.showInputDialog(jif,
                                                         "Select Ticker / Security set to merge (sorted by Name, Ticker, ID)",
                                                        _THIS_METHOD_NAME.upper(),
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(None),
                                                         listDuplicateTickers,
                                                         None)                                                              # type: StoreTickerData
            del listDuplicateTickers

            if not tickerToMerge:
                txt = "%s: User did not select a Ticker / Security set to merge - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            quickSecurityDropdownList = []
            for secDropdown in tickerToMerge.getSecurityList():
                quickSecurityDropdownList.append(StoreSecurity(secDropdown))

            selectedSecurity = JOptionPane.showInputDialog(jif,
                                                           "Select the Security that will be the final master (sorted by Name, Ticker, ID)",
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(None),
                                                           quickSecurityDropdownList,
                                                           None)  # type: StoreSecurity

            if not selectedSecurity:
                txt = "%s: User did not select a Security as the master for the merge - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            selectedSecurity = selectedSecurity.getSecurity()

            jif.dispose()

            if selectedSecurity != tickerToMerge.getPrimarySecurity():
                txt = "Master security switched from %s to %s (ID: %s)"\
                      %(tickerToMerge.getPrimarySecurity(), selectedSecurity, selectedSecurity.getIDString())
                myPrint("DB",txt); output += "%s\n" %(txt)
                tickerToMerge.setPrimarySecurity(selectedSecurity)

            output += "\n\n" \
                      "Selected Ticker / Security: '%s'\n" %(tickerToMerge.getTicker())

            output += "Selected Security to use as the master for the merge: %s\n\n" %(tickerToMerge.getDisplayString(selectedSecurity))
            del selectedSecurity

            # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
            allInvestmentAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(23))

            output += "\nAnalysis of Securities to Merge - Ticker '%s' - %s:\n\n" %(tickerToMerge.getTicker(),tickerToMerge.getName())

            lAnyCostBasisErrorsFound = [False]

            # Prepare before totals...
            _WHAT = 0
            _QTY = 1
            _COSTBASIS = 2
            _VALUE = 3
            _CBFLAG = 4

            # noinspection PyUnresolvedReferences
            def create_totals(theCount, theAccount, theTable):
                _acctRelCurr = theAccount.getCurrencyType()
                theTable.append(["Txn Count",    theCount, "", "", ""])
                theTable.append(["Account Starting Balance", "","",_acctRelCurr.formatSemiFancy(theAccount.getStartBalance(),MD_decimal), ""])
                theTable.append(["Cash Balance", "", "", _acctRelCurr.formatSemiFancy(theAccount.getBalance(),MD_decimal), ""])
                _totals = [0.0, 0.0, _acctRelCurr.getDoubleValue(theAccount.getBalance()), False]
                lDetectCBError = False
                for acct in theAccount.getSubAccounts():
                    if acct.getAccountType() == Account.AccountType.SECURITY:

                        if not InvestUtil.isCostBasisValid(acct):
                            lDetectCBError = True
                            lAnyCostBasisErrorsFound[0] = True

                        _subAcctRelCurr = acct.getCurrencyType()
                        subAcctBal = acct.getBalance()
                        subAcctCostBasis = InvestUtil.getCostBasis(acct)
                        # price = (1.0 / _subAcctRelCurr.adjustRateForSplitsInt(DateUtil.convertCalToInt(today), _subAcctRelCurr.getRelativeRate()))                        # noqa
                        price = CurrencyTable.getUserRate(_subAcctRelCurr, _acctRelCurr)                                # noqa

                        _totals[0] += _subAcctRelCurr.getDoubleValue(subAcctBal)
                        _totals[1] += _acctRelCurr.getDoubleValue(subAcctCostBasis)
                        _totals[2] +=  round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())
                        if lDetectCBError: _totals[3] = True
                        theTable.append([getSecurityNameAndID(acct.getCurrencyType()),
                                         _subAcctRelCurr.formatSemiFancy(subAcctBal,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(subAcctCostBasis,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())),MD_decimal),
                                         lDetectCBError])
                theTable.append(["**TOTALS:",
                                 _totals[0],
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[1]),MD_decimal),
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[2]),MD_decimal),
                                 _totals[3]])


            def output_stats(theText, theAccount, theTable):

                if theAccount.getCurrencyType() == base or theAccount.getCurrencyType() is None:
                    relText = ""
                else:
                    relText = " relative to %s" %(theAccount.getCurrencyType().getRelativeCurrency())

                local_output = "%s: %s (Currency: %s%s)\n" %(theText, theAccount, theAccount.getCurrencyType(), relText)
                iRow = 1
                posInc = 0
                for data in theTable:
                    if iRow == 2:
                        posInc += 14
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("Qty Shares",12), rpad("Cost Basis",15), rpad("Current Value",15))
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    if iRow == 4:
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("",12), rpad("",15), rpad("-------------",15))

                    if data[_WHAT].upper() == "**TOTALS:".upper():
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    cbMsg = ""
                    if data[_CBFLAG]: cbMsg = " * Cost Basis Error detected"
                    local_output += "   %s %s %s %s %s\n" %(pad(data[_WHAT],60+posInc),rpad(data[_QTY],12), rpad(data[_COSTBASIS],15), rpad(data[_VALUE],15),cbMsg)
                    iRow += 1
                return local_output


            def isSecurityHeldWithinInvestmentAccount(_theSecurity, _theInvestmentAccount):

                _subAccts = _theInvestmentAccount.getSubAccounts()
                for _subAcct in _subAccts:
                    # noinspection PyUnresolvedReferences
                    if _subAcct.getAccountType() != Account.AccountType.SECURITY: continue
                    _subAcctCurr = _subAcct.getCurrencyType()
                    if _subAcctCurr is None: continue
                    if _subAcctCurr == _theSecurity:
                        return _subAcct

                return None


            def isSecurityHeldWithinAnyInvestmentAccount(_theSecurity):

                # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
                _subAccts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(22))

                for _subAcct in _subAccts:
                    # noinspection PyUnresolvedReferences
                    if _subAcct.getAccountType() != Account.AccountType.SECURITY: continue
                    _subAcctCurr = _subAcct.getCurrencyType()
                    if _subAcctCurr is None: continue
                    if _subAcctCurr == _theSecurity:
                        return _subAcct

                return None


            def isAnySecurityHeldWithinInvestmentAccount(_theSecurityList, _theInvestmentAccount):

                for _theSecurity in _theSecurityList:
                    _result = isSecurityHeldWithinInvestmentAccount(_theSecurity,_theInvestmentAccount)
                    if _result is not None: return True

                return False


            for security in tickerToMerge.getSecurityList():
                output += "%s Price History Records: %s\n" %(pad(getSecurityNameAndID(security),80),rpad(security.getSnapshots().size(),10))
            output += "\n"


            # OK, now scan existing investment accounts... More validation.....
            investmentAccountsInvolvedInMerge = {}
            investmentAccountsNeedingPrimaryCreated = {}
            investmentAccountsNeedingSecondaryMerge = {}

            lFailValidation = False
            iFoundAnyInvestmentAccounts = 0
            iPrimarySecuritiesToCreate = 0
            iSecuritiesMergedDeleted = 0
            output += "Investment Accounts:\n"
            for investAccount in allInvestmentAccounts:
                if not isAnySecurityHeldWithinInvestmentAccount(tickerToMerge.getSecurityList(), investAccount): continue
                failStartingBalanceMustBeZero = False
                failUsesAverageCostValidation = False
                validateUsesAvgCost = None
                iFoundAnyInvestmentAccounts += 1
                output += "** %s\n" %(investAccount.getAccountName())
                foundPrimary = isSecurityHeldWithinInvestmentAccount(tickerToMerge.getPrimarySecurity(), investAccount)
                if not foundPrimary:
                    iPrimarySecuritiesToCreate += 1
                    output += "   <NEW MASTER SECURITY NOT FOUND IN THIS INVESTMENT ACCOUNT - WILL BE ADDED>\n"
                foundSecondary = False
                for security in tickerToMerge.getSecurityList():
                    foundSecurity = isSecurityHeldWithinInvestmentAccount(security, investAccount)
                    if foundSecurity is not None:
                        if security != tickerToMerge.getPrimarySecurity():
                            foundSecondary = True
                            iSecuritiesMergedDeleted += 1
                        txnsUsed = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(foundSecurity)
                        _relCurr = foundSecurity.getCurrencyType()
                        output += "   %s Uses Avg Cost: %s Shares Held: %s Txns: %s" \
                                  %(pad("'%s':%s" %(foundSecurity.getParentAccount().getAccountName()[:30], getSecurityNameAndID(foundSecurity.getCurrencyType(),theLen=35)),85),
                                    pad(str(foundSecurity.getUsesAverageCost()),6),
                                    rpad(_relCurr.formatSemiFancy(foundSecurity.getBalance(),MD_decimal),18),
                                    rpad(txnsUsed.getSize(),15))
                        if security == tickerToMerge.getPrimarySecurity():
                            output += "   <MASTER - KEEP>\n"
                        else:
                            output += "   ** will be merged/removed **\n"

                        if foundSecurity.getStartBalance() != 0:
                            failStartingBalanceMustBeZero = lFailValidation = True
                            output += "   *** <ERROR - StartingBalance() reports %s - SHOULD ALWAYS BE ZERO! CANNOT MERGE>\n" %(foundSecurity.getStartBalance())

                        if validateUsesAvgCost is None:
                            validateUsesAvgCost = foundSecurity.getUsesAverageCost()
                        elif validateUsesAvgCost != foundSecurity.getUsesAverageCost():
                            output += "   *** <ERROR - UsesAverageCost() differs between Investment Accounts for this same Security! CANNOT MERGE>\n"
                            failUsesAverageCostValidation = lFailValidation = True

                investmentAccountsInvolvedInMerge[investAccount] = True

                if failUsesAverageCostValidation or failStartingBalanceMustBeZero:
                    output += "   <Above Investment account FAILED VALIDATION. Function will ABORT WITHOUT CHANGES>\n"
                elif foundSecondary:
                    investmentAccountsNeedingSecondaryMerge[investAccount] = True
                    output += "   <Above Investment account will be included in Security merge>\n"
                    if not foundPrimary:
                        investmentAccountsNeedingPrimaryCreated[investAccount] = True
                else:
                    output += "   <Above Investment account will NOT be touched, no 'duplicate' securities to merge>\n"

                output += "   ----\n"
            del allInvestmentAccounts

            if not iFoundAnyInvestmentAccounts:
                output += "<NONE FOUND>\n\n"
            else:
                output += "%s Investment Accounts are involved in the merge...\n" %(iFoundAnyInvestmentAccounts)
                output += "... Will add the master security to %s investment accounts\n" %(iPrimarySecuritiesToCreate)
                output += "... Will merge/remove %s duplicate securities from investment accounts\n" %(iSecuritiesMergedDeleted)
                output += "----\n"


            if lFailValidation:
                txt = "\n\n INVESTMENT ACCOUNT: SECURITY HOLDING VALIDATION FAILED - CANNOT PROCEED! Review the report on screen for details.\n"
                myPrint("DB", txt); output += "\n\n%s\n" %(txt)
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            output += "\n"

            ############################################################################################################
            # OK - Snapshot validation etc
            primarySnaps = 0
            allOtherSnaps = 0
            for security in tickerToMerge.getSecurityList():
                if security == tickerToMerge.getPrimarySecurity():
                    primarySnaps = security.getSnapshots().size()
                else:
                    allOtherSnaps += security.getSnapshots().size()

            lSnapshotActionRequired = False
            lSnapsDeleteAll = lSnapsMergeAll = lSnapsKeepMasterOnly = lSnapsDumpMaster = False
            if (primarySnaps+allOtherSnaps) < 1:
                output += "No Price History Exists - No action required....\n"
            elif primarySnaps > 0 and allOtherSnaps < 1:
                output += "Only the Primary Security has Price History records - No action required....\n"
            else:
                lSnapshotActionRequired = True
                output += "Master Security has %s Price History records, the others have %s - STRATEGY REQUIRED...\n" %(primarySnaps, allOtherSnaps)

            if lSnapshotActionRequired:
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()

                options = ["Keep Master's %s Price History Records Only (dump the other's %s records)"  %(primarySnaps, allOtherSnaps),
                           "Merge all other %s history records into master's (currently holds %s)"      %(allOtherSnaps, primarySnaps),
                           "Dump Master's %s Price History records, merge %s others into master"        %(primarySnaps, allOtherSnaps),
                           "DELETE ALL %s PRICE HISTORY RECORDS"                                        %(primarySnaps+allOtherSnaps)]

                selectedSnapStrategy = JOptionPane.showInputDialog(jif,
                                                               "Select the Price History Strategy?",
                                                               "%s - PRICE HISTORY" %(_THIS_METHOD_NAME.upper()),
                                                               JOptionPane.INFORMATION_MESSAGE,
                                                               getMDIcon(lAlwaysGetIcon=True),
                                                               options,
                                                               None)

                if not selectedSnapStrategy:
                    txt = "%s: User did not select a Price History Strategy for the merge - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                jif.dispose()

                if options.index(selectedSnapStrategy) == 0:    lSnapsKeepMasterOnly = True
                elif options.index(selectedSnapStrategy) == 1:  lSnapsMergeAll = True
                elif options.index(selectedSnapStrategy) == 2:  lSnapsDumpMaster = True
                else:                                           lSnapsDeleteAll = True

                output += "** Price History Strategy selected: %s\n\n" %(selectedSnapStrategy)


            ############################################################################################################
            # OK - hidden CUSIP validation etc


            def countCUSIPs(_theSec):
                iCUSIPs = 0
                for key in _theSec.getParameterKeys():
                    if key.startswith(PARAM_CURRID):
                        iCUSIPs += 1
                return iCUSIPs


            def getAllUniqueCUSIPs(_theSecList):
                _allUniqueCUSIPs = {}
                returnUniqueCUSIPs = []
                for _theSec in _theSecList:
                    for key in _theSec.getParameterKeys():
                        if key.startswith(PARAM_CURRID):
                            _theScheme = key[len(PARAM_CURRID):]
                            _theCUSIP = _theSec.getIDForScheme(_theScheme)
                            if _allUniqueCUSIPs.get(_theScheme+"."+_theCUSIP) is None:
                                _allUniqueCUSIPs[_theScheme+"."+_theCUSIP] = True
                                returnUniqueCUSIPs.append([_theScheme, _theCUSIP])
                return returnUniqueCUSIPs


            primaryCUSIPs = 0
            allOtherCUSIPs = 0
            for security in tickerToMerge.getSecurityList():
                if security == tickerToMerge.getPrimarySecurity():
                    primaryCUSIPs = countCUSIPs(security)
                else:
                    allOtherCUSIPs += countCUSIPs(security)

            allUniqueCUSIPs = getAllUniqueCUSIPs(tickerToMerge.getSecurityList())
            if len(allUniqueCUSIPs) > 0:
                output += "Hidden CUSIP data found (used for linking Investment Downloaded Securities to MD Securities)...:\n"
                for theScheme, theCUSIP in allUniqueCUSIPs:
                    output += "Scheme: %s, ID: %s\n" %(theScheme, theCUSIP)
                output += "\n"

            lCUSIPActionRequired = False
            if len(allUniqueCUSIPs) < 1:
                output += "No hidden CUSIP data exists - This is OK and No action required....\n"
            elif primaryCUSIPs > 0 and allOtherCUSIPs < 1:
                output += "Only the Master Security has hidden CUSIP data - This is OK and No action required....\n"
            else:
                lCUSIPActionRequired = True
                output += "Hidden CUSIP data - STRATEGY REQUIRED...\n"

            selectedCUSIP = None
            if lCUSIPActionRequired:
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()

                class StoreCUSIP:
                    def __init__(self, _objScheme, _objCUSIP):
                        self._objScheme = _objScheme
                        self._objCUSIP = _objCUSIP

                    def getScheme(self): return self._objScheme

                    def getCUSIP(self): return self._objCUSIP

                    def __str__(self):
                        if self.getScheme() is None: return ("<NONE> (No hidden CUSIP data)")
                        return ("Scheme: %s, ID: %s" % (self.getScheme(), self.getCUSIP()))

                    def __repr__(self): return self.__str__()


                allUniqueCUSIPsPicklist = []                                                                            # noqa
                allUniqueCUSIPsPicklist.append(StoreCUSIP(None,None))
                for theScheme, theCUSIP in allUniqueCUSIPs:
                    allUniqueCUSIPsPicklist.append(StoreCUSIP(theScheme, theCUSIP))

                selectedCUSIP = JOptionPane.showInputDialog(jif,
                                                            "Select the hidden CUSIP to keep/use in the new Master Security?",
                                                            "%s - HIDDEN CUSIP DATA" % (_THIS_METHOD_NAME.upper()),
                                                            JOptionPane.INFORMATION_MESSAGE,
                                                            getMDIcon(lAlwaysGetIcon=True),
                                                            allUniqueCUSIPsPicklist,
                                                            None)

                del allUniqueCUSIPsPicklist

                if not selectedCUSIP:
                    txt = "%s: User did not select a hidden CUSIP record for the merge - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                jif.dispose()

                output += "** Hidden CUSIP Strategy: - CUSIP data selected: %s\n\n" %(selectedCUSIP)
            del allUniqueCUSIPs


            ############################################################################################################
            output += "\n------\n"
            output += "Investment Accounts included in merge:                  %s\n" %(len(investmentAccountsInvolvedInMerge))
            output += "Investment new Master securities to be added:           %s\n" %(len(investmentAccountsNeedingPrimaryCreated))
            output += "Investment 'duplicate' securities to be merged/removed: %s\n" %(len(investmentAccountsNeedingSecondaryMerge))
            output += "\n------\n"


            jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
            ask = MyPopUpDialogBox(jif,
                                   "%s: REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE SECURITY MERGE" %(_THIS_METHOD_NAME.upper()),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s: User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R"); myPrint("B",txt)
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE MERGE OF SECURITY %s / %s?" %(tickerToMerge.getTicker(),tickerToMerge.getPrimarySecurity())):
                return

            jif.dispose()

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH SECURITY MERGE of %s / %s.....\n\n" %(tickerToMerge.getTicker(),getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))

            if len(investmentAccountsInvolvedInMerge) > 0:
                output += "\nSTATISTICS BEFORE START...\n\n"
                for reportAccount in investmentAccountsInvolvedInMerge:
                    getTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(reportAccount)
                    countTxns = getTxns.getSize()
                    valuesTable = []
                    create_totals(countTxns, reportAccount, valuesTable)
                    output += output_stats("Before:", reportAccount, valuesTable)
                    output += "\n----\n"
                    del getTxns, valuesTable

                if lAnyCostBasisErrorsFound[0]:
                    output += "\n\n** WARNING: Lot Control / Cost Basis errors detected before changes started - review output....\n\n"
                else:
                    output += "\nLot Control / Cost Basis reports OK before changes....\n"

            output += "\n"

        except:
            txt = ("MINOR ERROR - %s: crashed before any merge actions. Please review output and console" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing 'duplicate' security merge right now..",
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the merge..
            MD_REF.getCurrentAccountBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            ############################################################################################################
            # Start with snapshot merge...
            if not lSnapshotActionRequired:
                txt = "Skipping Price History actions...."
                myPrint("B", txt); output += "%s\n\n" %(txt)
            else:
                primary = tickerToMerge.getPrimarySecurity()
                if lSnapsDumpMaster or lSnapsDeleteAll:
                    getSnaps = primary.getSnapshots()
                    txt = "Deleting %s price history records from %s" %(getSnaps.size(), getSecurityNameAndID(primary))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    SyncerDebug.changeState(debug)
                    for snap in getSnaps: snap.deleteItem()
                    SyncerDebug.resetState()

                if lSnapsMergeAll or lSnapsDumpMaster:
                    for security in tickerToMerge.getSecurityListWithoutPrimary():
                        rCurr = primary.getRelativeCurrency()
                        getSnaps = security.getSnapshots()
                        txt = "Merging %s potential price history records from %s into %s" %(getSnaps.size(), getSecurityNameAndID(security), getSecurityNameAndID(primary))
                        myPrint("B",txt); output += "%s\n" %(txt)
                        for snap in getSnaps:
                            foundSnap = primary.getSnapshotForDate(snap.getDateInt())
                            if foundSnap is not None and foundSnap.getDateInt() == snap.getDateInt():
                                # Found a match - skip
                                pass
                            else:
                                newSnap = primary.addSnapshotInt(snap.getDateInt(), snap.getRate(), rCurr)
                                newSnap.setEditingMode()
                                newSnap.setDailyVolume(snap.getDailyVolume())
                                newSnap.setUserDailyLow(snap.getDailyLow())
                                newSnap.setUserDailyHigh(snap.getDailyHigh())
                                newSnap.syncItem()

                if lSnapsKeepMasterOnly: pass

                for security in tickerToMerge.getSecurityListWithoutPrimary():
                    getSnaps = security.getSnapshots()
                    txt = "Now Deleting %s price history records from %s (post any merge actions)" %(getSnaps.size(), getSecurityNameAndID(security))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    SyncerDebug.changeState(debug)
                    for snap in getSnaps: snap.deleteItem()
                    SyncerDebug.resetState()

                output += "----\n"
                output += "Master %s now contains: %s Price History records...\n" %(getSecurityNameAndID(primary), primary.getSnapshots().size())
                for security in tickerToMerge.getSecurityListWithoutPrimary():
                    output += "Duplicate %s now contains: %s Price History records...\n" %(getSecurityNameAndID(security), security.getSnapshots().size())
                output += "----\n"

            ############################################################################################################
            # Now CUSIP merge...

            def deleteCUSIPs(_theSec):
                _deleteList = []
                for key in _theSec.getParameterKeys():
                    if key.startswith(PARAM_CURRID):
                        _theScheme = key[len(PARAM_CURRID):]
                        _deleteList.append(_theScheme)
                for _delSchemeCUSIP in _deleteList:
                    _theSec.setIDForScheme(_delSchemeCUSIP, None)


            if not lCUSIPActionRequired:
                txt = "Skipping hidden CUSIP data actions...."
                myPrint("B", txt); output += "%s\n\n" %(txt)

            else:

                txt = "Removing any hidden CUSIP data from %s" %(getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))
                myPrint("B",txt); output += "%s\n" %(txt)

                tickerToMerge.getPrimarySecurity().setEditingMode()
                deleteCUSIPs(tickerToMerge.getPrimarySecurity())

                if selectedCUSIP.getScheme():
                    txt = "Adding CUSIP data - Scheme: %s ID: %s to %s" %(selectedCUSIP.getScheme(), selectedCUSIP.getCUSIP(), getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    tickerToMerge.getPrimarySecurity().setIDForScheme(selectedCUSIP.getScheme(),selectedCUSIP.getCUSIP())

                tickerToMerge.getPrimarySecurity().setParameter(PARAMETER_KEY,True)
                tickerToMerge.getPrimarySecurity().syncItem()

                output += "----\n"
                output += "Master %s now contains: hidden CUSIP record: Scheme: %s, ID: %s\n" %(getSecurityNameAndID(tickerToMerge.getPrimarySecurity()), selectedCUSIP.getScheme(),selectedCUSIP.getCUSIP())
                output += "----\n"


            ############################################################################################################
            # Now create any missing Primary security sub account(s)...

            if len(investmentAccountsNeedingPrimaryCreated) > 0:
                txt = "Adding the new master Security to %s Investment accounts:" %(len(investmentAccountsNeedingPrimaryCreated))
                myPrint("B", txt); output += "%s\n" %(txt)

                primary = tickerToMerge.getPrimarySecurity()
                for createAccount in investmentAccountsNeedingPrimaryCreated:
                    # Copy the first one we find... Yup - there could be more, but tough!
                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,createAccount)

                        if copyAcct is None: continue

                        txt = "... Adding: %s to %s" %(getSecurityNameAndID(primary), createAccount)
                        myPrint("B", txt); output += "%s\n" %(txt)

                        newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(),
                                                              Account.AccountType.SECURITY,
                                                              createAccount)
                        newSecurityAcct.setEditingMode()
                        newSecurityAcct.getUUID()
                        newSecurityAcct.setAccountName(primary.getName())
                        newSecurityAcct.setCurrencyType(primary)
                        newSecurityAcct.setStartBalance(0)

                        newSecurityAcct.setUsesAverageCost(copyAcct.getUsesAverageCost())
                        newSecurityAcct.setBroker(copyAcct.getBroker())
                        newSecurityAcct.setBrokerPhone(copyAcct.getBrokerPhone())
                        newSecurityAcct.setAPR(copyAcct.getAPR())
                        newSecurityAcct.setBondType(copyAcct.getBondType())
                        newSecurityAcct.setComment(copyAcct.getComment())
                        newSecurityAcct.setCompounding(copyAcct.getCompounding())
                        newSecurityAcct.setFaceValue(copyAcct.getFaceValue())
                        newSecurityAcct.setFaceValue(copyAcct.getFaceValue())
                        newSecurityAcct.setMaturity(copyAcct.getMaturity())
                        newSecurityAcct.setMonth(copyAcct.getMonth())
                        newSecurityAcct.setNumYears(copyAcct.getNumYears())
                        newSecurityAcct.setPut(copyAcct.getPut())
                        newSecurityAcct.setOptionPrice(copyAcct.getOptionPrice())
                        newSecurityAcct.setDividend(copyAcct.getDividend())
                        newSecurityAcct.setExchange(copyAcct.getExchange())
                        newSecurityAcct.setSecurityType(copyAcct.getSecurityType())
                        newSecurityAcct.setSecuritySubType(copyAcct.getSecuritySubType())
                        newSecurityAcct.setStrikePrice(copyAcct.getStrikePrice())

                        for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                            newSecurityAcct.setParameter(param, copyAcct.getParameter(param))

                        newSecurityAcct.setParameter(PARAMETER_KEY,True)
                        newSecurityAcct.syncItem()

                        break

            lErrorDeletingSecuritySubAccounts = False
            if len(investmentAccountsNeedingSecondaryMerge) > 0:
                txt = "Now reassigning relevant txns to the new/merged master security....:"
                myPrint("B", txt); output += "\n\n%s\n" %(txt)

                # now for the merge/reassignment of relevant transactions...
                for reassignAcct in investmentAccountsNeedingSecondaryMerge:

                    primaryAcct = isSecurityHeldWithinInvestmentAccount(tickerToMerge.getPrimarySecurity(),reassignAcct)

                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,reassignAcct)
                        if copyAcct is None: continue

                        reassignTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(copyAcct)
                        reassignTxns = sorted(reassignTxns, key=lambda _x: (_x.getDateInt()))

                        # Note sorted loses x.getSize() >> use len(x)
                        output += "... retrieved %s txns from duplicate security %s within investment account '%s' - reassigning.....\n" %(len(reassignTxns), getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount())

                        for srcTxn in reassignTxns:

                            if not isinstance(srcTxn, SplitTxn):       # Should never happen..... ;->
                                raise Exception("Error: found a non-split: %s" %(srcTxn))

                            pTxn = srcTxn.getParentTxn()
                            pTxn.setEditingMode()
                            srcTxn.setAccount(primaryAcct)
                            srcTxn.setParameter(PARAMETER_KEY,True)
                            pTxn.syncItem()
                            output += ".. %s %s %s %s\n" %(convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                           pad(pTxn.getInvestTxnType().getIDString(),12),
                                                           pad(pTxn.getDescription()+pTxn.getMemo(),60),
                                                           rpad(copyAcct.getCurrencyType().formatFancy(srcTxn.getValue(),MD_decimal),18))
                            continue

                        output += "\n"
                        del reassignTxns

                output += "\n>> Txn reassignment completed.....\n\n"

                txt = "Now removing duplicate securities from Investment account(s)...."
                myPrint("B", txt); output += "\n%s\n" %(txt)

                ############################################################################################################
                # now delete the empty sub accounts.....
                for reassignAcct in investmentAccountsNeedingSecondaryMerge:

                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,reassignAcct)
                        if copyAcct is None: continue

                        remainingTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(copyAcct)
                        output += "... %s txns left in %s for duplicate security %s ..." %(remainingTxns.getSize(), copyAcct.getParentAccount(), getSecurityNameAndID(copyAcct.getCurrencyType()))

                        if remainingTxns.getSize() < 1:
                            txt = "... Removing: security %s (empty) from Account: %s" %(getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount())
                            myPrint("B", txt); output += "%s\n" %(txt)
                            copyAcct.deleteItem()
                        else:
                            lErrorDeletingSecuritySubAccounts = True
                            txt = "... *** ERROR - Cannot remove security %s from %s as it still contains %s txns! ***" %(getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount(), remainingTxns.getSize())
                            myPrint("B", txt); output += "%s\n" %(txt)

                output += "\n>> Removal of duplicate Securities from Investment Account(s) completed.....\n\n"

            # Now delete the (empty) and now unused old duplicate Securities
            txt = "Now deleting the redundant duplicate security(s) (that have been merged into the new master) from Tools>Securities..:"
            myPrint("B", txt); output += "\n%s\n\n" %(txt)

            lErrorDeletingSecurities = False
            for securityToDelete in tickerToMerge.getSecurityListWithoutPrimary():
                findSecurityAcct = isSecurityHeldWithinAnyInvestmentAccount(securityToDelete)
                if findSecurityAcct is None:
                    output += ".. Verified %s is not being used...... DELETING REDUNDANT SECURITY FROM TOOLS>SECURITIES....\n" %(getSecurityNameAndID(securityToDelete))
                    securityToDelete.deleteItem()
                else:
                    lErrorDeletingSecurities = True
                    output += ".. ERROR %s is still being used in %s ...... ** NOT DELETING REDUNDANT SECURITY FROM TOOLS>SECURITIES **\n" %(getSecurityNameAndID(securityToDelete), findSecurityAcct)

            output += "\n>> Merge 'duplicate' Securities completed..\n\n"

            del tickerToMerge

        except:

            txt = ("MAJOR ERROR - %s: crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output, lAlertLevel=2, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset merge 'duplicate' security changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es)..")
            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccountBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # OK - Main update is done....

            lAnyCostBasisErrorsFound[0] = False
            if len(investmentAccountsInvolvedInMerge) > 0:
                output += "\n\nSTATISTICS AFTER MERGE ACTIONS COMPLETED...\n\n"
                for reportAccount in investmentAccountsInvolvedInMerge:
                    getTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(reportAccount)
                    countTxns = getTxns.getSize()
                    valuesTable = []
                    create_totals(countTxns, reportAccount, valuesTable)
                    output += output_stats("After:", reportAccount, valuesTable)
                    output += "\n----\n"
                    del getTxns, valuesTable

                if lAnyCostBasisErrorsFound[0]:
                    output += "\n\n** WARNING: Lot Control / Cost Basis errors detected after changes completed - review output....\n\n"
                else:
                    output += "\nLot Control / Cost Basis reports OK after changes....\n"

            del investmentAccountsInvolvedInMerge, investmentAccountsNeedingSecondaryMerge, investmentAccountsNeedingPrimaryCreated

            output += "\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and merge actions) back to disk.....",
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccountBook().saveTrunkFile()
                pleaseWait.kill()

            if lErrorDeletingSecuritySubAccounts or lErrorDeletingSecurities:
                txt = "%s: completed ** WITH ERRORS ** Please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.ERROR_MESSAGE
                optionColor = "R"
            elif lAnyCostBasisErrorsFound[0]:
                txt = "%s: completed ** NOTE: You have Lot Control errors >> please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.ERROR_MESSAGE
                optionColor = "R"
            else:
                txt = "%s: successfully completed - please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.INFORMATION_MESSAGE
                optionColor = "DG"
            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES ***\n\n"
            output += "\n<END>"

        except:
            txt = ("ERROR - %s: crashed after the merge actions. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame(txt,output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
        setDisplayStatus(txt, optionColor)
        logToolboxUpdates("merge_duplicate_securities", txt)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionMessage)

    def move_merge_investment_txns():
        if MD_REF.getCurrentAccountBook() is None: return

        _THIS_METHOD_NAME = "Move/Merge Investment Accounts"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        scriptToRun = "toolbox_move_merge_investment_txns.py"

        # if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute the script: %s?" %(scriptToRun)):
        #     return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    def fix_non_hier_sec_acct_txns(autofix=False):

        _THIS_METHOD_NAME = "FIX: Non-Hierarchical Security Acct Txns".upper()

        PARAMETER_KEY = "toolbox_fix_non_hier_sec_acct_txns"

        book = MD_REF.getCurrentAccountBook()
        base = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()

        # fix_non-hierarchical_security_account_txns.py
        # (replaces fix_investment_txns_to_wrong_security.py)

        if autofix: myPrint("B", "AUTOFIX running... There will be no prompts and all fixes will be applied silently....")

        myPrint("B", "Diagnosing Investment Transactions where Security's Account is not linked properly to the Parent Txn's Acct")
        myPrint("P", " ----------------------------------------------------------------------------------------------------------")

        output = "FIX Investment Transactions where Security's Account is not linked properly to the Parent Txn's Acct:\n" \
                 " =====================================================================================================\n\n"

        try:

            def getAccountTypeTxt(acct):
                _at = acct.getAccountType()
                return ("Investment" if (_at == Account.AccountType.INVESTMENT) else "NON INVESTMENT(%s)" %(_at))   # noqa

            txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
            txns = list(txnSet.iterableTxns())      # copy into list() to prevent concurrent modification when modifying.....
            fields = InvestFields()

            iOrphans = 0
            txt = "Scanning for Security Orphans...:"
            output += "\n%s\n" %(txt); myPrint("B",txt)

            saveInvestmentAccountsNeedingDummy = {}
            for _txn in txns:
                if not isinstance(_txn, ParentTxn): continue   # only work with parent transactions
                _acct = _txn.getAccount()
                _acctType = _acct.getAccountType()

                if _acctType == Account.AccountType.SECURITY:                                                           # noqa
                    # Should never happen - abort early.....
                    txt = "ERROR: Found Parent Txn where the Txn's Account Type is a SECURITY (review console for details)!"
                    myPrint("B", txt, "Txn follows..:")
                    myPrint("B", _txn.toMultilineString())
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt, "ERROR", theMessageType=JOptionPane.ERROR_MESSAGE)
                    return

                if _acctType != Account.AccountType.INVESTMENT: continue                                                # noqa

                fields.setFieldStatus(_txn)

                if fields.hasSecurity and fields.security is None:
                    iOrphans += 1
                    txt = "ERROR: Txn for 'Orphaned' Security %s found within Investment Account %s! (old QIF import or you have force removed a Security with linked TXNs?\n" \
                          "txn:\n%s\n" %(fields.security, _acct, _txn.getSyncInfo().toMultilineHumanReadableString())
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                    saveInvestmentAccountsNeedingDummy[_acct] = True

            if iOrphans:
                txt = "ERROR: %s investment txn(s) with 'Orphaned' securities detected (probably an old QIF import or User has force removed Security from Investment Account)" %(iOrphans)
                if not autofix:
                    MyPopUpDialogBox(toolbox_frame_,
                                     txt,
                                     "It's highly likely that you have...:\n"
                                     "a) Historical QIF Import data (improperly imported); OR\n"
                                     "b) Dividend txns that were downloaded from QIF/OFX/MD+ with no Security assigned; OR\n"
                                     "c) You have previously clicked 'Actions' > 'Remove Security' from an Investment Account..:\n"
                                     ".. and where this Security had linked Transactions... You would have been warned and asked to respond 'yes'\n"
                                     ".. this will have deleted Buy/Sell txns and partially removed the Security from other related txns (e.g. Div, MiscInc/Exp etc)\n"
                                     ".. these are 'illogical' and/or 'damaged' records.... The proper 'security' linkage is irrecoverable\n"
                                     ">> Toolbox can 'repair' these txns by assigning a 'dummy' security which you can edit/change later.\n"
                                     "(suggestion: for a/b above where it's mainly Dividends, use Tools/Securities. Rename security 'TOOLBOX' to 'Dividends(Misc)')\n"
                                     "**OR** You can restore, or manually edit and repair the txns with your own knowledge of what security was lost...",
                                     theTitle=_THIS_METHOD_NAME,
                                     OKButtonText="ACKNOWLEDGED",
                                     lAlertLevel=1).go()

            else:
                txt = ">> No investment txn(s) with Orphaned securities were detected!"
                output += "\n%s\n" %(txt); myPrint("B",txt)

            output += "\n\n"

            lFixedOrphans = False
            ############################################################################################################
            if iOrphans:

                if autofix:
                    txt = "AUTOFIX will proceed and fix 'Orphaned' securities..."
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                else:
                    txt = "ERROR: %s investment txn(s) with 'Orphaned' securities detected (probably an old QIF import or User has force removed a Security from this Investment Account)" %(iOrphans)
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                    jif = QuickJFrame(_THIS_METHOD_NAME,output,lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
                    if not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME, "FIX %s orphaned security txns (using a dummy security)?" %(iOrphans)):
                        return

                    jif.dispose()
                    txt = "User accepted disclaimer to FIX orphaned security txns. Proceeding....."
                    output += "\n%s\n" %(txt); myPrint("B",txt)

                newSecurity = CurrencyType(book.getCurrencies())  # Creates a new CT object
                newSecurity.setEditingMode()
                newSecurity.setRelativeCurrency(base)
                newSecurity.setCurrencyType(CurrencyType.Type.SECURITY)                                                 # noqa
                newSecurity.setName("TOOLBOX: %s" %(_THIS_METHOD_NAME))
                newSecurity.setIDString("^TOOLBOX")
                newSecurity.setTickerSymbol("^TOOLBOX")
                newSecurity.setDecimalPlaces(4)
                newSecurity.setRelativeRate(1.0)
                newSecurity.syncItem()
                output += "\n\nCreated dummy Security: %s (%s)\n" %(newSecurity, newSecurity.getUUID())

                dummySecurityAccounts = {}

                for _txn in txns:
                    if not isinstance(_txn, ParentTxn): continue   # only work with parent transactions
                    _acct = _txn.getAccount()
                    if _acct.getAccountType() != Account.AccountType.INVESTMENT: continue                               # noqa
                    fields.setFieldStatus(_txn)

                    if fields.hasSecurity and fields.security is None:

                        if saveInvestmentAccountsNeedingDummy.pop(_acct, False):

                            # need to create the Security sub-account in this Investment Account....
                            newSecurityAcct = Account.makeAccount(book, Account.AccountType.SECURITY, _acct)            # noqa
                            newSecurityAcct.setEditingMode()
                            newSecurityAcct.getUUID()
                            newSecurityAcct.setAccountName("TOOLBOX DUMMY")
                            newSecurityAcct.setCurrencyType(newSecurity)
                            newSecurityAcct.setStartBalance(0)
                            newSecurityAcct.setUsesAverageCost(True)
                            newSecurityAcct.setComment("Dummy created by Toolbox: %s" %(_THIS_METHOD_NAME))
                            newSecurityAcct.setParameter(PARAMETER_KEY, True)
                            newSecurityAcct.syncItem()
                            output += "\nCreated dummy Security Sub Account: %s (%s) linked to new dummy security\n" %(newSecurityAcct, newSecurityAcct.getUUID())
                            dummySecurityAccounts[_acct] = newSecurityAcct

                        fields.security = dummySecurityAccounts[_acct]
                        fields.storeFields(_txn)
                        _txn.syncItem()

                        txt = "FIXED: Txn for 'Orphaned' Security - Investment Account %s: '%s'\n" %(_acct, _txn)
                        output += "\n%s\n" %(txt)

                output += "\nFinished fixing 'orphans'....\n" \
                          " -----------------------------\n\n"
                lFixedOrphans = True

                # Create a new list of txns
                txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
                txns = list(txnSet.iterableTxns())      # copy into list() to prevent concurrent modification when modifying.....

            ############################################################################################################

            def review_security_accounts(_txns, FIX_MODE=False):

                count_the_errors = 0
                count_unfixable_yet = 0
                errors_fixed = 0
                text = ""
                for txn in _txns:
                    if not isinstance(txn, ParentTxn): continue   # only work with parent transactions

                    acct = txn.getAccount()
                    acctType = acct.getAccountType()

                    # if acct.getAccountType() != Account.AccountType.INVESTMENT: continue

                    isSittingInInvestmentAccount = acctType == Account.AccountType.INVESTMENT                           # noqa

                    # at this point we are only dealing with investment parent txns
                    fields.setFieldStatus(txn)

                    if fields.hasSecurity and not acct.isAncestorOf(fields.security):
                        count_the_errors += 1
                        txnTxt = txn.toMultilineString().replace(";",";\n")
                        text += ("Must fix txn %s\n"
                                 "%s\n"
                                 " > in '%s' with sec acct '%s'\n" %(fields.txnType,
                                                                 txnTxt,
                                                                 acct,
                                                                 (None if (fields.security is None) else fields.security.getFullAccountName())))

                        if not isSittingInInvestmentAccount:
                            if fields.security is None:
                                text += ("** CANNOT FIX Txn where the Parent is sitting within an %s account and the SECURITY is NONE - SKIPPING **"
                                         %(getAccountTypeTxt(acct)))
                                continue

                            # This fix is for where the investment txn is not sitting within an Investment account (batch change on xfr category usually)...
                            text += " >> LOGICAL ERROR as Parent txn is sitting within an %s account **\n" %(getAccountTypeTxt(acct))
                            correctParentAcct = fields.security.getParentAccount()
                            if FIX_MODE:
                                errors_fixed += 1
                                text += (" -> ASSIGNING txn's Parent account to '%s'\n" %(correctParentAcct))
                                txn.setAccount(correctParentAcct)
                                txn.syncItem()
                            else:
                                text+=(" -> need to assign txn's Parent account to '%s'\n" %(correctParentAcct))
                            continue
                        else:
                            # This fix assumes that the split / security bit should sit within the txn's parent account. It seeks for the same
                            # security in this account and reattaches it.

                            # Alternatively you could txn.setAccount() to be the split security's parent account
                            # e.g. txn.setAccount(fields.security.getParentAccount())

                            if fields.security is None:
                                _txt = "LOGIC ERROR: Should not be possible?"
                                myPrint("B", _txt)
                                myPrint("B", txn.toMultilineString())
                                raise Exception(_txt)

                            secCurr = fields.security.getCurrencyType()
                            correctSecAcct = None
                            for subacct in AccountUtil.getAccountIterator(acct):
                                if subacct.getCurrencyType() == secCurr:
                                    correctSecAcct = subacct
                                    break

                            if not correctSecAcct:
                                if FIX_MODE:
                                    _txt = ".. Security sub-acct '%s' not found within this Investment account '%s' - so manually creating/adding..." %(secCurr.getName(), acct)
                                    text += "%s\n" %(_txt); myPrint("B",_txt)

                                    # need to create the Security sub-account in this Investment Account....
                                    newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(), Account.AccountType.SECURITY, acct)   # noqa
                                    newSecurityAcct.setEditingMode()
                                    newSecurityAcct.getUUID()
                                    newSecurityAcct.setAccountName(fields.security.getAccountName())
                                    newSecurityAcct.setCurrencyType(fields.security.getCurrencyType())
                                    newSecurityAcct.setStartBalance(0)

                                    newSecurityAcct.setUsesAverageCost(fields.security.getUsesAverageCost())
                                    newSecurityAcct.setBroker(fields.security.getBroker())
                                    newSecurityAcct.setBrokerPhone(fields.security.getBrokerPhone())
                                    newSecurityAcct.setAPR(fields.security.getAPR())
                                    newSecurityAcct.setBondType(fields.security.getBondType())
                                    newSecurityAcct.setComment(fields.security.getComment())
                                    newSecurityAcct.setCompounding(fields.security.getCompounding())
                                    newSecurityAcct.setFaceValue(fields.security.getFaceValue())
                                    newSecurityAcct.setMaturity(fields.security.getMaturity())
                                    newSecurityAcct.setMonth(fields.security.getMonth())
                                    newSecurityAcct.setNumYears(fields.security.getNumYears())
                                    newSecurityAcct.setPut(fields.security.getPut())
                                    newSecurityAcct.setOptionPrice(fields.security.getOptionPrice())
                                    newSecurityAcct.setDividend(fields.security.getDividend())
                                    newSecurityAcct.setExchange(fields.security.getExchange())
                                    newSecurityAcct.setSecurityType(fields.security.getSecurityType())
                                    newSecurityAcct.setSecuritySubType(fields.security.getSecuritySubType())
                                    newSecurityAcct.setStrikePrice(fields.security.getStrikePrice())

                                    for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                                        newSecurityAcct.setParameter(param, fields.security.getParameter(param))

                                    newSecurityAcct.setParameter(PARAMETER_KEY,True)
                                    newSecurityAcct.syncItem()

                                    correctSecAcct = newSecurityAcct
                                else:
                                    text+=(" -> will need to auto-create/add Security and then assign txn to %s\n" %(acct))

                            if correctSecAcct:
                                if FIX_MODE:
                                    errors_fixed += 1
                                    text+=(" -> ASSIGNING txn to '%s'\n" %(correctSecAcct.getFullAccountName()))
                                    fields.security = correctSecAcct
                                    fields.storeFields(txn)
                                    txn.syncItem()
                                else:
                                    text+=(" -> need to assign txn to '%s'\n" %(correctSecAcct.getFullAccountName()))

                del _txns
                return text, count_the_errors, count_unfixable_yet, errors_fixed


            output += "\nScanning txns for non-hierarchical accounts:\n" \
                        " -------------------------------------------\n\n"

            x, iCountErrors, iCountUnfixable, iErrorsFixed = review_security_accounts(txns, FIX_MODE=False)
            output += x

            output += "\n\nYou have %s non-hierarchical txn errors...\n\n" %(iCountErrors)

            if iCountErrors < 1:
                if lFixedOrphans:
                    txt = "%s: I found no additional non-hierarchical / invalid txns....... UPDATES COMPLETED" %(_THIS_METHOD_NAME)
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                    if not autofix:
                        MD_REF.saveCurrentAccount()
                        setDisplayStatus(txt, "B")
                        play_the_money_sound()
                        jif = QuickJFrame(_THIS_METHOD_NAME,output,lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
                        myPopupInformationBox(jif, txt)
                    return
                txt = "%s: CONGRATULATIONS - I found no non-hierarchical / invalid txns......." %(_THIS_METHOD_NAME)
                output += "\n%s\n" %(txt); myPrint("B",txt)
                if not autofix:
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt)
                return

            myPrint("B","%s: found %s non-hierarchical txn errors..." %(_THIS_METHOD_NAME, iCountErrors))

            jif = None
            if not autofix:
                jif = QuickJFrame("VIEW Investment Security Txns with Invalid Parent Accounts".upper(), output, lAlertLevel=1, lWrapText=False, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

            # if iCountUnfixable>0:
            #     txt = "%s: You have %s errors to manually first first!" %(_THIS_METHOD_NAME, iCountUnfixable)
            #     myPrint("B", txt)
            #     if not autofix:
            #         setDisplayStatus(txt, "R")
            #         myPopupInformationBox(jif,"You have %s errors to manually first first!" %(iCountUnfixable), _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
            #     return

            if not autofix:
                if not lFixedOrphans \
                        and not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME,"FIX %s Security Txns with Invalid Parent Accts?" %(iCountErrors)):
                    return

                jif.dispose()
                myPrint("B", "User accepted disclaimer to FIX Investment Security Txns with Invalid Parent Accounts. Proceeding.....")

            output += "\n\nRUNNING FIX ON SECURITY TXNS TO RE-LINK PARENT ACCOUNTS\n" \
                      " -----------------------------------------------------------\n\n"

            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the move/changes..
            MD_REF.getCurrentAccountBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            x, iCountErrors, iCountUnfixable, iErrorsFixed = review_security_accounts(txns, FIX_MODE=True)
            del txns, txnSet

            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccountBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            output += x
            output += "\n\nYou had %s non-hierarchical txn errors... FIXED %s\n\n" %(iCountErrors, iErrorsFixed)
            output += "\n<END>"

            txt = "FIXED %s Investment Security Txns with Invalid Parent Accounts (non-hierarchical txn errors)" %(iErrorsFixed)
            myPrint("B", txt)
            logToolboxUpdates("fix_non_hier_sec_acct_txns", txt)

            if not autofix:
                play_the_money_sound()
                setDisplayStatus(txt, "B")
                jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, lWrapText=False, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            else:
                myPrint("B", "AUTOFIX ENDING....")

        except:
            output += dump_sys_error_to_md_console_and_errorlog(True)
            txt = "%s: ERROR - Script has crashed. Review screen and console!" %(_THIS_METHOD_NAME)
            output += txt + "\n"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=2, lWrapText=False, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)

    def detect_non_hier_sec_acct_or_orphan_txns(startupCheck=False):
        if MD_REF.getCurrentAccountBook() is None: return 0
        txnSet = MD_REF.getCurrentAccountBook().getTransactionSet()
        fields = InvestFields()
        count_the_errors = 0
        count_non_investment_account_errors = 0

        # noinspection PyUnresolvedReferences
        ATI = Account.AccountType.INVESTMENT

        startTimeMS = System.currentTimeMillis()

        for txn in txnSet:

            if not isinstance(txn, ParentTxn): continue   # only work with parent transactions

            acct = txn.getAccount()
            acctType = acct.getAccountType()

            # noinspection PyUnresolvedReferences
            if acctType == Account.AccountType.SECURITY:
                myPrint("B", "*** MAJOR ERROR: Txn is a Parent AND its a SECURITY ACCOUNT:")
                myPrint("B", txn.toMultilineString())
                count_the_errors += 1
                continue

            # Check(s) expanded to include all Account Types (as Security records should only be within Investment Accounts)
            fields.setFieldStatus(txn)

            if fields.hasSecurity and not acct.isAncestorOf(fields.security):
                count_the_errors += 1

                # noinspection PyUnresolvedReferences
                if acctType != ATI:
                    count_non_investment_account_errors += 1

                if debug or not startupCheck:
                    myPrint("B", "ERROR: Txn for Security %s found within '%s' Account %s that is cross linked to another account (or Security is orphaned)!\n"
                                 "txn:\n%s\n" %(fields.security,
                                                ("Investment" if (acctType == ATI) else "** NON INVESTMENT(%s)" %(acctType)),
                                                acct,
                                                txn.toMultilineString()))
        del txnSet

        if count_the_errors:
            myPrint("B", "ERROR: %s investment txn(s) with cross-linked securities detected" %(count_the_errors))
            if count_non_investment_account_errors:
                myPrint("B", ".... *** AND %s investment txn(s) with cross-linked securities detected found in NON INVESTMENT ACCOUNTS! ***" %(count_non_investment_account_errors))
        else:
            if debug or startupCheck:
                myPrint("B", "NOTE: No investment txn(s) with cross-linked securities were detected...")

        if debug:
            myPrint("B", ".... check took: %s seconds..." %((System.currentTimeMillis() - startTimeMS) / 1000.0))


        return count_the_errors

    def fix_delete_one_sided_txns():

        # delete_invalid_txns.py
        myPrint("B", "Script running to analyse whether you have any one sided transactions - usually from Quicken Imports....")
        myPrint("P", " -------------------------------------------------------------------------------------------------------")

        book = MD_REF.getCurrentAccountBook()
        txnSet = book.getTransactionSet()
        txns = txnSet.iterableTxns()

        output = ""
        toDelete = []

        output +="\nLIST OF ONE SIDED TRANSACTIONS (usually from Quicken Imports)\n"
        output +=" ------------------------------------------------------------\n"

        for txn in txns:
            if txn.getOtherTxnCount() == 0:
                output += pad(str(txn.getUUID()),50)+" "
                output += "Date: "+pad(convertStrippedIntDateFormattedText(txn.getDateInt()),15)+" "
                output += pad(str(txn.getAccount()),25)+" "
                output += pad(str(txn.getAccount().getAccountType()),25)+" "
                output += pad(str(txn.getTransferType()),15)+" "
                output += rpad(str(txn.getValue()),12)+" "
                output += "\n"

                toDelete.append(txn)

        if not len(toDelete)>0:

            txt = "You have no one-sided transactions to delete!!"
            setDisplayStatus(txt, "B"); myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE ONE-SIDE TXNS", JOptionPane.INFORMATION_MESSAGE)
            return

        output += "\n<END>"

        jif = QuickJFrame("LIST OF ONE SIDED TRANSACTIONS (usually from Quicken Imports)", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        myPrint("J","You have %s one-sided transactions that can be deleted!!"%len(toDelete))
        myPopupInformationBox(jif, "You have %s one-sided transactions that can de deleted!!"%len(toDelete), "DELETE ONE-SIDE TXNS", JOptionPane.WARNING_MESSAGE)

        if not confirm_backup_confirm_disclaimer(jif, "DELETE ONE-SIDED TRANSACTIONS", "delete %s one-sided transactions?" %(len(toDelete))):
            return

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccountBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for t in toDelete:
            myPrint("J", "Item %s deleted" %t.getUUID())
            t.deleteItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "%s Invalid One-Sided Transactions DELETED!" %(len(toDelete))
        setDisplayStatus(txt, "DG"); myPrint("B", txt)
        logToolboxUpdates("fix_delete_one_sided_txns", txt)
        play_the_money_sound()
        myPopupInformationBox(jif,txt, "DELETE ONE-SIDE TXNS", JOptionPane.WARNING_MESSAGE)

    def convert_stock_avg_cst_control():
        if MD_REF.getCurrentAccountBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,"CONVERT ACCT/STOCK TO Avg Cst Ctrl","Do you want to convert a stock to Average Cost Control and reset/wipe any LOT data?",theMessageType=JOptionPane.WARNING_MESSAGE):
            myPopupInformationBox(toolbox_frame_,"NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        accountsList = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(14))
        accountsList = sorted(accountsList, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        accountSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                 "Select a LOT Controlled Acct/Stock to convert to Avg Cost Control",
                                                 "CONVERT ACCT/STOCK TO Avg Cst Ctrl",
                                                 JOptionPane.INFORMATION_MESSAGE,
                                                 getMDIcon(lAlwaysGetIcon=True),
                                                 accountsList,
                                                 None)

        if not accountSec:
            txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl - No Account/Security was selected - no changes made.."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        class SecurityObj:
            def __init__(self,Obj,Book):                                                                                # noqa
                self.Obj = Obj
                self.Acct = Obj.getParentAccount()
                self.TxnSet = Book.getTransactionSet().getTransactionsForAccount(Obj)
                self.Name = Obj.getAccountName()
                self.Num = Obj.getAccountNum()
                self.Type = "SECURITY"
                self.AvgCost = Obj.getUsesAverageCost()
                self.Txns = []
                for _Txn in self.TxnSet: self.Txns.append(TxnObj(_Txn))

        class TxnObj:
            def __init__(self,Txn):                                                                                     # noqa
                self.Obj = Txn
                self.Parent = Txn.getParentTxn()
                self.ID = Txn.getUUID()
                self.DateInt = Txn.getDateInt()
                self.Type = self.Parent.getInvestTxnType().getIDString()
                self.saveCostBasisState = self.Obj.getParameter("cost_basis",None)

        Book = MD_REF.getCurrentAccountBook()

        # We are forcing just the one selected Security into the List (the original script allowed user to hard code several)
        Securities = [SecurityObj(accountSec,Book)]

        iErrors=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    iErrors+=1

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "CONVERT ACCT/STOCK TO Avg Cst Ctrl","Convert %s to Avg Cst Control and wipe %s LOT records?" %(accountSec,iErrors)):
            return

        listWiped=""
        for Security in Securities:
            myPrint("B","@@ User requested to convert Acct/Security %s to Average Lot Control and wipe %s LOT records... EXECUTING NOW" %(Security.Obj, iErrors))
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    listWiped+=" %s Wiped LOT tag on record (was: %s)\n" %(Security.Obj, Txn.Obj.getParameter("cost_basis", None))
                    myPrint("B","@@ Security %s Wiping LOT record on %s" %(Security.Obj, Txn.Obj))
                    Txn.Obj.setParameter("cost_basis", None)
                    Txn.Obj.syncItem()

            Security.Obj.setUsesAverageCost(True)
            Security.AvgCost = True
            Security.Obj.syncItem()

        txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl - Security %s Changed to Average Cost Control (and %s LOT records wiped)"%(accountSec,iErrors)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("convert_stock_avg_cst_control", txt)
        play_the_money_sound()
        MyPopUpDialogBox(toolbox_frame_,
                         theStatus="Security %s converted to Average Cost Control (I wiped %s LOT records - shown below)" %(accountSec,iErrors),
                         theMessage="%s" %(listWiped),
                         theTitle="CONVERT ACCT/STOCK TO Avg Cst Ctrl",
                         lAlertLevel=1).go()

    def convert_stock_lot_FIFO():
        # MakeFifoCost.py (author unknown)

        if MD_REF.getCurrentAccountBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "CONVERT ACCT/STOCK TO LOT/FIFO: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,"CONVERT ACCT/STOCK TO LOT/FIFO","Do you want to attempt to convert a stock to LOT Controlled and match Sells to Buys using FiFo?",theMessageType=JOptionPane.WARNING_MESSAGE):
            myPopupInformationBox(toolbox_frame_,"NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        accountsList = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(13))
        accountsList = sorted(accountsList, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        accountSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                 "Select an Avg Cost Controlled Acct/Stock to convert to LOT/FiFo",
                                                 "CONVERT STOCK FIFO",
                                                 JOptionPane.INFORMATION_MESSAGE,
                                                 getMDIcon(lAlwaysGetIcon=True),
                                                 accountsList,
                                                 None)

        if not accountSec:
            txt = "CONVERT STOCK FIFO - No Account/Security was selected - no changes made.."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # noinspection PyUnresolvedReferences
        if len(accountSec.getCurrencyType().getSplits()) >0:
            # noinspection PyUnresolvedReferences
            txt = "CONVERT STOCK FIFO - SORRY - You have %s split(s) on this security %s. I have not been programmed to deal with these - contact author...." %(len(accountSec.getCurrencyType().getSplits()),accountSec)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, "CONVERT STOCK FIFO", theMessageType=JOptionPane.ERROR_MESSAGE)
            return


        MyPopUpDialogBox(toolbox_frame_,
                         theStatus="Information before you proceed: %s" %(accountSec),
                         theMessage="This function updates the Acct/Security records as it progresses to generate the report\n"
                                    "There is no pre-report for you to validate/confirm\n"
                                    "1. It will ask you to confirm I can wipe any existing LOT tags incorrectly set first (I will save these)\n"
                                    "2. The report will run, Convert to LOT Control, update the LOT records, and show you the results\n"
                                    "3. If you are not happy, I can reset the Security back to Avg Cost Control (removing/resetting LOT tags)\n"
                                    "4. I will restore wiped (incorrect) LOT tags back to the saved data from step 1.\n"
                                    "** You will be asked to confirm and perform a backup then proceed in the next step....",
                         theTitle="CONVERT STOCK FIFO",
                         OKButtonText="I HAVE READ THIS",
                         lAlertLevel=1).go()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "CONVERT STOCK FIFO","Convert %s to LOT control and assign FiFio?" %(accountSec)):
            return

        class SecurityObj:
            def __init__(self,Obj,Book):                                                                                # noqa
                self.Obj = Obj
                self.Acct = Obj.getParentAccount()
                self.TxnSet = Book.getTransactionSet().getTransactionsForAccount(Obj)
                self.Name = Obj.getAccountName()
                self.Num = Obj.getAccountNum()
                self.Type = "SECURITY"
                self.Balance = Obj.getBalance()
                self.CurTyp = Obj.getCurrencyType()
                self.AvgCost = Obj.getUsesAverageCost()
                self.Txns = []
                for _Txn in self.TxnSet:
                    self.Txns.append(TxnObj(_Txn))
                self.Txns.sort(key=lambda l: l.Date)

        class TxnObj:
            def __init__(self,Txn):                                                                                     # noqa
                self.Obj = Txn
                self.Parent = Txn.getParentTxn()
                self.ID = Txn.getUUID()
                self.DateInt = Txn.getDateInt()
                self.Type = self.Parent.getInvestTxnType().getIDString()
                # noinspection PyUnresolvedReferences
                self.Date = datetime.datetime.fromtimestamp(DateUtil.convertIntDateToLong(Txn.getDateInt()).time/1e3)
                self.LngShrs = Txn.getValue()
                securityAcct = Txn.getAccount()
                securityCurr = securityAcct.getCurrencyType()
                self.Shares = securityCurr.getDoubleValue(Txn.getValue())
                self.saveCostBasisState = self.Obj.getParameter("cost_basis",None)

        def MakeCostsFifo(Security,Book, INCLUDE_THE_ZEROS):                                                            # noqa
            WrngCnt = 0                                                                                                 # noqa

            textLog = ""

            if not Security.AvgCost:
                _txt = "CONVERT STOCK FIFO - ERROR - Security is already using LOT control - LOGIC ERROR - ABORTING!"
                setDisplayStatus(_txt, "R")
                return
            else:
                textLog+=("Setting the Security '{}:{}' to FIFO lot matching.\n\n".format(Security.Acct.getAccountName(),Security.Name))

                # If you don't do this here, then InvestUtil.getRemainingLots() returns None
                Security.Obj.setUsesAverageCost(False)
                Security.AvgCost = False
                Security.Obj.syncItem()

                for Txn in Security.Txns:                                                                               # noqa
                    if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                            and (Txn.LngShrs != 0 or INCLUDE_THE_ZEROS)):
                        RLots = InvestUtil.getRemainingLots(Book,Security.Obj,Txn.Obj.getDateInt())
                        ShrsLeft = -(Txn.LngShrs)
                        Buys = ""
                        prettyBuys = ""
                        for Txn2 in Security.Txns:
                            if Txn2.LngShrs > 0 and Txn2.ID in RLots:
                                RInfo = RLots.get(Txn2.ID)
                                # noinspection PyUnresolvedReferences
                                RShrs = RInfo.getAvailableShares()
                                if RShrs >= ShrsLeft:
                                    Buys += "{}:{};".format(Txn2.ID,ShrsLeft)
                                    prettyBuys += "BUY-{}:{};".format(convertStrippedIntDateFormattedText(Txn2.DateInt),Txn.Obj.getAccount().getCurrencyType().getDoubleValue(ShrsLeft))
                                    ShrsLeft = 0
                                    break
                                elif RShrs > 0:
                                    Buys += "{}:{};".format(Txn2.ID,RShrs)
                                    prettyBuys += "BUY-{}:{};".format(convertStrippedIntDateFormattedText(Txn2.DateInt),Txn.Obj.getAccount().getCurrencyType().getDoubleValue(RShrs))
                                    ShrsLeft -= RShrs
                        if ShrsLeft > 0:
                            textLog+=("@@ WARNING! Came up short %s shares for ID='%s' on date=%s!\n" %(rpad(Txn.Obj.getAccount().getCurrencyType().getDoubleValue(ShrsLeft),12),Txn.ID,Txn.Date.strftime(convertMDShortDateFormat_strftimeFormat())))
                            WrngCnt += 1
                        if len(Buys) > 0:
                            Txn.Obj.setParameter("cost_basis",Buys)
                            Txn.Obj.syncItem()
                            Txn.Obj.getParentTxn().syncItem()
                            textLog+=("cost_basis for the sale dated: %s of %s shares on %s set to '%s'\n" %(convertStrippedIntDateFormattedText(Txn.DateInt),rpad(Txn.Shares,12),Txn.Date.strftime(convertMDShortDateFormat_strftimeFormat()),prettyBuys))
                    else:
                        if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())):
                            textLog+=("skipped ZERO sale dated: %s of %s shares...'\n" %(convertStrippedIntDateFormattedText(Txn.DateInt),rpad(Txn.Shares,12)))

            return WrngCnt, textLog

        output = "CONVERT STOCK FIFO (Convert Accounts/Security using Avg Cost Control to LOT control & assign FiFo)\n" \
                 " =================================================================================================\n\n"

        WrngCnt = 0
        Book = MD_REF.getCurrentAccountBook()

        # We are forcing just the one selected Security into the List (the original script allowed user to hard code several)
        Securities = [SecurityObj(accountSec,Book)]

        iErrors=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    iErrors+=1
        if iErrors>0:
            if not myPopupAskQuestion(toolbox_frame_,"CONVERT STOCK FIFO",
                                      "WARNING: I found %s LOTS already set on account/security. Do you want to proceed (and overwrite) these?" %(iErrors),
                                      theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "CONVERT STOCK FIFO - ABORTED - as Acct/Security %s already had %s LOT records!!??" %(accountSec, iErrors)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            myPrint("B", "CONVERT STOCK FIFO - RESETTING %s LOT TAGS on Acct/Security %s!!"%(iErrors, accountSec))
            output+=("\nRESETTING %s LOT TAGS on Acct/Security %s!!\n"%(iErrors, accountSec))

            for Security in Securities:
                for Txn in Security.Txns:
                    if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                            and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                        output+=" > Found LOT tag on Sale record, when it should be None... Resetting to None (was SELL %s Shrs Dated:%s: %s)\n" %(rpad(Txn.Shares,12),convertStrippedIntDateFormattedText(Txn.DateInt),Txn.Obj.getParameter("cost_basis", None))
                        Txn.Obj.setParameter("cost_basis", None)
                        Txn.Obj.syncItem()

        iSellZeros=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType()) and Txn.LngShrs == 0):
                    iSellZeros+=1

        lIncludeSellZeros=False
        if iSellZeros>0:
            if myPopupAskQuestion(toolbox_frame_,"CONVERT STOCK FIFO",
                                  "WARNING: I found %s Sale Txns for ZERO shares. YES = INCLUDE and match these to Zero Buys; NO = SKIP/IGNORE them?" %(iSellZeros),
                                  theMessageType=JOptionPane.WARNING_MESSAGE):
                myPrint("B", "CONVERT STOCK FIFO: Acct/Security %s - Will match %s ZERO sales too..."%(accountSec, iSellZeros))
                lIncludeSellZeros = True

        for Security in Securities:
            count, text = MakeCostsFifo(Security,Book, lIncludeSellZeros)
            WrngCnt += count
            output += text

        if iSellZeros>0:
            if lIncludeSellZeros:
                output+="\n\n @@ ALERT - I have matched Sales for ZERO shares to BUYS... @@\n\n"
            else:
                output+="\n\n @@ ALERT - The MD LOT Window will pop up wanting you to match the Zero Sells, which you can't.. You can just press Cancel on this (or re-run and Include them) @@\n\n"

        output+=("\nFinished. Processed {} securities producing {} warnings.\n".format(len(Securities),WrngCnt))

        _secAcctRelCurr = accountSec.getCurrencyType()                                                                  # noqa
        _secAcctCostBasis = InvestUtil.getCostBasis(accountSec)
        _secAcctCostBasisDbl = _secAcctRelCurr.getDoubleValue(_secAcctCostBasis)

        output += "\nMD Reports the cost basis for '%s' is now %s\n" %(accountSec, _secAcctCostBasisDbl)

        if not InvestUtil.isCostBasisValid(accountSec):
            cbMessageValidIndicator = "** INVALID ** (you can edit these manually later in MD)"
            txt = "CONVERT STOCK FIFO: WARNING - MD reports the cost basis for '%s' is **INVALID** after the update.." %(accountSec)
        else:
            cbMessageValidIndicator = "VALID"
            txt = "CONVERT STOCK FIFO: NOTE: MD is reporting that the cost basis for '%s' is VALID after the update.." %(accountSec)
        myPrint("B", txt); output += "\n%s\n" %(txt)

        jif=QuickJFrame("CONVERT STOCK FIFO - REVIEW RESULTS", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        ask=MyPopUpDialogBox(jif,
                             theStatus="Please review results on security: %s" %(accountSec),
                             theMessage="These changes have already been made to your dataset\n"
                                        "FYI - MD is reporting that the updated Cost Basis / Lot control status is %s\n"
                                        "To reset the security back to Avg Cost Control and reset/remove these altered LOT records select CANCEL\n"
                                        "(NOTE: I will put the LOT records back to the same state before this script ran)"
                                        "[OK KEEP RESULTS] will accept these changes" %(cbMessageValidIndicator),
                             theTitle="CONVERT STOCK FIFO",
                             OKButtonText="OK KEEP RESULTS",
                             lCancelButton=True,
                             lAlertLevel=1)
        if not ask.go():
            jif.dispose()       # already within the EDT
            myPrint("B", "\nREVERTING CHANGES - RESETTING ACCOUNT/SECURITY %s BACK TO AVERAGE COST CONTROL!!\n"%(accountSec))
            myPrint("B", "CONVERT STOCK FIFO - RESETTING LOT TAGS on Acct/Security %s!!"%(accountSec))

            output+=("\nREVERTING CHANGES - RESETTING ACCOUNT/SECURITY %s BACK TO AVERAGE COST CONTROL!!\n"%(accountSec))
            output+=("\nRESETTING LOT TAGS on Acct/Security %s!!\n"%(accountSec))

            for Security in Securities:

                myPrint("B","CONVERT STOCK FIFO - Reverting Security %s back to Average Cost Control" %(accountSec))
                output+=("@@ CONVERT STOCK FIFO - Reverting Security %s back to Average Cost Control@@\n" %(accountSec))

                for Txn in Security.Txns:
                    if InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType()):
                        if Txn.Obj.getParameter("cost_basis", None) != Txn.saveCostBasisState:
                            output+="  >> Reverting LOT record to: %s\n" %(Txn.saveCostBasisState)
                            Txn.Obj.setParameter("cost_basis", Txn.saveCostBasisState)
                            Txn.Obj.syncItem()
                output+=" > Reverting to Average Cost Control...\n"
                Security.Obj.setUsesAverageCost(True)
                Security.AvgCost = True
                Security.Obj.syncItem()
                output+="\n<END>"
                txt = "CONVERT STOCK FIFO - Changes to Security %s REJECTED and REVERSED - review report" %(accountSec)
                setDisplayStatus(txt, "R")
        else:
            jif.dispose()       # already within the EDT
            output+="\nCHANGES ACCEPTED and RETAINED...\n" \
                    "\n<END>"
            txt = "CONVERT STOCK FIFO - Changes to Security %s Accepted and retained - review report" %(accountSec)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("convert_stock_lot_FIFO", txt)


        jif = QuickJFrame("CONVERT STOCK FIFO - REVIEW RESULTS", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        play_the_money_sound()
        myPopupInformationBox(jif, "REVIEW REPORT", "CONVERT STOCK FIFO", JOptionPane.WARNING_MESSAGE)

    def show_open_share_lots():
        if MD_REF.getCurrentAccountBook() is None: return

        class LotInfo:
            def __init__(self, _date, _buyPrice, _availableShares, _costBasis, _currentPrice, _currentValue):
                self.date = _date
                self.buyPrice = _buyPrice
                self.availableShares = _availableShares
                self.costBasis = _costBasis
                self.currentPrice = _currentPrice
                self.currentValue = _currentValue

        book = MD_REF.getCurrentAccountBook()
        date = datetime.datetime.today()

        output="\n\nANALYSING SHARES/SECURITIES WITH OPEN (Unconsumed LOTS)\n" \
               " ======================================================\n\n"

        output+='Outstanding Tax Lots as of %s\n\n'%(date.strftime(convertMDShortDateFormat_strftimeFormat()))

        iFound = 0
        for secAcct in AccountUtil.getAccountIterator(book):
            if secAcct.getAccountType() !=  secAcct.AccountType.SECURITY: continue
            if secAcct.getUsesAverageCost(): continue

            curr = secAcct.getCurrencyType()
            rcurr = secAcct.getCurrencyType().getRelativeCurrency()

            dpc = curr.getDecimalPlaces()
            rdpc = rcurr.getDecimalPlaces()

            dpc_divvy = Math.pow(10, dpc)
            rdpc_divvy = Math.pow(10, dpc - rdpc)

            if InvestUtil.getCostBasis(secAcct) > 0 or not InvestUtil.isCostBasisValid(secAcct):
                output+="\nInvestment Account: %s Security: %s\n\n" %(secAcct.getParentAccount(), secAcct.getAccountName())
                if not InvestUtil.isCostBasisValid(secAcct):
                    output+="\n** COST BASIS IS INVALID** (you have sales not fully matched to buys)\n\n"

                totalCostBasis = 0.0
                totalAvailableShares = 0.0
                currentPrice = 1.0 / secAcct.getCurrencyType().getRelativeRate()
                lotList = []
                lots = InvestUtil.getRemainingLots(book, secAcct, DateUtil.getStrippedDateInt())

                # noinspection PyUnresolvedReferences
                for transaction, availSharesTracker in lots.items():
                    availableShares = availSharesTracker.getAvailableShares() / dpc_divvy
                    if availableShares > 0:
                        # t = book.getTransactionSet().getTxnByID(transaction)
                        t = TxnUtil.getTxnByID(book.getTransactionSet(), transaction)
                        # noinspection PyUnresolvedReferences
                        date = datetime.datetime.fromtimestamp(DateUtil.convertIntDateToLong(t.getDateInt()).time / 1000)
                        adjustedBuyPrice = 1.0 / secAcct.getCurrencyType().adjustRateForSplitsInt(t.getDateInt(), t.getRate()) * (rdpc_divvy)  # noqa
                        costBasis = availableShares*adjustedBuyPrice
                        currentValue = currentPrice*availableShares
                        totalCostBasis += costBasis
                        totalAvailableShares += availableShares
                        lotList.append(LotInfo(date, adjustedBuyPrice, availableShares, costBasis, currentPrice, currentValue))
                lotList.sort(key=lambda sort_l: sort_l.date)
                lotCount = 0

                output+=("%s %s %s %s %s %s\n"
                         %(pad("Buy.Date",10),
                           rpad("Buy.Price",12),
                           rpad("Avail.Shares",14),
                           rpad("Cost.Basis",14),
                           rpad("Current.Price",14),
                           rpad("Current.Value",14)))

                for _lot in lotList:
                    lotCount += 1
                    output+=("%s %s %s %s %s %s\n"
                             %(pad(_lot.date.strftime(convertMDShortDateFormat_strftimeFormat()),10),
                               rpad(_lot.buyPrice,12),
                               rpad(_lot.availableShares,14),
                               rpad(_lot.costBasis,14),
                               rpad(_lot.currentPrice,14),
                               rpad(_lot.currentValue,14)))
                    iFound+=1
                output+=("%s %s %s %s %s %s\n"
                         %(pad("",10),
                           rpad("",12),
                           rpad("----------",14),
                           rpad("----------",14),
                           rpad("",14),
                           rpad("----------",14)))
                if lotCount > 1:
                    output+=("%s %s %s %s %s %s\n"
                             %(pad("",10),
                               rpad("",12),
                               rpad(totalAvailableShares,14),
                               rpad(totalCostBasis,14),
                               rpad("",14),
                               rpad(totalAvailableShares*currentPrice,14)))

                output+=("%s %s\n\n" %(rpad("Current share balance:",(10+1+12)), rpad(secAcct.getBalance()/dpc_divvy,14)))

                output+="\n"
        output+="\n<END>"

        # diag.kill()
        #
        if iFound<1:
            txt = "VIEW OPEN LOTS - You have no open / unconsumed LOTs to display!"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,"VIEW OPEN LOTS")
        else:
            toolbox_frame_.toFront()
            txt = "VIEW OPEN LOTS - Displaying %s open LOTS!" %(iFound)
            setDisplayStatus(txt, "B")
            jif = QuickJFrame("VIEW OPEN LOTS",output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,txt)

    def diagnose_matched_lot_data():
        _THIS_METHOD_NAME = "DIAGNOSE MATCHED LOT DATA"

        if MD_REF.getCurrentAccountBook() is None: return

        book = MD_REF.getCurrentAccountBook()
        date = datetime.datetime.today()

        output = "\n\nDIAGNOSING SHARES/SECURITIES LOT MATCHING DATA\n" \
                 " =================================================\n\n"

        output += 'as of %s\n\n' %(date.strftime(convertMDShortDateFormat_strftimeFormat()))

        allAccounts = AccountUtil.allMatchesForSearch(book, AcctFilter.ALL_ACCOUNTS_FILTER)
        secAccounts = [acct for acct in allAccounts if acct.getAccountType() == Account.AccountType.SECURITY]           # noqa

        securitiesToValidate = []

        for secAcct in secAccounts:
            if InvestUtil.isCostBasisValid(secAcct): continue

            output += "%s: reports invalid cost basis... Checking for sells\n" %(secAcct)

            sellCheck = False
            tSet = secAcct.getBook().getTransactionSet().getTransactionsForAccount(secAcct)
            if tSet is not None:
                for i in range(0, tSet.getSize()):
                    absTxn = tSet.getTxn(i)
                    txnType = absTxn.getParentTxn().getInvestTxnType()
                    if txnType.isBuy() or txnType.isSell():
                        split = TxnUtil.getSecurityPart(absTxn.getParentTxn())
                        if split.getValue() < 0:
                            sellCheck = True
                            break

            if not sellCheck: continue

            output += "... this security account does hold Sell txns - will proceed to validate LOTS\n"
            securitiesToValidate.append(secAcct)

        if len(securitiesToValidate) < 1:
            txt = "SUCCESS - FOUND NO 'INVALID' LOT MATCHING DATA"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME)
            return

        output += "\n\nWARNING: Found %s 'INVALID' LOT MATCHING(s) TO VALIDATE\n\n" %(len(securitiesToValidate))

        def validateLots(sec):
            # duplicates - isCostBasisValid(Account sec)
            curr = sec.getCurrencyType()
            buySet = TxnSet()
            sellSet = TxnSet()
            buyList = {}
            txnSet = sec.getBook().getTransactionSet().getTransactionsForAccount(sec)
            _errorTxt = ""

            for _i in range(0, txnSet.getSize()):
                _absTxn = txnSet.getTxn(_i)
                _txnType = _absTxn.getParentTxn().getInvestTxnType()
                if (_txnType == InvestTxnType.BUY or _txnType == InvestTxnType.SELL
                        or _txnType == InvestTxnType.BUY_XFER or _txnType == InvestTxnType.SELL_XFER):
                    _split = TxnUtil.getSecurityPart(_absTxn.getParentTxn())
                    if (_split.getParentAmount() < 0):
                        buySet.addTxn(_split)
                    elif (_split.getParentAmount() > 0):
                        sellSet.addTxn(_split)
                elif (_txnType == InvestTxnType.DIVIDEND or _txnType == InvestTxnType.DIVIDEND_REINVEST):
                    _split = TxnUtil.getSecurityPart(_absTxn.getParentTxn())
                    if (_split.getParentAmount() < 0):
                        buySet.addTxn(_split)

            for j in range(0, sellSet.getSize()):
                stxn = sellSet.getTxn(j)
                shares = Math.abs(stxn.getValue())
                if (shares != TxnUtil.getNumShares(stxn)):
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed on 'shares != TxnUtil.getNumShares(stxn)'\n"
                    _errorTxt += "shares: %s, getNumShares: %s\n" %(shares, TxnUtil.getNumShares(stxn))
                    _errorTxt += "This means that the total qty of shares for this Sell is not exactly matched to the same qty of Buy(s)\n"
                    _errorTxt += "stxn: %s\n" %(stxn)
                    _errorTxt += stxn.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                    _errorTxt += "Transaction date: %s\n" %(convertStrippedIntDateFormattedText(stxn.getParentTxn().getDateInt()))
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

                buyTable = TxnUtil.parseCostBasisTag(stxn)
                if (buyTable is not None):
                    for txnID in buyTable:
                        if (txnID in buyList):
                            oldValue = buyList.get(txnID)
                            plusValue = buyTable.get(txnID)
                            adjustedShares = curr.adjustValueForSplitsInt(stxn.getDateInt(), plusValue)
                            newValue = oldValue + adjustedShares
                            buyList[txnID] = newValue
                            continue
                        buyList[txnID] = curr.adjustValueForSplitsInt(stxn.getDateInt(), buyTable.get(txnID))
                else:
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed as buyTable (cost basis lot tags) is None\n"
                    _errorTxt += "This probably means that no Buy(s) have been matched to this Sell\n"
                    _errorTxt += "stxn: %s\n" %(stxn)
                    _errorTxt += stxn.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                    _errorTxt += "Transaction date: %s\n" %(convertStrippedIntDateFormattedText(stxn.getParentTxn().getDateInt()))
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

            for txnID in buyList:
                txn = TxnUtil.getTxnByID(buySet, txnID)
                if (txn is None):
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed as could not find txnID: '%s' in buySet\n" %(txnID)
                    _errorTxt += "This means that a matched Buy txn doesn't seem to exist any more?\n"
                    _errorTxt += "buySet  contains: %s\n" %(buySet)
                    _errorTxt += "buyList contains: %s\n" %(buyList)
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

                numShares = buyList.get(txnID)
                if (curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()) < numShares):
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed as 'curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()) < numShares'\n"
                    _errorTxt += "This means that a Buy is over matched on Sell(s) - i.e. the Buy qty is less than the total matched Sell qty\n"
                    _errorTxt += "On TxnID: %s\n" %(txnID)
                    _errorTxt += "On Txn:   %s\n" %(txn)
                    _errorTxt += txn.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                    _errorTxt += "Transaction date: %s\n" %(convertStrippedIntDateFormattedText(txn.getParentTxn().getDateInt()))
                    _errorTxt += "curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()): %s\n" %(curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()))
                    _errorTxt += "numShares: %s\n" %(numShares)
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

            return True, _errorTxt

        for secAcct in securitiesToValidate:
            output += "\nVALIDATING: %s\n" %(secAcct)
            result, _output = validateLots(secAcct)
            output += _output
            if result:
                output += "STRANGE RESULT - Now seems to validates as OK? %s\n" %(secAcct)
                continue

            output += "... FAILED VALIDATION!!! %s\n\n" %(secAcct)

        toolbox_frame_.toFront()
        txt = "%s: Displaying invalid LOT matching data" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "B")
        jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        myPopupInformationBox(jif,txt)

    class OpenFolderButtonAction(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):                                                                               # noqa
            if MD_REF.getCurrentAccountBook() is None: return

            grabProgramDir = find_the_program_install_dir()
            if not os.path.exists((grabProgramDir)): grabProgramDir = None

            grabSyncFolder = get_sync_folder(lReturnFileOrURLObject=True)

            locations = [
                "Show preferences (config.dict) folder",
                "Show custom themes folder",
                "Show console (error) log folder",
                "Show contents of your current dataset folder",
                "Show extensions folder",
                "Show auto Backup folder",
                "Show last used (manual) backup folder"]

            # noinspection PyUnresolvedReferences
            locationsDirs = [
                Common.getPreferencesFile(),
                ThemeInfo.customThemeFile,
                MD_REF.getLogFile(),
                MD_REF.getCurrentAccountBook().getRootFolder(),
                Common.getFeatureModulesDirectory(),
                FileUtils.getBackupDir(MD_REF.getPreferences()),
                File(MD_REF.getUI().getPreferences().getSetting("backup.last_saved", ""))]

            if grabSyncFolder:
                locations.append("Open sync folder")
                locationsDirs.append(grabSyncFolder)

            if grabProgramDir:
                locations.append("Open program's install directory")
                locationsDirs.append(File(grabProgramDir))

            logPath = logToolboxUpdates(None, None, lOnlyRtnCommonPath=True)
            if os.path.exists(logPath):
                locations.append("Open Toolbox's update log folder: common log")
                locationsDirs.append(File(logPath))

            logPath = logToolboxUpdates(None, None, lOnlyRtnDatasetPath=True)
            if os.path.exists(logPath):
                locations.append("Open Toolbox's update log folder: this dataset's log")
                locationsDirs.append(File(logPath))

            selectedFolder = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "Select the Folder you would like to open",
                                                         "Select Folder",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(lAlwaysGetIcon=True),
                                                         locations,
                                                         None)
            if not selectedFolder:
                txt = "No folder was selected to open.."
                setDisplayStatus(txt, "R")
                return

            selectedLocationAsFileOrURL = locationsDirs[locations.index(selectedFolder)]
            if isinstance(selectedLocationAsFileOrURL, URL):
                selectedLocationAsPathOrURL = selectedLocationAsFileOrURL.toString()
            elif isinstance(selectedLocationAsFileOrURL, File):
                selectedLocationAsPathOrURL = selectedLocationAsFileOrURL.getCanonicalPath()
            else:
                raise Exception("Unknown FileURL type?", type(selectedLocationAsFileOrURL))

            try:
                myPrint("B", "Attempting to copy path to clipboard:", selectedLocationAsPathOrURL)
                Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(selectedLocationAsPathOrURL), None)
            except: pass

            if isinstance(selectedLocationAsFileOrURL, File) and not os.path.exists(selectedLocationAsPathOrURL):
                txt = "Sorry - File/Folder does not exist! (path copied to clipboard)"
                setDisplayStatus(txt, "R")
                return

            if isinstance(selectedLocationAsFileOrURL, URL):
                myPrint("B", "Attempting to open website URL:", selectedLocationAsPathOrURL)
                MD_REF.showURL(selectedLocationAsPathOrURL)
            elif (Platform.isOSX() and grabSyncFolder and
                    ("iCloud~com~infinitekind~moneydancesync" in selectedLocationAsPathOrURL
                     or "dropbox" in selectedLocationAsPathOrURL.lower())):                                             # noqa
                # Bypass system security preventing access to certain folders....
                openResponse = subprocess.check_output('open "%s"' %(selectedLocationAsPathOrURL), shell=True)          # noqa
                txt = "Sync Folder location: %s (copied to clipboard) & opened" %(selectedLocationAsPathOrURL)
                setDisplayStatus(txt, "B")
            else:
                MD_REF.getPlatformHelper().openDirectory(locationsDirs[locations.index(selectedFolder)])
                txt = "Folder %s opened..: %s  (path copied to clipboard)" %(selectedFolder, locationsDirs[locations.index(selectedFolder)])
                setDisplayStatus(txt, "B")

    def display_passwords():
        MD_enc = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
        MD_hnt = MD_REF.getUI().getCurrentAccounts().getEncryptionHint()
        MD_sync_pwd = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()

        theMsg = u"'Master' Encryption Passphrase ('password'): "
        displayMsg = u"'Master' Encryption Passphrase ('password'): "

        if MD_enc is not None and MD_enc != u"":
            theMsg += u"%s" %(MD_enc)
            displayMsg += u"%s" %(MD_enc)
            if MD_hnt is not None and MD_hnt != u"":
                theMsg += u"  >> Encryption Passphrase Hint: %s" %(MD_hnt)
                displayMsg += u"  >> Encryption Passphrase Hint: %s" %(MD_hnt)
            else:
                theMsg += u"  >> Encryption Passphrase Hint: (NOT SET)"
                displayMsg += u"  >> Encryption Passphrase Hint: (NOT SET)"

            theMsg += u"\n"
            displayMsg += u"  -  "
        else:
            theMsg += u"(NOT SET - this means a default 'internal' encryption passphrase is being used)\n"
            displayMsg += u"(NOT SET - this means a default 'internal' encryption passphrase is being used)  -  "

        theMsg += u"Sync Passphrase: "
        displayMsg += u"Sync Passphrase: "

        if MD_sync_pwd is not None and MD_sync_pwd != u"":
            theMsg += u"%s" %(MD_sync_pwd)
            displayMsg += u"%s" %(MD_sync_pwd)
        else:
            theMsg += u"(NOT SET)"
            displayMsg += u"(NOT SET)"

        myPrint(u"B",u"Displaying Moneydance Encryption & Sync Passphrase(s) ....!")

        txt = u"Moneydance Encryption Passphrases: %s" %(displayMsg)
        setDisplayStatus(txt, "B")

        MyPopUpDialogBox(toolbox_frame_,u"Moneydance Encryption Passphrases:",theMsg,theTitle=u"PASSWORDS",lAlertLevel=1).go()
        return theMsg, displayMsg

    def disable_moneyforesight():
        extnPrefs = getExtensionGlobalPreferences()
        newSetting = not extnPrefs.getBoolean(GlobalVars.EXTN_PREF_KEY_DISABLE_FORESIGHT, False)
        if myPopupAskQuestion(toolbox_frame_, "MONEYFORESIGHT", "%s The bundled MoneyForesight extension?" %("DISABLE" if newSetting else "ENABLE")):
            extnPrefs.put(GlobalVars.EXTN_PREF_KEY_DISABLE_FORESIGHT, Boolean(newSetting))
            saveExtensionGlobalPreferences(extnPrefs)
            if debug: myPrint("B", "Extension Global Preferences now contains: %s" %(extnPrefs))
            txt = "@@ MoneyForesight: %s @@" %("DISABLED" if newSetting else "(re)enabled)")
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            logToolboxUpdates("disable_moneyforesight", txt, onlyLogGenericEntry=True)
            myPopupInformationBox(toolbox_frame_, txt + " >> Moneydance will now QUIT (please relaunch)", "MONEYFORESIGHT", JOptionPane.WARNING_MESSAGE)
            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False)
        else:
            txt = "@@ MoneyForesight disable settings not changed - remains: %s @@" %("DISABLED" if not newSetting else "enabled")
            setDisplayStatus(txt, "B");  myPrint("DB", txt)
        if debug: myPrint("B", "Extension Global Preferences now contains: %s" %(extnPrefs))

    def close_dataset():
        # type: () -> bool

        if not ToolboxMode.isUpdateMode() or not isToolboxUnlocked(): return False

        _THIS_METHOD_NAME = "CLOSE DATASET"

        currentBook = MD_REF.getCurrentAccountBook()     # type: AccountBook
        if currentBook is None:
            myPopupInformationBox(toolbox_frame_, "CRITICAL ERROR: AccountBook is missing? (Suggest you restart!)",theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        # Already on the EDT....
        if not ManuallyCloseAndReloadDataset.isSafeToCloseDataset():
            txt = "ERROR: MD reports that it's not OK to close open windows - no changes made"
            myPopupInformationBox(toolbox_frame_,txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return False

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return False
        if not backup_config_dict():  return False

        try:
            myPrint("B", "%s: Opening the Console Window (as it might be useful)" %(_THIS_METHOD_NAME))
            ConsoleWindow.showConsoleWindow(MD_REF.getUI())
        except: myPrint("B", "%s: FAILED to open the Console Window... ignoring the error...." %(_THIS_METHOD_NAME))

        if float(MD_REF.getBuild()) >= 4057:    # MoneyBot can be a bit quirky on ealrier builds....
            try:
                myPrint("B", "%s: Opening a Moneybot Window (as it might be useful)" %(_THIS_METHOD_NAME))
                MoneyBotWindow.showBotView(MD_REF.getUI())
            except: myPrint("B", "%s: FAILED to open a Moneybot Window... ignoring the error...." %(_THIS_METHOD_NAME))
        else:
            myPrint("B", "%s: Not bothering to open a Moneybot Window... (it's quirky on earlier builds)..." %(_THIS_METHOD_NAME))

        toolbox_frame_.toFront()

        _msg = pad("Please wait:", 50, padChar=".")
        pleaseWait = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
        pleaseWait.go()

        try:
            MD_REF.getUI().setStatus("Toolbox will now close your dataset", -1.0)

            myPrint("B", "%s: Executing CLOSE CURRENT DATASET" %(_THIS_METHOD_NAME))

            closeDatasetStatus = ManuallyCloseAndReloadDataset.manuallyCloseDataset(currentBook, lKillAllSyncers=True, lCloseWindows=True, lKillAllFramesWithBookReferences=True)
            if closeDatasetStatus == 1:
                txt = "ERROR: Could not close all open windows.... - no changes made (you might need to restart MD)"
                myPopupInformationBox(toolbox_frame_, txt, theTitle="ERROR", theMessageType=JOptionPane.ERROR_MESSAGE)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                return False

            if closeDatasetStatus != 0:
                txt = "ERROR: Could not cleanly close dataset (probably syncer threads). Dataset now closed(ish) - PLEASE RESTART MD)"
                statusColor = "R"
                msgType = JOptionPane.ERROR_MESSAGE
            else:
                txt = "DATASET CLOSED OK (review console if appropriate)"
                statusColor = "B"
                msgType = JOptionPane.WARNING_MESSAGE
            setDisplayStatus(txt, statusColor); myPrint("B", txt)
            disableToolboxButtons()
            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_, theMessage=txt, theTitle=_THIS_METHOD_NAME, theMessageType=msgType)

            try: WelcomeWindow.showWelcomeWindow(MD_REF.getUI())
            except: myPrint("B", "%s: FAILED to launch the WelcomeWindow... ignoring the error...." %(_THIS_METHOD_NAME))

            return closeDatasetStatus == 0

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "%s function has failed. Review log and console - You should probably RESTART MD" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,theMessage=txt, theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)

        finally:

            ManuallyCloseAndReloadDataset.startBackgroundSyncing()

            pleaseWait.kill()

        return False

    def rename_relocate_dataset(lRelocateDataset=False, lRelocateToInternal=True):
        # type: (bool, bool) -> None

        if lRelocateDataset:
            actionString = "relocate"
        else:
            actionString = "rename"
        _THIS_METHOD_NAME = ("%s DATASET" %(actionString)).upper()

        currentBook = MD_REF.getCurrentAccountBook()     # type: AccountBook
        if currentBook is None:
            myPopupInformationBox(toolbox_frame_, "CRITICAL ERROR: AccountBook is missing? (Suggest you restart!)",theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Already on the EDT....
        if not ManuallyCloseAndReloadDataset.isSafeToCloseDataset():
            txt = "ERROR: MD reports that it's not OK to close open windows - no changes made"
            myPopupInformationBox(toolbox_frame_,txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return

        currentRoot = currentBook.getRootAccount()
        currentName = currentBook.getName()

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return
        if not backup_config_dict():  return

        fCurrentFilePath = MD_REF.getCurrentAccountBook().getRootFolder()
        currentFilePath = fCurrentFilePath.getCanonicalPath()

        newName = currentName

        if lRelocateDataset:

            if lRelocateToInternal:
                newLocation = AccountBookUtil.DEFAULT_FOLDER_CONTAINER

            else:
                selectedFolder = getFileFromFileChooser(toolbox_frame_,                     # Parent frame or None
                                                        get_home_dir(),                     # Starting path
                                                        None,                               # Default Filename
                                                        "Select new location for dataset",  # Title
                                                        False,                              # Multi-file selection mode
                                                        True,                               # True for Open/Load, False for Save
                                                        False,                              # True = Files, else Dirs
                                                        "SELECT FOLDER",                    # Load/Save button text, None for defaults
                                                        None,                               # File filter (non Mac only). Example: "txt" or "qif"
                                                        lAllowTraversePackages=False,
                                                        lAllowTraverseApplications=False,
                                                        lForceJFC=False,
                                                        lForceFD=False,
                                                        lAllowNewFolderButton=True,
                                                        lAllowOptionsButton=True)

                if selectedFolder is None or selectedFolder == "" or not File(selectedFolder).exists():
                    txt = "%s: User chose to cancel or no folder selected." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return
                newLocation = File(selectedFolder)

            fNewNamePath = AccountBook.getUnusedFileNameWithBase(newLocation, StringUtils.stripExtension(fCurrentFilePath.getName()))
            newName = fNewNamePath.getName()
            oldPathURI = Paths.get(fCurrentFilePath.toURI())
            newPathURI = Paths.get(fNewNamePath.toURI())

        else:

            while True:
                userRequestedNewName = myPopupAskForInput(toolbox_frame_,
                                                          theTitle=_THIS_METHOD_NAME,
                                                          theFieldLabel="NEW NAME:",
                                                          theFieldDescription="Enter a new name for this dataset",
                                                          defaultValue=newName)

                if userRequestedNewName is None or userRequestedNewName == "":
                    txt = "No new name entered - no changes made"
                    myPopupInformationBox(toolbox_frame_,txt)
                    setDisplayStatus(txt, "R")
                    return

                newName = AccountBook.stripNonFilenameSafeCharacters(userRequestedNewName)
                newNamePath = os.path.join(os.path.dirname(currentFilePath), newName + Common.ACCOUNT_BOOK_EXTENSION)
                fNewNamePath = File(newNamePath)

                oldPathURI = Paths.get(fCurrentFilePath.toURI())
                newPathURI = Paths.get(fNewNamePath.toURI())

                if newName is None or newName == "" or fNewNamePath.exists():
                    myPopupInformationBox(toolbox_frame_, "ERROR: new name: '%s' invalid or already exists?" %(newName),theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                    continue

                break

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "%s this dataset?" %(actionString.capitalize())):
            return

        _msg = pad("Please wait:", 50, padChar=".")
        pleaseWait = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
        pleaseWait.go()

        try:
            MD_REF.getUI().setStatus("Toolbox will now %s your dataset" %(actionString), -1.0)

            myPrint("B", "Updating Root's internal name to match new name")
            currentRoot.setAccountName(os.path.splitext(newName)[0])
            currentRoot.syncItem()

            myPrint("B", "Executing '%s' on current dataset: %s - will %s to: %s" %(_THIS_METHOD_NAME, fCurrentFilePath.getCanonicalPath(), actionString, fNewNamePath.getCanonicalPath()))

            closeDatasetStatus = ManuallyCloseAndReloadDataset.manuallyCloseDataset(currentBook, lKillAllSyncers=True, lCloseWindows=True, lKillAllFramesWithBookReferences=True)
            if closeDatasetStatus == 1:
                txt = "ERROR: MD reports that it could not close all open windows.... - no changes made (you might need to restart MD)"
                myPopupInformationBox(toolbox_frame_, txt, theTitle="ERROR", theMessageType=JOptionPane.ERROR_MESSAGE)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                return

            elif closeDatasetStatus != 0:
                txt = "ERROR: Could not cleanly close dataset. No file %s action taken. MD WILL QUIT - PLEASE RELAUNCH & TRY AGAIN (review console)" %(actionString)
                myPopupInformationBox(toolbox_frame_, txt, theTitle="ERROR", theMessageType=JOptionPane.ERROR_MESSAGE)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPrint("B","Requesting Moneydance shuts down now...")
                ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False, lAllowSaveWorkspace=True)
                return

            del currentBook, currentRoot

            success = False
            try:
                myPrint("B", "attempting to move (rename/copy) file from " + fCurrentFilePath.getAbsolutePath() + " to " + fNewNamePath.getAbsolutePath())
                Files.move(oldPathURI, newPathURI, [StandardCopyOption.ATOMIC_MOVE])
                myPrint("B", "... nio atomic (rename/copy) successful!")
                success = True
            except IOException as e:
                myPrint("B", "nio atomic move failed.  Reverting to old-fashioned copy-and-move. Error was:", e)
                try:
                    MDIOUtils.copyDirectoryContents(fCurrentFilePath, fNewNamePath)
                    MDIOUtils.deleteFolder(fCurrentFilePath)
                    myPrint("B", "... copyDirectoryContents successful!")
                    success = True
                except IOException as e2:
                    myPrint("B", "copy copyDirectoryContents FAILED!  Deleting destination and sticking with the original. Error was:", e2)
                    dump_sys_error_to_md_console_and_errorlog()
                    MDIOUtils.deleteFolder(fNewNamePath)

            if not success:
                txt = "%s: File operation(s) failed (review console) - no changes made...." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,"%s - Will close Toolbox & reopen original" %(txt),theMessageType=JOptionPane.ERROR_MESSAGE)

                absPath = fCurrentFilePath.getAbsolutePath()

                newWrapper = AccountBookWrapper.wrapperForFolder(fCurrentFilePath)   # type: AccountBookWrapper

            else:

                myPrint("B", "** %sd dataset to: %s\n" %(actionString, fNewNamePath.getCanonicalPath()))

                absPath = fNewNamePath.getAbsolutePath()

                if fCurrentFilePath.exists():
                    raise Exception("ERROR: The old file/path still exists: %s" %(fCurrentFilePath.getAbsolutePath()))

                txt = "Dataset: %sd to: '%s" %(actionString, newName)
                setDisplayStatus(txt, "B"); myPrint("B", txt)

                txt2 = "Dataset: '%s' %sd to: '%s" %(fCurrentFilePath.getCanonicalPath(), actionString, fNewNamePath.getCanonicalPath())
                logToolboxUpdates("rename_relocate_dataset", txt2, book=fNewNamePath.getCanonicalPath())

                play_the_money_sound()
                myPopupInformationBox(toolbox_frame_, "%s - Will close Toolbox and open %sd dataset" %(txt, actionString))

                newWrapper = AccountBookWrapper.wrapperForFolder(fNewNamePath)   # type: AccountBookWrapper

            prefs = MD_REF.getUI().getPreferences()

            if not AccountBookUtil.isWithinInternalStorage(newWrapper.getBook()):
                externalFiles = prefs.getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, StreamVector())
                if not externalFiles.contains(absPath):
                    myPrint("DB", "adding file '%s' to external account list (config.dict)" %(absPath))
                    externalFiles.add(absPath)
                    prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFiles)

            prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_CURRENT_ACCOUNT_BOOK, absPath)

            if newWrapper is None: raise Exception("ERROR: 'AccountBookWrapper.wrapperForFolder' returned None")
            myPrint("B", "Successfully obtained 'wrapper' for: %s\n" %(fNewNamePath))

            cleanup_external_files_setting(lAutoPurge=True)

            if success and fCurrentFilePath.exists():
                # This really should NOT happen (if original dataset reappears, look for Syncer doing something....
                raise Exception("ERROR: The old file/path still exists: %s" %(fCurrentFilePath.getAbsolutePath()))

            ManuallyCloseAndReloadDataset.startBackgroundSyncing()

            _operationMsg = "renamed/relocated" if success else "original"
            myPrint("B", "(Re)opening %s dataset...." %(_operationMsg))

            ManuallyCloseAndReloadDataset.setOtherExtensionsEnabled(True)

            openResult = None                                                                                           # noqa
            try:
                # .setCurrentBook() always pushes mdGUI().dataFileOpened() on the EDT (if not already on the EDT)....
                myPrint("DB", "... calling .setCurrentBook() to (re)open the %s dataset..." %(_operationMsg))
                openResult = MD_REF.setCurrentBook(newWrapper)
            except OutOfMemoryError:
                myPrint("B", "@@@ CRITICAL ERROR <<OUT OF MEMORY>> setCurrentBook() has crashed whilst (re)opening %s dataset!?" %(_operationMsg))
                dump_sys_error_to_md_console_and_errorlog()
                myPrint("B", getJVMUsageStatistics())
                myPopupInformationBox(theParent=toolbox_frame_, theTitle="CRITICAL ERROR",
                                      theMessage="TOOLBOX: OUT OF MEMORY whilst (re)opening %s dataset. WILL SHUT DOWN MD (review Console/errlog.txt)" %(_operationMsg), theMessageType=JOptionPane.ERROR_MESSAGE)
                MD_REF.getUI().shutdownApp(False)
                return
            except:
                myPrint("B", "@@@ CRITICAL ERROR - .setCurrentBook() has crashed whilst (re)opening %s dataset!?" %(_operationMsg))
                dump_sys_error_to_md_console_and_errorlog()
                myPopupInformationBox(theParent=toolbox_frame_, theTitle="CRITICAL ERROR",
                                      theMessage="TOOLBOX: ERROR: whilst (re)opening %s dataset. WILL SHUT DOWN MD (review Console/errlog.txt)" %(_operationMsg), theMessageType=JOptionPane.ERROR_MESSAGE)
                MD_REF.getUI().shutdownApp(False)
                return

            if success and fCurrentFilePath.exists():
                raise Exception("ERROR: The old file/path still exists: %s" %(fCurrentFilePath.getAbsolutePath()))

            if not openResult or newWrapper.getBook() is None:
                txt = "%s: Failed to open %s Dataset (wrong password?)...." %(_THIS_METHOD_NAME, _operationMsg)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,"%s - Will show Welcome Window" %(txt),theMessageType=JOptionPane.WARNING_MESSAGE)
                WelcomeWindow.showWelcomeWindow(MD_REF.getUI())

                # Do this after .setCurrentBook() so-as not to co-modify listeners.....
                SwingUtilities.invokeLater(GenericWindowClosingRunnable(toolbox_frame_))
                return

            myPrint("B", "** SUCCESSFUL COMPLETION RENAME/RELOCATE FUNCTION **")                                        # Phew - made it!

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "%s function has failed. Review log and console - You should probably RESTART MD" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,theMessage=txt, theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)

        finally:

            pleaseWait.kill()

        return

    def remove_inactive_from_sidebar():
        _THIS_METHOD_NAME = "REMOVE INACTIVE ACCTS/CATS FROM SIDEBAR"

        book = MD_REF.getCurrentAccountBook()

        # fullList = FullSideBarItemList(book, MD_REF.getUI(), False)
        dtm = SideBarNodeFactory.getBarModelFromSettings(book, MD_REF.getUI())
        nodeList = SideBarNodeFactory.getNodesFromTree(dtm)

        removeNodes = []

        for node in nodeList:
            if node.getChildType() not in [SideBarNodeType.ACCOUNT, SideBarNodeType.INCOME, SideBarNodeType.EXPENSE, SideBarNodeType.CATEGORY]:continue
            acctId = node.getAccountId()
            acct = book.getAccountByNum(acctId)
            if acct is None: continue
            active = False if acct.getAccountIsInactive() else True
            if not active: removeNodes.append(node)

        if len(removeNodes) < 1:
            txt = "%s: NO inactive nodes found - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Remove %s inactive accounts/categories from sidebar?" %(len(removeNodes))):
            return

        nodesRemoved = 0
        myPrint("B", "Removing inactive sidebar account/category nodes...:")
        for node in removeNodes:
            myPrint("B", "... %s" %(node))
            nodesRemoved += 1
            nodeList.remove(node)

        myPrint("B", "Saving Sidebar Nodelist....")
        SideBarNodeFactory.saveNodesToSettings(book, MD_REF.getUI(), nodeList)

        txt = "%s: %s nodes removed from sidebar - Toolbox will now restart/reload dataset" %(_THIS_METHOD_NAME, nodesRemoved)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("remove_inactive_from_sidebar", txt)
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def change_fonts():
        if float(MD_REF.getBuild()) < 3030:
            txt = "Error - must be on Moneydance build 3030+ to change fonts! NO CHANGES MADE!"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User requested to change Moneydance Default Fonts!")

        if not backup_config_dict():
            txt = "Error backing up config.dict preferences file before deletion - NO CHANGES MADE!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        prefs = MD_REF.getUI().getPreferences()

        systemFonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames()
        for installedFont in systemFonts: myPrint("DB","System OS Font %s is installed in your system..:" %installedFont)

        # These are taken from MD Code - build 3034 - watch out they may change...!
        Mac_fonts_main =     ["SF Pro Display", "SF Display", "Helvetica Neue", "Helvetica", "Lucida Grande", "Dialog"]
        Mac_fonts_mono =     ["Gill Sans", "Menlo", "Monaco", "Monospaced"]

        Windows_fonts_main = ["Dialog"]
        Windows_fonts_mono = ["Calibri","Monospaced"]

        Linux_fonts_main =   ["Dialog"]
        Linux_fonts_mono =   ["Monospaced"]

        all_fonts_code =   ["Hack", "Monospaced"]
        all_fonts_print =   ["Helvetica", "Dialog"]

        lExit=False
        lAnyFontChanges=False

        for checkFont in ["main_font","mono_font","code_font","print.font_name"]:
            x = prefs.getSetting(checkFont, None)
            if x is not None and x == "null":
                lAnyFontChanges=True
                prefs.setSetting(checkFont,None)
                myPrint("B","@@ Font setting %s in config.dict was set to 'null'. I have corrected this and deleted the setting.." %checkFont)

        if lAnyFontChanges: MD_REF.savePreferences()

        while True:
            if lExit: break

            mainF = prefs.getSetting("main_font", None)
            monoF = prefs.getSetting("mono_font", None)
            codeF = prefs.getSetting("code_font", None)
            printF = prefs.getSetting("print.font_name", None)

            myPrint("DB",'@@ MONEYDANCE: Config.dict: "main_font" currently set to %s' %mainF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "mono_font" currently set to %s' %monoF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "code_font" currently set to %s' %codeF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "print.font_name" currently set to %s' %printF)

            display_main="None(Moneydance defaults)"
            display_mono="None(Moneydance defaults)"
            display_code="None(Moneydance defaults)"
            display_print="None(Moneydance defaults)"
            if mainF and mainF != "null": display_main = mainF
            if monoF and monoF != "null": display_mono = monoF
            if codeF and codeF != "null": display_code = codeF
            if printF and printF != "null": display_print = printF

            MyPopUpDialogBox(toolbox_frame_,"Config.dict - CURRENT FONTS:",
                             '"main_font" currently set to %s\n'
                             '"mono_font" currently set to %s  (Used for mainly numbers)\n'
                             '"code_font" currently set to %s  (the Moneybot / Python Font >> IMPACTS OUTPUT COLUMN ALIGNMENT <<)\n'
                             '"print.font_name" currently set to %s' %(display_main,display_mono,display_code,display_print),
                             theTitle="FONTS",OKButtonText="CONTINUE").go()

            _options=["MAIN: CHANGE SETTING",
                      "MAIN: DELETE SETTING",
                      "MONO: CHANGE SETTING",
                      "MONO: DELETE SETTING",
                      "CODE: CHANGE SETTING",
                      "CODE: DELETE SETTING",
                      "PRINT: CHANGE SETTING",
                      "PRINT: DELETE SETTING"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "What type of change do you want to make?",
                                                         "ALTER FONTS",
                                                         JOptionPane.WARNING_MESSAGE,
                                                         getMDIcon(None),
                                                         _options,
                                                         None)

            if not selectedOption: break

            lMain = (_options.index(selectedOption) == 0 or _options.index(selectedOption) == 1)
            lMono = (_options.index(selectedOption) == 2 or _options.index(selectedOption) == 3)
            lCode = (_options.index(selectedOption) == 4 or _options.index(selectedOption) == 5)
            lPrint = (_options.index(selectedOption) == 6 or _options.index(selectedOption) == 7)

            lDelete = (_options.index(selectedOption) == 1 or _options.index(selectedOption) == 3 or _options.index(selectedOption) == 5 or _options.index(selectedOption) == 7)
            lChange = (_options.index(selectedOption) == 0 or _options.index(selectedOption) == 2 or _options.index(selectedOption) == 4 or _options.index(selectedOption) == 6)

            if lMain:
                theKey = "main_font"
            elif lMono:
                theKey = "mono_font"
            elif lCode:
                theKey = "code_font"
            elif lPrint:
                theKey = "print.font_name"
            else:
                raise(Exception("error"))

            if lDelete:
                if myPopupAskQuestion(toolbox_frame_,"DELETE FONT KEY","Are you sure you want to delete key: %s?" %theKey,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE):
                    prefs.setSetting(theKey, None)
                    MD_REF.savePreferences()
                    lAnyFontChanges = True
                    txt = "Config.dict: key: %s DELETED - RESTART MD" %(theKey)
                    myPrint("B", txt)
                    logToolboxUpdates("change_fonts", txt, onlyLogGenericEntry=True)
                    myPopupInformationBox(toolbox_frame_, "Config.dict: key: %s DELETED - RESTART MD" %theKey, "FONTS", JOptionPane.WARNING_MESSAGE)
                    continue
                else:
                    continue

            elif lChange:

                theFonts = None                                                                                         # noqa
                if Platform.isOSX():
                    if lMain:
                        theFonts = Mac_fonts_main
                    elif lMono:
                        theFonts = Mac_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))
                elif Platform.isWindows():
                    if lMain:
                        theFonts = Windows_fonts_main
                    elif lMono:
                        theFonts = Windows_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))
                else:
                    if lMain:
                        theFonts = Linux_fonts_main
                    elif lMono:
                        theFonts = Linux_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))

                for x in theFonts: myPrint("DB","Possible internal default fonts for your Platform...: %s" %x)

                _options = ["CHOOSE FROM MD INTERNAL LIST", "CHOOSE FROM YOUR OS' SYSTEM INSTALLED"]
                selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "New Font Selection options for: %s?" %theKey,
                                                             "ALTER FONTS",
                                                             JOptionPane.WARNING_MESSAGE,
                                                             getMDIcon(None),
                                                             _options,
                                                             None)

                if not selectedOption:
                    continue

                if _options.index(selectedOption) == 0 or _options.index(selectedOption) == 1:

                    if _options.index(selectedOption) == 1: theFonts = systemFonts
                    selectedFont = JOptionPane.showInputDialog(toolbox_frame_,
                                                               "Select new Font to set for %s" %theKey,
                                                               "ALTER FONTS",
                                                               JOptionPane.WARNING_MESSAGE,
                                                               getMDIcon(None),
                                                               theFonts,
                                                               None)
                    if not selectedFont:
                        continue
                    else:
                        prefs.setSetting(theKey,selectedFont)
                        MD_REF.savePreferences()
                        lAnyFontChanges = True
                        txt = 'Config.dict: key: %s CHANGED to "%s" - RESTART MD' %(theKey, selectedFont)
                        myPrint("B", txt)
                        logToolboxUpdates("change_fonts", txt, onlyLogGenericEntry=True)
                        myPopupInformationBox(toolbox_frame_, 'Config.dict: key: %s CHANGED to "%s"\nRESTART MD' %(theKey,selectedFont), "FONTS", JOptionPane.WARNING_MESSAGE)
                        continue

                else: raise(Exception("error"))

            continue

        if lAnyFontChanges:

            try:
                if int(MD_REF.getBuild()) > 4060:
                    MD_REF.getUI().getFonts().updateFonts(True)     # from MD2022.3(4077) onwards...
                else:
                    MD_REF.getUI().getFonts().updateFonts()         # MD2022.2 and prior.....
                txt = "MD Font Changes made (MD Fonts were also reinitialised) - YOU MIGHT NEED TO RESTART MONEYDANCE ANYWAY (config.dict was also backed up)...."
            except:
                txt = "MD Font Changes made (failed to reinitialise MD Fonts) - PLEASE RESTART MONEYDANCE (config.dict was also backed up)...."

            setDisplayStatus(txt, "R"); myPrint("DB", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
        else:
            txt = "NO FONT ACTIONS TAKEN! - NO CHANGES MADE...."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

    def delete_theme_file():
        myPrint("DB", "User requested to delete custom theme file!")

        # noinspection PyUnresolvedReferences
        customThemeFile = str(ThemeInfo.customThemeFile)
        if not os.path.exists(customThemeFile):
            txt = "Custom Theme file does not exist to delete!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,
                                  "DELETE MD custom Theme file?",
                                  "Are you sure you want to delete custom Theme file?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.ERROR_MESSAGE):

            txt = "User declined to delete custom Theme file!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not doesUserAcceptDisclaimer(toolbox_frame_, "DELETE MD custom Theme file", "DELETE custom theme file?"):
            txt = "User declined to agree to disclaimer >> custom Theme file!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User confirmed to delete custom Theme file...")

        try:
            if not backup_custom_theme_file():
                txt = "Error backing up custom theme file prior to deletion - no changes made!"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            os.remove(customThemeFile)
            txt = "DELETED CUSTOM THEME FILE: %s" %(customThemeFile)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            logToolboxUpdates("delete_theme_file", txt, onlyLogGenericEntry=True)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE CUSTOM THEME FILE", JOptionPane.WARNING_MESSAGE)

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR DELETING CUSTOM THEME FILE: %s" %(customThemeFile)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE CUSTOM THEME FILE", JOptionPane.ERROR_MESSAGE)

# DECOMISSIONED find_IOS_sync_data() as py file too large...
#
#     def find_IOS_sync_data():
#
#         if not(Platform.isOSX() or Platform.isWindows()):
#             txt = "FindIOSSyncDataButtonAction() called, but not OSx or Windows!?"
#             setDisplayStatus(txt, "R"); myPrint("B",txt)
#             return
#
#         instructions = """
# INSTRUCTIONS TO ATTEMPT TO RETRIEVE YOUR MONEYDANCE SYNC ENCRYPTION KEY FROM iPHONE/iPAD
#
# NOTE: As of 15th January 2021, there is a new iOS app in Beta Test, this allows you to view your encryption passphrase
# ... I understand an Android version is also coming... Ideally use these first if you have access to your mobile
#
# OTHERWISE:
# STEP 1. Ensure you have the Moneydance iOS App working & Syncing on an iphone/iPad.
# STEP 2. Perform an iPhone/iPad backup to your computer Using iTunes (or Finder on Mac Big Sur). Instructions below....
# STEP 3. RETURN HERE and let Toolbox attempt search; or search manually yourself (instructions below)
#
# -----------------------------------------------------------------------------------------------------------------------------
# NOTE: If on a Mac, and you want Toolbox to search in step 3, then you must change these Mac Settings first...
# >>The system prevents programmatic access to the backups..
# >> Go to Mac / Settings / Security & Privacy. Privacy Tab
# - Click the padlock to unlock the settings
# - Scroll down left side to Full Disk Access
# - On the right, find Moneydance and tick it (or click the + to add and tick it) to Grant Access
# - Exit and restart Moneydance, then run this Toolbox option again (if you don't do this, it will not find your backups!)..
# >> Change this setting back afterwards.....
# -----------------------------------------------------------------------------------------------------------------------------
#
# NOTE: DO NOT EDIT THE FILE MENTIONED BELOW. ALWAYS QUIT WITHOUT SAVING.
# IF YOU COPY THE FILE TO YOUR DESKTOP, MAKE SURE YOU COPY (and not move)...
# (Normally you hold down the CTRL, or OPTION/ALT key whilst dragging so the icon changes to a plus and copy)
#
#
# ================================
# Mac (easiest option if possible)
# ================================
# Please review these instructions:
# https://support.apple.com/en-gb/guide/iphone/iph3ecf67d29/ios
# - Essentially install iTunes (not needed on Mac Big Sur - which uses finder)
# - Go to the iPhone/iPad tab, General options
# - Perform a local backup (NOT ENCRYPTED)
#
# >> Come back here after backup completed and then run this Toolbox option to search backups........ <<
#
# OR MANUAL INSTRUCTIONS BELOW
#
# This link has details on the backup location: https://support.apple.com/en-gb/HT204215
#
# >> Locate your backup(s) in Finder:
# - Open Finder. Menu GO
# - Go To Folder
# - Copy and paste this:
#
# ~/Library/Application Support/MobileSync/Backup/
# Press Return.
#
# You will see a list of backups. (e.g. 00008030-000E31343A02802E)
# Right click this folder (the most recent)
# Select "New terminal at folder". Then terminal will open at this folder.
#
# Copy / paste this command below and press enter...
#
# grep -rl tik_dropbox_md *
#
# ...wait...
#
# It will find something like this:
# c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c
# This is the file you need, stay in Terminal
#
# plutil -p c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c
# (and you will see the information on the screen next to "tik_dropbox_md_sync_key" =>
#
# or do this:
# open -a TextEdit c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c
#
# And you will see text and gibberish..... but also your key... Your key should be visible... See example. My was after the text 'last_account_used2V'
#
# (of course, now you know the file, you can find it, copy it to desktop, open with other text viewers....)
#
#
# ================================
# WINDOWS
# ================================
# Download and install iTunes, plug in iPhone. Select the iPhone icon and you should see  (General) options
# (Help here: https://support.apple.com/en-gb/guide/iphone/iph3ecf67d29/ios)
#
# Perform a local backup, DESELECT Encrypt local backup. Select Backup NOW
#
# ...wait...
#
# >> Come back here after backup completed and then run this Toolbox option to search backups........ <<
#
# OR MANUAL INSTRUCTIONS BELOW
#
# When finished, locate your backup - help here: https://support.apple.com/en-gb/HT204215
#
# In the taskbar search box, type command (no enter) and when there is a popup select run as administrator
# type
# cd %userprofile% (Or a different folder if in a different place)
# cd apple
# cd mobilesync
# cd backup
# dir
# Your backups will be listed. If only one, skip this next step, else find the latest. Select/copy the name
# cd <the selected name>
#
# So you will now be at something like...:
# C:\\Users\\<username>\\Apple\\MobileSync\\Backup\\00008030-000E31343A02802E>
# or
# C:\\Users\\<username>>\\Apple\\MobileSync\\Backup> (if only one backup)
#
# Now type this and enter:
#
# findstr /S /I /M /C:"tik_dropbox_md" *.*
# ... wait ...
#
# It will show you something like this..:
#
# 00008030-000E31343A02802E\\c8\\c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c
#
# Backup name: 00008030-000E31343A02802E
# SubDir: c8
# Actual file name you want: c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c
#
# Now copy/paste the whole string (one line) and type this (paste the long name) and enter
#
# start notepad 00008030-000E31343A02802E\\c8\\c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c
#
# Notepad is rubbish, so use the cursor and move right along the lines until you see your key...
# ---
#
# On both the above options, you can find and copy the file to your desktop. Rename the desktop copy to 'key.plist' for ease of use after you have it.
#
# Once you have the file..:
# On windows you can download and use this tool:
# https://www.imactools.com/iphonebackupviewer/download/win
# Run the program, select the 3 line menu button top right, Tools, Property List View, then open the key.plist file you saved to your desktop..
#
# On Mac, in terminal
# cd /Users/<yourname>/Desktop
# type and enter
# plutil -convert xml1 key.plist
# Now you will have a text readable version of the file you can open in a text editor..
#
# <END>
# """
#
#         jif = QuickJFrame("View Instructions:", instructions,lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
#         jif.setLocationRelativeTo(toolbox_frame_)
#
#         if not myPopupAskQuestion(jif,
#                                   "SEARCH COMPUTER iOS BACKUP(s)",
#                                   "This may be time consuming...Do you want to continue with the search for Encryption Sync Passphrases now?",
#                                   JOptionPane.YES_NO_OPTION,
#                                   JOptionPane.WARNING_MESSAGE):
#
#             txt = "User Aborted iOS backup(s) search..."
#             setDisplayStatus(txt, "R")
#             return
#
#         jif.dispose()       # already within the EDT
#
#         if Platform.isOSX():
#             searchList = ["Library/Application Support/MobileSync/Backup"]
#         else:
#             searchList = ["Apple\\MobileSync\\Backup",
#                           "Apple Computer\\MobileSync\\Backup",
#                           "AppData\\Roaming\\Apple\\MobileSync\\Backup",
#                           "AppData\\Roaming\\Apple Computer\\MobileSync\\Backup"]
#
#
#         miniText=""
#         pathList = []
#         for x in (searchList):
#             fullPath = os.path.join(get_home_dir(), x)
#             miniText += "%s\n" %fullPath
#             if os.path.exists(fullPath) and os.path.isdir(fullPath):
#                 pathList.append(fullPath)
#
#         if len(pathList)<1:
#             txt = "Sorry - could not find your IOS Backup directory(s)..."
#             setDisplayStatus(txt, "R")
#             myPrint("B", "Sorry - could not find your IOS Backup directory(s) in %s ....:" %get_home_dir())
#             myPrint("B", searchList)
#             MyPopUpDialogBox(toolbox_frame_,"Search for iOS Backup(s) - could not find your directory(s):",
#                              miniText,theTitle="RECOVER IOS SYNC KEY",OKButtonText="ABORT").go()
#             return
#
#         theIKReference = "c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c"  # WARNING, this may change? Might have to switch to finding the key..!
#         diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching iOS Backup(s)..",theTitle="SEARCH", lModal=False, OKButtonText="WAIT")
#         diag.go()
#
#         def findIOSBackup(pattern, path):
#             iFound=0                                                                                                    # noqa
#             result = []
#             dotCounter = 0
#
#             lContinueToEnd=False
#
#             if not GlobalVars.i_am_an_extension_so_run_headless:
#                 print "Searching for your iOS Backups (might be time consuming):.....",
#
#             for root, dirs, files in os.walk(path):
#
#                 if dotCounter % 1000 <1:
#                     if not GlobalVars.i_am_an_extension_so_run_headless: print ".",
#
#                 if not dotCounter or (dotCounter % 10000 <1 and not lContinueToEnd):
#
#                     options=["STOP HERE","SEARCH TO END", "KEEP ASKING"]
#                     response = JOptionPane.showOptionDialog(toolbox_frame_,
#                                                             "Are you OK to continue (%s found so far)?"%iFound,
#                                                             "SEARCH COMPUTER FOR iOS BACKUP(s)",
#                                                             0,
#                                                             JOptionPane.QUESTION_MESSAGE,
#                                                             getMDIcon(None),
#                                                             options,
#                                                             options[2])
#                     if response == 0:
#                         _txt = "User Aborted iOS Backup(s) search..."
#                         setDisplayStatus(_txt, "R")
#                         return result, iFound
#
#                     elif response == 1:
#                         lContinueToEnd = True
#
#                 dotCounter+=1
#
#                 if debug: myPrint("DB","Searching: %s" %(root))
#
#                 for name in files:
#                     fp = os.path.join(root, name)
#                     if os.path.islink(fp):
#                         myPrint("DB", "found file link! %s - will skip" %fp)
#                         continue
#                     if fnmatch.fnmatch(name, pattern):
#                         iFound+=1
#                         result.append(fp)
#
#                 for name in dirs:
#                     fp = os.path.join(root, name)
#                     if os.path.islink(fp):
#                         myPrint("DB", "found dir link! %s - will skip" %fp)
#                         continue
#                     if fnmatch.fnmatch(name, pattern):
#                         iFound+=1
#                         result.append(fp)
#
#             return result, iFound
#
#         iFound = 0
#         fileList=[]
#
#         for theDir in pathList:
#             myPrint("P","Searching from Directory: %s" %theDir)
#
#             holdFileList, holdFound = findIOSBackup(theIKReference, theDir)
#             fileList += holdFileList
#             iFound += holdFound
#
#         diag.kill()
#
#         print
#         myPrint("B","Completed search for iOS Backup(s): %s found (called: %s)" %(iFound, theIKReference))
#
#         if iFound < 1:
#             txt = "Sorry - could not find the Moneydance Sync file(s) (%s) in iOS backup(s)..." %(theIKReference)
#             setDisplayStatus(txt, "R"); myPrint("B", txt)
#             myPrint("B", fileList)
#             x=""
#             if Platform.isOSX():
#                 x="PLEASE CHECK YOU GRANTED FULL DISK ACCESS (READ INSTRUCTIONS)\n\n"
#             MyPopUpDialogBox(toolbox_frame_,"Search for iOS Backups - SORRY >> COULD NOT FIND the Moneydance App Sync File (%s) in these directories:"%theIKReference,
#                              x+miniText,theTitle="RECOVER IOS SYNC KEY",OKButtonText="CLOSE").go()
#             return
#
#
#         # ###############################################################################################
#         # https://github.com/provegard/binaryplist/
#         # Copyright (c) 2011, Per Rovegard <per@rovegard.se>
#         # Licensed under the 3-clause BSD license.
#         from struct import unpack
#         from datetime import tzinfo, timedelta
#
#         # noinspection PyDeprecation
#         def dump_plist(obj, _format):
#             if 'plist' == (_format or 'plist'):
#                 from plistlib import writePlist
#                 writePlist(obj, sys.stdout)
#             elif 'json' == _format:
#                 import json
#                 s = json.dumps(obj, indent=2)
#                 print(s)
#
#         def decode_plist(_filename, _format="plist", _search="ALL"):   # Can be "plist" or "json"
#             with open(_filename, 'rb') as fd:
#                 try:
#                     plist_root = read_binary_plist(fd)
#
#                     if _search == "ALL":
#                         dump_plist(plist_root, _format)
#                     else:
#                         if _search in plist_root:
#                             return plist_root[_search]
#                         else:
#                             return "NOT FOUND"
#
#                 except PListFormatError as e:
#                     myPrint("B","Format error: %s" % (e.message))
#                     return "ERROR"
#                 except PListUnhandledError as e:
#                     myPrint("B","Unhandled: %s" % (e.message))
#                     return "ERROR"
#
#         # HEADER
#         #         magic number ("bplist")
#         #         file format version
#         #
#         # OBJECT TABLE
#         #         variable-sized objects
#         #
#         #         Object Formats (marker byte followed by additional info in some cases)
#         #         null    0000 0000
#         #         bool    0000 1000                       // false
#         #         bool    0000 1001                       // true
#         #         fill    0000 1111                       // fill byte
#         #         int     0001 nnnn       ...             // # of bytes is 2^nnnn, big-endian bytes
#         #         real    0010 nnnn       ...             // # of bytes is 2^nnnn, big-endian bytes
#         #         date    0011 0011       ...             // 8 byte float follows, big-endian bytes
#         #         data    0100 nnnn       [int]   ...     // nnnn is number of bytes unless 1111 then int count follows, followed by bytes
#         #         string  0101 nnnn       [int]   ...     // ASCII string, nnnn is # of chars, else 1111 then int count, then bytes
#         #         string  0110 nnnn       [int]   ...     // Unicode string, nnnn is # of chars, else 1111 then int count, then big-endian 2-byte uint16_t
#         #                 0111 xxxx                       // unused
#         #         uid     1000 nnnn       ...             // nnnn+1 is # of bytes
#         #                 1001 xxxx                       // unused
#         #         array   1010 nnnn       [int]   objref* // nnnn is count, unless '1111', then int count follows
#         #                 1011 xxxx                       // unused
#         #         set     1100 nnnn       [int]   objref* // nnnn is count, unless '1111', then int count follows
#         #         dict    1101 nnnn       [int]   keyref* objref* // nnnn is count, unless '1111', then int count follows
#         #                 1110 xxxx                       // unused
#         #                 1111 xxxx                       // unused
#         #
#         # OFFSET TABLE
#         #         list of ints, byte size of which is given in trailer
#         #         -- these are the byte offsets into the file
#         #         -- number of these is in the trailer
#         #
#         # TRAILER
#         #         byte size of offset ints in offset table
#         #         byte size of object refs in arrays and dicts
#         #         number of offsets in offset table (also is number of objects)
#         #         element # in offset table which is top level object
#         #         offset table offset
#
#
#         try:
#             unichr(8364)                                                                                                # noqa
#         except NameError:
#             # Python 3
#             def unichr(x):                                                                                              # noqa
#                 return chr(x)
#
#         # From CFDate Reference: "Absolute time is measured in seconds relative to the
#         # absolute reference date of Jan 1 2001 00:00:00 GMT".
#         SECS_EPOCH_TO_2001 = 978307200
#
#         MARKER_NULL = 0X00
#         MARKER_FALSE = 0X08
#         MARKER_TRUE = 0X09
#         MARKER_FILL = 0X0F                                                                                              # noqa
#         MARKER_INT = 0X10
#         MARKER_REAL = 0X20
#         MARKER_DATE = 0X33
#         MARKER_DATA = 0X40
#         MARKER_ASCIISTRING = 0X50
#         MARKER_UNICODE16STRING = 0X60
#         MARKER_UID = 0X80
#         MARKER_ARRAY = 0XA0
#         MARKER_SET = 0XC0
#         MARKER_DICT = 0XD0
#
#
#         def read_binary_plist(fd):
#             """Read an object from a binary plist.
#             The binary plist format is described in CFBinaryPList.c at
#             http://opensource.apple.com/source/CF/CF-550/CFBinaryPList.c. Only the top
#             level object is returned.
#             Raise a PListFormatError or a PListUnhandledError if the input data cannot
#             be fully understood.
#             Arguments:
#             fd -- a file-like object that is seekable
#             """
#             r = BinaryPListReader(fd)
#             return r.read()
#
#
#         class PListFormatError(Exception):
#             """Represent a binary plist format error."""
#             pass
#
#
#         class PListUnhandledError(Exception):
#             """Represent a binary plist error due to an unhandled feature."""
#             pass
#
#
#         class ObjectRef(object):
#             def __init__(self, index):                                                                                  # noqa
#                 self.index = index
#
#             def resolve(self, lst):
#                 return lst[self.index]
#
#
#         class BinaryPListReader(object):
#
#             def __init__(self, fd):                                                                                     # noqa
#                 self._fd = fd
#                 self._offsets = None
#                 self.objectRefSize = None
#
#             def read(self):
#                 fd = self._fd
#
#                 # start from the beginning to check the signature
#                 fd.seek(0, 0)
#                 buf = fd.read(7)
#
#                 # verify the signature; the first version digit is always 0
#                 if buf != b"bplist0":
#                     raise PListFormatError("Invalid signature: %s" % (buf, ))
#
#                 # seek to and read the trailer (validation omitted for now)
#                 fd.seek(-32, 2)
#                 buf = fd.read(32)
#
#                 _, offsetIntSize, self.objectRefSize, numObjects, topObject, offsetTableOffset = unpack(">5x3B3Q", buf)
#
#                 # read the object offsets
#                 fd.seek(offsetTableOffset, 0)
#                 self._offsets = [self._read_sized_int(offsetIntSize) for _ in range(0, numObjects)]
#
#                 # read the actual objects
#                 objects = [self._read_object(offs) for offs in self._offsets]
#
#                 # resolve lazy values (references to the object list)
#                 self._resolve_objects(objects)
#
#                 return objects[topObject]
#
#             def _resolve_objects(self, objects):
#                 # all resolutions are in-place, to avoid breaking references to
#                 # the outer objects!
#                 for obj in objects:
#                     if isinstance(obj, list):
#                         for i in range(0, len(obj)):
#                             obj[i] = obj[i].resolve(objects)
#                     if isinstance(obj, set):
#                         temp = [item.resolve(objects) for item in obj]
#                         obj.clear()
#                         obj.update(temp)
#                     if isinstance(obj, dict):
#                         temp = {k.resolve(objects): v.resolve(objects) for k, v in list(obj.items())}
#                         obj.clear()
#                         obj.update(temp)
#
#             def _read_object(self, offset=-1):
#                 if offset >= 0:
#                     self._fd.seek(offset)
#                 else:
#                     offset = self._fd.tell()  # for the error message
#                 marker = ord(self._fd.read(1))
#                 nb1 = marker & 0xf0
#                 nb2 = marker & 0x0f
#
#                 obj = None
#                 if nb1 == MARKER_NULL:
#                     if marker == MARKER_NULL:
#                         obj = None
#                     elif marker == MARKER_FALSE:
#                         obj = False
#                     elif marker == MARKER_TRUE:
#                         obj = True
#                     # TO DO: Fill byte, skip over
#                 elif nb1 == MARKER_INT:
#                     count = 1 << nb2
#                     obj = self._read_sized_int(count)
#                 elif nb1 == MARKER_REAL:
#                     obj = self._read_sized_float(nb2)
#                 elif marker == MARKER_DATE:  # marker!
#                     secs = self._read_sized_float(3)
#                     secs += SECS_EPOCH_TO_2001
#                     obj = datetime.datetime.fromtimestamp(secs, UTC())
#                 elif nb1 == MARKER_DATA:
#                     # Binary data
#                     count = self._read_count(nb2)
#                     obj = self._fd.read(count)
#                 elif nb1 == MARKER_ASCIISTRING:
#                     # ASCII string
#                     count = self._read_count(nb2)
#                     obj = self._fd.read(count).decode("ascii")
#                 elif nb1 == MARKER_UNICODE16STRING:
#                     # UTF-16 string
#                     count = self._read_count(nb2)
#                     data = self._fd.read(count * 2)
#                     chars = unpack(">%dH" % (count, ), data)
#                     s = u''
#                     for ch in chars:
#                         s += unichr(ch)
#                     obj = s
#                 elif nb1 == MARKER_UID:
#                     count = 1 + nb2
#                     obj = self._read_sized_int(count)
#                 elif nb1 == MARKER_ARRAY:
#                     count = self._read_count(nb2)
#                     # we store lazy references to the object list
#                     obj = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
#                 elif nb1 == MARKER_SET:
#                     count = self._read_count(nb2)
#                     # we store lazy references to the object list
#                     obj = set([ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)])
#                 elif nb1 == MARKER_DICT:
#                     count = self._read_count(nb2)
#                     # first N keys, then N values
#                     # we store lazy references to the object list
#                     keys = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
#                     values = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
#                     obj = dict(list(zip(keys, values)))
#
#                 try:
#                     return obj
#                 except NameError:
#                     raise PListFormatError("Unknown marker at position %d: %d" %
#                                            (offset, marker))
#
#             def _read_count(self, nb2):
#                 count = nb2
#                 if count == 0xf:
#                     count = self._read_object()
#                 return count
#
#             def _read_sized_float(self, log2count):
#                 if log2count == 2:
#                     # 32 bits
#                     ret, = unpack(">f", self._fd.read(4))
#                 elif log2count == 3:
#                     # 64 bits
#                     ret, = unpack(">d", self._fd.read(8))
#                 else:
#                     raise PListUnhandledError("Unhandled real size: %d" %
#                                               (1 << log2count, ))
#                 return ret
#
#             def _read_sized_int(self, count):
#                 # in format version '00', 1, 2, and 4-byte integers have to be
#                 # interpreted as unsigned, whereas 8-byte integers are signed
#                 # (and 16-byte when available). negative 1, 2, 4-byte integers
#                 # are always emitted as 8 bytes in format '00'
#                 buf = self._fd.read(count)
#                 if count == 1:
#                     ret = ord(buf)
#                 elif count == 2:
#                     ret, = unpack(">H", buf)
#                 elif count == 4:
#                     ret, = unpack(">I", buf)
#                 elif count == 8:
#                     ret, = unpack(">q", buf)
#                 else:
#                     raise PListUnhandledError("Unhandled int size: %d" %
#                                               (count, ))
#                 return ret
#
#
#         class UTC(tzinfo):
#
#             def utcoffset(self, dt):
#                 return timedelta(0)
#
#             def tzname(self, dt):
#                 return "UTC"
#
#             def dst(self, dt):
#                 return timedelta(0)
#
#         # typedef struct {
#         #    uint8_t  _unused[5];
#         #    uint8_t  _sortVersion;
#         #    uint8_t  _offsetIntSize;
#         #    uint8_t  _objectRefSize;
#         #    uint64_t _numObjects;
#         #    uint64_t _topObject;
#         #    uint64_t _offsetTableOffset;
#         # } CFBinaryPlistTrailer;
#
#         syncPassphrases=[]
#         for foundFile in fileList:
#             try:
#                 theSyncKey = decode_plist(foundFile,_format="plist",_search="tik_dropbox_md_sync_key")
#                 syncPassphrases.append(theSyncKey)
#             except:
#                 syncPassphrases.append("Sorry - caught an error decoding the file")
#
#         niceFileList="\n SEARCH FOR MONEYDANCE (%s) iOS Backup(s)\n"%theIKReference
#         niceFileList+="Search for these Directories:\n"
#         niceFileList+=miniText
#         niceFileList+="\nFound these Directories:\n"
#
#         for x in pathList:
#             niceFileList+="%s\n" %x
#         niceFileList+="\n"
#
#         if not iFound:
#             niceFileList+="\n<NONE FOUND>\n"
#
#         for x in fileList:
#             myPrint("B","Found: %s" %x)
#             niceFileList+=x+"\n"
#
#         niceFileList+="\nPOSSIBLE SYNC ENCRYPTION PASSPHRASES:\n"
#         if len(syncPassphrases) < 1:
#             niceFileList+="\n<NONE FOUND>\n"
#
#         for encryptionKey in syncPassphrases:
#             niceFileList+="%s\n" %encryptionKey
#
#         niceFileList+="\n\n<END>"
#         txt = "Find my iOS Backup(s) found %s files, with %s possible Sync Encryption keys" %(iFound,len(syncPassphrases))
#         setDisplayStatus(txt, "DG")
#
#         jif = QuickJFrame("LIST OF MONEYDANCE iOS Backups and Sync Encryption keys FOUND".upper(), niceFileList, lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
#
#         myPopupInformationBox(jif, "%s Sync Encryption keys found...." %(len(syncPassphrases)), "iOS BACKUP SEARCH", JOptionPane.INFORMATION_MESSAGE)

    def import_QIF():
        _THIS_METHOD_NAME = "IMPORT QIF"

        theTitle = "Select QIF file for import"
        QIFfilename = getFileFromFileChooser(toolbox_frame_,         # Parent frame or None
                                            get_home_dir(),          # Starting path
                                            "select_your_file.qif",  # Default Filename
                                            theTitle,                # Title
                                            False,                   # Multi-file selection mode
                                            True,                    # True for Open/Load, False for Save
                                            True,                    # True = Files, else Dirs
                                            None,                    # Load/Save button text, None for defaults
                                            "qif",                   # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if QIFfilename is None or QIFfilename == "":
            txt = "%s: User chose to cancel or no file selected >>  So no Import will be performed... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not os.path.exists(QIFfilename) or not os.path.isfile(QIFfilename):
            txt = "%s: Sorry, file selected to import either does not exist or is not a file" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        dropdownAccts=AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(5))
        dropdownAccts=sorted(dropdownAccts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))  # type: [Account]
        dropdownAccts.insert(0,"<NONE: USE QIF SPECIFIED>")

        label_QIF = JLabel("%s" %(os.path.basename(QIFfilename)))

        label_accounts = JLabel("Select Default Account if none specified in QIF:")
        user_accounts = JComboBox(dropdownAccts)

        # QIF_FORMATS = ["QIF_FORMAT_AUTO", "QIF_FORMAT_MMDDYY", "QIF_FORMAT_DDMMYY", "QIF_FORMAT_YYMMDD"]
        QIF_FORMATS = ["QIF_FORMAT_AUTO", "QIF_FORMAT_MMDDYY", "QIF_FORMAT_DDMMYY", "QIF_FORMAT_YYMMDD"]
        label_qif_format = JLabel("Select QIF Format")
        user_QIF_format = JComboBox(QIF_FORMATS)

        decimalStrings = [".",","]
        label_decimal = JLabel("Select your decimal point character")
        user_selectDecimal = JComboBox(decimalStrings)
        user_selectDecimal.setSelectedIndex(0)

        dropdownCurrs=[]
        currencies = MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() != CurrencyType.Type.CURRENCY: continue                                           # noqa
            dropdownCurrs.append(curr)
        dropdownCurrs=sorted(dropdownCurrs, key=lambda sort_x: (sort_x.getName().upper()))
        label_currency = JLabel("Select Default Currency for any Accounts created:")
        user_currency = JComboBox(dropdownCurrs)
        user_currency.setSelectedItem(MD_REF.getCurrentAccountBook().getCurrencies().getBaseType())

        IMPORT_TYPE = ["QIF_MODE_TRANSFER", "QIF_MODE_DOWNLOAD"]
        # label_import_type = JLabel("Select Import Type")
        # user_import_type = JComboBox(IMPORT_TYPE)
        #

        label_import_type_transfer = JLabel("TRANSFER MODE?")
        user_import_type_transfer = JRadioButton("(transfer)", True)
        label_import_type_download = JLabel("DOWNLOAD (from bank) MODE?")
        user_import_type_download = JRadioButton("(disabled - use newer function)",False)
        user_import_type_download.setEnabled(False)
        bg2 = ButtonGroup()
        bg2.add(user_import_type_transfer)
        bg2.add(user_import_type_download)

        label_importStructure = JLabel("Import Structure only (no data)?")
        user_importStructureOnly = JRadioButton("(structure only)", False)
        label_importAllData = JLabel("Import all data?")
        user_importAllData = JRadioButton("(all data)", False)
        bg = ButtonGroup()
        bg.add(user_importStructureOnly)
        bg.add(user_importAllData)

        userFilters = JPanel(GridLayout(0, 2))
        userFilters.add(JLabel("IMPORT FILE:"))
        userFilters.add(label_QIF)
        userFilters.add(label_qif_format)
        userFilters.add(user_QIF_format)
        userFilters.add(label_decimal)
        userFilters.add(user_selectDecimal)
        userFilters.add(label_currency)
        userFilters.add(user_currency)
        userFilters.add(label_accounts)
        userFilters.add(user_accounts)
        userFilters.add(JLabel(""))
        userFilters.add(JLabel("---"))
        # userFilters.add(label_import_type)
        # userFilters.add(user_import_type)
        userFilters.add(label_import_type_transfer)
        userFilters.add(user_import_type_transfer)
        userFilters.add(label_import_type_download)
        userFilters.add(user_import_type_download)
        userFilters.add(JLabel(""))
        userFilters.add(JLabel("---"))
        userFilters.add(label_importStructure)
        userFilters.add(user_importStructureOnly)
        userFilters.add(label_importAllData)
        userFilters.add(user_importAllData)


        while True:
            options = ["EXIT", "IMPORT"]
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       userFilters,
                                                       "IMPORT QIF (Older MD Function)",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))
            if userAction != 1:
                txt = "%s: - User aborted - No changes made....." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not user_importStructureOnly.isSelected() and not user_importAllData.isSelected():
                user_importStructureOnly.setForeground(getColorRed())
                user_importAllData.setForeground(getColorRed())
                continue

            if not user_import_type_transfer.isSelected() and not user_import_type_download.isSelected():
                user_import_type_transfer.setForeground(getColorRed())
                user_import_type_download.setForeground(getColorRed())
                continue

            break

        if user_QIF_format.getSelectedItem() == "QIF_FORMAT_AUTO":
            theQIFFormat = Common.QIF_FORMAT_AUTO
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_MMDDYY":
            theQIFFormat = Common.QIF_FORMAT_MMDDYY
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_DDMMYY":
            theQIFFormat = Common.QIF_FORMAT_DDMMYY
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_YYMMDD":
            theQIFFormat = Common.QIF_FORMAT_YYMMDD
        else:
            txt = "%s: Error - QIF Format %s unknown / unsupported by Moneydance now....?!" %(_THIS_METHOD_NAME, user_QIF_format.getSelectedItem())
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if user_import_type_transfer.isSelected():
            theImportType = Common.QIF_MODE_TRANSFER
        elif user_import_type_download.isSelected():
            theImportType = Common.QIF_MODE_DOWNLOAD
        else:
            txt = "%s: Error - QIF MODE unknown / unsupported by Moneydance now....?!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # if user_import_type.getSelectedItem() == "QIF_MODE_TRANSFER":
        #     theImportType = Common.QIF_MODE_TRANSFER
        # elif user_import_type.getSelectedItem() == "QIF_MODE_DOWNLOAD":
        #     theImportType = Common.QIF_MODE_DOWNLOAD
        # else:
        #     txt = "QIF IMPORT: Error - QIF MODE %s unknown / unsupported by Moneydance now....?!" %(user_import_type.getSelectedItem())
        #     setDisplayStatus(txt, "R")
        #     myPopupInformationBox(toolbox_frame_,txt,"QIF IMPORT" %(user_import_type.getSelectedItem()), theMessageType=JOptionPane.WARNING_MESSAGE)
        #     return

        theAcct = None
        if isinstance(user_accounts.getSelectedItem(), Account):
            theAcct = user_accounts.getSelectedItem()

        theMsg =  "File name:        %s\n"         %(QIFfilename)
        theMsg += "QIF Format:       %s (%s)\n"    %(user_QIF_format.getSelectedItem(),theQIFFormat)
        theMsg += "Decimal Char:     %s\n"         %(user_selectDecimal.getSelectedItem())
        theMsg += "Default Currency: %s\n"         %(user_currency.getSelectedItem())
        theMsg += "Default Account:  %s\n"         %(user_accounts.getSelectedItem())
        theMsg += "Import Type:      %s (%s)\n"    %(IMPORT_TYPE[theImportType],theImportType)
        theMsg += "Structure Only:   %s\n"         %(user_importStructureOnly.isSelected())

        ask = MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Please confirm parameters:",
                             theMessage=theMsg,
                             theTitle="QIF IMPORT",
                             OKButtonText="PROCEED",
                             lCancelButton=True)
        if (not ask.go() or not myPopupAskBackup(toolbox_frame_,"Do you want to make a Backup before your QIF Import?")):
            txt = "%s: User aborted - NO CHANGES MADE" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B","User has requested a QIF import with these following parameters:\n")
        myPrint("B",theMsg)
        myPrint("J",">>EXECUTING IMPORT................\n")

        MD_REF.importQIFIntoAccount(    MD_REF.getCurrentAccountBook(),
                                            File(QIFfilename),
                                            theQIFFormat,                           # one of Common.QIF_FORMAT_MMDDYY, QIF_FORMAT_YYMMDD, QIF_FORMAT_DDMMYY, QIF_FORMAT_AUTO
                                            user_selectDecimal.getSelectedItem(),   # your decimal place character.
                                            user_currency.getSelectedItem(),        # the default currency to use for any new accounts that are created
                                            theAcct,                                # the default account to import into (though the QIF file may also specify multiple accounts with names)
                                            theImportType,                          # Common.QIF_MODE_DOWNLOAD or Common.QIF_MODE_TRANSFER
                                            user_importStructureOnly.isSelected())  # if true, only import the account and category structure

        myPrint("J",">>FINISHED IMPORT................\n")

        txt = "%s: File %s imported (review console log for any messages)" %(_THIS_METHOD_NAME, os.path.basename(QIFfilename))
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        logToolboxUpdates("import_QIF", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

        ConsoleWindow.showConsoleWindow(MD_REF.getUI())

    def convert_timestamp_readable_date():
        getTimeStamp = myPopupAskForInput(toolbox_frame_,"CONVERT TIMESTAMP","TimeStamp:","Enter the TimeStamp (Milliseconds) to see the readable date")

        setDisplayStatus(" ", "DG")

        if getTimeStamp is None or getTimeStamp == "" or not StringUtils.isInteger(getTimeStamp) or int(getTimeStamp) < 1: return
        readableStamp = get_time_stamp_as_nice_text(int(getTimeStamp))

        txt = "Convert Timestamp (%s): %s" %(getTimeStamp,readableStamp)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"CONVERT TIMESTAMP")

    def force_remove_extension():
        myPrint("DB", "User requested to delete all references to orphaned/outdated Extensions from config.dict and *.mxt files...")

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs) < 1 and len(orphan_files) < 1 and len(orphan_confirmed_extn_keys) < 1:
            txt = "No orphaned Extension preferences or files detected - nothing to do!"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        displayData = "\nLISTING EXTENSIONS ORPHANED IN CONFIG.DICT OR FILES (*.MXT)\n\n"

        for x in orphan_prefs.keys():
            displayData += "%s Extension: %s is %s\n" %(pad("config.dict:",40),pad(x,40),pad(orphan_prefs[x],40))

        displayData += "\n"

        for x in orphan_confirmed_extn_keys.keys():
            _theVersion = MD_REF.getUI().getPreferences().getSetting(orphan_confirmed_extn_keys[x][1],None)
            displayData+="%s Extension: %s Key: %s (build: %s) is %s\n" %(pad("config.dict: ",40),pad(x,40),pad(orphan_confirmed_extn_keys[x][1],40),_theVersion,pad(orphan_confirmed_extn_keys[x][0],40))

        displayData += "\n"

        for x in orphan_files.keys():
            displayData += "%s Extension: %s is %s\n" %(pad("File: "+orphan_files[x][1],40),pad(x,40),pad(orphan_files[x][0],40))

        displayData += "\n<END>"
        jif = QuickJFrame("ORPHANED EXTENSIONS", displayData,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

        if not confirm_backup_confirm_disclaimer(jif, "DELETE ORPHANED EXTENSIONS", "delete the Extension Orphans?"):
            return

        extensionDir = Common.getFeatureModulesDirectory()
        if not extensionDir:
            txt = "DELETE ORPHANED EXTENSIONS - Error getting Extensions directory - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not backup_config_dict():
            txt = "DELETE ORPHANED EXTENSIONS - Error backing up config.dict preferences file - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # reload latest preferences
        extension_prefs = MD_REF.getUI().getPreferences().getTableSetting("gen.fmodules", None)
        if not extension_prefs:
            txt = "DELETE ORPHANED EXTENSIONS - Error getting gen.fmodules setting - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # OK - let's go....!! Delete away!!!
        for x in orphan_prefs.keys():
            extension_prefs.put(x,None)
            myPrint("B","Orphaned extension %s removed from config.dict!" %x)

        MD_REF.getUI().getPreferences().setSetting("gen.fmodules",extension_prefs)
        myPrint("B","config.dict gen.fmodules setting re-saved....")

        for x in orphan_confirmed_extn_keys:
            MD_REF.getUI().getPreferences().setSetting(orphan_confirmed_extn_keys[x][1],None)
            myPrint("B","Orphaned extension key %s removed from config.dict!" %orphan_confirmed_extn_keys[x][1])

        MD_REF.savePreferences()

        lError = False
        # extensionDir = Common.getFeatureModulesDirectory()
        for x in orphan_files.keys():
            # noinspection PyTypeChecker
            fileToDelete = os.path.join(extensionDir.getAbsolutePath(),orphan_files[x][1])
            if not os.path.exists(fileToDelete):
                lError = True
                myPrint("B","ERROR orphaned extension file %s MISSING" %fileToDelete)
            else:
                try:
                    os.remove(fileToDelete)
                    myPrint("B","Orphaned extension file %s deleted" %fileToDelete)
                except:
                    lError = True
                    myPrint("B","ERROR deleting orphaned extension file %s deleted" %fileToDelete)
                    dump_sys_error_to_md_console_and_errorlog()

        if lError:
            myPrint("B", "Orphaned Extensions have been deleted - WITH ERRORS - from config.dict and the .MXT files from the Extensions folder....")
            txt = "ORPHANED EXTENSIONS HAVE BEEN DELETED - WITH ERRORS - REVIEW CONSOLE ERROR LOG!"
        else:
            myPrint("B", "SUCCESS - Your Orphaned Extensions have been deleted from config.dict and the .MXT files from the Extensions folder....")
            txt = "SUCCESS - YOUR ORPHANED EXTENSIONS HAVE BEEN DELETED - MANUALLY RESTART MONEYDANCE!"

        setDisplayStatus(txt, "R")
        logToolboxUpdates("force_remove_extension", txt, onlyLogGenericEntry=True)
        play_the_money_sound()
        myPopupInformationBox(jif, txt, "DELETE ORPHANED EXTENSIONS", JOptionPane.ERROR_MESSAGE)

    def reset_window_positions():
        _RESETWINLOC    = 0
        _RESETREGFILT   = 1
        _RESETREGVIEW   = 2
        _RESETALL       = 3

        what = [
            "RESET - Only Window Locations on their own (Excludes Filters & Views)",
            "RESET - Only Transaction Register Filters",
            "RESET - Only Transaction Register Initial / Current View screen",
            "RESET - Window display settings (Sizes, Locations, Sorts, Widths etc) - Everything EXCEPT Filters & Views"
        ]

        resetWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                "Select the Window display setting(s) to RESET",
                                                "RESET WINDOW DISPLAY SETTINGS",
                                                JOptionPane.WARNING_MESSAGE,
                                                getMDIcon(None),
                                                what,
                                                None)
        if not resetWhat:
            txt = "No RESET WINDOW DISPLAY SETTINGS TYPE option was chosen - no changes made!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User requested to %s settings from config.dict, LocalStorage() ./safe/settings , and by account!" %resetWhat)

        lAll = lWinLocations = lRegFilters = lRegViews = False

        if resetWhat == what[_RESETALL]:        lAll            = True
        if resetWhat == what[_RESETWINLOC]:     lWinLocations   = True
        if resetWhat == what[_RESETREGFILT]:    lRegFilters     = True
        if resetWhat == what[_RESETREGVIEW]:    lRegViews       = True

        def get_set_config(st, tk, lReset, lResetAll, lResetWinLoc, lResetRegFilters, lResetRegViews):                  # noqa
            # As of 2021.2010   Window locations are only in config.dict.
            #                   Register Filters and Initial Register Views are only in LocalStorage()
            #                   column width, sort orders, etc are everywhere......

            configData = []

            invalidKeysToZap = StreamVector()
            if isinstance(invalidKeysToZap, Vector): pass

            if not lReset:
                configData.append("\nDATA STORED WITHIN CONFIG.DICT (effectively defaults where not specifically set by Account):")
                configData.append(" -------------------------------------------------------------------------------------------")

            lastKey = None
            for theKey in tk:
                # Skip config settings we don't want to reset

                # Main safety filter here
                value = st.get(theKey)
                if not check_for_window_display_data(theKey, value): continue

                if lResetAll:
                    pass
                elif lResetWinLoc:
                    if not check_for_just_locations_window_display_data(theKey, value): continue
                elif lResetRegFilters:
                    if not check_for_just_register_filters_window_display_data(theKey, None): continue
                elif lResetRegViews:
                    if not check_for_just_initial_view_filters_window_display_data(theKey, None): continue
                else:
                    myPrint("B", "@@@ ERROR in get_set_config(): unexpected parameter!?")
                    raise(Exception("@@@ ERROR in get_set_config(): unexpected parameter!?"))

                if lReset:
                    invalidKeysToZap.add(theKey)

                test = "col_widths."
                if theKey.startswith(test):
                    if lReset:
                        pass
                        # MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("COLUMN WIDTHS:")

                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                test = "ext_mgmt_win"
                if theKey.startswith(test):
                    if lReset:
                        pass
                        # MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nEXTENSIONS WINDOW:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                lFoundKeyTest = False
                for test in ["moneybot_py_divider", "mbot."]:
                    if theKey.startswith(test):
                        lFoundKeyTest = True
                        if lReset:
                            pass
                            # MD_REF.getPreferences().setSetting(theKey, None)
                        else:
                            if theKey[:len(test)] != lastKey:
                                lastKey = theKey[:len(test)]
                                configData.append("\nMONEYBOT:")
                            configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                        break
                if lFoundKeyTest: continue

                test = "gui."
                if theKey.startswith(test):
                    if lReset:
                        pass
                        # MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nGUI.:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                lFoundKeyTest = False
                for test in ["security_list", "curr_list", "ratioSettings.", "ol_acct_map_win"]:
                    if theKey.startswith(test) or "custom_filter" in theKey:
                        lFoundKeyTest = True
                        if lReset:
                            pass
                            # MD_REF.getPreferences().setSetting(theKey, None)
                        else:
                            if theKey[:len(test)] != lastKey:
                                lastKey = theKey[:len(test)]
                                configData.append("\nMISC:")
                            configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                        break
                if lFoundKeyTest: continue

                myPrint("B","@@ RESET WINDOW DATA - ERROR >> What is this key: %s ? @@" %theKey)
                raise(Exception("ERROR - caught an un-coded key: " + str(theKey)))

            # END OF config.dict search
            ########################################################################################################

            if lResetAll or lResetRegFilters or lResetRegViews:
                # Now get the same data for each account
                accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), MyAcctFilter(6))

                if not lReset:
                    configData.append("\nDATA STORED INTERNALLY BY ACCOUNT (not config.dict):")
                    configData.append(" ----------------------------------------------------")

                dataPrefKey = "col_widths."
                dataPrefKeys_legacy = [  "gui.col_widths",
                                         "rec_reg.credit",
                                         "rec_reg.debit" ]

                keyIterator = []
                if lResetRegFilters:    keyIterator.append("sel_reg_filter")
                if lResetRegFilters:    keyIterator.append("sel_invreg_filter")
                if lResetRegFilters:    keyIterator.append("custom_filter_int")
                if lResetRegViews:      keyIterator.append("sel_inv_view")

                for acct in accounts:

                    last = None

                    if lResetAll:
                        for x in GlobalVars.Strings.CONFIG_COLWIDTHS:
                            xx = acct.getPreference(dataPrefKey+x, None)

                            if xx:
                                if lReset:
                                    # NOTE: This really sets the preference in LocalStorage() with the acct's UUII+"." prepended as the key!!!! (Sneaky eh!!??)
                                    acct.setPreference(dataPrefKey+x, None)
                                    # acct.syncItem() # Not entirely sure about this.... If Preference goes to LocalStorage() then Acct shouldn't be affected..
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Key: %s Value: %s" %(pad(dataPrefKey+x+":",30),str(xx).strip()))

                    if lResetRegFilters or lResetRegViews:
                        for x in keyIterator:
                            xx = acct.getPreference(x, None)

                            if xx:
                                if lReset:
                                    # NOTE: This really sets the preference in LocalStorage() with the acct's UUII+"." prepended as the key!!!! (Sneaky eh!!??)
                                    acct.setPreference(x, None)
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Key: %s Value: %s" %(pad(x+":",30),str(xx).strip()))

                    lNeedsSync = False

                    if lResetAll:
                        for theLegacyKey in dataPrefKeys_legacy:

                            # Look for legacy keys actually on the account..!
                            yy = acct.getParameter(theLegacyKey, None)

                            if yy:  # Should be a legacy setting
                                if lReset:
                                    acct.setEditingMode()
                                    acct.setParameter(theLegacyKey, None)
                                    lNeedsSync = True
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Legacy Key: %s Value: %s" %(pad(theLegacyKey+":",30-7),str(yy).strip()))

                    if lResetRegFilters or lResetRegViews:
                        for theLegacyKey in keyIterator:

                            # Look for legacy keys actually on the account..!
                            yy = acct.getParameter(theLegacyKey, None)

                            if yy:  # Should be a legacy setting
                                if lReset:
                                    acct.setEditingMode()
                                    acct.setParameter(theLegacyKey, None)
                                    lNeedsSync = True
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Legacy Key: %s Value: %s" %(pad(theLegacyKey+":",30-7),str(yy).strip()))

                    if lReset and lNeedsSync:
                        acct.syncItem()

                # END OF Accounts search
                ########################################################################################################

                if not lReset:
                    configData.append("\nDATA STORED INTERNALLY WITHIN LOCAL STORAGE (not config.dict):")
                    configData.append(" ---------------------------------------------------------------")

                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                keys = sorted(LS.keys())

                if lResetAll:

                    last = None

                    for theKey in keys:
                        value = LS.get(theKey)

                        for theTypeToCheck in dataPrefKeys_legacy:

                            if theKey.endswith("." + theTypeToCheck):

                                if lReset:
                                    LS.put(theKey, None)
                                else:
                                    splitKey = theKey.split('.')
                                    if splitKey[0] != last:
                                        last = splitKey[0]
                                        lookupAcct = MD_REF.getCurrentAccountBook().getAccountByUUID(splitKey[0])
                                        if lookupAcct:
                                            configData.append("\n>>Account: %s" %(lookupAcct.getAccountName()))
                                        else:
                                            configData.append("\n>>Account: <NOT FOUND> ???")

                                    configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                        # Now look for keys not linked to Accounts... Perhaps deleted ones?
                        for theTypeToCheck in GlobalVars.Strings.CONFIG_COLWIDTHS:

                            if theKey.endswith(".col_widths."+theTypeToCheck):

                                splitKey = theKey.split('.')
                                lookupAcct = MD_REF.getCurrentAccountBook().getAccountByUUID(splitKey[0])

                                if lookupAcct: continue     # Found one, probably caught above, so skip

                                if lReset:
                                    LS.put(theKey, None)
                                else:
                                    if splitKey[0] != last:
                                        last = splitKey[0]
                                        configData.append("\n>>Account: <NOT FOUND> ??? (probably a deleted account)")

                                    configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                if lResetRegFilters or lResetRegViews:

                    last = None

                    for theKey in keys:
                        value = LS.get(theKey)

                        if lResetRegFilters:
                            if not check_for_just_register_filters_window_display_data(theKey, None):
                                continue
                        elif lResetRegViews:
                            if not check_for_just_initial_view_filters_window_display_data(theKey, None):
                                continue
                        else:
                            myPrint("B", "@@ ERROR: RESET WINDOW DISPLAY SETTINGS - Unexpected filter!?")
                            raise(Exception("@@ ERROR: RESET WINDOW DISPLAY SETTINGS - Unexpected filter!?"))

                        if lReset:
                            LS.put(theKey, None)
                        else:
                            splitKey = theKey.split('.')
                            if splitKey[0] != last:
                                last = splitKey[0]
                                lookupAcct = MD_REF.getCurrentAccountBook().getAccountByUUID(splitKey[0])
                                if lookupAcct:
                                    configData.append("\n>>Account: %s" %(lookupAcct.getAccountName()))
                                else:
                                    configData.append("\n>>Account: <NOT FOUND>???")

                            configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                # END OF LocalStorage() search
                ########################################################################################################

            if lReset and invalidKeysToZap.size() > 0:
                myPrint("B","Saving keys to zap into Preferences:", invalidKeysToZap)
                MD_REF.getPreferences().setSetting(GlobalVars.Strings.TOOLBOX_PREFERENCES_ZAPPER, invalidKeysToZap)

            configData.append("\n <END>")

            for i in range(0, len(configData)):
                configData[i] = configData[i] + "\n"

            configData = "".join(configData)

            if not lReset:
                jif = QuickJFrame("View the relevant RESET WINDOW DISPLAY SETTINGS that will be reset if you select OK to proceed", configData,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
                return jif

            return

        st,tk = read_preferences_file(lSaveFirst=False)

        if not st:
            _txt = "ERROR: RESET WINDOW DISPLAY SETTINGS >> reading and sorting the data file - no changes made!..."
            setDisplayStatus(_txt, "R")
            myPopupInformationBox(None,_txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        theNewViewFrame = get_set_config(st, tk, False, lAll, lWinLocations, lRegFilters, lRegViews)

        if not confirm_backup_confirm_disclaimer(theNewViewFrame, "RESET WINDOW DISPLAY SETTINGS", "%s data?" %(resetWhat)):
            return

        if not backup_config_dict():
            _txt = "RESET WINDOW DISPLAY SETTINGS: ERROR making backup of config.dict - no changes made!"
            setDisplayStatus(_txt, "R")
            myPopupInformationBox(theNewViewFrame,_txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not backup_local_storage_settings():
            _txt = "RESET WINDOW DISPLAY SETTINGS: ERROR making backup of LocalStorage() ./safe/settings - no changes made!"
            setDisplayStatus(_txt, "R")
            myPopupInformationBox(theNewViewFrame,_txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        ##### FORCE CLOSE ALL WINDOWS SO THEY DO NOT SAVE THEIR SETTINGS AFTER TOOLBOX CHANGES #########################
        # try:
        #     forceCloseMoneydanceWindows()
        # except:
        #     dump_sys_error_to_md_console_and_errorlog()
        #     myPopupInformationBox(theNewViewFrame, "ERROR: forceCloseMoneydanceWindows() crashed (will continue anyway)", "RESET WINDOW DISPLAY SETTINGS", JOptionPane.ERROR_MESSAGE)


        # DO THE RESET HERE
        myPrint("B","Executing the windows settings reset....")
        get_set_config(st, tk, True, lAll, lWinLocations, lRegFilters, lRegViews)

        MD_REF.savePreferences()                                        # save config.dict
        MD_REF.getCurrentAccountBook().getLocalStorage().save()   # Flush local storage to safe/settings

        txt = "SUCCESS - %s data reset in config.dict config file, internally by Account & Local Storage.. RESTART MD" %(resetWhat)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("reset_window_positions", txt)

        play_the_money_sound()
        myPopupInformationBox(theNewViewFrame, "SUCCESS - %s - MONEYDANCE WILL EXIT - PLEASE MANUALLY RESTART MD" %(resetWhat), "RESET WINDOW DISPLAY SETTINGS", JOptionPane.WARNING_MESSAGE)

        myPrint("B","Requesting Moneydance shuts down now...")
        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False, lAllowSaveWorkspace=False)

    def advanced_options_suppress_dropbox_warning():
        ask = MyPopUpDialogBox(toolbox_frame_, theStatus="You can suppress the 'Your file seems to be in a shared folder' Warning..",
                             theMessage="Moneydance support states that you should NEVER store your dataset in Dropbox.\n"
                                        "... and that you should store your dataset locally and use Moneydance's built-in syncing instead to share across computers and devices.\n"
                                        "THEREFORE YOU PROCEED AT ENTIRELY YOUR OWN RISK AND ACCEPT THAT STORING IN DROPBOX MIGHT DAMAGE YOUR DATA!",
                             theTitle="SUPPRESS DROPBOX WARNING",
                             lCancelButton=True,
                             OKButtonText="ACCEPT RISK",
                             lAlertLevel=3)

        if not ask.go():
            txt = "'SUPPRESS DROPBOX WARNING' - User chose to exit  - no changes made"
            setDisplayStatus(txt, "R")
            return

        if confirm_backup_confirm_disclaimer(toolbox_frame_, "SUPPRESS DROPBOX WARNING", "Suppress 'Your data is stored in a shared folder' (Dropbox) message?"):
            suppressFile = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath(), "suppress_file_in_dropbox_restriction.txt")
            if not os.path.exists(suppressFile):
                try:
                    x = open(suppressFile, "w")
                    x.write("DISCLAIMER - YOU SUPPRESS THE 'Your file is stored in a shared folder' (Dropbox) WARNING AT YOUR OWN RISK\n"
                            "STORING YOUR MD DATASET IN DROPBOX CAN DAMAGE YOUR DATASET\n\n"
                            "(Warning courtesy of Toolbox)")

                    x.close()
                    myPrint("B","SUPPRESS DROPBOX WARNING: User requested to suppress the 'Your file is stored in a shared folder' (dropbox) warning....")
                    myPrint("B", "@@User accepted warnings and disclaimer about dataset damage and instructed Toolbox to create %s - EXECUTED" %(suppressFile))
                    txt = "'SUPPRESS DROPBOX WARNING' - Suppressed >> 'Your file is stored in a shared folder' (dropbox) warning. MONEYDANCE WILL NOW RESTART"
                    setDisplayStatus(txt, "R")
                    logToolboxUpdates("advanced_options_suppress_dropbox_warning", txt)
                    play_the_money_sound()
                    myPopupInformationBox(toolbox_frame_, txt, "'SUPPRESS DROPBOX WARNING'", JOptionPane.ERROR_MESSAGE)
                    ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)
                    return
                except:
                    myPrint("B","'SUPPRESS DROPBOX WARNING' - Error creating %s" %(suppressFile))
                    dump_sys_error_to_md_console_and_errorlog()

            txt = "'SUPPRESS DROPBOX WARNING' - ERROR - either the file already exists, or I failed to create the file..(review console log)?"
            setDisplayStatus(txt, "R")

    def advanced_options_save_trunk_file():
        _THIS_METHOD_NAME = "SAVE TRUNK FILE"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME,"Execute Save Trunk File function?"):
            return

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..
        MD_REF.getCurrentAccountBook().saveTrunkFile()

        txt = "%s: Save Trunk Executed!" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("advanced_options_save_trunk_file", txt)

        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

    def advanced_clone_dataset():
        """This feature clones the open dataset. It takes a backup, restores the backup, wipes sync, removes transactional data.
        It deletes txns, price history, attachments from the clone (rather than recreating a new structure. The next evolution
        of this function will allow recreation of balances and cutoff dates"""

        _THIS_METHOD_NAME = "Clone Dataset".upper()
        PARAMETER_KEY = "toolbox_clone_dataset"

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, ("-" * (len(_THIS_METHOD_NAME)+1)))

        # Refer:
        # com.moneydance.apps.md.view.gui.MoneydanceGUI.saveToBackup(SecondaryFrame) : void
        # com.moneydance.apps.md.view.gui.MoneydanceGUI.openBackup(Frame) : boolean

        currentBook = MD_REF.getCurrentAccountBook()     # type: AccountBook
        if currentBook is None:
            myPopupInformationBox(toolbox_frame_, "ERROR: AccountBook is missing?",theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        currentName = currentBook.getName().strip()

        fCurrentFilePath = MD_REF.getCurrentAccountBook().getRootFolder()
        currentFilePath = fCurrentFilePath.getCanonicalPath()

        # newName = AccountBook.stripNonFilenameSafeCharacters(currentName+"_CLONE_%s" %(System.currentTimeMillis()))
        newName = AccountBook.stripNonFilenameSafeCharacters(currentName+"_CLONE")

        lbl_cloneName = JLabel("Enter the name for the cloned dataset:")
        user_cloneName = JTextField(newName)

        user_zeroAcctOpeningBalances = JCheckBox("Zero all account opening balances?", True)
        user_zeroAcctOpeningBalances.setToolTipText("When enabled, will reset account initial/opening balances to zero")

        user_purgeAllTransactions = JCheckBox("Purge all transactions?", True)
        user_purgeAllTransactions.setToolTipText("When enabled, purges all transactions from the clone")

        user_purgeSnapHistory = JCheckBox("Purge all security price & currency rate history (keep current and most recent one)?", True)
        user_purgeSnapHistory.setToolTipText("When enabled, purges security price & currency rate history (leaving current price/rate and most recent price/rate)")

        filterPanel = JPanel(GridLayout(0, 1))
        filterPanel.add(lbl_cloneName)
        filterPanel.add(user_cloneName)
        filterPanel.add(JLabel(""))
        filterPanel.add(user_zeroAcctOpeningBalances)
        filterPanel.add(user_purgeAllTransactions)
        filterPanel.add(user_purgeSnapHistory)

        _options = ["Cancel", "CLONE"]

        while True:
            jsp_acd = MyJScrollPaneForJOptionPane(filterPanel,850, 175)

            userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                      jsp_acd,
                                                      "%s: Select CLONE Options:" %(_THIS_METHOD_NAME.upper()),
                                                      JOptionPane.OK_CANCEL_OPTION,
                                                      JOptionPane.QUESTION_MESSAGE,
                                                      getMDIcon(None),
                                                      _options,
                                                      _options[0])

            if userAction < 1:
                txt = "%s: User did not select clone options - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt)
                return

            # userRequestedNewName = myPopupAskForInput(toolbox_frame_,
            #                                           theTitle=_THIS_METHOD_NAME,
            #                                           theFieldLabel="CLONED DATASET NAME:",
            #                                           theFieldDescription="Enter a new name for the cloned dataset",
            #                                           defaultValue=newName)
            #
            # if userRequestedNewName is None or userRequestedNewName == "":
            #     txt = "No name entered for cloned dataset - no changes made"
            #     myPopupInformationBox(toolbox_frame_,txt)
            #     setDisplayStatus(txt, "R")
            #     return

            newName = AccountBook.stripNonFilenameSafeCharacters(user_cloneName.getText())
            newNamePath = os.path.join(os.path.dirname(currentFilePath),newName + Common.ACCOUNT_BOOK_EXTENSION)
            fNewNamePath = File(newNamePath)

            if newName is None or newName == "" or fNewNamePath.exists():
                myPopupInformationBox(toolbox_frame_, "ERROR: new cloned file name: '%s' invalid or already exists?" %(newName),theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                continue

            if not user_zeroAcctOpeningBalances.isSelected() and not user_purgeAllTransactions.isSelected() and not user_purgeSnapHistory.isSelected():
                myPopupInformationBox(toolbox_frame_, "ERROR: Nothing selected to remove whilst cloning (pointless!)?",theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                continue

            break

        if not doesUserAcceptDisclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Are you really sure you want to create a clone of current dataset?"):
            txt = "%s: User declined the disclaimer - no changes made...." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # lKeepBalances = True
        # keepTxnsAfterDate = None
        lZeroOpeningBalances = user_zeroAcctOpeningBalances.isSelected()
        lRemoveAllTxns = user_purgeAllTransactions.isSelected()
        lRemoveAllSnapHistory = user_purgeSnapHistory.isSelected()

        output += "CLONE PROCESSING OPTIONS:\n" \
                  " ------------------------\n"
        output += "Purge all transactions:                           %s\n" %(lRemoveAllTxns)
        output += "Zero all accounts' opening balances:              %s\n" %(lZeroOpeningBalances)
        output += "Purge all security price & currency rate history: %s\n" %(lRemoveAllSnapHistory)
        output += "\n"

        _msgPad = 100
        _msg = pad("Please wait:",_msgPad,padChar=".")
        diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
        diag.go()

        try:
            output += "Current dataset file path:    %s\n" %(fCurrentFilePath.getCanonicalPath())
            output += "New cloned dataset file path: %s\n" %(fNewNamePath.getCanonicalPath())

            tmpFile = File.createTempFile("toolbox_%s" %(System.currentTimeMillis()), ".moneydancearchive")
            tmpFile.deleteOnExit()

            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..

            output += "Saving current dataset back to disk (trunk)\n"
            currentBook.saveTrunkFile()    # Save dataset too before backup


            class MyFilenameFilter(FilenameFilter):
                def accept(self, thedirname, thefilename):

                    keepDirs = ["attach"]
                    ignoreFiles = ["processed.dct"]
                    ignoreExtns = [".txn", ".txn-tmp", ".mdtxn", ".mdtxnarchive"]

                    for keepDir in keepDirs:
                        if thedirname.getPath().endswith(keepDir):
                            return True

                    for ignoreExt in ignoreExtns:
                        if thefilename.endswith(ignoreExt): return False

                    for ignoreFile in ignoreFiles:
                        if thefilename == ignoreFile: return False
                    return True

            _msg = pad("Please wait: Creating a temporary backup",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)
            try:
                zipOut = ZipOutputStream(BufferedOutputStream(FileOutputStream(tmpFile), 65536))   # type: ZipOutputStream
                MDIOUtils.zipRecursively(zipOut, currentBook.getRootFolder(), MyFilenameFilter())
                zipOut.close()
                output += "Current dataset backed up to: %s (stripping out txn and archive files)\n" %(tmpFile)
            except:
                myPopupInformationBox(toolbox_frame_, "ERROR: could not create temporary backup (review console)",theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                output += dump_sys_error_to_md_console_and_errorlog(True)
                raise

            passphrase = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
            if passphrase and passphrase != "":
                output += "Your encryption passphrase: '%s' will be reused in the cloned dataset\n" %(passphrase)
            else:
                output += "No user encryption passphrase will be set in the clone\n"

            class MySecretKeyCallback(SecretKeyCallback):
                def __init__(self, passPhrase):
                    self.passPhrase = passPhrase

                def setVerifier(self, paramSecretKeyVerifier): pass

                def getPassphrase(self, hint):                                                                              # noqa
                    return self.passPhrase

                def getPassphrase(self, dataName, hint):                                                                    # noqa
                    return self.passPhrase

            passwordCallback = MySecretKeyCallback(passphrase)

            # try:
            class MyFilenameFilter(FilenameFilter):
                def accept(self, dirname, filename):                                                                    # noqa
                    if filename.endswith(Common.ACCOUNT_BOOK_EXTENSION):
                        return True
                    return False

            _msg = pad("Please wait: Restoring temporary backup to clone new dataset",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            tmpFolder = MDIOUtils.createTempFolder()
            output += "Created temporary folder (for restore): %s\n" %(tmpFolder)
            MDIOUtils.openZip(tmpFile, tmpFolder.getAbsolutePath())
            output += "Unzipped temporary backup into: %s\n" %(tmpFolder)
            zipContents = tmpFolder.list(MyFilenameFilter())
            if zipContents is None or len(zipContents) < 1: raise Exception("ERROR: Zip file seems incorrect")
            tmpMDFile = File(tmpFolder, zipContents[0])

            newBookFile = fNewNamePath
            if not tmpMDFile.renameTo(newBookFile):
                MDIOUtils.copyFolder(tmpMDFile, newBookFile)
                output += "Renamed restored dataset to: %s\n" %(newBookFile)

            newWrapper = AccountBookWrapper.wrapperForFolder(newBookFile)   # type: AccountBookWrapper
            if newWrapper is None: raise Exception("ERROR: 'AccountBookWrapper.wrapperForFolder' returned None")
            output += "Successfully obtained 'wrapper' for: %s\n" %(newBookFile)

            newWrapper.setUUIDResetFlag(True)

            _msg = pad("Please wait: Opening cloned dataset",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            try:
                if not newWrapper.loadLocalStorage(passwordCallback): raise Exception("ERROR: calling 'newWrapper.loadLocalStorage()'")
                output += "Successfully loaded Clone's local storage \n"

                if not newWrapper.loadDataModel(passwordCallback): raise Exception("ERROR: calling 'newWrapper.loadDataModel()'")
                output += "Successfully loaded Clone's data model \n"

                newBook = newWrapper.getBook()
                if newBook is None: raise Exception("ERROR: 'AccountBook' is None")
                output += "Successfully obtained Clone's AccountBook reference\n"

                newBookSyncer = newBook.getSyncer()
                if newBookSyncer is None: raise Exception("ERROR: cloned dataset's 'Syncer' is None")
                output += "Clone's 'Syncer' is running (%s)\n" %(newBookSyncer)

            except MDException as mde:
                if mde.getCode() == 1004:
                    MD_REF.getUI().showErrorMessage("ERROR: The dataset's password is incorrect!?  Failed to open clone?")
                    raise
                else:
                    dump_sys_error_to_md_console_and_errorlog()
                    raise

            cloneTime = System.currentTimeMillis()
            newRoot = newBook.getRootAccount()

            newRoot.setParameter(PARAMETER_KEY, safeStr(cloneTime))
            newRoot.setComment("This dataset was cloned by the Toolbox extension on: %s (%s)"
                               %(convertStrippedIntDateFormattedText(DateUtil.getStrippedDateInt()), cloneTime))
            if newRoot.getAccountName().strip() != newBook.getName():
                output += "Updating new root's account name to: '%s'\n" %(newBook.getName())
                newRoot.setAccountName(newBook.getName())
            newBook.logModifiedItem(newRoot)

            if not AccountBookUtil.isWithinInternalStorage(newBook):
                AccountBookUtil.registerExternalAccountBook(newBook)
                output += "Registered cloned dataset with the File/Open menu list\n"

            _msg = pad("Please wait: Resetting Sync in cloned dataset..",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            SYNC_KEYS = getNetSyncKeys()

            newStorage = newBook.getLocalStorage()
            for skey in SYNC_KEYS: newStorage.remove(skey)                                                              # noqa
            newStorage.put("netsync.dropbox.fileid", UUID.randomUUID())
            newStorage.put("_is_master_node", True)
            newStorage.put(PARAMETER_KEY, safeStr(cloneTime))
            newStorage.save()
            if newRoot is not None:
                newRoot.setEditingMode()
                for skey in SYNC_KEYS: newRoot.removeParameter(skey)
                newBook.logModifiedItem(newRoot)

            output += "Clone's Sync settings have been reset and the internal UUID set to: '%s'\n" %(newStorage.getStr("netsync.dropbox.fileid","<ERROR>"))

            output += "Imported and created clone book: %s\n" %(newBookFile.getCanonicalPath())
            # newBook.notifyAccountModified(newBook.getRootAccount())
            MD_REF.getUI().updateOpenFilesMenus()
            output += "Updated 'open files' menu...\n"

            if lZeroOpeningBalances:
                _msg = pad("Please wait: Zeroing account opening/initial balances..",_msgPad,padChar=".")
                diag.updateMessages(newTitle=_msg, newStatus=_msg)

                allAccounts = AccountUtil.allMatchesForSearch(newBook, AcctFilter.ALL_ACCOUNTS_FILTER)
                for acct in allAccounts:

                    lChangedBal = False
                    if not isKotlinCompiledBuild():     # Pre MD2023 there was only start balance (no adjustment balance)
                        xbal = acct.getStartBalance()
                        if xbal != 0:
                            rCurr = acct.getCurrencyType()
                            output += "Setting account's initial / opening balance to zero (was: %s): %s\n" %(rCurr.formatFancy(xbal, MD_decimal), acct)
                            acct.setStartBalance(0)
                            lChangedBal = True
                    else:
                        xbal = acct.getUnadjustedStartBalance()
                        if xbal != 0:
                            rCurr = acct.getCurrencyType()
                            output += "Setting account's unadjusted initial / opening balance to zero (was: %s): %s\n" %(rCurr.formatFancy(xbal, MD_decimal), acct)
                            acct.setStartBalance(0)
                            lChangedBal = True
                        xbal = acct.getBalanceAdjustment()
                        if xbal != 0:
                            rCurr = acct.getCurrencyType()
                            output += "Setting account's balance adjustment to zero (was: %s): %s\n" %(rCurr.formatFancy(xbal, MD_decimal), acct)
                            acct.setBalanceAdjustment(0)
                            lChangedBal = True

                    if lChangedBal:
                        SyncerDebug.changeState(debug)
                        newBook.logModifiedItem(acct)
                        SyncerDebug.resetState()
                        # acct.syncItem()

            # noinspection PyArgumentList
            class MyCloneTxnSearchFilter(TxnSearch):

                # def __init__(self,dateStart,dateEnd):
                #     self.dateStart = dateStart
                #     self.dateEnd = dateEnd

                def matchesAll(self):                                                                                           # noqa
                    return False

                def matches(self, _txn):
                    if not isinstance(_txn, ParentTxn): return False
                    return True
                    #
                    # if txn.getDateInt() >= self.dateStart and txn.getDateInt() <= self.dateEnd:                                 # noqa
                    #     return True
                    # return False


            if lRemoveAllTxns:
                newBook.setRecalcBalances(False)

                _msg = pad("Please wait: Deleting txns/attachments (as necessary)..",_msgPad,padChar=".")
                diag.updateMessages(newTitle=_msg, newStatus=_msg)

                startTimeMs = System.currentTimeMillis()
                attachmentsToDelete = []
                ts = newBook.getTransactionSet().getTransactions(MyCloneTxnSearchFilter())
                output += "Removing all (%s) transactions from clone...\n" %(ts.getSize())
                for txn in ts:
                    if not isinstance(txn, ParentTxn):
                        myPrint("B",txn.getSyncInfo().toMultilineHumanReadableString())
                        raise Exception("ERROR: Should not delete splits!")
                    if txn.hasAttachments():
                        for attachKey in txn.getAttachmentKeys():
                            attachTag = txn.getAttachmentTag(attachKey)
                            attachmentsToDelete.append(attachTag)
                tsList = ArrayList()
                ts.copyInto(tsList)

                SyncerDebug.changeState(debug)
                if not newBook.logRemovedItems(tsList): raise Exception("ERROR: newBook.logRemovedItems(tsList) returned false?")
                SyncerDebug.resetState()

                if len(attachmentsToDelete):
                    output += "Deleting %s attachments from clone...\n" %(len(attachmentsToDelete))
                    for attachment in attachmentsToDelete:
                        fAttachFile = File(attachment)
                        if fAttachFile.exists():
                            fAttachFile.delete()

                    if removeEmptyDirs(os.path.join(newBook.getRootFolder().getCanonicalPath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME)):
                        output += "Successfully removed empty attachment folders...\n"
                    else:
                        output += "Error whilst removing empty attachment folders... (ignoring and continuing)\n"

                output += "Mass delete of %s txns and %s attachments took: %s seconds\n" %(ts.getSize(), len(attachmentsToDelete), (System.currentTimeMillis() - startTimeMs) / 1000.0)

            if lRemoveAllSnapHistory:
                startTimeMs = System.currentTimeMillis()

                _msg = pad("Please wait: Purging security price / currency rate history..",_msgPad,padChar=".")
                diag.updateMessages(newTitle=_msg, newStatus=_msg)

                keepSnaps = []

                allCurrencies = newBook.getCurrencies().getAllCurrencies()
                allSnaps = newBook.getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE)

                iCountSecurities = iCountCurrencies = 0

                for curSec in allCurrencies:
                    if curSec.getCurrencyType() == CurrencyType.Type.SECURITY: iCountSecurities += 1                    # noqa
                    if curSec.getCurrencyType() == CurrencyType.Type.CURRENCY: iCountCurrencies += 1                    # noqa
                    secSnapshots = curSec.getSnapshots()
                    if len(secSnapshots) > 0: keepSnaps.append(secSnapshots[-1])

                output += "Currency rate / Security price history ('csnaps') before purge: %s (%s currencies, %s securities)\n"\
                          %(allSnaps.size(), iCountCurrencies, iCountSecurities)

                for snap in keepSnaps: allSnaps.remove(snap)

                output += "Price history - keeping: %s 'csnaps', deleting: %s 'csnaps'\n" %(len(keepSnaps), allSnaps.size())

                SyncerDebug.changeState(debug)
                if not newBook.logRemovedItems(allSnaps): raise Exception("ERROR: newBook.logRemovedItems(allSnaps) returned false?")
                SyncerDebug.resetState()

                output += "Mass delete of %s currency rate / security price history 'csnaps' took: %s seconds\n"\
                          %(allSnaps.size(), (System.currentTimeMillis() - startTimeMs) / 1000.0)

            newBook.setRecalcBalances(True)

            if not newBook.save(): raise Exception("ERROR: cloned AccountBook .save() returned false")

            # myPrint("B", "Syncer: %s, isSyncing: %s, isRunningInBackground: %s" %(newBookSyncer, newBookSyncer.isSyncing(), newBookSyncer.isRunningInBackground()))
            newBookSyncer.stopSyncing()
            output += "Cloned dataset's 'Syncer' has been shut down (flushing remaining in-memory changes)\n"

            # register attachment for deletion etc
            # delete all txn files afterwards

            # newBook.saveTrunkFile()
            newBookSyncer.saveNewTrunkFile(True)
            output += "Cloned dataset has been re-saved to disk (as a new trunk file)\n"

            # Copied from com.infinitekind.tiksync.Syncer
            OUTGOING_PATH = "tiksync/out"
            INCOMING_PATH = "tiksync/in"
            TXN_FILE_EXTENSION = ".txn"
            TXN_FILE_EXTENSION_TMP = ".txn-tmp"
            OUTGOING_TXN_FILE_EXTENSION = ".mdtxn"
            PROCESSED_FILES = "tiksync/processed.dct"
            newStorage.delete(PROCESSED_FILES)
            for mdDir in [OUTGOING_PATH, INCOMING_PATH]:
                for filename in newStorage.listFiles(mdDir):
                    if (filename.endswith(TXN_FILE_EXTENSION_TMP)
                            or filename.endswith(OUTGOING_TXN_FILE_EXTENSION)
                            or filename.endswith(TXN_FILE_EXTENSION)):
                        newStorage.delete(mdDir + "/" + filename)
            output += "Deleted clone's 'processed.dct' and all .txn type files.....\n"

            output += "\n\n" \
                      " ------------------------------------------------------------------------------------------------\n"
            output += "Original dataset's object analysis:\n"
            output += count_database_objects()
            fileSize, fileCount = calculateMoneydanceDatasetSize(True)
            output += "...dataset size: %sMB (%s files)\n" %(rpad(fileSize,12),fileCount)
            output += "\n"

            output += "Analysis of objects in cloned dataset:\n"
            output += count_database_objects(newBook)
            fileSize, fileCount = calculateMoneydanceDatasetSize(True, whichBook=newBook)
            output += "...dataset size: %sMB (%s files)\n" %(rpad(fileSize,12),fileCount)
            output += " ------------------------------------------------------------------------------------------------\n"
            output += "\n"

            txt = "DATASET '%s' WAS CREATED FROM A CLONE OF '%s'" %(newBook.getName(), currentFilePath)
            myPrint("B", txt)
            logToolboxUpdates("advanced_clone_dataset", txt, book=newBook)

        except:
            txt = "Clone function has failed. Review log and console (CLONE INCOMPLETE)"
            myPrint("B", txt)
            output += "%s\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            jif = QuickJFrame(title=_THIS_METHOD_NAME, output=output, lAlertLevel=2, copyToClipboard=True, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,theMessage=txt, theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
            return
        finally:
            diag.kill()

        output += "\n\nCLONE %s SUCCESSFULLY CREATED - USE MENU>FILE>OPEN\n\n" %(newBook.getName())
        output += "<END>"
        jif = QuickJFrame(title=_THIS_METHOD_NAME,output=output,copyToClipboard=True,lWrapText=False).show_the_frame()
        myPopupInformationBox(jif,"Clone dataset: %s created (review output)" %(newBook.getName()))

    def advanced_options_sync_push_pull(_push_pull):
        _THIS_METHOD_NAME = "FORCE SYNC PUSH/PULL"

        PUSH_RESYNC = "tiksync/force_push_resync"                                                                       # noqa
        PULL_RESYNC = "tiksync/force_pull_resync"                                                                       # noqa

        lSyncPush = lSyncPull = False
        if _push_pull.upper() == "PUSH": lSyncPush = True
        if _push_pull.upper() == "PULL": lSyncPull = True
        if not lSyncPush and not lSyncPull: raise Exception("%s: Invalid parameter supplied" %(_THIS_METHOD_NAME))

        if lSyncPull: raise Exception("%s: Sorry - PULL function is disabled" %(_THIS_METHOD_NAME))

        if lSyncPull: _THIS_METHOD_NAME = "FORCE SYNC PULL"
        if lSyncPush: _THIS_METHOD_NAME = "FORCE SYNC PUSH"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()                                                      # noqa

        if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = "%s: Sorry - can only push from a Primary Sync Dataset...(Toolbox can promote to Primary if required)" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)

        syncFolder = None                                                                                               # noqa
        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
        except:
            syncFolder = False                                                                                          # noqa
            dump_sys_error_to_md_console_and_errorlog()
            txt = "Sorry - cannot proceed as error getting Sync status (review console for details)"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if syncFolder is None:
            txt = "%s: Cannot proceed as you don't appear to be using Sync" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        txt = None
        if lSyncPull:
            txt = "THIS WILL FORCE SYNC TO PULL REMOTE DATASET, OVERWRITING YOUR LOCAL COPY"
            myPopupInformationBox(toolbox_frame_, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            txt = "%s: Execute Sync Force Pull (of remote Sync Data, overwrite local data)?" %(_THIS_METHOD_NAME)
        if lSyncPush:
            txt = "THIS WILL FORCE SYNC TO PUSH LOCAL DATASET, OVERWRITING REMOTE COPIES"
            myPopupInformationBox(toolbox_frame_, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            txt = "%s: Execute Sync Force Push (of local Sync Data to remotes)?" %(_THIS_METHOD_NAME)

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME,txt): return

        myPrint("B", "User accepted disclaimer - now executing: %s" %(txt))
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..

        SyncerDebug.changeState(debug)

        if lSyncPush:
            MD_REF.getCurrentAccountBook().getSyncer().forceResyncFromLocal()
            myPrint("B", "@@ Called .getSyncer().forceResyncFromLocal() to Force Push (Re)Sync to remotes...")
            # storage.writeToFileAtomically(PyByteArray(), PUSH_RESYNC)
            # myPrint("B", "@@ Created: %s" %(PUSH_RESYNC))

        if lSyncPull:
            MD_REF.getUI().getCurrentAccounts().setNeedsResetFromSyncFolder()
            myPrint("B", "@@ Called .getCurrentAccounts().setNeedsResetFromSyncFolder() to Force Pull (Re)Sync from remotes...")

            # MD_REF.getCurrentAccountBook().getSyncer().resetSyncingAndWaitForRemoteData()
            # myPrint("B", "@@ Called .getSyncer().resetSyncingAndWaitForRemoteData() to Force Pull (Re)Sync from remotes...")

            # storage.writeToFileAtomically(PyByteArray(), PULL_RESYNC)
            # myPrint("B", "@@ Created: %s" %(PULL_RESYNC))

        SyncerDebug.resetState()
        MD_REF.saveCurrentAccount()

        txt = "%s: Force Sync Push/Pull requested." %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")
        logToolboxUpdates("advanced_options_sync_push_pull", txt)

        ConsoleWindow.showConsoleWindow(MD_REF.getUI())

        play_the_money_sound()
        MyPopUpDialogBox(toolbox_frame_,
                         "%s" %(txt),
                         "Check the Help>Console Window...\n"
                         "Wait (up to) a few minutes and look for the following entries in the console log....:\n"
                         "...'Toolbox.... @@ Called .getSyncer().forceResyncFromLocal() to Force Push (Re)Sync to remotes...'\n"
                         "...'uploading new trunk file v3/trunk-nnnnnnnnnnnn.mdtxn to syncFolder'\n"
                         "...'deleting stale sync log file: v3/nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.mdtxn'\n"
                         "(the above line may repeat several times)...\n"
                         "... and then 'checking for txn logs...'....\n"
                         "When it's finished, hopefully with no errors, then RESTART MD. <GOOD LUCK!>",
                         theTitle=_THIS_METHOD_NAME,
                         lModal=True,OKButtonText="ACKNOWLEDGE").go()

    # def advanced_options_set_check_days():
    #     key = "moneydance.checknum_series_threshold"
    #     props_lookback_days = System.getProperty(key, "180")
    #
    #     ask = MyPopUpDialogBox(toolbox_frame_, "Next Check Number Algorithm look-back Threshold:",
    #                            'System.getProperty("%s") currently set to: %s\n'%(key,props_lookback_days),
    #                            theTitle="NEXT CHEQUE NUMBER ALGORITHM",
    #                            lCancelButton=True,OKButtonText="CHANGE")
    #     if not ask.go():
    #         txt = "NO CHANGES MADE TO NEXT CHECK NUMBER LOOK-BACK THRESHOLD"
    #         setDisplayStatus(txt, "B")
    #         return
    #
    #     lDidIChangeDays=False
    #
    #     while True:
    #         days_response = myPopupAskForInput(toolbox_frame_,"CHANGE NEXT CHECK NUMBER LOOK-BACK THRESHOLD","Days:",
    #                                            "Enter new number of days (1 to 365):",props_lookback_days)
    #
    #         if days_response is None:
    #             days_response = 0
    #             break
    #         elif days_response == props_lookback_days:
    #             break
    #         elif not StringUtils.isInteger(days_response):
    #             continue
    #         elif int(days_response)>0 and int(days_response)<365:                                                       # noqa
    #             lDidIChangeDays = True
    #             break
    #
    #     if lDidIChangeDays:
    #         System.setProperty(key,str(days_response))
    #         myPrint("B","System Property '%s' set to %s" %(key,days_response))
    #     else:
    #         txt = "NO CHANGES MADE TO NEXT CHECK NUMBER LOOK-BACK THRESHOLD"
    #         setDisplayStatus(txt, "B")
    #         return
    #
    #     txt = "Next Check Number Algorithm look-back Threshold set to %s (days)" %(days_response)
    #     setDisplayStatus(txt, "B")
    #     logToolboxUpdates("advanced_options_set_check_days", txt)
    #     myPopupInformationBox(toolbox_frame_,txt,"NEXT CHEQUE NUMBER ALGORITHM", JOptionPane.WARNING_MESSAGE)

    def advanced_options_edit_parameter_keys():
        if MD_REF.getCurrentAccountBook() is None: return

        if not myPopupAskQuestion(toolbox_frame_,"EDIT OBJs MODE","DANGER - ARE YOU SURE YOU WANT TO VISIT THIS FUNCTION?", theMessageType=JOptionPane.ERROR_MESSAGE):
            txt = "Edit Obj Mode - User declined to proceed - aborting.."
            setDisplayStatus(txt, "R")
            return

        objSelecter = CuriousViewInternalSettingsButtonAction(lOFX=False, EDIT_MODE=True)
        theObject = objSelecter.actionPerformed("")  # type: list
        del objSelecter

        if theObject is None or len(theObject)!= 1:
            # txt = "ADVANCED Edit Obj Mode - No Object selected/found - aborting.."
            # setDisplayStatus(txt, "R")
            return

        theObject = theObject[0]            # type: MoneydanceSyncableItem

        _ADVANCED_KEYADD          = 0
        _ADVANCED_KEYCHG          = 1
        _ADVANCED_KEYDEL          = 2
        _ADVANCED_RECORDDELETE    = 3

        what = [
            "Object ADD    Parameter Key (and data)",
            "Object CHANGE Parameter Key's Data",
            "Object DELETE Parameter Key (and it's data)",
            "DELETE OBJECT - NOT RECOMMENDED!"
        ]

        while True:

            lAdd = lChg = lDel = lDeleteRecord = False

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the option for the modification (on %s)?" %(theObject),
                                                       "ADVANCED",
                                                       JOptionPane.WARNING_MESSAGE,
                                                       getMDIcon(None),
                                                       what,
                                                       None)

            if not selectedWhat:
                txt = "ADVANCED - Exiting"
                setDisplayStatus(txt, "B")
                return

            if selectedWhat == what[_ADVANCED_KEYADD]:          lAdd = True
            if selectedWhat == what[_ADVANCED_KEYCHG]:          lChg = True
            if selectedWhat == what[_ADVANCED_KEYDEL]:          lDel = True
            if selectedWhat == what[_ADVANCED_RECORDDELETE]:    lDeleteRecord = True

            text = ""
            if lChg:            text = "ADD"
            if lChg:            text = "CHANGE"
            if lDel:            text = "DELETE"
            if lDeleteRecord:   text = "DELETE OBJECT"

            if lAdd:
                addKey = myPopupAskForInput(toolbox_frame_,
                                            "ADD PARAMETER TO %s" % (theObject),
                                            "PARAMETER:",
                                            "Carefully enter the name of the Parameter you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                            "",
                                            False,
                                            JOptionPane.WARNING_MESSAGE)

                if not addKey or len(addKey.strip()) < 1: continue
                addKey = addKey.strip()

                if not check_if_key_string_valid(addKey):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter %s is NOT valid!" % addKey, "ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED Options menu

                testKeyExists = theObject.getParameter(addKey,None)                                                     # noqa

                if testKeyExists:
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter %s already exists - cannot add - aborting..!" %(addKey), "ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED Options menu

                addValue = myPopupAskForInput(toolbox_frame_,
                                              "ADD PARAMETER VALUE TO %s" %(theObject),
                                              "VALUE:",
                                              "Carefully enter the value you want to add (STRINGS ONLY! CaSE MattERS):",
                                              "",
                                              False,
                                              JOptionPane.WARNING_MESSAGE)

                if not addValue or len(addValue.strip()) <1: continue
                addValue = addValue.strip()

                if not check_if_key_data_string_valid(addValue):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter value %s is NOT valid!" %(addValue), "ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED Options menu

                if confirm_backup_confirm_disclaimer(toolbox_frame_, "ADVANCED OPTIONS", "ADD PARAMETER VALUE TO %s" %(theObject)):

                    theObject.setParameter(addKey,addValue)                                                             # noqa
                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.syncItem()                                                                            # noqa
                    txt = "Parameter: %s Value: %s added to %s @@" %(addKey,addValue,theObject)
                    setDisplayStatus(txt, "R"); myPrint("B", txt)
                    logToolboxUpdates("advanced_options_edit_parameter_keys", txt)
                    play_the_money_sound()
                    myPopupInformationBox(toolbox_frame_,
                                          "SUCCESS: Key %s added to %s!" % (addKey,theObject),
                                          "ADD TO %s" %(theObject),
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                continue

            # DELETE OBJECT  :-<
            if lDeleteRecord:

                output =  "%s PLEASE REVIEW PARAMETER & VALUE BEFORE DELETING OBJECT\n" %(theObject)
                output += " --------------------------------------------------------\n\n"

                if isinstance(theObject, SplitTxn):
                    txt = theObject.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                else:
                    txt = theObject.getSyncInfo().toMultilineHumanReadableString()

                output += "\n%s\n" %(txt)

                output += "\n<END>"
                if isinstance(theObject, SplitTxn):
                    jif = QuickJFrame("REVIEW THE SPLIT TXN's DATA BEFORE DELETION (OF THE SPLIT)", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
                elif isinstance(theObject, ParentTxn):
                    jif = QuickJFrame("REVIEW THE PARENT'S TXN DATA BEFORE DELETION (OF THE WHOLE PARENT TXN)", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()
                else:
                    jif = QuickJFrame("REVIEW THE OBJECT's DATA BEFORE DELETION", output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

                if confirm_backup_confirm_disclaimer(jif, "DELETE OBJECT", "DELETE OBJECT %s" %(theObject)):

                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        # This will delete the split only; thus we also must sync the parent
                        theObject.deleteItem()                                                                          # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.deleteItem()                                                                          # noqa

                    txt = "ADVANCED OPTIONS: OBJECT %s DELETED @@" %(theObject)
                    setDisplayStatus(txt, "R"); myPrint("B", txt)
                    logToolboxUpdates("advanced_options_edit_parameter_keys", txt)

                    play_the_money_sound()
                    myPopupInformationBox(jif,
                                          "SUCCESS: OBJECT %s DELETED" %(theObject),
                                          "DELETE OBJECT",
                                          JOptionPane.ERROR_MESSAGE)
                    return

                continue

            # OK, so we are changing or deleting
            if lChg or lDel:

                paramKeys = sorted(theObject.getParameterKeys())                                                        # noqa
                selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                          "Select the %s Parameter you want to %s" % (theObject,text),
                                                          "ADVANCED OPTIONS",
                                                          JOptionPane.WARNING_MESSAGE,
                                                          getMDIcon(None),
                                                          paramKeys,
                                                          None)
                if not selectedKey: continue

                value = theObject.getParameter(selectedKey, None)                                                       # noqa

                output =  "%s PLEASE REVIEW PARAMETER & VALUE BEFORE MAKING CHANGES\n" %(theObject)
                output += " -----------------------------------------------\n\n"

                output += "\n@@ This '%s' key can be changed/deleted by this script @@\n" %(selectedKey)

                output += "\n%s %s\n" %(pad("%s PARAMETER:"%(theObject), 25), selectedKey)
                output += "\n%s %s\n" %(pad("Type:",25), type(value))
                output += "\n%s %s\n" %(pad("Value:",25), value)

                output += "\n<END>"
                jif = QuickJFrame("REVIEW THE KEY BEFORE CHANGES to %s" %(theObject), output, lAutoSize=True, lWrapText=False, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

                chgValue = None

                if lChg:
                    chgValue = myPopupAskForInput(jif,
                                                  "CHANGE PARAMETER VALUE IN %s" %(theObject),
                                                  "VALUE:",
                                                  "Carefully enter the new value (STRINGS ONLY! CaSE MattERS):",
                                                  value,
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                    chgValue = chgValue.strip()

                    if not check_if_key_data_string_valid(chgValue):
                        myPopupInformationBox(jif,"ERROR: value %s is NOT valid!" %chgValue,"CHANGE IN %s" %(theObject),JOptionPane.ERROR_MESSAGE)
                        continue    # back to ADVANCED Options menu

                confAction = ""
                if lDel:
                    if isinstance(value, basestring) and value.count('\n') > 10:
                        confAction = "%s key: %s (old value to long to display)" %(text, selectedKey)
                    else:
                        confAction = "%s key: %s (with old value: %s)" %(text, selectedKey, value)
                if lChg:
                    confAction = "%s key: %s to new value: %s" %(text, selectedKey, chgValue)

                if confirm_backup_confirm_disclaimer(jif, "%s VALUE IN %s" %(text, theObject), confAction):

                    if lDel:
                        theObject.setParameter(selectedKey,None)                                                        # noqa

                    if lChg:
                        theObject.setParameter(selectedKey,chgValue)                                                    # noqa

                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.syncItem()                                                                            # noqa

                    MD_REF.savePreferences()            # Flush all in memory settings to config.dict file on disk
                    play_the_money_sound()

                    if lDel:
                        if isinstance(value, basestring) and value.count('\n') > 10:
                            txt = "Parameter: %s DELETED from %s (old value to long to display) @@" %(selectedKey, theObject)
                            _msgTxt = "SUCCESS: Parameter: %s DELETED from %s (old value to long to display)" %(selectedKey, theObject)
                        else:
                            txt = "Parameter: %s DELETED from %s (old value: %s) @@" %(selectedKey, theObject, value)
                            _msgTxt = "SUCCESS: Parameter: %s DELETED from %s (old value: %s)" %(selectedKey, theObject, value)
                        myPrint("B", txt)
                        logToolboxUpdates("advanced_options_edit_parameter_keys", txt)

                        myPopupInformationBox(jif, _msgTxt, "DELETE IN %s" %(theObject), JOptionPane.WARNING_MESSAGE)

                    if lChg:
                        txt = "Parameter: %s CHANGED to %s in %s @@" %(selectedKey, chgValue, theObject)
                        myPrint("B", txt)
                        logToolboxUpdates("advanced_options_edit_parameter_keys", txt)
                        myPopupInformationBox(jif,
                                              "SUCCESS: Parameter: %s CHANGED to %s in %s" %(selectedKey, chgValue, theObject),
                                              "CHANGE IN %s" %(theObject),
                                              JOptionPane.WARNING_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                jif.dispose()       # already within the EDT
                continue

    def remove_int_external_files_settings():
        if MD_REF.getCurrentAccountBook() is None: return

        options = ["Remove 'External' entries from File>Open menu [and optionally DELETE dataset from disk too]",
                   "DELETE 'Internal' / Default location dataset(s) from Disk (which will also remove entry from File>Open)"]

        selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                     "Select the option you require",
                                                     "DELETE INT/EXT DATASET",
                                                     JOptionPane.WARNING_MESSAGE,
                                                     getMDIcon(lAlwaysGetIcon=True),
                                                     options,
                                                     None)

        if not selectedOption or options.index(selectedOption) > 1:
            txt = "No option selected.. No changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        theText = ""
        lInternal = lExternal = False
        if options.index(selectedOption) == 0:
            lExternal = True
            theText = ( "This allows you to REMOVE references to Datasets stored in the non-default 'External' locations\n"
                        "This removes the entries from the MD File>Open Menu.\n"
                        "Missing dataset references will be auto-purged from the list before you start selection\n"
                        "You will be offered each Dataset name one-by-one\n"
                        "You will NOT be offered, or allowed, to delete the current open dataset\n"
                        "OPTIONALLY - You can choose to also DELETE these dataset(s) FROM DISK (after your confirmation)\n"
                        "There will not be any backup prompt - please do this yourself first!\n\n"
                        "THIS IS THE DISCLAIMER UP FRONT - CLICK I AGREE TO PROCEED" )

        elif options.index(selectedOption) == 1:
            lInternal = True
            theText = ( "This allows you to DELETE Datasets from the MD default 'Internal' location\n"
                        "You will be offered each Dataset name one-by-one\n"
                        "You will NOT be offered, or allowed, to delete the current open dataset\n"
                        "Each dataset you select will be DELETED FROM DISK (after your confirmation)\n"
                        "(This will therefore remove the entry from the MD File>Open Menu)\n"
                        "There will not be any backup prompt - please do this yourself first!\n\n"
                        "THIS IS THE DISCLAIMER UP FRONT - CLICK I AGREE TO PROCEED" )

        ask = MyPopUpDialogBox(toolbox_frame_,
                             "For Your Information",
                             theText,
                             theTitle="REMOVE ENTRIES/DATASETS",
                             OKButtonText="I AGREE - PROCEED", lCancelButton=True,
                             lAlertLevel=2)
        if not ask.go():
            txt = "No agreement to proceed.. No changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if lInternal:
            removeInternalFilesSettings()

        elif lExternal:
            removeExternalFilesSettings()

        MD_REF.getUI().updateOpenFilesMenus()

    def advanced_options_edit_prefs():
        if MD_REF.getCurrentAccountBook() is None: return

        _ADVANCED_CONFIGADD          = 0
        _ADVANCED_CONFIGCHG          = 1
        _ADVANCED_CONFIGDEL          = 2
        _ADVANCED_LOCALSTORAGEADD    = 3
        _ADVANCED_LOCALSTORAGECHG    = 4
        _ADVANCED_LOCALSTORAGEDEL    = 5

        what = [
            "config.dict ADD setting",
            "config.dict CHANGE setting",
            "config.dict DELETE setting",
            "Local Storage Setting ADD setting",
            "Local Storage Setting CHANGE setting",
            "Local Storage Setting DELETE setting"
        ]

        while True:

            lAdd = lChg = lDel = False
            lConfigDict = lLocalStorage = False

            # noinspection PyUnusedLocal
            LS = st = tk = prefs = fileType = None

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Key data / option to modify",
                                                       "ADVANCED",
                                                       JOptionPane.WARNING_MESSAGE,
                                                       getMDIcon(None),
                                                       what,
                                                       None)

            if not selectedWhat:
                txt = "Thank you for using ADVANCED OPTIONS!.."
                setDisplayStatus(txt, "B")
                return

            if selectedWhat == what[_ADVANCED_CONFIGADD]: lAdd = True
            if selectedWhat == what[_ADVANCED_CONFIGCHG]: lChg = True
            if selectedWhat == what[_ADVANCED_CONFIGDEL]: lDel = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEADD]: lAdd = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGECHG]: lChg = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEDEL]: lDel = True

            if selectedWhat == what[_ADVANCED_CONFIGADD]: lConfigDict = True
            if selectedWhat == what[_ADVANCED_CONFIGCHG]: lConfigDict = True
            if selectedWhat == what[_ADVANCED_CONFIGDEL]: lConfigDict = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEADD]: lLocalStorage = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGECHG]: lLocalStorage = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEDEL]: lLocalStorage = True

            LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

            if lConfigDict:
                fileType = "config.dict"
                st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
                prefs = sorted(tk)
            elif lLocalStorage:
                fileType = "LocalStorage() ./safe/settings"
                ls_keys = LS.keys()
                prefs = sorted(ls_keys)
            else:
                raise(Exception("ERROR - Unknown type!"))

            text = ""
            if lChg: text = "CHANGE"
            if lDel: text = "DELETE"

            if lAdd:
                addKey = myPopupAskForInput(toolbox_frame_,
                                            "ADD KEY TO %s" % fileType,
                                            "KEY NAME:",
                                            "Carefully enter the name of the key you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                            "",
                                            False,
                                            JOptionPane.WARNING_MESSAGE)

                if not addKey or len(addKey.strip()) < 1: continue
                addKey = addKey.strip()

                if not check_if_key_string_valid(addKey):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key %s is NOT valid!" % addKey, "ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED Options menu

                testKeyExists = True
                if lConfigDict:     testKeyExists = MD_REF.getUI().getPreferences().getSetting(addKey,None)
                if lLocalStorage:   testKeyExists = LS.get(addKey)

                if testKeyExists:
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key %s already exists - cannot add - aborting..!" % addKey, "ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED Options menu

                addValue = myPopupAskForInput(toolbox_frame_,
                                              "ADD KEY VALUE TO %s" % fileType,
                                              "KEY VALUE:",
                                              "Carefully enter the key value you want to add (STRINGS ONLY!):",
                                              "",
                                              False,
                                              JOptionPane.WARNING_MESSAGE)

                if not addValue or len(addValue.strip()) <1: continue
                addValue = addValue.strip()

                if not check_if_key_data_string_valid(addValue):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key value %s is NOT valid!" % addValue, "ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED Options menu

                if doesUserAcceptDisclaimer(toolbox_frame_, "ADD KEY VALUE TO %s" %(fileType), "Add key: '%s' with value: '%s'?" %(addKey,addValue)):
                    if lConfigDict:
                        MD_REF.getUI().getPreferences().setSetting(addKey,addValue)
                        MD_REF.savePreferences()                # Flush all in memory settings to config.dict file on disk
                    if lLocalStorage:
                        LS.put(addKey,addValue)
                        LS.save()    # Flush local storage to safe/settings

                    txt = "key: %s value: %s added to %s @@" %(addKey, addValue, fileType)
                    myPrint("B", txt)
                    logToolboxUpdates("advanced_options_edit_prefs", txt, onlyLogGenericEntry=lConfigDict)
                    play_the_money_sound()
                    myPopupInformationBox(toolbox_frame_,
                                          "SUCCESS: Key %s added to %s!" % (addKey, fileType),
                                          "ADD TO %s" %(fileType),
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                myPopupInformationBox(toolbox_frame_, "NO CHANGES MADE!", "ADVANCED", JOptionPane.INFORMATION_MESSAGE)
                continue

            # OK, so we are changing or deleting
            if lChg or lDel:
                selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                          "Select the %s key/setting you want to %s" % (fileType,text),
                                                          "ADVANCED",
                                                          JOptionPane.WARNING_MESSAGE,
                                                          getMDIcon(None),
                                                          prefs,
                                                          None)
                if not selectedKey: continue

                lOK_to_Change = False
                value = None
                if lConfigDict:
                    # value = MD_REF.getUI().getPreferences().getSetting(selectedKey)
                    value = st.get(selectedKey)   # Have to use the backdoor to maintain the real instance type

                if lLocalStorage:
                    value = LS.get(selectedKey)
                    valueTest = LS.getString(selectedKey, "")

                    try:
                        # Is it a StreamTable?
                        valueTest_st = StreamTable()
                        valueTest_st.readFrom(valueTest)
                        value = valueTest_st
                    except:
                        # Is it a StreamVector?
                        valueTest_sv = StreamVector()
                        try:
                            valueTest_sv.readFrom(valueTest)
                            value = valueTest_sv
                        except:
                            pass

                output =  "%s PLEASE REVIEW KEY & VALUE BEFORE MAKING CHANGES\n" %(fileType)
                output += "%s------------------------------------------------\n\n" %("-" * len(fileType))

                if isinstance(value,(StreamTable,StreamVector)) and lChg:
                    output += "\n@@ Sorry: StreamTable & StreamVector keys cannot be changed by this script (only deleted) @@\n"
                elif not isinstance(value, (str, unicode)) and lChg:
                    output += "\n@@ Sorry: %s keys cannot be changed by this script (only deleted) @@\n" % type(value)
                else:
                    lOK_to_Change = True
                    output += "\n@@ This '%s' key can be changed/deleted by this script @@\n" % selectedKey

                output += "\n%s %s\n" %(pad("%s KEY:" %(fileType), 25), selectedKey)
                output += "\n%s %s\n" %(pad("Type:", 25), type(value))

                if isinstance(value,(StreamTable,StreamVector)):
                    try:
                        output += "\n%s\n%s\n" %("Value:", value)
                    except IllegalArgumentException:
                        value = "<ERROR: Failed to show contents>"
                        output += "\n%s... (you can proceed anyway)\n" %(value)
                else:
                    output += "\n%s %s\n" %(pad("Value:",25), value)

                output += "\n<END>"
                jif = QuickJFrame("REVIEW THE KEY BEFORE CHANGES to %s" %(fileType), output, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB).show_the_frame()

                if lChg and not lOK_to_Change:
                    myPopupInformationBox(jif,
                                          "SORRY: I cannot change the key %s in %s" %(selectedKey, fileType),
                                          "CHANGE KEY IN %s" %(fileType),
                                          JOptionPane.ERROR_MESSAGE)
                    continue

                chgValue = None

                if lChg:
                    chgValue = myPopupAskForInput(jif,
                                                  "CHANGE KEY VALUE IN %s" %(fileType),
                                                  "KEY VALUE:",
                                                  "Carefully enter the new key value (STRINGS ONLY!):",
                                                  value,
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not chgValue or len(chgValue.strip()) < 1 or chgValue == value: continue
                    chgValue = chgValue.strip()

                    if not check_if_key_data_string_valid(chgValue):
                        myPopupInformationBox(jif,"ERROR: Key value %s is NOT valid!" %chgValue,"CHANGE IN %s" %fileType,JOptionPane.ERROR_MESSAGE)
                        continue    # back to ADVANCED Options menu

                agreed = False
                if lDel: agreed = doesUserAcceptDisclaimer(jif, "%s KEY VALUE IN %s" %(text,fileType), "%s key: %s (with old value: %s)?" %(text, selectedKey, value))
                if lChg: agreed = doesUserAcceptDisclaimer(jif, "%s KEY VALUE IN %s" %(text,fileType), "%s key: %s to new value: %s?" %(text, selectedKey, chgValue))
                if agreed:
                    if lConfigDict:
                        if lDel:
                            MD_REF.getUI().getPreferences().setSetting(selectedKey, None)
                        if lChg:
                            MD_REF.getUI().getPreferences().setSetting(selectedKey, chgValue)
                        MD_REF.savePreferences()            # Flush all in memory settings to config.dict file on disk
                    if lLocalStorage:
                        if lDel:
                            LS.put(selectedKey, None)
                        if lChg:
                            LS.put(selectedKey, chgValue)
                        LS.save()                               # Flush local storage to safe/settings

                    play_the_money_sound()

                    if lDel:
                        txt = "key: %s DELETED from %s (old value: %s) @@" %(selectedKey, fileType, value)
                        myPrint("B", txt)
                        logToolboxUpdates("advanced_options_edit_prefs", txt)
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s DELETED from %s (old value: %s)" %(selectedKey,fileType,value),
                                              "DELETE IN %s" %fileType,
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        txt = "key: %s CHANGED to %s in %s @@" %(selectedKey, chgValue, fileType)
                        myPrint("B", txt)
                        logToolboxUpdates("advanced_options_edit_prefs", txt)
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s CHANGED to %s in %s" %(selectedKey,chgValue, fileType),
                                              "CHANGE IN %s" %fileType,
                                              JOptionPane.WARNING_MESSAGE)
                    continue

                myPopupInformationBox(jif,"NO CHANGES MADE!", "ADVANCED", JOptionPane.INFORMATION_MESSAGE)
                continue

    def getModifiedDatesFomZip(_storage, _archiveFile):
        """Interrogates a zip archive, then processes all entries, and determines the oldest and newest modified dates"""

        zip_in = ZipInputStream(convertBufferedSourceToInputStream(_storage.openFileForReading(_archiveFile)))  # type: ZipInputStream
        oldestMInt = newestMInt = 0
        try:
            while True:
                entry = zip_in.getNextEntry()       # type: ZipEntry
                if entry is None: break
                if not entry.isDirectory():
                    name = entry.getName()                                                                              # noqa
                    modifiedDate = entry.getTime()
                    if modifiedDate > 0:
                        modifiedDateInt = DateUtil.convertLongDateToInt(modifiedDate)
                        oldestMInt = (modifiedDateInt if oldestMInt < 1 else min(oldestMInt, modifiedDateInt))
                        newestMInt = (modifiedDateInt if newestMInt < 1 else max(newestMInt, modifiedDateInt))
                zip_in.closeEntry()
        except: pass

        finally:
            try: zip_in.closeEntry()
            except: pass

            try: zip_in.close()
            except: pass

        return (oldestMInt, newestMInt)

    def advanced_options_shrink_dataset():
        """Attempts to reduce dataset size by 'purging' txn log files - relies on processed.dct as failsafe for dates"""

        SIMULATE = False
        _THIS_METHOD_NAME = "ADVANCED: SHRINK DATASET SIZE"

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, " "*len(_THIS_METHOD_NAME))

        if SIMULATE: output += "*** SIMULATION MODE *** No changes really being made!!\n"*3; output += "\n"

        DAYS_TO_KEEP = 30

        SAVE_TRUNK = True

        # Copied from com.infinitekind.tiksync.Syncer
        OUTGOING_PATH = "tiksync/out"
        INCOMING_PATH = "tiksync/in"
        TXN_FILE_EXTENSION = ".txn"
        TXN_FILE_EXTENSION_TMP = ".txn-tmp"
        OUTGOING_TXN_FILE_EXTENSION = ".mdtxn"
        ARCHIVE_PATH = "archive"
        ARCHIVE_EXTENSION = ".mdtxnarchive"
        PROCESSED_FILES = "tiksync/processed.dct"
        UPLOADBUFFER = "tiksync/uploadbuf"

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

        MD_REF.saveCurrentAccount()

        safeFullPath = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath(), AccountBookWrapper.SAFE_SUBFOLDER_NAME)

        fp = os.path.join(safeFullPath, PROCESSED_FILES)
        if not os.path.exists(fp):
            myPrint("B", "ERROR - cannot proceed as file does not exist: %s" %(os.path.join(safeFullPath, PROCESSED_FILES)))
            txt = "Sorry - cannot proceed as %s does not exist?! (review console for details)" %(PROCESSED_FILES)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output += "Base 'safe' folder is: %s\n\n" %(safeFullPath)

        output += "Verified and found: %s\n" %(PROCESSED_FILES)

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        # Grab processed files here - freeze at this point....
        lError = False
        processedIn = None
        processedTxnFiles = StreamTable()  # type: StreamTable
        try:
            if storage.exists(PROCESSED_FILES):
                processedIn = storage.openFileForReading(PROCESSED_FILES)
                output += "Read %s data into memory\n" %(PROCESSED_FILES)
            else:
                lError = True                                                                                           # noqa
                raise Exception("Error: %s does not appear to exist?" %(PROCESSED_FILES))
            if processedIn is not None: processedTxnFiles.readFrom(processedIn)
        except:
            lError = True
            dump_sys_error_to_md_console_and_errorlog()
        finally:
            if processedIn is not None:
                try:
                    processedIn.close()
                except IOException:
                    lError = True
                    dump_sys_error_to_md_console_and_errorlog()

        oldestP = newestP = 0
        for pFileName in processedTxnFiles:
            pDate = processedTxnFiles.getLong(pFileName, 0)
            if pDate > 0:
                oldestP = (pDate if oldestP < 1 else min(oldestP, pDate))
                newestP = (pDate if newestP < 1 else max(newestP, pDate))

        output += ("Loaded %s (contains: %s entries, size: %sMBs). Oldest: %s, Newest: %s\n"
                  %(PROCESSED_FILES, len(processedTxnFiles), convertBytesMBs(os.path.getsize(fp)),
                    convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(oldestP)),
                    convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(newestP))))

        if lError or len(processedTxnFiles) < 1:
            if lError:
                txt = "Sorry - cannot proceed as error processing %s (review console for details)" %(PROCESSED_FILES)
            elif len(processedTxnFiles) < 1:
                txt = "Sorry - cannot proceed as %s contains no records?" %(PROCESSED_FILES)
            setDisplayStatus(txt, "R"); myPrint("B", txt)                                                                                           # noqa
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        syncFolder = None                                                                                               # noqa
        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
        except:
            syncFolder = False                                                                                          # noqa
            dump_sys_error_to_md_console_and_errorlog()
            txt = "Sorry - cannot proceed as error getting Sync status (review console for details)"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        fileSize, fileCount = calculateMoneydanceDatasetSize(True)

        output += "\nDataset is currently %sMBs containing %s files\n" %(fileSize, fileCount)

        MyPopUpDialogBox(toolbox_frame_,
                         "%sThis function attempts to shrink your dataset size (currently %sMBs, %s files)." %(("SIMULATION MODE: " if SIMULATE else ""),fileSize, fileCount),
                         "It does NOT change your actual database of records (known as 'trunk')\n"
                         "MD keeps log files for every change you (have ever) made. Typically these are .txn and .mdtxn files\n"
                         "Whilst in theory they could be used to rebuild your database from an older start point, this has rarely been done [to my knowledge].\n"
                         "These files accumulate over time, and can be safely deleted. Toolbox can purge log files older than [%s] days (you set this value)\n"
                         "It validates against the log of known processed dates, and also peeks inside archived zip files that MD creates\n"
                         "NOTE: You will need to repeat this process on other Sync copies too...\n"
                         "PRIOR TO RUNNING THIS, IDEALLY RESTART MD, & ENSURE THAT QUOTE LOADER/Q&ER EXTNS, IMPORTS & BANK DOWNLOADS ARE **NOT** RUNNING\n"
                         "<GOOD LUCK>" %(DAYS_TO_KEEP),
                         theTitle=_THIS_METHOD_NAME,
                         lModal=True,OKButtonText="ACKNOWLEDGE").go()

        lPurgeOutDir = False
        if syncFolder is None:
            output += "\nSyncing appears disabled....\n"
            theMsg = MyPopUpDialogBox(toolbox_frame_,
                                        "It appears that you have Syncing disabled (is this correct?).",
                                        "If you really are NOT using Sync, I can purge the 'out' directory too?\n"
                                        "Only Click 'PURGE-OUT' if you are NOT using Sync on this dataset.\n"
                                        "(i.e. if you have temporarily disabled Sync, click Cancel)\n"
                                        "If you 'PURGE-OUT', you can (re)create a NEW Sync relationship later (if needed)....\n"
                                        "(clicking 'Cancel' means Do NOT purge 'out' directory...)",
                                        theTitle=_THIS_METHOD_NAME, lCancelButton=True, OKButtonText="PURGE-OUT")
            if theMsg.go():
                output += "User confirmed that Sync is not being used and to proceed with purge of '%s'..\n" %(OUTGOING_PATH)
                lPurgeOutDir = True
            else:
                output += "User requested NOT to purge '%s'..\n" %(OUTGOING_PATH)
        else:
            output += "\nSync is ENABLED and as such, '%s' will NOT be purged. (SyncDir: %s)\n" %(OUTGOING_PATH, syncFolder)

        while True:

            newDaysToKeep = myPopupAskForInput(toolbox_frame_,
                                            _THIS_METHOD_NAME,
                                            "Days to Keep:",
                                            "Enter the new Days to Keep setting (currently %s) - min 0" %(DAYS_TO_KEEP),
                                            defaultValue=str(DAYS_TO_KEEP))

            if newDaysToKeep is not None and not StringUtils.isInteger(newDaysToKeep):
                continue

            if newDaysToKeep is None or int(newDaysToKeep) < 0 or int(newDaysToKeep) > (365*5):
                txt = "%s: No valid days to keep entered.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            DAYS_TO_KEEP = int(newDaysToKeep)
            myPrint("DB", "Days to Keep set to %s" %(DAYS_TO_KEEP))
            break

        todayDateInt = DateUtil.getStrippedDateInt()
        lookBackDateInt = DateUtil.incrementDate(todayDateInt, 0, 0, -(DAYS_TO_KEEP))

        output += "\nDays to keep setting set as: %s. Today: %s. Purge up to Date: %s\n" %(DAYS_TO_KEEP,
                                                                                           convertStrippedIntDateFormattedText(todayDateInt),
                                                                                           convertStrippedIntDateFormattedText(lookBackDateInt))

        output += "\n\n" \
                  "LISTING POTENTIAL PURGE TARGET FILES\n" \
                  " ===================================\n"

        class StoreFileReference:

            def __init__(self, _safePath, _filename, _fullPath, _theDateInt=0, _oldestProcessedInt=0, _newestProcessedInt=0):
                self.safePath = _safePath
                self.filename = _filename
                self.fullPath = _fullPath
                self.theDateInt = _theDateInt
                self.oldestProcessedInt = _oldestProcessedInt
                self.newestProcessedInt = _newestProcessedInt
                self.fileSize = os.path.getsize(_fullPath)

        output += "\n%s targets...:\n" %(OUTGOING_PATH)
        # Scan 'out' files... (awaiting Sync)
        targetOutFilesForDeletion = []
        for filename in storage.listFiles(OUTGOING_PATH):
            fp = os.path.join(safeFullPath, OUTGOING_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if (filename.endswith(TXN_FILE_EXTENSION_TMP)) and is_file_older_than_x_days(fp, max(1, DAYS_TO_KEEP)):
                # These are normally 'broken' sync txn files..... get rid of them (but always keep today's just in case)....
                targetOutFilesForDeletion.append(StoreFileReference(OUTGOING_PATH, filename, fp))
                output += "%s\n" %(filename)
                continue

            if not lPurgeOutDir: continue

            if not filename.endswith(TXN_FILE_EXTENSION):   continue
            if not processedTxnFiles.containsKey(filename): continue                                                    # noqa

            txnFileTimestamp = processedTxnFiles.getLong(filename, 0)
            txnFileDate = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
            if txnFileDate != 0 and txnFileDate <= lookBackDateInt:
                # Confirmed that the processed file database has logged this file as processed into trunk!
                targetOutFilesForDeletion.append(StoreFileReference(OUTGOING_PATH, filename, fp, txnFileDate))

        if len(targetOutFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetOutFilesForDeletion = sorted(targetOutFilesForDeletion, key=lambda sort_x: (sort_x.theDateInt))
            for target in targetOutFilesForDeletion:
                output += "%s (processed: %s, modified: %s)\n" %(target.filename,
                                                                 convertStrippedIntDateFormattedText(target.theDateInt),
                                                                 getHumanReadableModifiedDateTimeFromFile(target.fullPath))

        output += "\n%s targets...:\n" %(UPLOADBUFFER)
        targetUploadBufferForDeletion = []
        fp = os.path.join(safeFullPath, UPLOADBUFFER)
        if (os.path.exists(fp) and is_file_older_than_x_days(fp, max(1, DAYS_TO_KEEP))):
            # Should be an 'old' file... delete it.....
            targetUploadBufferForDeletion.append(StoreFileReference(UPLOADBUFFER, UPLOADBUFFER, fp))
            output += "%s (modified: %s)\n" %(UPLOADBUFFER, getHumanReadableModifiedDateTimeFromFile(fp))
        del fp
        if len(targetUploadBufferForDeletion) < 1: output += "<NONE>\n"

        # Scan 'in' files (in theory all processed into Sync locally)
        output += "\n%s targets...:\n" %(INCOMING_PATH)
        targetInFilesForDeletion = []
        for filename in storage.listFiles(INCOMING_PATH):
            fp = os.path.join(safeFullPath, INCOMING_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if not filename.endswith(OUTGOING_TXN_FILE_EXTENSION):  continue
            if not processedTxnFiles.containsKey(filename):         continue                                            # noqa

            txnFileTimestamp = processedTxnFiles.getLong(filename, 0)
            txnFileDate = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
            if txnFileDate != 0 and txnFileDate <= lookBackDateInt:
                # Confirmed that the processed file database has logged this file as processed into trunk!
                targetInFilesForDeletion.append(StoreFileReference(INCOMING_PATH, filename, fp, txnFileDate))
            del fp
        if len(targetInFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetInFilesForDeletion = sorted(targetInFilesForDeletion, key=lambda sort_x: (sort_x.theDateInt))
            for target in targetInFilesForDeletion:
                output += "%s (processed: %s, modified: %s)\n" %(target.filename,
                                                                 convertStrippedIntDateFormattedText(target.theDateInt),
                                                                 getHumanReadableModifiedDateTimeFromFile(target.fullPath))

        # Scan 'archive' files (these are zip files containing .mdtxn files)
        output += "\n%s targets...:\n" %(ARCHIVE_PATH)
        targetArchiveFilesForDeletion = []

        for filename in storage.listFiles(ARCHIVE_PATH):
            fp = os.path.join(safeFullPath, ARCHIVE_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if not filename.endswith(ARCHIVE_EXTENSION): continue

            oldestModInt, newestModInt = getModifiedDatesFomZip(storage, ARCHIVE_PATH + "/" + filename)
            if oldestModInt < 1 or newestModInt < 1: continue

            if newestModInt <= lookBackDateInt:
                targetArchiveFilesForDeletion.append(StoreFileReference(ARCHIVE_PATH, filename, fp, _oldestProcessedInt=oldestModInt, _newestProcessedInt=newestModInt))
            del fp
        if len(targetArchiveFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetArchiveFilesForDeletion = sorted(targetArchiveFilesForDeletion, key=lambda sort_x: (sort_x.newestProcessedInt))
            for target in targetArchiveFilesForDeletion:
                output += "%s ZIPFile (contains oldest: %s, newest: %s; ZIPfile modified: %s)\n"\
                          %(target.filename,
                            convertStrippedIntDateFormattedText(target.oldestProcessedInt),
                            convertStrippedIntDateFormattedText(target.newestProcessedInt),
                            getHumanReadableModifiedDateTimeFromFile(target.fullPath))


        sizeOutDelete = sizeInDelete = sizeUploadBufferDelete = sizeArchiveFilesDelete = 0.0
        for fn in targetOutFilesForDeletion:        sizeOutDelete           += fn.fileSize
        for fn in targetInFilesForDeletion:         sizeInDelete            += fn.fileSize
        for fn in targetUploadBufferForDeletion:    sizeUploadBufferDelete  += fn.fileSize
        for fn in targetArchiveFilesForDeletion:    sizeArchiveFilesDelete  += fn.fileSize

        totalSize = sizeOutDelete + sizeInDelete + sizeUploadBufferDelete + sizeArchiveFilesDelete
        totalFiles = len(targetOutFilesForDeletion) + len(targetInFilesForDeletion) + len(targetUploadBufferForDeletion) + len(targetArchiveFilesForDeletion)

        if totalFiles < 1:
            txt = "Sorry. No files to purge found!"
            myPrint("B", "%s: %s" %(_THIS_METHOD_NAME, txt))
            setDisplayStatus("%s: %s" %(_THIS_METHOD_NAME, txt), "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        txt1 = "OK, I can purge %s files and reduce dataset size by %sMBs" %(totalFiles, convertBytesMBs(totalSize))
        txt2 = ("Syncing is currently: %s\n"
                "Purge of 'out' directory is: %s\n"
                "Days to keep is set at: %s\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs" % (
                    ("ENABLED" if syncFolder is not None else "DISABLED"), ("ENABLED" if lPurgeOutDir else "DISABLED"),
                    DAYS_TO_KEEP,
                    OUTGOING_PATH,  len(targetOutFilesForDeletion),         convertBytesMBs(sizeOutDelete),
                    INCOMING_PATH,  len(targetInFilesForDeletion),          convertBytesMBs(sizeInDelete),
                    ARCHIVE_PATH,   len(targetArchiveFilesForDeletion),     convertBytesMBs(sizeArchiveFilesDelete),
                    UPLOADBUFFER,   len(targetUploadBufferForDeletion),     convertBytesMBs(sizeUploadBufferDelete)))

        output += "\n" \
                  "%s\n" \
                  "%s\n\n" %(txt1, txt2)

        jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        MyPopUpDialogBox(jif,
                         txt1,
                         txt2,
                         theTitle=_THIS_METHOD_NAME,
                         lModal=True,OKButtonText="ACKNOWLEDGE").go()


        if not confirm_backup_confirm_disclaimer(jif,
                                                 _THIS_METHOD_NAME,
                                                 "%sShrink Dataset by removing %s old change log files (older than %s days)?"
                                                 %(("SIMULATION MODE: " if SIMULATE else ""),totalFiles, DAYS_TO_KEEP)):
            return

        jif.dispose()
        output += "\nUSER CONFIRMED DISCLAIMER AND AGREED TO PROCEED WITH %s\n\n" %(_THIS_METHOD_NAME)

        # Should probably do something with com.moneydance.apps.md.controller.BackgroundOpsThread - but haven't worked that out yet

        output += "Flushing memory and saving Preferences to disk....\n"
        MD_REF.savePreferences()

        output += "Flushing memory and saving local storage settings to disk....\n"
        MD_REF.getCurrentAccountBook().getLocalStorage().save()

        output += "Flushing memory and saving in memory dataset changes to disk (log files)....\n"
        MD_REF.saveCurrentAccount()

        output += "Pausing the MD Syncing engine....\n"
        MD_REF.getCurrentAccountBook().pauseSyncing()

        if not SIMULATE and SAVE_TRUNK:  # Now that we check processed.dct, not strictly necessary....
            output += "Flushing dataset back to trunk file....\n"
            MD_REF.getCurrentAccountBook().saveTrunkFile()

        output += "\n" \
                  "DELETING LOG FILES...\n" \
                  " --------------------\n"

        for fn in targetOutFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))


        for fn in targetInFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        for fn in targetUploadBufferForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        for fn in targetArchiveFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        output += ">> Finished removing files.....\n\n"

        output += "Resuming the MD Syncing engine....\n\n"
        MD_REF.getCurrentAccountBook().resumeSyncing()

        newFileSize, newFileCount = calculateMoneydanceDatasetSize(True)
        output += "Dataset was %sMBs containing %s files\n" %(fileSize, fileCount)
        output += "Dataset now %sMBs containing %s files\n" %(newFileSize, newFileCount)
        output += "...reduced (%sMBs)          (%s files)\n" %(fileSize-newFileSize, fileCount-newFileCount)

        if SIMULATE:
            output += "\n\n" \
                      "SIMULATION OVER - NO CHANGES MADE...\n".upper()
        else:
            output += "\n\n" \
                      "I recommend you perform another backup and restart MD...\n".upper()

        output += "\n<END>"

        jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lJumpToEnd=True, lWrapText=False).show_the_frame()

        if SIMULATE:
            txt = "SIMULATION - Dataset (not really) reduced by %sMBs (%s files) - review log for details" %(fileSize-newFileSize, fileCount-newFileCount)
        else:
            txt = "SUCCESS - Dataset reduced by %sMBs (%s files) - review log for details" %(fileSize-newFileSize, fileCount-newFileCount)
            logToolboxUpdates("advanced_options_shrink_dataset", txt)

        setDisplayStatus("%s: %s" %(_THIS_METHOD_NAME, txt), "R")
        myPrint("B","%s: %s" %(_THIS_METHOD_NAME, txt))
        myPopupInformationBox(jif,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

    def advanced_options_DEBUG(lForceON=False, lForceOFF=False):
        md_debug = MD_REF.DEBUG
        moneydance_debug_props_key = "moneydance.debug"
        props_debug = Boolean.getBoolean(moneydance_debug_props_key)


        if lForceON:
            toggleText = "ON"
        elif lForceOFF:
            toggleText = "OFF"
        else:
            toggleText = "OFF" if (md_debug or props_debug) else "ON"

            ask = MyPopUpDialogBox(toolbox_frame_, "MONEYDANCE DEBUG(s) STATUS:",
                                   "main.DEBUG                             currently set to: %s\n"
                                   "System.getProperty('%s') currently set to: %s\n"
                                   "OFXConnection.DEBUG_MESSAGES           currently set to: %s\n"
                                   "MoneybotURLStreamHandlerFactory.DEBUG  currently set to: %s\n"
                                   "OnlineTxnMerger.DEBUG                  currently set to: %s\n"
                                   "Syncer.DEBUG                           currently set to: %s\n"
                                   "CustomURLStreamHandlerFactory.DEBUG    currently set to: %s\n"
                                   "PlaidConnection.DEBUG                  currently set to: %s\n"
                                   %(md_debug,
                                     moneydance_debug_props_key,
                                     props_debug,
                                     OFXConnection.DEBUG_MESSAGES,
                                     MoneybotURLStreamHandlerFactory.DEBUG,
                                     OnlineTxnMerger.DEBUG,
                                     Syncer.DEBUG,
                                     CustomURLStreamHandlerFactory.DEBUG,
                                     "n/a" if (not isMDPlusEnabledBuild()) else PlaidConnection.DEBUG),
                                   theTitle="TOGGLE MONEYDANCE INTERNAL DEBUG(s)",
                                   lCancelButton=True,OKButtonText="SET ALL to %s" %toggleText)
            if not ask.go():
                txt = "NO CHANGES MADE TO MONEYDANCE's DEBUG(s)!"
                setDisplayStatus(txt,"B")
                return

            myPrint("B","User requested to change all Moneydance's internal DEBUG mode(s) to %s - flipping these now...!" %(toggleText))

        if toggleText == "OFF":
            newDebugSetting = False
            System.clearProperty(moneydance_debug_props_key)
        else:
            newDebugSetting = True
            System.setProperty(moneydance_debug_props_key, Boolean.toString(newDebugSetting))

        MD_REF.DEBUG = newDebugSetting
        OFXConnection.DEBUG_MESSAGES = newDebugSetting
        MoneybotURLStreamHandlerFactory.DEBUG = newDebugSetting
        OnlineTxnMerger.DEBUG = newDebugSetting
        Syncer.DEBUG = newDebugSetting
        CustomURLStreamHandlerFactory.DEBUG = newDebugSetting
        if isMDPlusEnabledBuild(): PlaidConnection.DEBUG = newDebugSetting

        txt = "All Moneydance internal debug modes turned %s" %(toggleText)

        if lForceON:
            myPrint("DB", txt)
            return

        setDisplayStatus(txt,"B")
        myPopupInformationBox(toolbox_frame_, txt, "TOGGLE MONEYDANCE INTERNAL DEBUG(s)", JOptionPane.WARNING_MESSAGE)

    def advanced_options_other_DEBUG():
        # Also: System.getProperty("ofx.debug.console") - Throws up connection issues in a new file/console...

        debugKeys = ["com.moneydance.apps.md.view.gui.txnreg.DownloadedTxnsView.DEBUG",
                     "com.moneydance.apps.md.view.gui.OnlineUpdateTxnsWindow.DEBUG",
                     "com.infinitekind.util.StreamTable.DEBUG"]

        if isKotlinCompiledBuildAll():
            # Before this build, the field is hidden as the class is not public even tho' field is public....
            debugKeys.append("com.infinitekind.moneydance.model.CostCalculation.DEBUG_COST")

        selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                  "Select the DEBUG Setting you want to view/toggle",
                                                  "OTHER DEBUG",
                                                  JOptionPane.INFORMATION_MESSAGE,
                                                  getMDIcon(lAlwaysGetIcon=True),
                                                  debugKeys,
                                                  None)

        if not selectedKey or debugKeys.index(selectedKey) > len(debugKeys):
            txt = "No Debug key was selected to view/toggle.."
            setDisplayStatus(txt, "R")
            return

        if debugKeys.index(selectedKey) == 0:
            currentSetting = DownloadedTxnsView.DEBUG
        elif debugKeys.index(selectedKey) == 1:
            currentSetting = OnlineUpdateTxnsWindow.DEBUG
        elif debugKeys.index(selectedKey) == 2:
            currentSetting = getFieldByReflection(StreamTable, "DEBUG")
        elif debugKeys.index(selectedKey) == 3:
            currentSetting = getFieldByReflection(CostCalculation, "DEBUG_COST")
        else:
            raise Exception("LOGIC ERROR: Unknown selectedKey:", selectedKey)

        ask = MyPopUpDialogBox(toolbox_frame_, "OTHER DEBUG STATUS:",
                               "%s currently set to: %s" %(selectedKey, currentSetting),
                               theTitle="TOGGLE THIS MONEYDANCE INTERNAL OTHER DEBUG",
                               lCancelButton=True,OKButtonText="SET to %s" %(not currentSetting))
        if not ask.go():
            txt = "NO CHANGES MADE TO OTHER DEBUG!"
            setDisplayStatus(txt, "B")
            return

        myPrint("B","User requested to change DEBUG %s to %s - setting now...!" %(selectedKey,not currentSetting))

        if debugKeys.index(selectedKey) == 0:
            DownloadedTxnsView.DEBUG = not currentSetting
        elif debugKeys.index(selectedKey) == 1:
            OnlineUpdateTxnsWindow.DEBUG = not currentSetting
        elif debugKeys.index(selectedKey) == 2:
            setFieldByReflection(StreamTable, "DEBUG", not currentSetting)
        elif debugKeys.index(selectedKey) == 3:
            setFieldByReflection(CostCalculation, "DEBUG_COST", not currentSetting)

        txt = "Moneydance internal debug settings %s turned %s" %(selectedKey, not currentSetting)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_, txt, "TOGGLE MONEYDANCE INTERNAL OTHER DEBUG", JOptionPane.WARNING_MESSAGE)

    def advanced_options_demote_primary_to_secondary():
        # the reverse of convert_secondary_to_primary_data_set

        _THIS_METHOD_NAME = "ADVANCED: MAKE this PRIMARY a SECONDARY NODE"

        if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = "Your dataset is already Secondary - no changes made.."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "DEMOTE this Primary into a Secondary Dataset?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(False)
        MD_REF.getCurrentAccountBook().getLocalStorage().save()        # Flush local storage to safe/settings

        txt = "%s: Dataset DEMOTED to Secondary (non-Primary/Master) Node - MONEYDANCE WILL NOW RESTART" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("advanced_options_demote_primary_to_secondary", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def advanced_options_force_sync_off():
        _THIS_METHOD_NAME = "ADVANCED: FORCE DISABLE/TURN SYNC OFF"

        _PARAM_KEY = "netsync.sync_type"
        _NONE = "none"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        if storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE:
            txt = "Your Sync is already disabled/turned off! NO ACTION TAKEN"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Force Disable/Turn OFF Sync?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        storage.put(_PARAM_KEY, _NONE)
        MD_REF.getCurrentAccountBook().getLocalStorage().save()        # Flush local storage to safe/settings

        txt = "Sync ('%s')has been force disabled/turned OFF - MONEYDANCE WILL NOW RESTART" %(_PARAM_KEY)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("advanced_options_force_sync_off", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def getNetSyncKeys():
        _SYNC_KEYS = ["netsync.dropbox.fileid",
                      "netsync.sync_type",
                      "netsync.subpath",
                      "netsync.dropbox_enabled",
                      "netsync.synckey",
                      "ext.netsync.settings",
                      "netsync.guid",
                      "netsync.fs.sync_path",
                      "netsync.db.access_token_key",
                      "netsync.db.access_token_secret",
                      "netsync.db.v2token",
                      "netsync.download_attachments",
                      "migrated.netsync.dropbox.fileid",
                      "migrated.ext.netsync.settings",
                      "migrated.netsync.dropbox_enabled",
                      "migrated.netsync.guid",
                      "migrated.netsync.synckey"
                      ]
        return _SYNC_KEYS

    def advanced_options_force_reset_sync_settings():
        # Resets all Sync settings, generates a new Sync ID, Turns Sync Off. You can turn it back on later....

        _THIS_METHOD_NAME = "ADVANCED: FORCE RESET SYNC SETTINGS"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Force reset all Sync settings, generate new SyncID & disable Sync?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        SYNC_KEYS = getNetSyncKeys()

        for skey in SYNC_KEYS: storage.remove(skey)

        # Copied from: com.moneydance.apps.md.controller.AccountBookWrapper.resetSyncInfoIfNecessary()
        storage.put("netsync.dropbox.fileid", UUID.randomUUID())

        # NOTE: as of 2022.3(4063) - this is also performed: .setIsMasterSyncNode(True)
        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(True)
        storage.save()

        root = MD_REF.getCurrentAccountBook().getRootAccount()
        if root is not None:
            root.setEditingMode()
            for skey in SYNC_KEYS: root.removeParameter(skey)
            root.syncItem()

        txt = "ALL SYNC SETTINGS HAVE BEEN RESET - MONEYDANCE WILL NOW RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("advanced_options_force_reset_sync_settings", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def advanced_options_repair_migrated_dropbox_alias():
        # Attempts to (re)create the missing Alias pointing to new Dropbox location...

        _THIS_METHOD_NAME = "ADVANCED: REPAIR MIGRATED DROPBOX ALIAS"

        if not detectMigratedDropboxFolderProblem():
            txt = "%s: No problem detected - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Attempt to (re)create missing alias pointing to new Dropbox location?"):
            return

        if detectMigratedDropboxFolderProblem(createSymbolicLink=True):
            statusTxt = "ERROR: Could not (re)create the alias (review console log)"
            setDisplayStatus(statusTxt, "R"); myPrint("B", statusTxt)
            output = ("You may need to manually intervene...\n"
                      "- MD / File / Syncing. Select Method 'Don't Sync' ...\n"
                      "- Quit MD, use Finder to locate your Home Folder...\n"
                      "- Highlight Dropbox, then rename it to old_dropbox...\n"
                      "- Launch Moneydance, launch Toolbox, Update Mode...\n"
                      "- Rerun this fix to (re)create the alias....")
            MyPopUpDialogBox(toolbox_frame_,
                             theStatus=statusTxt,
                             theMessage=output,
                             theTitle="ERROR - COULD NOT (RE)CREATE DROPBOX ALIAS",
                             OKButtonText="ACKNOWLEDGE",
                             lAlertLevel=2,
                             lModal=False).go()
            return

        txt = "Dropbox alias to new location has been (re)created - MONEYDANCE WILL NOW RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("advanced_options_repair_migrated_dropbox_alias", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def toggle_sync_download_attachments():
        _THIS_METHOD_NAME = "ADVANCED: TOGGLE SYNC DOWNLOAD ATTACHMENTS"

        shouldDownloadAllAttachments = getShouldDownloadAllAttachments()

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Toggle Sync Download Attachments setting to: %s"
                                                                                    %("OFF" if shouldDownloadAllAttachments else "ON")):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        storage.put("netsync.download_attachments", not shouldDownloadAllAttachments)
        storage.save()

        txt = "Sync download attachments setting now: %s - MONEYDANCE WILL NOW RESTART" %("ON" if getShouldDownloadAllAttachments() else "OFF")
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        logToolboxUpdates("toggle_sync_download_attachments", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def checkForREADONLY():
        checkDropbox = tell_me_if_dropbox_folder_exists()
        datasetPath = MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()

        if not os.access(datasetPath, os.W_OK) or (checkDropbox and not os.access(checkDropbox, os.W_OK)):
            myPrint("B", "@@@ ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! @@@")
            myPrint("B", "\n>> %s - Writable: %s\n"
                         ">> %s - Writable: %s\n"
                    %(checkDropbox, os.access(checkDropbox, os.W_OK), datasetPath, os.access(datasetPath, os.W_OK)))

            play_the_money_sound()
            txt = "ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! - YOU NEED TO EXIT MD AND FIX MANUALLY"
            MyPopUpDialogBox(toolbox_frame_,
                                   txt,
                                   "%s - Writable: %s\n"
                                   "%s - Writable: %s"
                                   %(checkDropbox, os.access(checkDropbox, os.W_OK), datasetPath, os.access(datasetPath, os.W_OK)),
                                   theTitle="FOLDER PROBLEM",
                                   OKButtonText="I WILL EXIT",
                                   lAlertLevel=2,
                                   lModal=False).go()
            setDisplayStatus(txt, "R")
        return

# END OF GLOBAL CLASSES and DEFs

    # ##################################################################################################################
    # ##################################################################################################################
    # ##### MAIN DISPLAY CLASS                                                                      ####################
    # ##################################################################################################################
    # ##################################################################################################################

    def findEnvironmentPassphrases():
        theList = []
        if int(MD_REF.getBuild()) < 3088:     # MD2021.2(3088) added this capability
            return theList
        for k, v in os.environ.items():
            if k.startswith("md_passphrase"):
                theList.append([k,v])
        return theList

    def getSyncMethodText():
        MainDebug.changeState(False)   # Prevent "ICloudContainer.isContainerAvailable(): ..." console messages
        try:
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            noSyncOption = SyncFolderUtil.configurerForIDFromList(u"none", syncMethods)
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)
            if syncMethod is None or syncMethod == noSyncOption:
                return "<Syncing not configured>", MD_REF.getUI().colors.defaultTextForeground
            else:
                return "<Syncing configured: %s>" %(syncMethod), getColorDarkGreen()
        except:
            return "<ERROR GETTING SYNC STATUS>", getColorRed()

        finally: MainDebug.resetState()

    def setSyncingLabel():
        txt, color = getSyncMethodText()
        GlobalVars.mainPnl_syncing_lbl.setText(txt)
        GlobalVars.mainPnl_syncing_lbl.setForeground(color)

    def setMemoryLabel():
        try:
            # https://stackoverflow.com/questions/3571203/what-are-runtime-getruntime-totalmemory-and-freememory
            runTime = Runtime.getRuntime()

            maxMemory = runTime.maxMemory()
            freeMemory = runTime.freeMemory()
            totalMemory = runTime.totalMemory()
            usedMemory = totalMemory - freeMemory
            memoryUsedPecentage = (usedMemory / float(maxMemory))

            maxMemoryTxt = "no limit" if (Long(maxMemory) == Long.MAX_VALUE) else "{:,} GB".format(convertBytesGBs(maxMemory))
            memoryAllocatedTxt = "{:,} GB".format(convertBytesGBs(totalMemory))
            memoryUsedTxt = "{:,} GB".format(convertBytesGBs(usedMemory))
            memoryFreeTxt = "{:,} GB".format(convertBytesGBs(freeMemory))
            memoryUsedPercentage = "{:.0%}".format(memoryUsedPecentage)
            vmoptionsTxt = "('-Xmx' .vmoption) " if (not Platform.isOSX()) else ""

            memoryText = ("<JVM Memory: Maximum %spossible: %s; Allocated to JVM: %s; Used: %s(%s of max); Free: %s>"
                          %(vmoptionsTxt, maxMemoryTxt, memoryAllocatedTxt, memoryUsedTxt, memoryUsedPercentage, memoryFreeTxt))

            color = MD_REF.getUI().colors.defaultTextForeground
            if  memoryUsedPecentage > 0.60: color = getColorRed()
            GlobalVars.mainPnl_memory_lbl.setText(memoryText)
            GlobalVars.mainPnl_memory_lbl.setForeground(color)
        except:
            GlobalVars.mainPnl_memory_lbl.setText("<MEMORY STATS ERROR>")
            GlobalVars.mainPnl_memory_lbl.setForeground(getColorRed())

    def disableToolboxButtons():

        class DisableToolboxButtonsRunnable(Runnable):
            def __init__(self): pass

            def run(self):
                try:
                    for btn in GlobalVars.allButtonsList: btn.setEnabled(False)
                except: pass

        if not SwingUtilities.isEventDispatchThread(): SwingUtilities.invokeLater(DisableToolboxButtonsRunnable())
        else: DisableToolboxButtonsRunnable().run()

    class MenuJRadioButton(JRadioButton):
        def __init__(self, *args, **kwargs):
            self.updateMenuItem = kwargs.pop("updateMenu", False)
            self.secondaryEnabledCondition = kwargs.pop("secondaryEnabled", True)
            super(self.__class__, self).__init__(*args, **kwargs)
            if self.isUpdateMenuItem(): self.setEnabled(ToolboxMode.isUpdateMode() and self.secondaryEnabledCondition)
            else: self.setEnabled(self.secondaryEnabledCondition)
        def isUpdateMenuItem(self): return self.updateMenuItem

    class DisabledButtonMouseAdapter(MouseAdapter):
        def __init__(self): pass
        def mouseClicked(self, event):
            jrb = event.getSource()
            if not isinstance(jrb, MenuJRadioButton) or jrb.isEnabled(): return
            if (jrb.isUpdateMenuItem() and not ToolboxMode.isUpdateMode()):
                txt = "Update"
                myPopupInformationBox(SwingUtilities.getWindowAncestor(jrb), "OPTION DISABLED - Enable '%s Mode' first!" %(txt), "ALERT", JOptionPane.WARNING_MESSAGE)
            else:
                myPopupInformationBox(SwingUtilities.getWindowAncestor(jrb), "OPTION DISABLED - Feature NOT allowed at this time...", "ALERT", JOptionPane.WARNING_MESSAGE)


    def setupMenuRadioButtons(componentHoldingRBs):
        dma = DisabledButtonMouseAdapter()
        _bg = ButtonGroup()
        for jrb in componentHoldingRBs.getComponents():
            if isinstance(jrb, JRadioButton): _bg.add(jrb)
            if isinstance(jrb, MenuJRadioButton):
                jrb.addMouseListener(dma)
                if jrb.isUpdateMenuItem():
                    jrb.setForeground(getColorRed())
        _bg.clearSelection()
        return _bg

    def isSwingComponentValid(swComponent): return not isSwingComponentInvalid(swComponent)

    def isSwingComponentInvalid(swComponent):

        # if debug:
        #     myPrint("B", "isSwingComponentInvalid(), swComponent is None: %s, !isVisible(): %s, !isValid(): %s, !isDisplayable(): %s, getWindowAncestor() is None: %s"
        #             % (swComponent is None, not swComponent.isVisible(), not swComponent.isValid(), not swComponent.isDisplayable(), SwingUtilities.getWindowAncestor(swComponent) is None))

        return (swComponent is None
                or not swComponent.isVisible() or not swComponent.isDisplayable() or SwingUtilities.getWindowAncestor(swComponent) is None)

    class BlinkSwingTimer(SwingTimer, ActionListener):
        ALL_BLINKERS = []
        blinker_LOCK = threading.Lock()

        @staticmethod
        def stopAllBlinkers():
            myPrint("DB", "BlinkSwingTimer.stopAllBlinkers() called....")
            with BlinkSwingTimer.blinker_LOCK:
                for i in range(0, len(BlinkSwingTimer.ALL_BLINKERS)):
                    blinker = BlinkSwingTimer.ALL_BLINKERS[i]
                    try:
                        blinker.stop()
                        myPrint("DB", "... stopped blinker: id: %s" %(blinker.uuid))
                    except:
                        myPrint("DB", ">> ERROR stopping blinker: id: %s" %(blinker.uuid))
                del BlinkSwingTimer.ALL_BLINKERS[:]

        def __init__(self, timeMS, swComponents, flipColor=None, flipBold=False):
            with BlinkSwingTimer.blinker_LOCK:
                self.uuid = UUID.randomUUID().toString()
                self.isForeground = True
                self.countBlinkLoops = 0

                if isinstance(swComponents, JComponent):
                    swComponents = [swComponents]
                elif not isinstance(swComponents, list) or len(swComponents) < 1:
                    return

                self.swComponents = []
                for swComponent in swComponents:
                    font = swComponent.getFont()
                    self.swComponents.append([swComponent,
                                              swComponent.getForeground(),
                                              swComponent.getBackground() if (flipColor is None) else flipColor,
                                              font.deriveFont(font.getStyle() | Font.BOLD) if (flipBold) else font,
                                              font.deriveFont(font.getStyle() & ~Font.BOLD) if (flipBold) else font
                                              ])
                super(self.__class__, self).__init__(max(timeMS, 1200), None)   # Less than 1000ms will prevent whole application from closing when requested...
                if self.getInitialDelay() > 0: self.setInitialDelay(int(self.getInitialDelay()/2))
                self.addActionListener(self)
                BlinkSwingTimer.ALL_BLINKERS.append(self)
                myPrint("DB", "Blinker initiated - id: %s; with %s components" %(self.uuid, len(swComponents)))

        def actionPerformed(self, event):                                                                               # noqa
            try:
                with BlinkSwingTimer.blinker_LOCK:
                    for i in range(0, len(self.swComponents)):
                        swComponent = self.swComponents[i][0]
                        if isSwingComponentInvalid(swComponent):
                            myPrint("DB", ">>> Shutting down blinker (id: %s) as component index: %s no longer available" %(self.uuid, i))
                            self.stop()
                            BlinkSwingTimer.ALL_BLINKERS.remove(self)
                            return

                    for i in range(0, len(self.swComponents)):
                        swComponent = self.swComponents[i][0]
                        fg = self.swComponents[i][1]
                        bg = self.swComponents[i][2]
                        boldON = self.swComponents[i][3]
                        boldOFF = self.swComponents[i][4]
                        swComponent.setForeground(fg if self.isForeground else bg)
                        swComponent.setFont(boldON if self.isForeground else boldOFF)

                    self.countBlinkLoops += 1
                    self.isForeground = not self.isForeground
                    if self.countBlinkLoops % 100 == 0:
                        myPrint("DB", "** Blinker (id: %s), has now iterated %s blink loops" %(self.uuid, self.countBlinkLoops))

            except: pass

    def detect_duplicate_securities():

        try:
            _startTimeMs = System.currentTimeMillis()

            # noinspection PyUnresolvedReferences
            allSecurities = [secCurr for secCurr in MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies()
                             if secCurr.getCurrencyType() is CurrencyType.Type.SECURITY]

            foundSecIDs = {}
            foundSecNames = {}
            foundSecTickers = {}

            for sec in allSecurities:
                secID = sec.getIDString().lower().strip()
                name = sec.getName().lower().strip()
                ticker = sec.getTickerSymbol().lower().strip()
                if secID != "": foundSecIDs[secID] = foundSecIDs.get(secID, []) + [sec]
                if name != "": foundSecNames[name] = foundSecNames.get(name, []) + [sec]
                if ticker != "": foundSecTickers[ticker] = foundSecTickers.get(ticker, []) + [sec]

            securitiesInvolved = {}
            duplicateSecurities = []
            for what in sorted(foundSecIDs):
                if len(foundSecIDs[what]) > 1:
                    for sec in foundSecIDs[what]: securitiesInvolved[sec] = True
                    duplicateSecurities.append(["ID:", foundSecIDs[what][0].getIDString(), foundSecIDs[what]])
            for what in sorted(foundSecNames):
                if len(foundSecNames[what]) > 1:
                    for sec in foundSecNames[what]: securitiesInvolved[sec] = True
                    duplicateSecurities.append(["Name:", foundSecNames[what][0].getName(), foundSecNames[what]])
            for what in sorted(foundSecTickers):
                if len(foundSecTickers[what]) > 1:
                    for sec in foundSecTickers[what]: securitiesInvolved[sec] = True
                    duplicateSecurities.append(["Ticker:", foundSecTickers[what][0].getTickerSymbol(), foundSecTickers[what]])

            output = None
            if len(duplicateSecurities) > 0:
                output = "POTENTIAL DUPLICATE SECURITIES:\n" \
                         " ------------------------------\n"
                for dup in duplicateSecurities:
                    secTxt = "["
                    for sec in dup[2]: secTxt += "'%s'," %(sec.getName())
                    secTxt += "]"
                    output += "%s '%s' Found in (%s): %s\n" %(dup[0], dup[1], len(dup[2]), secTxt)  # Avoid IllegalArgument Exceptions....!

                output += "\n" \
                          "--- Unique list of Securities with potential duplicates:\n"
                for sec in sorted(securitiesInvolved, key=lambda _x: (_x.getName().lower())):
                    output += "%s(Ticker: %s, ID: %s)\n" %(sec.getName(), sec.getTickerSymbol(), sec.getIDString())
                output += "\n<END>"

                myPrint("DB", "detect_duplicate_securities() took %s seconds..." %((System.currentTimeMillis() - _startTimeMs) / 1000.0))
        except:
            myPrint("B", "@@ ERROR: .detect_duplicate_securities() has failed.... Ignoring (but please report to developer!)")
            dump_sys_error_to_md_console_and_errorlog()
            return 0, [], ""

        return len(duplicateSecurities), duplicateSecurities, output


    class DiagnosticDisplay(PreferencesListener):

        def __init__(self):
            self.myScrollPane = None
            self.theFrame = None
            self.moduleID = myModuleID

        def preferencesUpdated(self):
            myPrint("DB", "In %s.%s()" %(self, inspect.currentframe().f_code.co_name))

            myPrint("B","Your MD Preferences have been updated... I am closing Toolbox... Please relaunch if you want to use it...")
            SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.theFrame))
            myPrint("DB","Back from calling GenericWindowClosingRunnable to push a WINDOW_CLOSING Event (via the Swing EDT) to %s...." %(self.moduleID))

        class WindowListener(WindowAdapter):

            def __init__(self, theFrame, callingClass):
                self.theFrame = theFrame        # type: MyJFrame
                self.callingClass = callingClass

            def windowActivated(self, windowEvent):                                                                     # noqa
                setSyncingLabel()
                setMemoryLabel()

            # def windowDeactivated(self, windowEvent): pass                                                            # noqa
            # def windowDeiconified(self, windowEvent): pass                                                            # noqa
            # def windowGainedFocus(self, windowEvent): pass                                                            # noqa
            # def windowLostFocus(self, windowEvent): pass                                                              # noqa
            # def windowIconified(self, windowEvent): pass                                                              # noqa
            # def windowOpened(self, windowEvent): pass                                                                 # noqa
            # def windowStateChanged(self, windowEvent): pass                                                           # noqa

            def windowClosing(self, windowEvent):
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()", windowEvent)
                myPrint("DB", "DiagnosticDisplay() Frame shutting down....")
                terminate_script()

            def windowClosed(self, windowEvent):
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()", windowEvent)
                myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))

                self.theFrame.isActiveInMoneydance = False

                myPrint("DB","applistener is %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))

                if self.theFrame.MoneydanceAppListener is not None:
                    try:
                        MD_REF.removeAppEventListener(self.theFrame.MoneydanceAppListener)
                        myPrint("DB","\n@@@ Removed my MD App Listener... %s\n" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
                        self.theFrame.MoneydanceAppListener = None
                    except:
                        myPrint("B","FAILED to remove my MD App Listener... %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
                        dump_sys_error_to_md_console_and_errorlog()

                if self.theFrame.HomePageViewObj is not None:
                    self.theFrame.HomePageViewObj.unload()
                    myPrint("DB","@@ Called HomePageView.unload() and Removed reference to HomePageView %s from MyJFrame()...@@\n" %(classPrinter("HomePageView", self.theFrame.HomePageViewObj)))
                    self.theFrame.HomePageViewObj = None

                myPrint("DB", "Removing Preferences listener:", self.callingClass)
                MD_REF.getPreferences().removeListener(self.callingClass)

                cleanup_actions(self.theFrame)

        class CloseAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In CloseAction().", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "DiagnosticDisplay() Frame shutting down....")

                myPrint("DB",".. calling terminate_script()")
                terminate_script()

        class UnlockAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame
                self.saveTitle = theFrame.getTitle()

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In UnlockAction().", inspect.currentframe().f_code.co_name, "()")

                if GlobalVars.TOOLBOX_UNLOCK:
                    txt = "@@@ Toolbox is already Unlocked... RELOCKING Toolbox! @@@"
                    sColor = "B"
                    GlobalVars.TOOLBOX_UNLOCK = False
                    self.theFrame.setTitle(self.saveTitle)
                else:
                    v = int(float(MD_REF.getVersion())); b = int(float(MD_REF.getBuild())); c = v+b
                    response = myPopupAskForInput(self.theFrame,"@@ UNLOCK TOOLBOX @@", "PASSWORD:", "Enter the password to unlock powerful features",
                                          defaultValue=None,isPassword=True,theMessageType=JOptionPane.ERROR_MESSAGE)
                    lCorrect = False

                    if response is not None:
                        if StringUtils.isInteger(response) and int(response) == c:
                            lCorrect = True
                        if StringUtils.looksLikeFormula(response):
                            if int(StringUtils.parseFormula(response, MD_REF.getPreferences().getDecimalChar())) == c:
                                lCorrect = True

                    if lCorrect:
                        txt = "@@@ Toolbox UNLOCKED @@@"
                        sColor = "R"
                        GlobalVars.TOOLBOX_UNLOCK = True
                        self.theFrame.setTitle(u"Toolbox UNLOCKED (%s+I for Help) - DATASET: %s" % (MD_REF.getUI().ACCELERATOR_MASK_STR, MD_REF.getCurrentAccountBook().getName().strip()))
                    else:
                        txt = "@@@ Toolbox NOT Unlocked @@@"
                        sColor = "B"

                GlobalVars.mainPnl_toolboxUnlocked_lbl.setText("<TOOLBOX UNLOCKED>" if isToolboxUnlocked() else "")
                setDisplayStatus(txt, sColor); myPrint("B",txt)

        class QuickJVMDiags(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event): self.gatherJVMDiagnostics()                                               # noqa

            @staticmethod
            def gatherJVMDiagnostics():

                diagTxt = "Quick JVM Diagnostics:\n" \
                          " ---------------------\n\n"

                myPrint("DB", "Calling garbage collection before QuickJVMDiags()....")
                System.gc()
                Thread.sleep(100)

                diagTxt += getJVMUsageStatistics(True, True, True) + "\n\n"

                diagTxt += "Threads:\n" \
                           " -------\n"
                lastGroup = None
                for t in sorted(Thread.getAllStackTraces().keySet(), key=lambda sort_t: (sort_t.getThreadGroup().getName(), sort_t.getName().lower())):
                    tg = t.getThreadGroup().getName()
                    if lastGroup is not None and tg != lastGroup: diagTxt += "  --\n"
                    lastGroup = tg
                    diagTxt += getJVMThreadInformation(t, True)
                diagTxt += "\n"

                ct = Thread.currentThread()
                diagTxt += "** This (Toolbox) thread:        %s (id: %s) %s\n" %(pad(ct.getName(),40), rpad(ct.getId(),4), ct.getThreadGroup())

                try:
                    backgroundOpsThread = MD_REF.getBackgroundThread()
                    if backgroundOpsThread is not None:
                        backgroundOpsThreadId = backgroundOpsThread.getId()
                        diagTxt += "** Main's Background Ops Thread: %s (id: %s)\n" %(pad(backgroundOpsThread,40), rpad(backgroundOpsThreadId,4))
                except: pass

                try:
                    syncer = None
                    book = MD_REF.getCurrentAccountBook()
                    if book is not None: syncer = book.getSyncer()
                    if syncer is not None:
                        syncer_keepSyncing = getFieldByReflection(syncer, "keepSyncing")
                        if not isKotlinCompiledBuildAll():
                            syncerThread = getFieldByReflection(syncer, "syncThread")
                            syncerThreadId = syncerThread.getId() if (syncerThread) else None
                            diagTxt += "** Current Book's Sync Thread:   %s (id: %s) %s(hash: %s) (keepSyncing: %s) (Syncer.isSyncing(): %s)\n"\
                                       %(pad(syncerThread,40), rpad(syncerThreadId,4), syncer, System.identityHashCode(syncer), syncer_keepSyncing, syncer.isSyncing())
                        else:
                            diagTxt += "** Current Book's Syncer:        mainTask.isSyncing(): %s, attachmentsTask.isSyncing(): %s\n\n"\
                                       %(isSyncTaskSyncing(checkMainTask=True), isSyncTaskSyncing(checkAttachmentsTask=True))
                            syncerTasks = getFieldByReflection(syncer, "syncTasks")
                            for sTask in syncerTasks:
                                syncerThreadId = sTask.getId()
                                diagTxt += "** Current Book's Sync Thread:   %s (id: %s) %s(hash: %s) (keepSyncing: %s)\n"\
                                           %(pad(sTask,40), rpad(syncerThreadId,4), syncer, System.identityHashCode(syncer), syncer_keepSyncing)

                except:
                    if debug:
                        myPrint("B", "@@ ERROR: Failed to get syncThread / syncTasks?")
                        dump_sys_error_to_md_console_and_errorlog()

                diagTxt += "\n\nWindows:\n" \
                           " -------\n"

                def sortWindowTypes(_win):
                    if isinstance(_win, JFrame): return 3
                    if isinstance(_win, Frame):  return 2
                    return 0

                for win in sorted(Window.getWindows(), key=lambda sort_w: (sortWindowTypes(sort_w), type(sort_w), sort_w.getName())):
                    try: jMenuBarStr = "None" if win.getJMenuBar() is None else "@%s(hash: %s)" %(Integer.toHexString(System.identityHashCode(win.getJMenuBar())), System.identityHashCode(win.getJMenuBar()))
                    except: jMenuBarStr = "n/a"
                    try: menuBarStr = "None" if win.menuBar is None else "@%s(hash: %s)" %(Integer.toHexString(System.identityHashCode(win.menuBar)), System.identityHashCode(win.menuBar))
                    except: menuBarStr = "n/a"
                    try: mainMenuStr = "None" if win.mainMenu is None else "@%s(hash: %s)" %(Integer.toHexString(System.identityHashCode(win.mainMenu)), System.identityHashCode(win.mainMenu))
                    except: mainMenuStr = "n/a"
                    try: mainMenuMenuBarStr = "None" if getFieldByReflection(win.mainMenu, "menuBar") is None else "@%s(hash: %s)" %(Integer.toHexString(System.identityHashCode(getFieldByReflection(win.mainMenu, "menuBar"))), System.identityHashCode(getFieldByReflection(win.mainMenu, "menuBar")))
                    except: mainMenuMenuBarStr = "n/a"
                    diagTxt += "%s %s isFocused: %s isVisible: %s isActive: %s isDisplayable: %s isShowing: %s (JMenuBar: %s) (.menuBar: %s) (.mainMenu: %s) (.mainMenu.menuBar: %s) (Owner: %s:%s) @%s(hash: %s)\n"\
                               %(pad(type(win),80), pad(win.getName(),35),
                                 getYN(win.isFocused()), getYN(win.isVisible()), getYN(win.isActive()), getYN(win.isDisplayable()), getYN(win.isShowing()),
                                 pad(jMenuBarStr, 30), pad(menuBarStr, 30), pad(mainMenuStr, 30), pad(mainMenuMenuBarStr, 30),
                                 type(win.getOwner()), (None if (win.getOwner()) is None else win.getOwner().getName()),  Integer.toHexString(System.identityHashCode(win)), System.identityHashCode(win))

                diagTxt += "\nSwing Containers holding on to known 'book' references....:\n" \
                           " ------------------------------------------------------------\n"
                for win in sorted(Window.getWindows(), key=lambda sort_w: (sortWindowTypes(sort_w), type(sort_w), sort_w.getName())):
                    for tryBookRefStr in ["book", "bookRef"]:
                        try:
                            wr_book = None
                            ref_book = getFieldByReflection(win, tryBookRefStr)
                            if ref_book is not None:
                                if isinstance(ref_book, WeakReference):
                                    wr_book = ref_book
                                    ref_book = ref_book.get()
                                if ref_book is not None and isinstance(ref_book, AccountBook):
                                    diagTxt += "%s %s%s %s '%s' (Owner: %s:%s) (book hash: %s, win hash: %s) \n" \
                                                                                      %(pad("<<THIS BOOK>>" if (ref_book is MD_REF.getCurrentAccountBook()) else "!!OLD BOOK", 13, "!"),
                                                                                        "" if wr_book is None else "(wr)",
                                                                                        pad(win.getName(),25), pad(type(win),70), pad(ref_book.getName(),70),
                                                                                        type(win.getOwner()), (None if (win.getOwner()) is None else win.getOwner().getName()),
                                                                                        System.identityHashCode(ref_book), System.identityHashCode(win))
                            del ref_book
                        except: pass

                if not getExtensionGlobalPreferences().getBoolean(GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER, False):
                    diagTxt += "\n** Enable 'Observer' feature & restart MD to view retained references to Wrapper/Book/Syncer/Thread Objects **\n"
                else:

                    try: _observeMoneydanceObjects(_ALL_OBSERVED_BOOKS)
                    except:
                        myPrint("B", "NOPE: Could not execute _observeMoneydanceObjects().... ignoring....")
                        dump_sys_error_to_md_console_and_errorlog()
                        diagTxt += "\n@@ Failed to execute _observeMoneydanceObjects() method. Results may be incomplete! (review console) - (NOTE: ONLY WORKS WHEN RUNNING AS EXTENSION) @@\n\n"

                    diagTxt += "\nOBSERVED REFERENCES....:\n" \
                               " -------------------------\n"

                    for wr_wrapper, wr_book, wr_syncer, wr_syncerThreads in _ALL_OBSERVED_BOOKS:

                        if wr_wrapper.get() is not None:
                            diagTxt += "Observed Wrapper: @{:x}(hash: %s)\n".format(System.identityHashCode(wr_wrapper.get())) \
                                       %(System.identityHashCode(wr_wrapper.get()))
                        else:
                            diagTxt += "Observed Wrapper: <gone away>\n"

                        if wr_book.get() is not None:
                            diagTxt += "... Observed Book: %s('%s') @{:x}(hash: %s)\n".format(System.identityHashCode(wr_book.get())) \
                                       %(wr_book.get(), wr_book.get().getName(), System.identityHashCode(wr_book.get()))
                        else:
                            diagTxt += "... Observed Book: <gone away>\n"

                        if wr_syncer.get() is not None:
                            wr_keepSyncing = WeakReference(getFieldByReflection(wr_syncer.get(), "keepSyncing"))
                            wr_currentSyncThreads = []
                            if not isKotlinCompiledBuildAll():
                                wr_syncThread = WeakReference(getFieldByReflection(wr_syncer.get(), "syncThread"))
                                wr_currentSyncThreads.append(wr_syncThread)
                            else:
                                wr_syncTasks = WeakReference(getFieldByReflection(wr_syncer.get(), "syncTasks"))
                                for wr_syncTask in wr_syncTasks.get():
                                    wr_currentSyncThreads.append(WeakReference(wr_syncTask))

                            diagTxt += "...... Observed Syncer: %s(hash: %s) (keepSyncing: %s, isSyncing: %s, isPausing: %s, isRunningInBackground: %s)\n"\
                                       %(wr_syncer.get(), System.identityHashCode(wr_syncer.get()), wr_keepSyncing.get(), wr_syncer.get().isSyncing(), wr_syncer.get().isPausing(), wr_syncer.get().isRunningInBackground())

                            for wr_syncThread in wr_currentSyncThreads:
                                if wr_syncThread.get() is not None:
                                    diagTxt += "....................: Sync Thread @{:x}(hash: %s)(attached to Observed Syncer):      [id: %s, '%s', isAlive: %s]\n".format(System.identityHashCode(wr_syncThread.get()))\
                                               %(System.identityHashCode(wr_syncThread.get()), wr_syncThread.get().getId(), wr_syncThread.get().getName(), wr_syncThread.get().isAlive())     # noqa
                                else:
                                    diagTxt += "....................: Sync Thread  (attached to Observed Syncer): <gone away>\n"

                        else:
                            diagTxt += "...... Observed Syncer: <gone away>\n"

                        for wr_syncThread in wr_syncerThreads:
                            if wr_syncThread.get() is not None:
                                diagTxt += "....................: Observed Sync Thread @{:x}(hash: %s)(previously attached):     [id: %s, '%s', isAlive: %s]\n".format(System.identityHashCode(wr_syncThread.get()))\
                                           %(System.identityHashCode(wr_syncThread.get()), wr_syncThread.get().getId(), wr_syncThread.get().getName(), wr_syncThread.get().isAlive())     # noqa
                            else:
                                diagTxt += "....................: Observed Sync Thread (previously attached): <gone away>\n"

                diagTxt += "\n<END>"

                QuickJFrame("QUICK JVM DIAGNOSTICS", diagTxt, lAlertLevel=1, copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
                setDisplayStatus("Quick JVM Diagnostics displayed...", "B")

        class DisplayUUID(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In DisplayUUID().", inspect.currentframe().f_code.co_name, "()")

                uuid = myPopupAskForInput(self.theFrame,"DISPLAY OBJECT BY UUID", "UUID:", "Enter the UUID to display",
                                          defaultValue=None,isPassword=False,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                if StringUtils.isEmpty(uuid): return

                uuid = uuid.strip()

                obj = MD_REF.getCurrentAccountBook().getItemForID(uuid)
                if obj is None: obj = MD_REF.getCurrentAccountBook().getItemForID(uuid.lower())                   # noqa

                # We search Txns too as Splits by their UUID (for example) can only be found this way...
                if obj is None: obj = MD_REF.getCurrentAccountBook().getTransactionSet().getTxnByID(uuid)
                if obj is None: obj = MD_REF.getCurrentAccountBook().getTransactionSet().getTxnByID(uuid.lower()) # noqa
                if obj is None: obj = TxnUtil.getTxnByID(MD_REF.getCurrentAccountBook().getTransactionSet(), uuid)

                if obj is None: return

                if isinstance(obj, AbstractTxn):
                    MD_REF.getUI().showTxnXML(obj, self.theFrame)
                else:
                    MD_REF.getUI().showRawItemDetails(obj, self.theFrame)

        class OnlineBankingToolsButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa

                # OFX BANKING MENU
                try:
                    user_UNLOCKMDPlusDiagnostic = MenuJRadioButton("UNLOCKED - Moneydance+ Diagnostics (READONLY)", False, secondaryEnabled=(isToolboxUnlocked() and isMDPlusEnabledBuild()))
                    user_UNLOCKMDPlusDiagnostic.setToolTipText("When Toolbox is unlocked, will display extra MD+ Diagnostics - DO NOT SHARE WITH OTHERS!")
                    user_UNLOCKMDPlusDiagnostic.setForeground(MD_REF.getUI().getColors().accountIconTint)

                    user_online_banking_view_configuration_data = MenuJRadioButton("View online banking configuration / connection data (OFX/DC and MD+) - VERY USEFUL, START HERE!", False)
                    user_online_banking_view_configuration_data.setToolTipText("This will display all the stored setup data relating to your online banking configurations (OFX and MD+)")

                    user_searchOFXData = MenuJRadioButton("Search for stored OFX/MD+ related data", False)
                    user_searchOFXData.setToolTipText("This searches for Online Banking (OFX/DC & MD+) related setup information in most places...")

                    user_viewListALLMDServices = MenuJRadioButton("View list of MD's Bank dynamic OFX/DC setup profiles (then select one)", False)
                    user_viewListALLMDServices.setToolTipText("This will display Moneydance's dynamic setup profiles for all banks - pulled from Infinite Kind's website..")

                    user_view_CUSIP_settings = MenuJRadioButton("View your Security's hidden CUSIP settings (The link between your Bank's Securities & MD Securities)", False)
                    user_view_CUSIP_settings.setToolTipText("This will show your Security's hidden CUSIP settings. These link your downloads on Investment Securities to MD Securities")

                    user_viewOnlineTxnsPayeesPayments = MenuJRadioButton("View your Online Txns/Payees/Payments", False)
                    user_viewOnlineTxnsPayeesPayments.setToolTipText("This will show you your cached Online Txns (there should be none) and also your saved online payees and payments")

                    user_viewAllLastTxnDownloadDates = MenuJRadioButton("View all your OFX last download txn dates (for all accounts)", False)
                    user_viewAllLastTxnDownloadDates.setToolTipText("View all your OFX last download txn dates (across all accounts)")

                    user_viewReconcileAsOfDates = MenuJRadioButton("View your active accounts' calculated reconcile window auto 'as of' dates (Bank/Credit Cards/Investment)", False)
                    user_viewReconcileAsOfDates.setToolTipText("Displays how the reconcile as_of date is calculated for your active accounts")

                    user_forgetOFXBankingLink = MenuJRadioButton("Forget OFX Banking File Import Link (remove_ofx_account_bindings.py) (MD versions < MD2022)", False, updateMenu=True, secondaryEnabled=(not isMDPlusEnabledBuild() or isToolboxUnlocked()))
                    user_forgetOFXBankingLink.setToolTipText("Force MD to forget OFX Banking Import link attributed to an Account. Moneydance will ask you to recreate the link on next import.. THIS CHANGES DATA! (remove_ofx_account_bindings.py)")

                    user_manageCUSIPLink = MenuJRadioButton("Reset/Fix/Edit/Add CUSIP Banking Link (remove_ofx_security_bindings.py)", False, updateMenu=True)
                    user_manageCUSIPLink.setToolTipText("Allows you to reset/add/edit/move your CUSIP banking link between security records. THIS CHANGES DATA! (remove_ofx_security_bindings.py)")

                    user_updateOFXLastTxnUpdate = MenuJRadioButton("Update OFX Last Txn Update Date (Downloaded) field for an account (MD versions >= 2022 use Online menu)", False, updateMenu=True)
                    user_updateOFXLastTxnUpdate.setToolTipText("Allows you to edit the last download txn date which is used to set the start date for txn downloads - THIS CHANGES DATA!")

                    user_reset_OFXLastTxnUpdate_dates = MenuJRadioButton("Reset ALL OFX Last Txn Update Dates (default, OFX and MD+) (MD 2022.3(4074) onwards)", False, updateMenu=True, secondaryEnabled=(isMulti_OFXLastTxnUpdate_build()))
                    user_reset_OFXLastTxnUpdate_dates.setToolTipText("Allows you to reset ALL the last download txn dates used to set the start date for txn downloads (2022.3(4074) onwards) - THIS CHANGES DATA!")

                    user_removeDownloadedDataFromTxns = MenuJRadioButton("Remove/disable (hidden) MD+/OFX(/QIF) data from downloaded Txns within an Account", False, updateMenu=True)
                    user_removeDownloadedDataFromTxns.setToolTipText("Will remove/disable hidden MD+/OFX(/QIF) data from downloaded Transactions (useful to address as_of reconcile date issues) - THIS CHANGES DATA!")

                    user_deleteOFXBankingLogonProfile = MenuJRadioButton("Delete OFX Banking Service / Logon Profile (remove_one_service.py)", False, updateMenu=True)
                    user_deleteOFXBankingLogonProfile.setToolTipText("This will allow you to delete an Online Banking logon / service profile (service) from Moneydance. E.g. you will have to set this up again. THIS CHANGES DATA! (remove_one_service.py)")

                    user_cleanupMissingOnlineBankingLinks = MenuJRadioButton("Cleanup missing Online Banking Links", False, updateMenu=True)
                    user_cleanupMissingOnlineBankingLinks.setToolTipText("This Cleans up missing Online Banking Links - NOTE: Always called when 'Delete OFX Banking Service / Logon Profile' is run. THIS CHANGES DATA!")

                    user_authenticationManagement = MenuJRadioButton("OFX Authentication Management (various functions to manage authentication, UserIDs, ClientUIDs)", False, updateMenu=True)
                    user_authenticationManagement.setToolTipText("Brings up the sub menu. Allows you to clear your authentication cache (single or all) and edit user IDs/ClientUIDs. THIS CAN CHANGE DATA!")

                    user_deleteOnlineTxns = MenuJRadioButton("Delete Single cached OnlineTxnList Record/Txns", False, updateMenu=True)
                    user_deleteOnlineTxns.setToolTipText("Allows you to surgically remove your cached Online Txn List txns - THESE SHOULD NOT BE HERE! THIS CHANGES DATA!")

                    user_deleteALLOnlineTxns = MenuJRadioButton("Delete ALL cached OnlineTxnList Record/Txns (delete_intermediate_downloaded_transaction_caches.py)", False, updateMenu=True)
                    user_deleteALLOnlineTxns.setToolTipText("Purges/cleans any/all your cached Online Txn List records / txns - THERE SHOULD BE NONE! VERY SAFE TO RUN! THIS CHANGES DATA! (delete_intermediate_downloaded_transaction_caches.py)")

                    user_cookieManagement = MenuJRadioButton("OFX Cookie Management", False, updateMenu=True)
                    user_cookieManagement.setToolTipText("Brings up the sub menu. Allows you to manage your OFX cookies - THIS CAN CHANGE DATA!")

                    user_forceMDPlusNameCacheAccessTokensRebuild = MenuJRadioButton("Force MD+ name cache & access tokens rebuild", False, updateMenu=True)
                    user_forceMDPlusNameCacheAccessTokensRebuild.setToolTipText("Wipes your internal MD+ cached bank names and access tokens. These should rebuild themselves. THIS CHANGES DATA!")

                    user_forceDisconnectMDPlusConnection = MenuJRadioButton("Force Disconnect an MD+ Connection (USE WITH CARE) (MD 2022.5(4090) onwards)", False, updateMenu=True, secondaryEnabled=(isMDPlusGetPlaidClientEnabledBuild()))
                    user_forceDisconnectMDPlusConnection.setToolTipText("Attempts to force disconnect and MD+ connection. THIS CHANGES DATA!")

                    user_export_MDPlus_LicenseObject = MenuJRadioButton("Export your Moneydance+ (Plaid) license (keys) to a file (for 'transplant')", False, updateMenu=True)
                    user_export_MDPlus_LicenseObject.setToolTipText("This will Export your stored Moneydance+ (Plaid) license (keys) etc to a file (for 'transplant'). READONLY")

                    user_import_MDPlus_LicenseObject = MenuJRadioButton("Import ('transplant') your Moneydance+ (Plaid) license (keys) from a file (exported by Toolbox)", False, updateMenu=True)
                    user_import_MDPlus_LicenseObject.setToolTipText("This will Import ('transplant') your Moneydance+ (Plaid) license (keys) from a file exported by Toolbox. THIS CHANGES DATA!")

                    user_zapMDPlusProfile = MenuJRadioButton("ZAP your Moneydance+ (Plaid) settings (only when status is NOT 'activated')", False, updateMenu=True, secondaryEnabled=(not isMDPlusLicenseActivated() or isToolboxUnlocked()))
                    user_zapMDPlusProfile.setToolTipText("This will delete your stored Moneydance+ (Plaid) data/keys (including banking links) etc - E.g. you will have to set this up again. THIS CHANGES DATA!")

                    user_manuallyPrimeUSAARootUserIDClientIDs = MenuJRadioButton("USAA ONLY: (NEW METHOD) Manually 'prime' / overwrite stored Root UserIDs/ClientUIDs", False, updateMenu=True)
                    user_manuallyPrimeUSAARootUserIDClientIDs.setToolTipText("USAA Only: Allows you to 'prime' / overwrite stored UserIDs/ClientUIDs for USSA")

                    # user_createUSAAProfile = MenuJRadioButton("USAA Only: (DEPRECATED METHOD) Executes the special script to create a working USAA OFX Profile", False, updateMenu=True)
                    # user_createUSAAProfile.setToolTipText("Executes: ofx_create_new_usaa_bank_custom_profile.py - THIS CHANGES DATA!")

                    userFilters = JPanel(GridLayout(0, 1))

                    rowHeight = 24
                    rows = 8
                    userFilters.add(ToolboxMode.DEFAULT_MENU_READONLY_TXT_LBL)

                    if isToolboxUnlocked():
                        rows += 1
                        userFilters.add(user_UNLOCKMDPlusDiagnostic)

                    userFilters.add(user_online_banking_view_configuration_data)
                    userFilters.add(user_searchOFXData)
                    userFilters.add(user_viewListALLMDServices)
                    userFilters.add(user_view_CUSIP_settings)
                    userFilters.add(user_viewOnlineTxnsPayeesPayments)
                    userFilters.add(user_viewAllLastTxnDownloadDates)
                    userFilters.add(user_viewReconcileAsOfDates)
                    # userFilters.add(user_toggleOFXDebug)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 13
                        userFilters.add(JLabel(" "))
                        userFilters.add(ToolboxMode.DEFAULT_MENU_UPDATE_TXT_LBL)
                        if not ToolboxMode.isUpdateMode():
                            rows += 1
                            userFilters.add(ToolboxMode.getMenuLabel())

                        userFilters.add(user_forgetOFXBankingLink)
                        userFilters.add(user_manageCUSIPLink)
                        userFilters.add(user_updateOFXLastTxnUpdate)
                        userFilters.add(user_reset_OFXLastTxnUpdate_dates)
                        userFilters.add(user_removeDownloadedDataFromTxns)
                        userFilters.add(user_deleteOFXBankingLogonProfile)
                        userFilters.add(user_cleanupMissingOnlineBankingLinks)
                        userFilters.add(user_authenticationManagement)
                        userFilters.add(user_deleteOnlineTxns)
                        userFilters.add(user_deleteALLOnlineTxns)
                        userFilters.add(user_cookieManagement)

                        if isMDPlusEnabledBuild():
                            rows += 5
                            userFilters.add(user_forceMDPlusNameCacheAccessTokensRebuild)
                            userFilters.add(user_forceDisconnectMDPlusConnection)
                            userFilters.add(user_export_MDPlus_LicenseObject)
                            userFilters.add(user_import_MDPlus_LicenseObject)
                            userFilters.add(user_zapMDPlusProfile)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 2
                        userFilters.add(JLabel(" "))
                        userFilters.add(user_manuallyPrimeUSAARootUserIDClientIDs)
                        # userFilters.add(user_createUSAAProfile)

                    bg = setupMenuRadioButtons(userFilters)

                    while True:
                        if MD_REF.getCurrentAccountBook() is None: return

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters, 875, (rowHeight * rows))
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Online Banking Tools",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Online Banking Tools - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_forgetOFXBankingLink.isSelected():                      forgetOFXImportLink()
                        if user_deleteOFXBankingLogonProfile.isSelected():              deleteOFXService()
                        if user_cleanupMissingOnlineBankingLinks.isSelected():          cleanupMissingOnlineBankingLinks(lAutoPurge=False)
                        if user_manageCUSIPLink.isSelected():                           CUSIPFix()
                        if user_UNLOCKMDPlusDiagnostic.isSelected():                    UNLOCKMDPlusDiagnostic()
                        if user_authenticationManagement.isSelected():                  OFX_authentication_management()
                        if user_forceMDPlusNameCacheAccessTokensRebuild.isSelected():   forceMDPlusNameCacheAccessTokensRebuild()
                        if user_forceDisconnectMDPlusConnection.isSelected():           forceDisconnectMDPlusConnection()
                        if user_export_MDPlus_LicenseObject.isSelected():               export_MDPlus_LicenseObject()
                        if user_import_MDPlus_LicenseObject.isSelected():               import_MDPlus_LicenseObject()
                        if user_zapMDPlusProfile.isSelected():                          zap_MDPlus_Profile()
                        if user_cookieManagement.isSelected():                          OFX_cookie_management()
                        if user_deleteOnlineTxns.isSelected():                          OFX_delete_saved_online_txns()
                        if user_deleteALLOnlineTxns.isSelected():                       OFX_delete_ALL_saved_online_txns()
                        if user_manuallyPrimeUSAARootUserIDClientIDs.isSelected():      manuallyPrimeUSAARootUserIDClientIDs()
                        # if user_createUSAAProfile.isSelected():                         createUSAAProfile()
                        if user_updateOFXLastTxnUpdate.isSelected():                    OFX_update_OFXLastTxnUpdate()
                        if user_reset_OFXLastTxnUpdate_dates.isSelected():              OFX_reset_OFXLastTxnUpdate_dates()
                        if user_removeDownloadedDataFromTxns.isSelected():              OFX_removeDownloadedDataFromTxns()
                        if user_searchOFXData.isSelected():                             CuriousViewInternalSettingsButtonAction(lOFX=True).actionPerformed("")
                        if user_viewListALLMDServices.isSelected():                     download_md_fiscal_setup()
                        if user_view_CUSIP_settings.isSelected():                       OFX_view_CUSIP_settings()
                        if user_viewOnlineTxnsPayeesPayments.isSelected():              OFX_view_online_txns_payees_payments()
                        if user_viewAllLastTxnDownloadDates.isSelected():               OFX_view_all_last_txn_download_dates()
                        if user_viewReconcileAsOfDates.isSelected():                    OFX_view_reconcile_AsOf_Dates()
                        if user_online_banking_view_configuration_data.isSelected():    online_banking_view_configuration_data()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class FixDropboxOneWaySyncButtonAction(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):                                                                           # noqa
                # fix_dropbox_one_way_syncing.py
                # reset_sync_and_dropbox_settings.py
                theKey = "migrated.netsync.dropbox.fileid"

                titleText = "Remove legacy Dropbox Migrated Sync Key".upper()
                question  = "Remove '%s' key to fix Dropbox one-way & iCloud Sync issues?" %(theKey)

                if not confirm_backup_confirm_disclaimer(toolbox_frame_, titleText, question):
                    return

                myPrint("B","%s: Removing key '%s' from LocalStorage() at user request...." %(titleText, theKey))

                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                LS.remove(theKey)
                LS.save()

                MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record...

                self.myButton.setVisible(False)
                self.myButton.setEnabled(False)

                txt = "%s: Completed. MONEYDANCE WILL NOW RESTART" %(titleText)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                logToolboxUpdates("FixDropboxOneWaySyncButtonAction", txt)
                play_the_money_sound()
                myPopupInformationBox(toolbox_frame_,txt,titleText,JOptionPane.WARNING_MESSAGE)
                ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

        class RegisterMoneydance(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):                                                                           # noqa
                # if MD_REF.isRegistered(): return
                LicenseKeyWindow(MD_REF.getUI(), toolbox_frame_).setVisible(True)


        class MakeDropBoxSyncFolder(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):                                                                           # noqa
                if check_for_dropbox_folder():
                    txt = "Sorry - Fix: Create .moneydancesync folder button not available!? NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPrint("B","MakeDropBoxSyncFolder() called, but check_for_dropbox_folder() returned True - so we should not be here? FIX NOT AVAILABLE")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if not myPopupAskQuestion(toolbox_frame_,
                                          "DROPBOX",
                                          "Create missing Dropbox .moneydancesync folder?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.ERROR_MESSAGE):

                    txt = "User declined to create missing Dropbox .moneydancesync folder - NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                self.myButton.setVisible(False)
                self.myButton.setEnabled(False)

                userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
                baseFolder = File(userHomeProperty, "Dropbox")

                try:
                    if File(baseFolder, ".moneydancesync").mkdir():
                        txt = "Created Dropbox .moneydancesync folder in Dropbox"
                        setDisplayStatus(txt, "B"); myPrint("B", txt)
                        logToolboxUpdates("MakeDropBoxSyncFolder", txt, onlyLogGenericEntry=True)
                        play_the_money_sound()
                        myPopupInformationBox(toolbox_frame_, txt, "DROPBOX", JOptionPane.WARNING_MESSAGE)
                        return

                except: dump_sys_error_to_md_console_and_errorlog()

                txt = "Error creating Dropbox .moneydancesync folder!?"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_, txt, "DROPBOX", JOptionPane.ERROR_MESSAGE)

        class FindDatasetButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa
                _THIS_METHOD_NAME = "FIND DATASET"

                if not myPopupAskQuestion(toolbox_frame_,
                                          "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)/BACKUP(s)",
                                          "This may be time consuming...Do you want to continue with search?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.WARNING_MESSAGE):

                    txt = "%s: User Aborted Dataset search..." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                whatType = ["Datasets",
                             "Backups"]


                selectedWhat = JOptionPane.showInputDialog(     toolbox_frame_,
                                                                "WHAT TYPE OF DATASET?",
                                                                "Choose Datasets or Backups",
                                                                JOptionPane.INFORMATION_MESSAGE,
                                                                getMDIcon(lAlwaysGetIcon=True),
                                                                whatType,
                                                                None)
                if selectedWhat is None:
                    txt = "%s: No Dataset Type was selected - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if whatType.index(selectedWhat) == 0:
                    lBackup=False
                    theExtension = "*.moneydance".lower()
                elif whatType.index(selectedWhat) == 1:
                    lBackup=True
                    theExtension = "*.moneydancearchive".lower()
                else:
                    txt = "%s: Dataset Type Error - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                myPrint("DB", "Dataset type: %s" %(theExtension))

                if Platform.isWindows():
                    theRoot = os.path.join("C:" + os.path.sep)
                else:
                    theRoot = os.path.sep

                lRootExclusions = False

                whereFrom = [ "From UserDir: %s" %get_home_dir(),
                              "From Root: %s (excluding some system locations and other volumes)" %theRoot,
                              "From Root: %s (nothing excluded - might take a long time / never finish)" %theRoot,
                              "Select your own start point"]

                selectedStart = JOptionPane.showInputDialog(toolbox_frame_,
                                                            "Select the Search start folder",
                                                            "WHERE TO SEARCH FROM",
                                                            JOptionPane.INFORMATION_MESSAGE,
                                                            getMDIcon(lAlwaysGetIcon=True),
                                                            whereFrom,
                                                            None)
                if selectedStart is None:
                    txt = "%s: No start point was selected - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if whereFrom.index(selectedStart) == 3:

                    theTitle = "Select location to start %s Dataset Search (CANCEL=ABORT)" %(theExtension)
                    theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                                        get_home_dir(),         # Starting path
                                                        None,                   # Default Filename
                                                        theTitle,               # Title
                                                        False,                  # Multi-file selection mode
                                                        True,                   # True for Open/Load, False for Save
                                                        False,                  # True = Files, else Dirs
                                                        "START SEARCH",         # Load/Save button text, None for defaults
                                                        None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                        lAllowTraversePackages=True,
                                                        lAllowTraverseApplications=True,
                                                        lForceJFC=False,
                                                        lForceFD=False,
                                                        lAllowNewFolderButton=False,
                                                        lAllowOptionsButton=False)

                    if theDir is None or theDir == "":
                        txt = "%s: User did not select Search Directory... Aborting" %(_THIS_METHOD_NAME)
                        setDisplayStatus(txt, "R")
                        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                        return None

                elif whereFrom.index(selectedStart) == 2:  # From ROOT with no exclusions
                    theDir = theRoot
                elif whereFrom.index(selectedStart) == 1:  # From ROOT with exclusions
                    lRootExclusions = True
                    theDir = theRoot
                elif whereFrom.index(selectedStart) == 0:  # From User Home Dir
                    theDir = get_home_dir()
                else:
                    txt = "%s: Error Selecting Search Directory... Aborting" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching..",theTitle=_THIS_METHOD_NAME, lModal=False, OKButtonText="WAIT")
                diag.go()

                save_list_of_found_files=[]

                myPrint("B","DATASET Search >> Searching from Directory: %s" %theDir)

                def findDataset(pattern, path):
                    iFound=0                                                                                            # noqa
                    result = []
                    dotCounter = 0
                    thingsSearched = 0

                    lContinueToEnd=False

                    if not GlobalVars.i_am_an_extension_so_run_headless:
                        print "Searching for your %s Datasets (might be time consuming):."%theExtension,

                    exclude_these_dirs = []

                    if lRootExclusions:
                        if Platform.isOSX():
                            exclude_these_dirs = ["/System", "/Library"]
                        elif Platform.isUnix():
                            exclude_these_dirs = ["/media", "/boot", "/cdrom", "/sys", "/proc", "/dev", "/mnt"]
                        myPrint("B","Root exclusions requested... These are: %s" %(exclude_these_dirs))

                    start_time = time.time()
                    timeOutCheckBackMinutes = 10.0
                    timeOutSeconds = 10

                    class MyTimerTask(TimerTask):

                        def __init__(self, dlg, theTimer):
                            self.dlg = dlg
                            self.theTimer = theTimer

                        def run(self):
                            myPrint("DB", "Timer task triggered - closing the JOption Pane....")
                            self.dlg.setVisible(False)
                            self.theTimer.cancel()
                            return

                    class MyJOptionPaneListener(ComponentAdapter):

                        def __init__(self, timeout, dlg):
                            self.timeout = timeout
                            self.dlg = dlg
                            self.t = None

                        def componentShown(self, e):
                            super(MyJOptionPaneListener, self).componentShown(e)                                        # noqa
                            myPrint("DB", "Toolbox setting up Timer Task for Search function to kill Search dialog...")
                            self.t = Timer("toolbox_finddataset_timer", True)
                            self.t.schedule(MyTimerTask(self.dlg,self.t), self.timeout)

                        def componentHidden(self, e):
                            super(MyJOptionPaneListener, self).componentHidden(e)                                       # noqa
                            myPrint("DB", "Killing Timer Task for Search function as dialog closed...")
                            self.t.cancel()

                    # showOptionDialog(Component parentComponent, Object message, String title, int optionType, int messageType, Icon icon, Object[] options, Object initialValue)
                    def showConfirmDialogWithTimeout(theFrame, theMessage, _theTitle, theOptionType, theMessageType, theIcon, theChoices, theInitialValue, timeout_ms, timeoutChoice):
                        theMsg = JOptionPane(theMessage, theMessageType, theOptionType, theIcon, theChoices, theInitialValue)
                        dlg = theMsg.createDialog(theFrame, _theTitle)
                        dlg.setAlwaysOnTop(True)
                        dlg.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)
                        theListener = MyJOptionPaneListener( timeout_ms, dlg )
                        dlg.addComponentListener( theListener )
                        dlg.setVisible(True)
                        selectedValue = theMsg.getValue()
                        dlg.removeComponentListener( theListener )
                        del theListener
                        if selectedValue is None or selectedValue < 0:
                            return -1
                        try:
                            return theChoices.index(selectedValue)
                        except:
                            pass    # Probably "uninitializedValue"

                        return theChoices.index(timeoutChoice)

                    options=["STOP HERE","SEARCH TO END", "KEEP ASKING"]

                    for root, dirs, files in os.walk(path, topdown=True):

                        if debug: myPrint("DB","Searching: %s" %(root))

                        if dotCounter % 1000 <1:
                            if not GlobalVars.i_am_an_extension_so_run_headless: print ".",

                        if (not dotCounter
                                or (dotCounter % 10000 <1 and not lContinueToEnd)
                                or (time.time() - start_time > (timeOutCheckBackMinutes*60))):

                            start_time = time.time()

                            # ####
                            response = showConfirmDialogWithTimeout(toolbox_frame_,
                                                                    "Are you OK to continue (so far..: %s found / %s files/searched)?" %(iFound, thingsSearched),
                                                                    "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)",
                                                                    JOptionPane.YES_NO_OPTION,
                                                                    JOptionPane.QUESTION_MESSAGE,
                                                                    getMDIcon(None),
                                                                    options,
                                                                    options[2],
                                                                    timeOutSeconds * 1000,
                                                                    options[2])

                            if response < 1:
                                _txt = "%s: User Aborted Dataset search..." %(_THIS_METHOD_NAME)
                                setDisplayStatus(_txt, "R"); myPrint("B", _txt)
                                return result, iFound
                            elif response == 1:
                                lContinueToEnd = True
                            elif response == 2:
                                pass

                        dotCounter+=1

                        # Remove /System dir etc on Mac/Linux....
                        if lRootExclusions:
                            for d in list(dirs):
                                for ex in exclude_these_dirs:
                                    if (root+d).startswith(ex):
                                        dirs.remove(d)

                        if lBackup:

                            for name in files:
                                fp = os.path.join(root,name)
                                if os.path.islink(fp):
                                    myPrint("DB", "found file link! %s - will skip" %fp)
                                    continue

                                thingsSearched+=1
                                if fnmatch.fnmatch(name, pattern):
                                    iFound+=1
                                    result.append("File >> Sz: %sMB Mod: %s Name: %s "
                                                  %(rpad(convertBytesMBs(os.path.getsize(os.path.join(root, name))),6),
                                                    pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11),
                                                    os.path.join(root, name)))
                        for name in dirs:
                            fp = os.path.join(root,name)
                            if os.path.islink(fp):
                                myPrint("DB", "found dir link! %s - will skip" %fp)
                                continue

                            thingsSearched+=1
                            if fnmatch.fnmatch(name, pattern):
                                if name != ".moneydance":
                                    save_list_of_found_files.append(fp)
                                    iFound+=1
                                result.append("Dir >> Modified: %s %s"
                                              %(pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11),
                                              os.path.join(root, name)))
                    return result, iFound

                fileList, iFound = findDataset(theExtension, theDir)

                diag.kill()

                print
                myPrint("B","Completed search for %s datafiles: %s found" %(theExtension,iFound))

                niceFileList="\n SEARCH FOR MONEYDANCE (%s) DATASETS\n" %(theExtension)
                niceFileList+="Search started from Directory: %s\n\n" %(theDir)

                if lRootExclusions:
                    niceFileList+="(NOTE: Root search exclusions of other volumes and some system locations were requested too)\n\n"

                if not iFound:
                    niceFileList+="\n<NONE FOUND>\n"

                for x in fileList:
                    myPrint("B","Found: %s" %x)
                    niceFileList+=x+"\n"

                txt = "Find my %s datasets(s) found %s possible files/directories" %(theExtension,iFound)
                setDisplayStatus(txt, "DG")

                jif = QuickJFrame("LIST OF MONEYDANCE %s DATASETS FOUND" %(theExtension),
                                  niceFileList,
                                  lAlertLevel=1,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

                myPopupInformationBox(jif, "%s %s Datasets located...." %(iFound,theExtension), _THIS_METHOD_NAME, JOptionPane.INFORMATION_MESSAGE)

                if not lBackup:
                    add_to_ext_list=[]
                    internalDir = Common.getDocumentsDirectory().getCanonicalPath()

                    externalFiles = AccountBookUtil.getExternalAccountBooks()
                    externalFiles_asList = []
                    for wrapperOrBook in externalFiles:
                        _book = wrapperOrBook if isinstance(wrapperOrBook, AccountBook) else wrapperOrBook.getBook()    # changed in MD2023.2(5020) to return [books]
                        externalFiles_asList.append(_book.getRootFolder().getCanonicalPath())
                        del _book

                    for filename in save_list_of_found_files:
                        if not os.path.exists(filename):
                            continue
                        if internalDir in filename:
                            continue
                        if filename in externalFiles_asList:
                            continue
                        add_to_ext_list.append(filename)

                    myPrint("DB","Found %s external files that can be added to config.dict: %s" %(len(add_to_ext_list),add_to_ext_list))

                    if (len(add_to_ext_list) > 0
                            and myPopupAskQuestion(jif, _THIS_METHOD_NAME, "%s of these datasets are not showing in your File/Open menu list(and config.dict)? WOULD YOU LIKE TO ADD ANY OF THEM?" %(len(add_to_ext_list))) ):

                        backup_config_dict(True)

                        iAdded = 0
                        externalFilesVector = MD_REF.getUI().getPreferences().getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, StreamVector())
                        for add_this_file in add_to_ext_list:
                            if not myPopupAskQuestion(jif,"ADD FILE TO FILE/OPEN MENU","ADD: %s?" %((add_this_file))):
                                continue
                            iAdded+=1
                            myPrint("B","SEARCH FOR DATASETS - %s added to config.dict and file/open menu" %(add_this_file))
                            externalFilesVector.add(add_this_file)
                            MD_REF.getUI().getPreferences().setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilesVector)

                        if iAdded:
                            MD_REF.savePreferences()
                            myPopupInformationBox(jif, "SEARCH FOR DATASETS - %s files added to config.dict and file/open menu (RESTART MD REQUIRED)" %(iAdded), "DATASET SEARCH", JOptionPane.INFORMATION_MESSAGE)


        class AccountsCategoriesMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa

                try:
                    user_view_check_number_settings = MenuJRadioButton("View Check Number Settings", False)
                    user_view_check_number_settings.setToolTipText("View the Check Number settings that will display in the Transaction Register")

                    user_force_change_accounts_currency = MenuJRadioButton("FIX: FORCE Change an Account's / Category's Currency (force_change_account_currency.py)", False, updateMenu=True)
                    user_force_change_accounts_currency.setToolTipText("This allows you to FORCE change an Account's / Category's currency - USE WITH CARE!.. THIS CHANGES DATA! (force_change_account_currency.py)")

                    user_force_change_all_accounts_cats_currency = MenuJRadioButton("FIX: FORCE Change ALL Accounts' / Categories' Currencies (force_change_all_currencies.py)", False, updateMenu=True)
                    user_force_change_all_accounts_cats_currency.setToolTipText("This allows you to FORCE change ALL Accounts' / Categories' Currencies - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")

                    user_force_change_accounts_cats_from_to_currency = MenuJRadioButton("FIX: FORCE Change Accounts / Categories [& Securities] FROM Currency TO Currency", False, updateMenu=True)
                    user_force_change_accounts_cats_from_to_currency.setToolTipText("This allows you to FORCE change Accounts / Categories [& Securities] from one currency to another - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")

                    user_force_change_an_accounts_type = MenuJRadioButton("FIX: FORCE Change an Account's Type (set_account_type.py)", False, updateMenu=True)
                    user_force_change_an_accounts_type.setToolTipText("This allows you to FORCE change an Account's Type - USE WITH CARE!.. THIS CHANGES DATA! (set_account_type.py)")

                    user_view_zero_bal_cats = MenuJRadioButton("DIAG: Categories and Balances Report", False)
                    user_view_zero_bal_cats.setToolTipText("This will list all your Categories and show which have Zero Balances - USE UPDATE MODE TO MAKE THESE INACTIVE")

                    user_inactivate_zero_bal_cats = MenuJRadioButton("FIX: Make Zero Balance Categories Inactive", False, updateMenu=True)
                    user_inactivate_zero_bal_cats.setToolTipText("This will allow you Inactivate all Categories with Zero Balances (you will see the report first). THIS CHANGES DATA!")

                    user_add_alternative_bank_number = MenuJRadioButton("FIX: Add alternative account numbers for 'Accounts and bank/account number' report (above)", False, updateMenu=True)
                    user_add_alternative_bank_number.setToolTipText("Enter alternative account number(s) to print in the 'Accounts and bank/account number' report above. THIS CHANGES DATA!")

                    user_view_shouldBeIncludedInNetWorth_settings = MenuJRadioButton("DIAG: View Accounts' shouldBeIncludedInNetWorth() settings...", False)
                    user_view_shouldBeIncludedInNetWorth_settings.setToolTipText("This will list all Accounts/Categories and the shouldBeIncludedInNetWorth() setting - USE UPDATE MODE TO EDIT")

                    user_reportAccountNumbers = MenuJRadioButton("DIAG: Produce report of Accounts and bank/account number information (Useful for legacy / Will making)", False)
                    user_reportAccountNumbers.setToolTipText("This produces a report of bank accounts along with account & sort numbers etc... ")

                    user_edit_shouldBeIncludedInNetWorth_settings = MenuJRadioButton("FIX: Edit an Account's shouldBeIncludedInNetWorth() setting", False, updateMenu=True)
                    user_edit_shouldBeIncludedInNetWorth_settings.setToolTipText("This will allow you to edit an Account's shouldBeIncludedInNetWorth() setting. THIS CHANGES DATA!")

                    user_fix_accounts_parent = MenuJRadioButton("FIX: Account's Invalid Parent Account (fix_account_parent.py)", False, updateMenu=True)
                    user_fix_accounts_parent.setToolTipText("This will diagnose your Parent Accounts and fix if invalid. THIS CHANGES DATA! (fix_account_parent.py)")

                    bookName = MD_REF.getCurrentAccountBook().getName().strip()
                    root = MD_REF.getCurrentAccountBook().getRootAccount()
                    rootName = root.getAccountName().strip()
                    user_fix_root_account_name = MenuJRadioButton("FIX: Correct Root Account Name (Only enabled if the name is incorrect)", False, updateMenu=True, secondaryEnabled=(rootName != bookName))
                    user_fix_root_account_name.setToolTipText("This allows you to change the (nearly) hidden Master/Parent Account Name in Moneydance (referred to as ROOT) to match the name of your Dataset (referred to as BOOK). THIS CHANGES DATA!")

                    labelFYI_curr_fix = JLabel("       ** disabled when a serious currency/security issue has been detected **")
                    labelFYI_curr_fix.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    rowHeight = 24
                    rows = 5

                    userFilters.add(ToolboxMode.DEFAULT_MENU_READONLY_TXT_LBL)
                    userFilters.add(user_view_check_number_settings)
                    userFilters.add(user_view_zero_bal_cats)
                    userFilters.add(user_view_shouldBeIncludedInNetWorth_settings)
                    userFilters.add(user_reportAccountNumbers)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 11
                        userFilters.add(JLabel(" "))
                        userFilters.add(ToolboxMode.DEFAULT_MENU_UPDATE_TXT_LBL)

                        if not ToolboxMode.isUpdateMode():
                            rows += 1
                            userFilters.add(ToolboxMode.getMenuLabel())

                        userFilters.add(user_add_alternative_bank_number)
                        userFilters.add(user_inactivate_zero_bal_cats)
                        userFilters.add(user_edit_shouldBeIncludedInNetWorth_settings)
                        userFilters.add(user_force_change_an_accounts_type)
                        userFilters.add(user_force_change_accounts_currency)
                        userFilters.add(user_force_change_all_accounts_cats_currency)
                        userFilters.add(user_force_change_accounts_cats_from_to_currency)
                        userFilters.add(user_fix_accounts_parent)
                        userFilters.add(user_fix_root_account_name)

                    bg = setupMenuRadioButtons(userFilters)

                    while True:
                        if MD_REF.getCurrentAccountBook() is None: return

                        bookName = MD_REF.getCurrentAccountBook().getName().strip()
                        root = MD_REF.getCurrentAccountBook().getRootAccount()
                        rootName = root.getAccountName().strip()

                        user_fix_root_account_name.setEnabled(ToolboxMode.isUpdateMode() and (rootName != bookName))

                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters, 950, (rowHeight * rows))
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Accounts / Categories Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Accounts / Categories Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_view_check_number_settings.isSelected():                        view_check_num_settings()
                        if user_view_zero_bal_cats.isSelected():                                zero_bal_categories(False)
                        if user_inactivate_zero_bal_cats.isSelected():                          zero_bal_categories(True)
                        if user_add_alternative_bank_number.isSelected():                       reportAccountNumbers(lEditAlternativeAccountNumbers=True)
                        if user_reportAccountNumbers.isSelected():                              reportAccountNumbers()
                        if user_view_shouldBeIncludedInNetWorth_settings.isSelected():          view_shouldBeIncludedInNetWorth_settings()
                        if user_edit_shouldBeIncludedInNetWorth_settings.isSelected():          edit_shouldBeIncludedInNetWorth_settings()
                        if user_force_change_an_accounts_type.isSelected():                     force_change_account_type()
                        if user_force_change_accounts_currency.isSelected():                    force_change_account_cat_currency()
                        if user_force_change_all_accounts_cats_currency.isSelected():           force_change_all_accounts_categories_currencies()
                        if user_force_change_accounts_cats_from_to_currency.isSelected():       force_change_accounts_cats_from_to_currency()
                        if user_fix_accounts_parent.isSelected():                               fix_account_parent()
                        if user_fix_root_account_name.isSelected():                             fix_root_account_name()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class CurrencySecurityMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa

                try:
                    lAlertPopupShown = False

                    user_show_open_share_lots = MenuJRadioButton("DIAG: Show Open Share LOTS (unconsumed) (show_open_tax_lots.py)", False)
                    user_show_open_share_lots.setToolTipText("This will list all Stocks/Shares with Open/Unconsumed LOTS (when LOT Control ON) - READONLY (show_open_tax_lots.py)")

                    user_diagnose_matched_lot_data = MenuJRadioButton("DIAG: Show Securities with 'invalid' LOT Matching (cause of LOT matching popup window)", False)
                    user_diagnose_matched_lot_data.setToolTipText("Diagnose LOT matching data and highlights 'invalid' matching (causing LOT matching window to appear) - READONLY")

                    user_convert_stock_lot_FIFO = MenuJRadioButton("FIX: Convert Stock to LOT controlled with FIFO lot matching (MakeFifoCost.py)", False, updateMenu=True)
                    user_convert_stock_lot_FIFO.setToolTipText("Convert Average Cost Controlled Stock to LOT Controlled and Allocate LOTs using FiFo method - THIS CHANGES DATA! (MakeFifoCost.py)")

                    user_convert_stock_avg_cst_control = MenuJRadioButton("FIX: Convert Stock to Average Cost Control", False, updateMenu=True)
                    user_convert_stock_avg_cst_control.setToolTipText("Convert LOT Controlled Stock to Average Cost Control (and wipe any LOT records) - THIS CHANGES DATA!")

                    user_thin_price_history = MenuJRadioButton("FIX: Thin/Purge Price History (price_history_thinner.py)", False, updateMenu=True)
                    user_thin_price_history.setToolTipText("This will allow you to Thin / Prune your Price History based on user parameters. THIS CHANGES DATA! (price_history_thinner.py)")

                    user_fix_nonlinked_security_records = MenuJRadioButton("FIX: Detect and fix Investment Security records not properly linked to Security Master records", False, updateMenu=True)
                    user_fix_nonlinked_security_records.setToolTipText("This will scan your Investment Security record and check that it's properly linked to a security master record... Allows you to fix this too")

                    user_fix_invalidLotRecords = MenuJRadioButton("FIX: Detect and fix (wipe) LOT records where matched Buy/Sell records are invalid", False, updateMenu=True)
                    user_fix_invalidLotRecords.setToolTipText("Scans LOT matching data and detects where matched records are invalid (missing)... Allows you to fix by wiping the LOT data")

                    user_can_i_delete_security = MenuJRadioButton("DIAG: Can I Delete a Security? (i.e. this is a show where used)", False)
                    user_can_i_delete_security.setToolTipText("This will tell you whether a Selected Security is in use and whether you can delete it in Moneydance")

                    user_can_i_delete_currency = MenuJRadioButton("DIAG: Can I Delete a Currency?  (i.e. this is a show where used)", False)
                    user_can_i_delete_currency.setToolTipText("This will tell you whether a Selected Currency is in use and whether you can delete it in Moneydance")

                    user_list_curr_sec_dpc = MenuJRadioButton("DIAG: List Security / Currency (hidden) decimal place settings", False)
                    user_list_curr_sec_dpc.setToolTipText("This will list your Security and Currency hidden decimal place settings (and attempt to advise of setup errors)")

                    user_diag_curr_sec = MenuJRadioButton("DIAG: Diagnose currencies / securities (including relative currencies) (if errors see fix below) (based on reset_relative_currencies.py)", False)
                    user_diag_curr_sec.setToolTipText("This will diagnose your Currency & Security setup, also checking relative currencies (and advise if you need to run a fix) (reset_relative_currencies.py)")

                    user_diag_price_date = MenuJRadioButton("DIAG: Diagnose currency and security's current price hidden 'price_date' field", False)
                    user_diag_price_date.setToolTipText("This will diagnose your Currency & Security's current price hidden price_date field....")

                    user_edit_security_decimal_places = MenuJRadioButton("FIX: Edit a Security's (hidden) Decimal Place setting (adjusts related Investment txns & Security balances accordingly) (2021.2(3089) onwards)", False, updateMenu=True, secondaryEnabled=(isRRateCurrencyIssueFixedBuild()))
                    user_edit_security_decimal_places.setToolTipText("This allows you to edit the hidden decimal places setting stored against a security (that you determined when you set the security up)")

                    user_merge_duplicate_securities = MenuJRadioButton("FIX: Merge 'duplicate' securities (and related Investment txns) into one master security record (2021.2(3089) onwards)", False, updateMenu=True, secondaryEnabled=(isRRateCurrencyIssueFixedBuild()))
                    user_merge_duplicate_securities.setToolTipText("Scans for 'duplicated' Securities and can merge together.. Tools>Securities>TickerSymbol is key, ID must be different... (Dpc, RelCurr, Rate, Splits must also match)")

                    user_fix_duplicate_securities_within_same_investment_account = MenuJRadioButton("FIX: Detect and merge/fix duplicate Securities within same Investment Account(s)", False, updateMenu=True)
                    user_fix_duplicate_securities_within_same_investment_account.setToolTipText("Scans and merges 'duplicated' Securities within the same Investment account(s).. THIS CHANGES DATA!")

                    user_autofix_price_date = MenuJRadioButton("FIX: Diagnose then fix your currency / security's current price hidden 'price_date' field (along with the current price/rate) (2021.2(3089) onwards)", False, updateMenu=True, secondaryEnabled=(isRRateCurrencyIssueFixedBuild()))
                    user_autofix_price_date.setToolTipText("This will diagnose then fix your Currency & Security's current price hidden price_date field (and current price/rate)....")

                    user_fix_price_date = MenuJRadioButton("FIX: Manually edit a currency/ security's current price hidden 'price_date' field (2021.2(3089) onwards)", False, updateMenu=True, secondaryEnabled=(isRRateCurrencyIssueFixedBuild()))
                    user_fix_price_date.setToolTipText("Allows you to manually edit a Currency / Security's current price hidden 'price_date' field....")

                    user_fix_curr_sec = MenuJRadioButton("FIX: Fix currencies / securities (including relative currencies) (based on reset_relative_currencies.py) (MUST RUN DIAGNOSE ABOVE FIRST)", False, updateMenu=True, secondaryEnabled=(GlobalVars.fixRCurrencyCheck is not None and GlobalVars.fixRCurrencyCheck > 1))
                    user_fix_curr_sec.setToolTipText("This will apply fixes to your Currency (& security) / Relative Currency setup (use after running the diagnose option first). THIS CHANGES DATA!  (reset_relative_currencies.py)")

                    user_fix_invalid_curr_sec = MenuJRadioButton("FIX: Fix Invalid Relative Currency (& security) Rates where <= (1.0/9999999999) or >= 9999999999 (fix_invalid_currency_rates.py)", False, updateMenu=True)
                    user_fix_invalid_curr_sec.setToolTipText("This will reset any relative rates back to 1.0 where <= (1.0/9999999999) or >= 9999999999. THIS CHANGES DATA!  (fix_invalid_currency_rates.py)")

                    user_fix_invalid_price_history = MenuJRadioButton("FIX: Delete invalid price history records where rate <= (1.0/9999999999) or >= 9999999999.", False, updateMenu=True)
                    user_fix_invalid_price_history.setToolTipText("This will delete and invalid price history records where rate <= (1.0/9999999999) or >= 9999999999. THIS CHANGES DATA!")

                    user_force_change_accounts_currency = MenuJRadioButton("FIX: FORCE Change an Account's / Category's Currency (force_change_account_currency.py)", False, updateMenu=True)
                    user_force_change_accounts_currency.setToolTipText("This allows you to FORCE change an Account's / Category's currency - USE WITH CARE!.. THIS CHANGES DATA! (force_change_account_currency.py)")

                    user_force_change_all_accounts_cats_currency = MenuJRadioButton("FIX: FORCE Change ALL Accounts' / Categories' Currencies (force_change_all_currencies.py)", False, updateMenu=True)
                    user_force_change_all_accounts_cats_currency.setToolTipText("This allows you to FORCE change ALL Accounts' / Categories' Currencies - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")

                    user_force_change_accounts_cats_from_to_currency = MenuJRadioButton("FIX: FORCE Change Accounts / Categories [& Securities] FROM Currency TO Currency", False, updateMenu=True)
                    user_force_change_accounts_cats_from_to_currency.setToolTipText("This allows you to FORCE change Accounts / Categories [& Securities] from one currency to another - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")

                    user_toggle_security_zero_shares_inactive = MenuJRadioButton("Toggle investment securities with zero shares status to active/inactive", False, updateMenu=True)
                    user_toggle_security_zero_shares_inactive.setToolTipText("Allows you toggle securities held in investment accounts with zero shares to inactive - THIS CHANGES DATA!")

                    labelFYI_curr_fix = JLabel("       ** only enabled if no serious currency/security issues detected (Some only available from 2021.2 onwards) **")
                    labelFYI_curr_fix.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    rowHeight = 24
                    rows = 8

                    userFilters.add(ToolboxMode.DEFAULT_MENU_READONLY_TXT_LBL)
                    userFilters.add(user_diag_curr_sec)
                    userFilters.add(user_can_i_delete_security)
                    userFilters.add(user_can_i_delete_currency)
                    userFilters.add(user_list_curr_sec_dpc)
                    userFilters.add(user_show_open_share_lots)
                    userFilters.add(user_diagnose_matched_lot_data)
                    userFilters.add(user_diag_price_date)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 19
                        userFilters.add(JLabel(" "))
                        userFilters.add(ToolboxMode.DEFAULT_MENU_UPDATE_TXT_LBL)

                        if not ToolboxMode.isUpdateMode():
                            rows += 1
                            userFilters.add(ToolboxMode.getMenuLabel())
                        else:
                            if not isRRateCurrencyIssueFixedBuild():
                                rows += 1
                                userFilters.add(labelFYI_curr_fix)

                        userFilters.add(user_fix_curr_sec)

                        userFilters.add(user_edit_security_decimal_places)
                        userFilters.add(user_merge_duplicate_securities)
                        userFilters.add(user_autofix_price_date)
                        userFilters.add(user_fix_price_date)

                        userFilters.add(user_fix_duplicate_securities_within_same_investment_account)
                        userFilters.add(user_fix_invalidLotRecords)
                        userFilters.add(user_convert_stock_lot_FIFO)
                        userFilters.add(user_convert_stock_avg_cst_control)
                        userFilters.add(user_fix_nonlinked_security_records)
                        userFilters.add(user_thin_price_history)
                        userFilters.add(user_fix_invalid_curr_sec)
                        userFilters.add(user_fix_invalid_price_history)
                        userFilters.add(user_force_change_accounts_currency)
                        userFilters.add(user_force_change_all_accounts_cats_currency)
                        userFilters.add(user_force_change_accounts_cats_from_to_currency)
                        userFilters.add(user_toggle_security_zero_shares_inactive)

                    bg = setupMenuRadioButtons(userFilters)

                    while True:
                        if MD_REF.getCurrentAccountBook() is None: return

                        user_fix_curr_sec.setEnabled(ToolboxMode.isUpdateMode() and GlobalVars.fixRCurrencyCheck is not None and GlobalVars.fixRCurrencyCheck > 1)

                        # Don't remove these as they are checked/disabled in the section below if certain conditions fail.....
                        user_edit_security_decimal_places.setEnabled(ToolboxMode.isUpdateMode() and isRRateCurrencyIssueFixedBuild())
                        user_merge_duplicate_securities.setEnabled(ToolboxMode.isUpdateMode() and isRRateCurrencyIssueFixedBuild())
                        user_autofix_price_date.setEnabled(ToolboxMode.isUpdateMode() and isRRateCurrencyIssueFixedBuild())
                        user_thin_price_history.setEnabled(ToolboxMode.isUpdateMode() and isRRateCurrencyIssueFixedBuild())
                        user_fix_invalid_curr_sec.setEnabled(ToolboxMode.isUpdateMode())
                        user_fix_invalid_price_history.setEnabled(ToolboxMode.isUpdateMode())

                        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
                        if not check_all_currency_raw_rates_ok():

                            user_diag_curr_sec.setForeground(getColorBlue())

                            if ToolboxMode.isUpdateMode() and not lAlertPopupShown:

                                if not isRRateCurrencyIssueFixedBuild():
                                    MyPopUpDialogBox(toolbox_frame_,
                                                     "ALERT: Currency/Security data issues need resolving - some menu items are disabled...",
                                                     "You have some Currency / Security records which were created in an older version of Moneydance\n"
                                                     "These need to be updated to the latest 'format' before Toolbox can allow some options\n"
                                                     "Please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to address this issue\n"
                                                     "OR BETTER >> Upgrade to Moneydance build %s onwards (as the MD code was fixed to deal with this data issue)\n"
                                                     "Menu items will remain disabled until you do this...." %(GlobalVars.MD_RRATE_ISSUE_FIXED_BUILD),
                                                     lModal=True, OKButtonText="Acknowledge", lAlertLevel=1).go()
                                else:
                                    MyPopUpDialogBox(toolbox_frame_,
                                                     "ALERT: Currency/Security data issues need resolving - some menu items are disabled...",
                                                     "You have some Currency / Security records which have a data issue\n"
                                                     "These need to be fixed before Toolbox can allow some options\n"
                                                     "Please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to address this issue\n"
                                                     "Menu items will remain disabled until you do this....",
                                                     lModal=True, OKButtonText="Acknowledge", lAlertLevel=1).go()

                                lAlertPopupShown = True

                            user_autofix_price_date.setEnabled(False)
                            user_thin_price_history.setEnabled(False)
                            user_fix_invalid_curr_sec.setEnabled(False)
                            user_fix_invalid_price_history.setEnabled(False)

                            # Just disable if errors on Security records....
                            if not check_all_currency_raw_rates_ok(CurrencyType.Type.SECURITY):                         # noqa
                                user_edit_security_decimal_places.setEnabled(False)
                                user_merge_duplicate_securities.setEnabled(False)

                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters, 1200, (rowHeight * rows))
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Currency / Security Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Currency / Security Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_can_i_delete_security.isSelected():                                     can_I_delete_security()
                        if user_can_i_delete_currency.isSelected():                                     can_I_delete_currency()
                        if user_list_curr_sec_dpc.isSelected():                                         list_security_currency_decimal_places()
                        if user_diag_price_date.isSelected():                                           list_security_currency_price_date()
                        if user_autofix_price_date.isSelected():                                        list_security_currency_price_date(autofix=True)
                        if user_diag_curr_sec.isSelected():                                             diagnose_currencies(False)
                        if user_fix_curr_sec.isSelected():                                              diagnose_currencies(True)
                        if user_fix_invalid_curr_sec.isSelected():                                      fix_invalid_relative_currency_rates()
                        if user_edit_security_decimal_places.isSelected():                              edit_security_decimal_places()
                        if user_merge_duplicate_securities.isSelected():                                merge_duplicate_securities()
                        if user_fix_duplicate_securities_within_same_investment_account.isSelected():   fix_duplicate_securities_within_same_investment_account()
                        if user_fix_invalid_price_history.isSelected():                                 fix_invalid_price_history()
                        if user_fix_nonlinked_security_records.isSelected():                            detect_fix_nonlinked_investment_security_records()
                        if user_thin_price_history.isSelected():                                        thin_price_history()
                        if user_show_open_share_lots.isSelected():                                      show_open_share_lots()
                        if user_diagnose_matched_lot_data.isSelected():                                 diagnose_matched_lot_data()
                        if user_fix_invalidLotRecords.isSelected():                                     fix_invalidLotRecords()
                        if user_convert_stock_lot_FIFO.isSelected():                                    convert_stock_lot_FIFO()
                        if user_convert_stock_avg_cst_control.isSelected():                             convert_stock_avg_cst_control()
                        if user_force_change_accounts_currency.isSelected():                            force_change_account_cat_currency()
                        if user_force_change_all_accounts_cats_currency.isSelected():                   force_change_all_accounts_categories_currencies()
                        if user_force_change_accounts_cats_from_to_currency.isSelected():               force_change_accounts_cats_from_to_currency()
                        if user_toggle_security_zero_shares_inactive.isSelected():                      toggle_security_zero_shares_inactive()
                        if user_fix_price_date.isSelected():                                            manually_edit_price_date_field()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class TransactionMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa

                try:
                    user_view_txn_sort = MenuJRadioButton("View Register Transactional Sort Orders", False)
                    user_view_txn_sort.setToolTipText("Allows you  to view the current transaction register sort orders in operation")

                    user_extract_attachments = MenuJRadioButton("Extract Attachments to Folder", False)
                    user_extract_attachments.setToolTipText("Extract all your attachments to a folder of your choosing...")

                    user_diagnose_attachments = MenuJRadioButton("DIAG: Diagnose Attachments and detect Orphans too", False)
                    user_diagnose_attachments.setToolTipText("This will analise your Attachments, show you the file storage consumed, and detect Orphans/issues")

                    syncFolder = None                                                                                   # noqa
                    try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
                    except: syncFolder = False

                    user_diagnose_fix_attachments = MenuJRadioButton("FIX: Diagnose Attachments - DELETE Orphan attachments (** Syncing must be Disabled **)", False, updateMenu=True, secondaryEnabled=(syncFolder is None))
                    user_diagnose_fix_attachments.setToolTipText("This will analise your Attachments, detect Orphans/issues - AND ALLOW YOU TO DELETE THE ORPHAN ATTACHMENTS")

                    user_move_invest_txns = MenuJRadioButton("Move/Merge Investment Transactions >> NOW RUN FROM EXTENSIONS MENU <<", False, updateMenu=True, secondaryEnabled=(isToolboxUnlocked()))
                    user_move_invest_txns.setToolTipText("This allows you to move your investment transactions from one account into (merges with) another")

                    user_fix_non_hier_sec_acct_txns = MenuJRadioButton("FIX: Non-Hierarchical Security Acct Txns (& detect Orphans) (fix_non-hierarchical_security_account_txns.py)", False, updateMenu=True)
                    user_fix_non_hier_sec_acct_txns.setToolTipText("This reviews your Investment Security Txns and fixes where the Account reference is cross-linked and incorrect (fix_non-hierarchical_security_account_txns.py & fix_investment_txns_to_wrong_security.py)")

                    user_fix_delete_one_sided_txns = MenuJRadioButton("FIX: Delete One-Sided Transactions (delete_invalid_txns.py)", False, updateMenu=True)
                    user_fix_delete_one_sided_txns.setToolTipText("This allows you to DELETE 'invalid' one-sided transactions - usually from a bad quicken import. THIS CHANGES DATA! (delete_invalid_txns.py)")

                    user_reverse_txn_amounts = MenuJRadioButton("FIX: Reverse Transaction Amounts (reverse_txn_amounts.py)", False, updateMenu=True)
                    user_reverse_txn_amounts.setToolTipText("This allows you to REVERSE the transaction values/amounts for an account within a date range. THIS CHANGES DATA! (reverse_txn_amounts.py)")

                    user_reverse_txn_exchange_rates_by_account_and_date = MenuJRadioButton("FIX: Reverse Transaction Exchange Rates (reverse_txn_exchange_rates_by_account_and_date)", False, updateMenu=True)
                    user_reverse_txn_exchange_rates_by_account_and_date.setToolTipText("This allows you to REVERSE the transactional exchange rates for an account within a date range. THIS CHANGES DATA! (reverse_txn_exchange_rates_by_account_and_date)")

                    user_detect_fix_txns_assigned_root = MenuJRadioButton("FIX: Detect and fix transactions assigned to 'root' account", False, updateMenu=True)
                    user_detect_fix_txns_assigned_root.setToolTipText("This detects transactions assigned to 'root' and offers options to display/fix. THIS CHANGES DATA!")

                    userFilters = JPanel(GridLayout(0, 1))

                    rowHeight = 24
                    rows = 4

                    userFilters.add(ToolboxMode.DEFAULT_MENU_READONLY_TXT_LBL)
                    userFilters.add(user_view_txn_sort)
                    userFilters.add(user_extract_attachments)
                    userFilters.add(user_diagnose_attachments)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 8
                        userFilters.add(JLabel(" "))
                        userFilters.add(ToolboxMode.DEFAULT_MENU_UPDATE_TXT_LBL)

                        if not ToolboxMode.isUpdateMode():
                            rows += 1
                            userFilters.add(ToolboxMode.getMenuLabel())

                        # These are new features - better supported from 2021.2 onwards
                        if isRRateCurrencyIssueFixedBuild():
                            rows += 1
                            userFilters.add(user_move_invest_txns)

                        userFilters.add(user_diagnose_fix_attachments)
                        userFilters.add(user_fix_non_hier_sec_acct_txns)
                        userFilters.add(user_fix_delete_one_sided_txns)
                        userFilters.add(user_reverse_txn_amounts)
                        userFilters.add(user_reverse_txn_exchange_rates_by_account_and_date)
                        userFilters.add(user_detect_fix_txns_assigned_root)

                    bg = setupMenuRadioButtons(userFilters)

                    while True:
                        if MD_REF.getCurrentAccountBook() is None: return

                        syncFolder = None                                                                               # noqa
                        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
                        except: syncFolder = False
                        user_diagnose_fix_attachments.setEnabled(ToolboxMode.isUpdateMode() and syncFolder is None)

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters, 850, (rowHeight * rows))
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Transaction(s) Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Transaction(s) Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_view_txn_sort.isSelected():                                     get_register_txn_sort_orders()
                        if user_extract_attachments.isSelected():                               extract_attachments()
                        if user_diagnose_attachments.isSelected():                              diagnose_attachments()
                        if user_diagnose_fix_attachments.isSelected():                          diagnose_attachments(lFix=True)
                        if user_move_invest_txns.isSelected():                                  move_merge_investment_txns()
                        if user_fix_non_hier_sec_acct_txns.isSelected():                        fix_non_hier_sec_acct_txns()
                        if user_fix_delete_one_sided_txns.isSelected():                         fix_delete_one_sided_txns()
                        if user_reverse_txn_amounts.isSelected():                               reverse_txn_amounts()
                        if user_reverse_txn_exchange_rates_by_account_and_date.isSelected():    reverse_txn_exchange_rates_by_account_and_date()
                        if user_detect_fix_txns_assigned_root.isSelected():                     detect_fix_txns_assigned_root()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class GeneralToolsMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa

                try:
                    user_display_passwords = MenuJRadioButton("Display Dataset Password/Hint and Sync Passphrase", False)
                    user_display_passwords.setToolTipText("Display the password/hint used to open your Encrypted Dataset, and also your Sync passphrase (if set)")

                    user_view_MD_config_file = MenuJRadioButton("View MD Config File", False)
                    user_view_MD_config_file.setToolTipText("View the contents of your Moneydance configuration file")

                    user_view_searchable_console_log = MenuJRadioButton("View Searchable Console Log", False)
                    user_view_searchable_console_log.setToolTipText("View the whole Console log file - searchable")

                    user_view_MD_custom_theme_file = MenuJRadioButton("View MD Custom Theme File (only when exists)", False, secondaryEnabled=(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath())))
                    user_view_MD_custom_theme_file.setToolTipText("View the contents of your Moneydance custom Theme file (if you have set one up)")

                    user_view_java_vmoptions = MenuJRadioButton("View Java VM Options File (only when exists)", False, secondaryEnabled=(os.path.exists(get_vmoptions_path())))
                    user_view_java_vmoptions.setToolTipText("View the contents of the Java VM Options runtime file that Moneydance uses")

                    user_view_extensions_details = MenuJRadioButton("View Extension(s) details", False)
                    user_view_extensions_details.setToolTipText("View details about the Extensions installed in your Moneydance system")

                    user_view_memorised_reports = MenuJRadioButton("View Memorised Reports", False)
                    user_view_memorised_reports.setToolTipText("View a list of your Memorised reports")

                    # user_find_sync_password_in_ios_backups = MenuJRadioButton("Find Sync Password in iOS Backups (only on Windows and Mac)", False)
                    # user_find_sync_password_in_ios_backups.setToolTipText("This search for iOS backup(s) and look for your Sync Encryption password(s)")
                    # user_find_sync_password_in_ios_backups.setEnabled(Platform.isOSX() or Platform.isWindows())
                    # user_find_sync_password_in_ios_backups.setEnabled(Platform.isOSX() or Platform.isWindows())

                    user_import_QIF = MenuJRadioButton("'Older' Import QIF file and set parameters", False)
                    user_import_QIF.setToolTipText("Runs the 'older' MD importQIFIntoAccount() function and allows you to set parameters (you can select create Account Structure Only) - WILL IMPORT / CHANGE DATA!")

                    user_convert_timestamp = MenuJRadioButton("Convert a TimeStamp number into a readable date/time", False)
                    user_convert_timestamp.setToolTipText("Allows you to input a TimeStamp (Milliseconds) and it will display a readable date/time")

                    user_close_dataset = MenuJRadioButton("Close this dataset (and related windows) (only with developer unlock)", False, updateMenu=True, secondaryEnabled=(isToolboxUnlocked()))
                    user_close_dataset.setToolTipText("Manually closes the dataset, all related windows, but leaves MD open....")

                    user_disable_moneyforesight = MenuJRadioButton("Disable/(re)enable the bundled MoneyForesight extension (requires MD restart)", False, updateMenu=True, secondaryEnabled=(float(MD_REF.getBuild()) >= 3095))
                    user_disable_moneyforesight.setToolTipText("Disables/(re)enables the bundled MoneyForesight extension when launching Moneydance - Restart after disabling...")

                    user_rename_dataset = MenuJRadioButton("Rename this dataset (within the same location)", False, updateMenu=True)
                    user_rename_dataset.setToolTipText("This will allow you to rename this dataset (within the same location) - THIS CHANGES DATA!")

                    user_relocate_dataset_internal = MenuJRadioButton("Relocate this dataset back to the default 'internal' location", False, updateMenu=True, secondaryEnabled=(not AccountBookUtil.isWithinInternalStorage(MD_REF.getCurrentAccountBook())))
                    user_relocate_dataset_internal.setToolTipText("This will allow you to relocate this dataset back to the internal default location - THIS CHANGES DATA!")

                    user_relocate_dataset_external = MenuJRadioButton("Relocate this dataset to another location [Note: IK do not recommend this]", False, updateMenu=True, secondaryEnabled=(not Platform.isOSX() or not MD_REF.getPlatformHelper().isConstrainedToSandbox()))
                    user_relocate_dataset_external.setToolTipText("This will allow you to relocate this dataset to another (non-default) location - THIS CHANGES DATA!")

                    user_cleanup_external_files = MenuJRadioButton("Cleanup MD's File/Open list of 'external' files (does not touch actual files)", False, updateMenu=True)
                    user_cleanup_external_files.setToolTipText("Cleans up the list of files shown on the MD File/Open menu - THIS CHANGES CONFIG.DICT!")

                    user_advanced_delete_int_ext_files = MenuJRadioButton("DELETE Files from Menu>File>Open list and also from DISK", False, updateMenu=True)
                    user_advanced_delete_int_ext_files.setToolTipText("This allows you to delete internal/external filenames from the list of File>Open files settings>> AND ASKS IF YOU WANT TO DELETE THE FILES TOO..... UPDATES CONFIG.DICT/CAN DELETE FILES")

                    user_remove_inactive_from_sidebar = MenuJRadioButton("Remove inactive accounts/categories from SideBar (only when sidebar visible)", False, updateMenu=True, secondaryEnabled=(MD_REF.getPreferences().getBoolSetting("gui.source_list_visible", True)))
                    user_remove_inactive_from_sidebar.setToolTipText("This remove inactive accounts/categories from SideBar. THIS CHANGES CONFIG!")

                    user_change_moneydance_fonts = MenuJRadioButton("Set/Change Default Moneydance FONTS (MD 2021.1(3030) onwards)", False, updateMenu=True, secondaryEnabled=(float(MD_REF.getBuild()) >= 3030))
                    user_change_moneydance_fonts.setToolTipText("This will allow you to Set/Change the Default Moneydance Fonts. THIS CHANGES DATA!")

                    user_delete_custom_theme_file = MenuJRadioButton("Delete Custom Theme file (only when exists)", False, updateMenu=True, secondaryEnabled=(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath())))
                    user_delete_custom_theme_file.setToolTipText("Delete your custom Theme file (if it exists). This is pretty safe. MD will create a new one if you select in Preferences. THIS DELETES A FILE!")

                    user_delete_orphan_extensions = MenuJRadioButton("FIX: Delete Orphaned Extensions", False, updateMenu=True)
                    user_delete_orphan_extensions.setToolTipText("This will delete any references to orphaned / outdated Extensions (config.dict & .mxt files). THIS CHANGES DATA!")

                    user_reset_window_display_settings = MenuJRadioButton("RESET Window Display Settings (disabled when script)", False, updateMenu=True, secondaryEnabled=(GlobalVars.i_am_an_extension_so_run_headless))
                    user_reset_window_display_settings.setToolTipText("This tells MD to 'forget' window display settings. CLOSE ALL REGISTER WINDOWS FIRST! The beauty is it keeps all other settings intact! THIS CHANGES DATA!")

                    userFilters = JPanel(GridLayout(0, 1))

                    rowHeight = 24
                    rows = 10
                    userFilters.add(ToolboxMode.DEFAULT_MENU_READONLY_TXT_LBL)
                    userFilters.add(user_display_passwords)
                    userFilters.add(user_view_searchable_console_log)
                    userFilters.add(user_view_MD_config_file)
                    userFilters.add(user_view_MD_custom_theme_file)
                    userFilters.add(user_view_java_vmoptions)
                    userFilters.add(user_view_extensions_details)
                    userFilters.add(user_view_memorised_reports)
                    # userFilters.add(user_find_sync_password_in_ios_backups)
                    userFilters.add(user_import_QIF)
                    userFilters.add(user_convert_timestamp)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 14
                        userFilters.add(JLabel(" "))
                        userFilters.add(ToolboxMode.DEFAULT_MENU_UPDATE_TXT_LBL)

                        if not ToolboxMode.isUpdateMode():
                            rows += 1
                            userFilters.add(ToolboxMode.getMenuLabel())

                        userFilters.add(user_reset_window_display_settings)
                        userFilters.add(user_disable_moneyforesight)
                        userFilters.add(user_close_dataset)
                        userFilters.add(user_rename_dataset)
                        userFilters.add(user_relocate_dataset_internal)
                        userFilters.add(user_relocate_dataset_external)
                        userFilters.add(user_cleanup_external_files)
                        userFilters.add(user_advanced_delete_int_ext_files)
                        userFilters.add(user_remove_inactive_from_sidebar)
                        userFilters.add(user_change_moneydance_fonts)
                        userFilters.add(user_delete_custom_theme_file)
                        userFilters.add(user_delete_orphan_extensions)

                    bg = setupMenuRadioButtons(userFilters)

                    while True:
                        if MD_REF.getCurrentAccountBook() is None: return

                        user_view_java_vmoptions.setEnabled(os.path.exists(get_vmoptions_path()))
                        user_view_MD_custom_theme_file.setEnabled(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))                             # noqa
                        user_delete_custom_theme_file.setEnabled(ToolboxMode.isUpdateMode() and os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))   # noqa
                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters, 700, (rowHeight * rows))
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "General Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "General Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_display_passwords.isSelected():                     display_passwords()
                        if user_view_searchable_console_log.isSelected():           ViewFileButtonAction(MD_REF.getLogFile(), "MD Console Log").actionPerformed(None)
                        if user_view_MD_config_file.isSelected():                   ViewFileButtonAction(Common.getPreferencesFile(), "MD Config").actionPerformed(None)
                        if user_view_MD_custom_theme_file.isSelected():             ViewFileButtonAction(ThemeInfo.customThemeFile, "MD Custom Theme").actionPerformed(None)
                        if user_view_java_vmoptions.isSelected():                   ViewFileButtonAction(File(get_vmoptions_path()), "Java VM File").actionPerformed(None)
                        if user_view_extensions_details.isSelected():               view_extensions_details()
                        if user_view_memorised_reports.isSelected():                get_list_memorised_reports()
                        # if user_find_sync_password_in_ios_backups.isSelected():     find_IOS_sync_data()
                        if user_import_QIF.isSelected():                            import_QIF()
                        if user_convert_timestamp.isSelected():                     convert_timestamp_readable_date()
                        if user_disable_moneyforesight.isSelected():                disable_moneyforesight()
                        if user_close_dataset.isSelected():                         close_dataset()
                        if user_rename_dataset.isSelected():                        rename_relocate_dataset(lRelocateDataset=False)
                        if user_relocate_dataset_internal.isSelected():             rename_relocate_dataset(lRelocateDataset=True, lRelocateToInternal=True)
                        if user_relocate_dataset_external.isSelected():             rename_relocate_dataset(lRelocateDataset=True, lRelocateToInternal=False)
                        if user_cleanup_external_files.isSelected():                cleanup_external_files_setting()
                        if user_advanced_delete_int_ext_files.isSelected():         remove_int_external_files_settings()
                        if user_remove_inactive_from_sidebar.isSelected():          remove_inactive_from_sidebar()
                        if user_change_moneydance_fonts.isSelected():               change_fonts()
                        if user_delete_custom_theme_file.isSelected():              delete_theme_file()
                        if user_delete_orphan_extensions.isSelected():              force_remove_extension()
                        if user_reset_window_display_settings.isSelected():         reset_window_positions()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class AdvancedOptionsMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa

                try:
                    # user_advanced_toggle_DEBUG = MenuJRadioButton("Toggle Moneydance DEBUG", False)
                    # user_advanced_toggle_DEBUG.setToolTipText("This will toggle Moneydance's internal DEBUG setting(s) ON/OFF.....")

                    user_advanced_toggle_other_DEBUGs = MenuJRadioButton("Toggle Other Moneydance DEBUGs", False)
                    user_advanced_toggle_other_DEBUGs.setToolTipText("This will allow you to toggle other known Moneydance internal DEBUG setting(s) ON/OFF..... (these add extra messages to Console output))")

                    user_show_encryption_keys = MenuJRadioButton("Show your encryption keys, and the Moneydance encryption methodology (use with care)", False, updateMenu=True, secondaryEnabled=GlobalVars.EXTRA_CODE_INITIALISED)
                    user_show_encryption_keys.setToolTipText("Will show your encryption keys used to encrypt your dataset [and sync data], along with the encryption methodologies")

                    user_advanced_extract_from_dataset = MenuJRadioButton("Extract/decrypt a file from Dataset", False, secondaryEnabled=GlobalVars.EXTRA_CODE_INITIALISED)
                    user_advanced_extract_from_dataset.setToolTipText("This allows you to extract/decrypt a file from inside Dataset (copied to Dataset/tmp/decrypted dir)..... TMP FILE SELF DESTRUCTS AFTER RESTART")

                    user_advanced_extract_from_sync = MenuJRadioButton("Extract/decrypt from Sync Folder (only when syncing)", False, secondaryEnabled=GlobalVars.EXTRA_CODE_INITIALISED)
                    user_advanced_extract_from_sync.setToolTipText("This allows you to extract/decrypt a file from inside Sync folder (copied to Dataset/tmp/decrypted/fromSync dir)..... TMP FILE SELF DESTRUCTS AFTER RESTART")

                    user_advanced_decrypt_dataset = MenuJRadioButton("Decrypt entire dataset...", False, secondaryEnabled=GlobalVars.EXTRA_CODE_INITIALISED)
                    user_advanced_decrypt_dataset.setToolTipText("Decrypts your entire Dataset (to a folder of your choosing)")

                    user_advanced_shrink_dataset = MenuJRadioButton("Shrink Dataset size", False, updateMenu=True)
                    user_advanced_shrink_dataset.setToolTipText("This function deletes MD's log files of all prior changes (not needed).. Typically these are .txn, .mdtxn files...")

                    user_advanced_clone_dataset = MenuJRadioButton("Clone Dataset's structure (purge transactional data)", False, updateMenu=True)
                    user_advanced_clone_dataset.setToolTipText("Clones you dataset, keeps the structures, purges the transactional data - CREATES NEW DATASET")

                    user_advanced_save_trunk = MenuJRadioButton("Save Trunk File (Flush all in-memory changes & dataset to disk)", False, updateMenu=True)
                    user_advanced_save_trunk.setToolTipText("This allows you to call the Save Trunk File function)..... Immediately flushes all in memory changes to disk, including your dataset (rather than wait for restart). UPDATES YOUR DATASET")

                    user_demote_primary_to_secondary = MenuJRadioButton("DEMOTE Primary dataset back to a Secondary Node (only when primary)", False, updateMenu=True, secondaryEnabled=(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))
                    user_demote_primary_to_secondary.setToolTipText("DEMOTE your Primary Sync Node/Dataset to a Secondary Node)..... UPDATES YOUR DATASET")

                    user_advanced_sync_push = MenuJRadioButton("Force a refresh/PUSH of your local dataset to Sync (only when master sync mode)", False, updateMenu=True)
                    user_advanced_sync_push.setToolTipText("Push new Sync data (and rebuild remote copies). Use with care! UPDATES YOUR DATASET")

                    user_force_sync_off = MenuJRadioButton("Force DISABLE/turn Sync OFF (only when sync detected)", False, updateMenu=True)
                    user_force_sync_off.setToolTipText("This sets your Sync method to None - all other settings are preserved. You can turn it back on again later - UPDATES YOUR DATASET")

                    user_force_reset_sync_settings = MenuJRadioButton("Force RESET Sync settings (generates new SyncID and turns Sync off. You can turn it back on after MD restart)", False, updateMenu=True)
                    user_force_reset_sync_settings.setToolTipText("This resets all Sync settings, changes your Sync ID, and turns Sync off. You can then re-enable it for a fresh Sync - You can turn it back on again later - UPDATES YOUR DATASET")

                    user_toggle_sync_download_attachments = MenuJRadioButton("Toggle Sync Downloading of Attachments (only when sync detected)", False, updateMenu=True)
                    user_toggle_sync_download_attachments.setToolTipText("Normally this defaults to ON; Change to OFF to prevent attachments downloading via Sync - UPDATES YOUR DATASET")

                    user_repair_migrated_dropbox_alias = MenuJRadioButton("Repair migrated Dropbox location 'alias' (MacOS & only when problem detected)", False, updateMenu=True, secondaryEnabled=(detectMigratedDropboxFolderProblem()))
                    user_repair_migrated_dropbox_alias.setToolTipText("Attempts to (re)create the missing alias from old to new Dropbox location(s)")

                    user_advanced_import_to_dataset = MenuJRadioButton("Import/encrypt a file back into Dataset", False, updateMenu=True, secondaryEnabled=GlobalVars.EXTRA_CODE_INITIALISED)
                    user_advanced_import_to_dataset.setToolTipText("This allows you to import/encrypt) a file back into Dataset/safe/tmp/encrypted dir.....")

                    user_advanced_import_to_sync_folder = MenuJRadioButton("Import/encrypt a file back into Sync folder", False, updateMenu=True, secondaryEnabled=GlobalVars.EXTRA_CODE_INITIALISED)
                    user_advanced_import_to_sync_folder.setToolTipText("This allows you to import/encrypt a file back into Sync/tmp/encrypted dir.....")

                    user_advanced_options_edit_prefs = MenuJRadioButton("ADD/CHG/DEL System Settings/Prefs (ie config.dict / LocalStorage() settings", False, updateMenu=True)
                    user_advanced_options_edit_prefs.setToolTipText("This allows you to MODIFY (add/change/delete) config.dict and LocalStorage() (./safe/settings) keys..... CAN UPDATE DATA")

                    user_advanced_edit_param_keys = MenuJRadioButton("ADD/CHG/DEL Database Object (ie Account, Currency, any object)", False, updateMenu=True)
                    user_advanced_edit_param_keys.setToolTipText("This allows you to MODIFY (add/change/delete) an Object's Parameter keys..... CAN UPDATE DATA - ONLY USE IF YOU KNOW WHAT YOU ARE DOING")

                    lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
                    user_advanced_suppress_dropbox_warning = MenuJRadioButton("Suppress File in Dropbox Warning (only when sync is dropbox)", False, updateMenu=True, secondaryEnabled=(lDropbox and not lSuppressed))
                    user_advanced_suppress_dropbox_warning.setToolTipText("This allows you to suppress the 'Your file seems to be in a shared folder (Dropbox)' warning")

                    userFilters = JPanel(GridLayout(0, 1))

                    rowHeight = 24
                    rows = 5

                    userFilters.add(ToolboxMode.DEFAULT_MENU_READONLY_TXT_LBL)
                    # userFilters.add(user_advanced_toggle_DEBUG)
                    userFilters.add(user_advanced_toggle_other_DEBUGs)
                    userFilters.add(user_advanced_extract_from_dataset)
                    userFilters.add(user_advanced_extract_from_sync)
                    userFilters.add(user_advanced_decrypt_dataset)

                    if GlobalVars.globalShowDisabledMenuItems or ToolboxMode.isUpdateMode():
                        rows += 17
                        userFilters.add(JLabel(" "))
                        userFilters.add(ToolboxMode.DEFAULT_MENU_UPDATE_TXT_LBL)

                        if not ToolboxMode.isUpdateMode():
                            rows += 1
                            userFilters.add(ToolboxMode.getMenuLabel())

                        userFilters.add(user_advanced_shrink_dataset)
                        userFilters.add(user_advanced_clone_dataset)
                        userFilters.add(user_advanced_save_trunk)
                        userFilters.add(user_demote_primary_to_secondary)
                        userFilters.add(user_advanced_sync_push)
                        userFilters.add(user_force_sync_off)
                        userFilters.add(user_force_reset_sync_settings)
                        userFilters.add(user_toggle_sync_download_attachments)
                        userFilters.add(user_repair_migrated_dropbox_alias)
                        userFilters.add(user_advanced_import_to_dataset)
                        userFilters.add(user_advanced_import_to_sync_folder)
                        userFilters.add(user_advanced_options_edit_prefs)
                        userFilters.add(user_advanced_edit_param_keys)
                        userFilters.add(user_advanced_suppress_dropbox_warning)
                        userFilters.add(user_show_encryption_keys)

                    bg = setupMenuRadioButtons(userFilters)

                    _NONE = "none"
                    _PARAM_KEY = "netsync.sync_type"
                    storage = MD_REF.getCurrentAccountBook().getLocalStorage()

                    while True:
                        if MD_REF.getCurrentAccountBook() is None: return

                        lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
                        user_advanced_suppress_dropbox_warning.setEnabled(ToolboxMode.isUpdateMode() and (lDropbox and not lSuppressed))
                        user_demote_primary_to_secondary.setEnabled(ToolboxMode.isUpdateMode() and (MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))
                        user_advanced_sync_push.setEnabled(ToolboxMode.isUpdateMode() and (MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))
                        user_force_sync_off.setEnabled(ToolboxMode.isUpdateMode() and (not (storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE)))
                        user_toggle_sync_download_attachments.setEnabled(ToolboxMode.isUpdateMode() and (not (storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE)))
                        user_advanced_import_to_sync_folder.setEnabled(ToolboxMode.isUpdateMode() and MD_REF.getUI().getCurrentAccounts().getSyncFolder() is not None and GlobalVars.EXTRA_CODE_INITIALISED)
                        user_advanced_extract_from_sync.setEnabled(MD_REF.getUI().getCurrentAccounts().getSyncFolder() is not None and GlobalVars.EXTRA_CODE_INITIALISED)
                        user_show_encryption_keys.setEnabled(ToolboxMode.isUpdateMode() and GlobalVars.EXTRA_CODE_INITIALISED)

                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters, 850, (rowHeight * rows))
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "ADVANCED - Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "ADVANCED - Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        # if user_advanced_toggle_DEBUG.isSelected():                 advanced_options_DEBUG()
                        if user_advanced_toggle_other_DEBUGs.isSelected():          advanced_options_other_DEBUG()
                        if user_show_encryption_keys.isSelected():                  advanced_show_encryption_keys()
                        if user_advanced_extract_from_dataset.isSelected():         advanced_options_decrypt_file_from_dataset()
                        if user_advanced_extract_from_sync.isSelected():            advanced_options_decrypt_file_from_sync()
                        if user_advanced_decrypt_dataset.isSelected():              advanced_options_decrypt_dataset()
                        if user_advanced_shrink_dataset.isSelected():               advanced_options_shrink_dataset()
                        if user_advanced_import_to_dataset.isSelected():            advanced_options_encrypt_file_into_dataset()
                        if user_advanced_import_to_sync_folder.isSelected():        advanced_options_encrypt_file_into_sync_folder()
                        if user_advanced_options_edit_prefs.isSelected():           advanced_options_edit_prefs()
                        if user_advanced_edit_param_keys.isSelected():              advanced_options_edit_parameter_keys()
                        if user_advanced_save_trunk.isSelected():                   advanced_options_save_trunk_file()
                        if user_advanced_sync_push.isSelected():                    advanced_options_sync_push_pull("PUSH")
                        if user_advanced_clone_dataset.isSelected():                advanced_clone_dataset()
                        if user_force_sync_off.isSelected():                        advanced_options_force_sync_off()
                        if user_force_reset_sync_settings.isSelected():             advanced_options_force_reset_sync_settings()
                        if user_repair_migrated_dropbox_alias.isSelected():         advanced_options_repair_migrated_dropbox_alias()
                        if user_toggle_sync_download_attachments.isSelected():      toggle_sync_download_attachments()
                        if user_demote_primary_to_secondary.isSelected():           advanced_options_demote_primary_to_secondary()
                        if user_advanced_suppress_dropbox_warning.isSelected():     advanced_options_suppress_dropbox_warning()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class ConvertSecondaryButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa
                # convert_secondary_to_primary_data_set

                if MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
                    txt = "Your dataset is already Master - NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if myPopupAskQuestion(toolbox_frame_,
                                      "MAKE this SECONDARY a PRIMARY/MASTER NODE",
                                      "Are you sure you want to make this secondary dataset the Primary?",
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.ERROR_MESSAGE):

                    if doesUserAcceptDisclaimer(toolbox_frame_, "MAKE this SECONDARY a PRIMARY/MASTER NODE", "Are you really sure you want to change this secondary into the Primary?"):
                        if not backup_local_storage_settings():
                            txt = "MAKE ME PRIMARY: ERROR making backup of LocalStorage() ./safe/settings - NO CHANGES MADE!"
                            setDisplayStatus(txt, "R")
                            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                            return

                        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(True)
                        MD_REF.getCurrentAccountBook().getLocalStorage().save()        # Flush local storage to safe/settings

                        txt = "Dataset Promoted to Primary/Master Node/Dataset - MONEYDANCE WILL NOW RESTART"
                        setDisplayStatus(txt, "R")
                        myPrint("B", txt)
                        logToolboxUpdates("ConvertSecondaryButtonAction", txt)

                        play_the_money_sound()
                        myPopupInformationBox(toolbox_frame_, txt, "PRIMARY DATASET", JOptionPane.WARNING_MESSAGE)
                        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)
                        return

                txt = "User did not say yes to Master Node promotion - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        class AnalyseDatasetSizeButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):                                                                           # noqa
                # show_object_type_quantities.py

                output = "DATASET FILE ANALYSIS\n" \
                         " ====================\n\n"

                # _msgPad = 100
                # _msg = pad("Please wait: Analysing Dataset", _msgPad,padChar=".")
                # diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False, OKButtonText="WAIT")
                # diag.go()

                startDir = MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()
                output += "Dataset path: %s\n\n" %(startDir)

                attach = MD_REF.getCurrentAccountBook().getAttachmentsFolder()
                keyDir = startDir
                trunkDir = os.path.join(startDir, AccountBookWrapper.SAFE_SUBFOLDER_NAME, "tiksync")
                attachDir = os.path.join(startDir, AccountBookWrapper.SAFE_SUBFOLDER_NAME, attach)
                settingsDir = os.path.join(startDir, AccountBookWrapper.SAFE_SUBFOLDER_NAME)
                archiveDir = os.path.join(startDir, AccountBookWrapper.SAFE_SUBFOLDER_NAME, "archive")
                sync_outDir = os.path.join(startDir, AccountBookWrapper.SAFE_SUBFOLDER_NAME, "tiksync", "out")

                sync_outCount = 0
                sync_outSize = 0

                safe_settingsSize = 0
                safe_attachmentsSize = 0
                countAttachments = 0
                safe_archiveSize = 0
                countArchiveFiles = 0
                safe_trunkSize = 0
                safe_tiksyncSize = 0
                countTIKfiles = 0
                # safe_tmpSize = 0
                keySize = 0
                countValidFiles = 0
                countNonValidFiles = 0
                validSize = 0
                nonValidSize = 0
                listNonValidFiles = []
                listLargeFiles = []

                total_size = 0
                start_path = startDir  # To get size of current directory
                for path, dirs, files in os.walk(start_path):
                    for f in files:
                        lValidFile = False

                        fp = os.path.join(path, f)
                        thisFileSize = os.path.getsize(fp)

                        total_size += thisFileSize

                        if os.path.basename(f) == "key" and path == keyDir and len:
                            lValidFile = True
                            keySize = thisFileSize
                        if os.path.basename(f) == "settings" and path == settingsDir:
                            lValidFile = True
                            safe_settingsSize = thisFileSize
                        if os.path.basename(f) == "trunk" and path == trunkDir:
                            lValidFile = True
                            safe_trunkSize=thisFileSize
                        if path[:len(sync_outDir)] == sync_outDir and (f.endswith(".txn") ):
                            lValidFile = True
                            sync_outSize += thisFileSize
                            sync_outCount += 1
                        if path[:len(trunkDir)] == trunkDir and (f.endswith("trunk") or f.endswith(".mdtxn") or f.endswith("processed.dct") or f.endswith("delete_to_push_sync_info") or f.endswith(".txn") or f.endswith("force_push_resync") ):
                            lValidFile = True
                            safe_tiksyncSize += thisFileSize
                            countTIKfiles += 1
                        if path[:len(attachDir)] == attachDir:
                            lValidFile = True
                            safe_attachmentsSize += thisFileSize
                            countAttachments += 1
                        if path[:len(archiveDir)] == archiveDir and f.endswith(".mdtxnarchive"):
                            lValidFile = True
                            safe_archiveSize += thisFileSize
                            countArchiveFiles += 1

                        if lValidFile:
                            countValidFiles += 1
                            validSize += thisFileSize
                            if thisFileSize > 500000:
                                listLargeFiles.append([fp,
                                                       thisFileSize,
                                                       pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11)])
                        else:
                            countNonValidFiles += 1
                            nonValidSize += thisFileSize
                            listNonValidFiles.append([fp,
                                                      thisFileSize,
                                                      pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11)])

                output+=("Dataset size:               %sMB\n" %(rpad(convertBytesMBs(total_size),12)))
                output+=("- settings file size:       %sKB\n" %(rpad(convertBytesKBs(safe_settingsSize),12)))
                output+=("- key file size:            %sKB\n" %(rpad(convertBytesKBs(keySize),12)))
                output+=("- tiksync folder size:      %sMB (with %s files)\n" %(rpad(convertBytesMBs(safe_tiksyncSize),12),countTIKfiles))
                output+=("  (note trunk file size:    %sMB)\n" %(rpad(convertBytesMBs(safe_trunkSize),12)))

                if sync_outCount:
                    output+=("  (WAITING Sync 'Out' size: %sMB with %s files)\n" %(rpad(convertBytesMBs(sync_outSize),12),sync_outCount))

                output+=("- attachments size:         %sMB (in %s attachments)\n" %(rpad(convertBytesMBs(safe_attachmentsSize),12),countAttachments))
                output+=("- archive size:             %sMB (in %s files)\n" %(rpad(convertBytesMBs(safe_archiveSize),12),countArchiveFiles))
                output+=(" --------------------------------------------\n")
                output+=("Valid files size:           %sMB (in %s files)\n\n" %(rpad(convertBytesMBs(validSize),12),countValidFiles))
                output+=("Non-core file(s) size:      %sMB (in %s files)\n" %(rpad(convertBytesMBs(nonValidSize),12),countNonValidFiles))
                for nonValid in listNonValidFiles:
                    output+=("   - Non-core: %sMB %s\n" %(rpad(convertBytesMBs(nonValid[1]),5),nonValid[0]))
                output+="\n\n"

                if len(listLargeFiles):
                    output+=("\nLARGE (core) file(s) > 0.5MB....:\n")
                    for largefile in listLargeFiles:
                        output+=("   - %sMB Mod: %s %s\n" %(rpad(convertBytesMBs(largefile[1]),5),largefile[2], largefile[0]))
                output += "\n\n"

                output += (count_database_objects())

                output += (find_other_datasets())

                output += "<END>"

                # diag.kill()

                txt = ("Your dataset contains %s files and is %sMB. %s non-core files were found consuming %sMB"
                       %(countValidFiles,convertBytesMBs(validSize),countNonValidFiles,convertBytesMBs(nonValidSize)))
                setDisplayStatus(txt, "B")

                jif = QuickJFrame("VIEW DATASET FILE ANALYSIS", output,copyToClipboard=GlobalVars.lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
                myPopupInformationBox(jif, txt, "DATASET FILE ANALYSIS")

        class DoTheMenu(AbstractAction):

            def __init__(self, specialCMD=False):
                self.specialCMD = specialCMD

            def actionPerformed(self, event):
                global debug        # Global must be here as we set this variable (i.e. do not create a local instance/copy)

                myPrint("DB", "DoTheMenu() - Command: '%s'" %(event.getActionCommand()))

                # ##########################################################################################################
                if event.getActionCommand().lower() == "page_setup":
                    pageSetup()

                # ##########################################################################################################
                if event.getActionCommand().lower() == GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER:
                    extnPrefs = getExtensionGlobalPreferences()
                    newSetting = not extnPrefs.getBoolean(GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER, False)
                    if myPopupAskQuestion(toolbox_frame_, "OBSERVER MODE", "%s Observer Mode?" %("ENABLE" if newSetting else "Disable")):
                        extnPrefs.put(GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER, Boolean(newSetting))        # Use Boolean() to get the right .put() method for boolean
                        saveExtensionGlobalPreferences(extnPrefs)
                        txt = "@@ OBSERVER MODE: %s" %("ENABLED" if newSetting else "disabled")
                        setDisplayStatus(txt, "B"); myPrint("B", txt)
                        if newSetting:
                            try: _observeMoneydanceObjects(_ALL_OBSERVED_BOOKS)
                            except: myPrint("B", "NOPE: Could not execute _observeMoneydanceObjects().... ignoring....")
                            myPopupInformationBox(toolbox_frame_,
                                                  theTitle="OBSERVER MODE",
                                                  theMessage="Please restart MD for Observer to harvest (weak)references to key objects as they are created",
                                                  theMessageType=JOptionPane.WARNING_MESSAGE)
                    else:
                        txt = "@@ OBSERVER MODE not changed - remains: %s" %("ENABLED" if not newSetting else "disabled")
                        setDisplayStatus(txt, "B"); myPrint("B", txt)
                    if debug: myPrint("B", "Extension Global Preferences now contains: %s" %(extnPrefs))
                    event.getSource().setSelected(extnPrefs.getBoolean(GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER, False))     # Use Boolean() to get the right .put() method for boolean

                # ##########################################################################################################
                if event.getActionCommand().lower() == "help":
                    DisplayHelp().actionPerformed(None)

                # ##########################################################################################################
                if event.getActionCommand().lower() == "about_toolbox":
                    AboutThisScript(toolbox_frame_).go()

                # ##########################################################################################################
                if event.getActionCommand().lower() == "about_moneydance":
                    # MD_REF.getUI().showAbout()
                    abtWin = AboutWindow(MD_REF.getUI(), toolbox_frame_)

                    try: abtWin.setEscapeKeyCancels(True)
                    except: pass

                    abtWin.setVisible(True)

                # ##########################################################################################################
                if event.getActionCommand().lower() == "auto_prune_internal_backups":

                    if not GlobalVars.lAutoPruneInternalBackups_TB:
                        if not myPopupAskQuestion(toolbox_frame_,
                                                  "AUTO PRUNE INTERNAL BACKUPS",
                                                  "Turn on Auto-Prune of internal backups of config.dict & settings (will always keep 5 days and/or 5 copies)?",
                                                  JOptionPane.YES_NO_OPTION,
                                                  JOptionPane.WARNING_MESSAGE):
                            txt = "AUTO-PRUNE INTERNAL BACKUPS DISABLED AS USER DECLINED TO PROCEED"
                            setDisplayStatus(txt, "R")

                            event.getSource().setSelected(False)

                            return
                        else:
                            myPrint("B", "@@ User asked to turn ON auto-prune of internal backups of config.dict and settings (5 days/5 copies).....")
                    else:
                        myPrint("B", "User asked to turn OFF the auto-prune of internal backups of config.dict and settings.....")

                    GlobalVars.lAutoPruneInternalBackups_TB = not GlobalVars.lAutoPruneInternalBackups_TB

                    if GlobalVars.lAutoPruneInternalBackups_TB:
                        prune_internal_backups()

                # ##########################################################################################################
                if event.getActionCommand().lower() == "disable_backups_disclaimers":

                    if not GlobalVars.lBypassAllBackupsAndDisclaimers_TB:
                        if not myPopupAskQuestion(toolbox_frame_,
                                                  "DISABLE BACKUP & DISCLAIMER WARNINGS",
                                                  "Disable all Backup & Disclaimer warnings?",
                                                  JOptionPane.YES_NO_OPTION,
                                                  JOptionPane.WARNING_MESSAGE):
                            txt = "BACKUP & DISCLAIMER WARNINGS STILL ENABLED - NO CHANGE"
                            setDisplayStatus(txt, "B")
                            event.getSource().setSelected(False)
                            return
                        else:
                            txt = "BACKUP & DISCLAIMER WARNINGS DISABLED"
                            setDisplayStatus(txt, "R")
                            myPrint("B", "@@ %s @@" %(txt))
                            logToolboxUpdates("DoTheMenu", txt)

                    else:
                        txt = "BACKUP & DISCLAIMER WARNINGS ENABLED"
                        setDisplayStatus(txt, "B")
                        myPrint("B", "@@ %s @@" %(txt))
                        myPrint("B", "User asked to enable Backup & Disclaimer warnings.....")
                        logToolboxUpdates("DoTheMenu", txt)

                    GlobalVars.lBypassAllBackupsAndDisclaimers_TB = not GlobalVars.lBypassAllBackupsAndDisclaimers_TB
                    GlobalVars.mainPnl_backupWarningsDisabled_lbl.setText("<BACKUP/DISCLAIMERS OFF>" if GlobalVars.lBypassAllBackupsAndDisclaimers_TB else "")

                # ##########################################################################################################
                if event.getActionCommand().lower() == "toolbox_debug":
                    debug = not debug
                    if not debug:
                        advanced_options_DEBUG(lForceOFF=True)
                        txt = "Toolbox Debug mode disabled... (Moneydance's internal Debug(s) turned off too...)"
                        setDisplayStatus(txt, "DG")
                    else:
                        advanced_options_DEBUG(lForceON=True)
                        txt = "Toolbox Debug mode ENABLED... (Moneydance's internal Debug(s) enabled too...)"
                        setDisplayStatus(txt, "DG"); myPrint("B", txt)

                    GlobalVars.mainPnl_debug_lbl.setText("<DEBUG ON>" if debug else "")

                # ##########################################################################################################
                if event.getActionCommand().lower() == "toggle_moneydance_debugs":
                    advanced_options_DEBUG()

                # ##########################################################################################################
                if event.getActionCommand().lower() == "copy_output_clipboard":
                    if GlobalVars.lCopyAllToClipBoard_TB:
                        txt = "Diagnostic outputs will NOT be copied to Clipboard"
                        setDisplayStatus(txt, "DG")
                    else:
                        txt = "Diagnostic outputs WILL now all be copied to the Clipboard"
                        setDisplayStatus(txt, "DG"); myPrint("B", txt)

                    GlobalVars.lCopyAllToClipBoard_TB = not GlobalVars.lCopyAllToClipBoard_TB

                # ##########################################################################################################
                if ((event.getActionCommand() == ToolboxMode.DEFAULT_CMD or event.getActionCommand() == ToolboxMode.DEFAULT_KEY_CMD)
                        or self.specialCMD):
                    if (not ToolboxMode.isUpdateMode() and
                            (GlobalVars.lBypassAllBackupsAndDisclaimers_TB or myPopupAskQuestion(toolbox_frame_,
                                          "ENABLE UPDATE MODE",
                                          "UPDATE MODE >> DISCLAIMER: DO YOU ACCEPT THAT YOU USE THIS TOOLBOX AT YOUR OWN RISK?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.ERROR_MESSAGE))):

                        if GlobalVars.lBypassAllBackupsAndDisclaimers_TB:
                            myPrint("B", "User enabled Toolbox UPDATE mode. NOTE: Backups and disclaimer warnings are DISABLED")
                        else:
                            myPrint("B", "User accepted Disclaimer and agreed to enable Toolbox UPDATE mode (at own risk).....")

                            backup = BackupButtonAction("Would you like to create a backup before enabling UPDATE mode?")
                            backup.actionPerformed(None)

                        backup_local_storage_settings()
                        backup_config_dict()

                        txt = "UPDATE MODE ENABLED - RED BUTTONS CAN CHANGE YOUR DATA (%s+I for Help)" %(MD_REF.getUI().ACCELERATOR_MASK_STR)
                        setDisplayStatus(txt, "R")

                        ToolboxMode.setUpdateMode(True)

                    else:

                        txt = "READ-ONLY MODE IN OPERATION (Update Mode NOT enabled)"
                        setDisplayStatus(txt, "DG")

                        ToolboxMode.setUpdateMode(False)

                    for btn in GlobalVars.allButtonsList: btn.setColorsAndVisibility()

                # ##########################################################################################################
                # Save parameters now...
                if (event.getActionCommand().lower() == "copy_output_clipboard"
                        or event.getActionCommand().lower() == "toolbox_debug"
                        or event.getActionCommand().lower() == "auto_prune_internal_backups"
                        or event.getActionCommand().lower() == "disable_backups_disclaimers"):

                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()

        def openDisplay(self):
            global toolbox_frame_   # global must be here as we define it here

            if debug:
                # ConsoleWindow.showConsoleWindow(MD_REF.getUI())
                myPrint("DB", "Flipping all Moneydance DEBUG flags ON.....")
                advanced_options_DEBUG(lForceON=True)

            screenSize = Toolkit.getDefaultToolkit().getScreenSize()

            # JFrame.setDefaultLookAndFeelDecorated(True)   # Note: Darcula Theme doesn't like this and seems to be OK without this statement...
            toolbox_frame_ = MyJFrame(u"Toolbox - Infinite Kind (co-authored by StuWareSoftSystems)... (%s+I for Help) - DATASET: %s" % (MD_REF.getUI().ACCELERATOR_MASK_STR, MD_REF.getCurrentAccountBook().getName().strip()))
            toolbox_frame_.setName(u"%s_main" %myModuleID)
            self.theFrame = toolbox_frame_

            ManuallyCloseAndReloadDataset.THIS_APPS_FRAME_REFERENCE = toolbox_frame_

            if (not Platform.isOSX()):
                MD_REF.getUI().getImages()
                toolbox_frame_.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

            toolbox_frame_.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)  # The CloseAction() and WindowListener() will handle dispose() - else change back to DISPOSE_ON_CLOSE

            displayString = buildDiagText()

            GlobalVars.STATUS_LABEL = JLabel("Infinite Kind (Moneydance) support tool >> DIAG STATUS: READ-ONLY MODE ACTIVE...", JLabel.LEFT)
            GlobalVars.STATUS_LABEL.setForeground(GlobalVars.DARK_GREEN)
            GlobalVars.STATUS_LABEL.setBorder(BorderFactory.createLineBorder(MD_REF.getUI().getColors().headerBorder, 2))

            try:
                if GlobalVars.lCopyAllToClipBoard_TB:
                    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(displayString), None)
            except:
                myPrint("J","Error copying diagnostic's main screen contents to Clipboard")
                dump_sys_error_to_md_console_and_errorlog()

            doTheMenu = self.DoTheMenu()

            # shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
            shortcut = MoneydanceGUI.ACCELERATOR_MASK

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, (shortcut | Event.SHIFT_MASK)), "unlock-window")   # So Plus on Mac...
            toolbox_frame_.getRootPane().getActionMap().put("unlock-window", self.UnlockAction(toolbox_frame_))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_SLASH, (shortcut)), "quick-jvm-diags")  # So / on Mac...
            toolbox_frame_.getRootPane().getActionMap().put("quick-jvm-diags", self.QuickJVMDiags(toolbox_frame_))

            # Add standard CMD-W keystrokes etc to close window
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F,  shortcut), "search-window")
            toolbox_frame_.getRootPane().getActionMap().put("close-window", self.CloseAction(toolbox_frame_))
            toolbox_frame_.addWindowListener(self.WindowListener(toolbox_frame_, self))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, shortcut), "display-pickle")
            toolbox_frame_.getRootPane().getActionMap().put("display-pickle", DisplayPickleFile())

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_U, (shortcut | Event.SHIFT_MASK)), "display-UUID")
            toolbox_frame_.getRootPane().getActionMap().put("display-UUID", self.DisplayUUID(toolbox_frame_))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_I, shortcut), "display-help")
            toolbox_frame_.getRootPane().getActionMap().put("display-help", DisplayHelp())

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(ToolboxMode.DEFAULT_KEY, shortcut), ToolboxMode.DEFAULT_CMD)
            toolbox_frame_.getRootPane().getActionMap().put(ToolboxMode.DEFAULT_CMD, self.DoTheMenu(True))

            frame_width = min(GetFirstMainFrame.DEFAULT_MAX_WIDTH, min(screenSize.width-20, max(GetFirstMainFrame.DEFAULT_MAX_WIDTH, int(round(GetFirstMainFrame.getSize().width *.95,0)))))
            frame_height = min(screenSize.height-20, max(GetFirstMainFrame.DEFAULT_MAX_HEIGHT, int(round(GetFirstMainFrame.getSize().height *.95,0))))
            toolbox_frame_.setPreferredSize(Dimension(frame_width, frame_height))

            # if MD_REF.getUI().firstMainFrame.getExtendedState() != JFrame.ICONIFIED:
            #     toolbox_frame_.setExtendedState(MD_REF.getUI().firstMainFrame.getExtendedState())
            # else:
            #     toolbox_frame_.setExtendedState(JFrame.MAXIMIZED_BOTH)

            toolbox_frame_.setExtendedState(JFrame.NORMAL)

            mainPnl = JPanel(GridBagLayout())

            if GlobalVars.lAutoPruneInternalBackups_TB:
                prune_internal_backups(lStartup=True)
            else:
                myPrint("J","Auto-prune of internal backups of config.dict, custom_theme.properties, ./safe/settings files is disabled... so no action")

            # --------------------------------------------------------------------------------------------------
            # START OF BUTTONS

            class MyJButton(JButton):
                def __init__(self, *args, **kwargs):
                    self.btnSize = Dimension(170,40)
                    # self.maxBtnSize = Dimension(170,80)
                    self.advancedCapable = kwargs.pop("advancedCapable", False)
                    self.updateCapable = kwargs.pop("updateCapable", False)
                    self.adhocButton = kwargs.pop("adhocButton", False)
                    self.backupButton = kwargs.pop("backupButton", False)
                    self.registerMDButton = kwargs.pop("registerMDButton", False)

                    super(JButton, self).__init__(*args)
                    self.setBorderPainted(False)
                    self.setOpaque(True)
                    self.setMinimumSize(self.btnSize)
                    # self.setMaximumSize(self.maxBtnSize)
                    self.setPreferredSize(self.btnSize)
                    self.setColorsAndVisibility()

                # def getPreferredSize(self):
                #     return self.btnSize

                def setColorsAndVisibility(self):

                    normalFG = MD_REF.getUI().getColors().defaultTextForeground
                    # normalBG = MD_REF.getUI().getColors().secondaryTextFG  # Just works across all themes better than 'defaultTextForeground'
                    normalBG = Color.LIGHT_GRAY

                    backupFG = MD_REF.getUI().getColors().hudFG
                    backupBG = getColorDarkGreen()
                    backupBOLD = True

                    registerMDFG = MD_REF.getUI().getColors().hudFG
                    registerMDBG = getColorRed()
                    registerMDBOLD = True

                    adhocFG = getColorRed()
                    adhocBG = normalBG
                    adhocBOLD = False

                    advancedEnabledFG = MD_REF.getUI().getColors().hudFG
                    advancedEnabledBG = getColorRed()
                    advancedEnabledBOLD = True

                    updateEnabledFG = getColorRed()
                    updateEnabledBOLD = False

                    if isMDThemeDark() or isMacDarkModeDetected(): pass
                    elif isMDThemeVAQua(): pass
                    elif isMDThemeDefault(): pass
                    elif isMDThemeClassic(): pass
                    elif isMDThemeHighContrast(): pass
                    elif isMDThemeSolarizedLight(): pass
                    elif isMDThemeSolarizedDark(): pass
                    elif isMDThemeCustomizable(): pass


                    if self.isBackupButton():
                        self.setForeground(backupFG)
                        self.setBackground(backupBG)
                        if backupBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        return

                    if self.isRegisterMDButton():
                        self.setForeground(registerMDFG)
                        self.setBackground(registerMDBG)
                        if registerMDBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        return

                    if self.isAdhocButton():
                        self.setForeground(adhocFG)
                        self.setBackground(adhocBG)
                        if adhocBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        self.setVisible(ToolboxMode.isUpdateMode())
                        return

                    if self.isAdvancedCapable() and ToolboxMode.isUpdateMode() and not self.isUpdateCapable():
                        self.setForeground(advancedEnabledFG)
                        self.setBackground(advancedEnabledBG)
                        if advancedEnabledBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        return

                    if ((self.isUpdateCapable() and ToolboxMode.isUpdateMode())
                            or (self.isAdvancedCapable() and ToolboxMode.isUpdateMode())):
                        self.setForeground(updateEnabledFG)
                        if updateEnabledBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                    else:
                        self.setForeground(normalFG)

                    self.setFont(self.getFont().deriveFont(Font.PLAIN))
                    self.setBackground(normalBG)

                def isBackupButton(self): return self.backupButton
                def isRegisterMDButton(self): return self.registerMDButton
                def isAdhocButton(self): return self.adhocButton
                def isAdvancedCapable(self): return self.advancedCapable
                def isUpdateCapable(self): return self.updateCapable

                def updateUI(self):
                    super(MyJButton, self).updateUI()
                    self.setColorsAndVisibility()


            backup_button = MyJButton("<html><center>CREATE BACKUP</center></html>", backupButton=True)
            backup_button.setToolTipText("This will allow you to take a backup of your Moneydance Dataset")
            backup_button.addActionListener(BackupButtonAction("Confirm you want to create a backup (same as MD Menu>File>Export Backup)?"))
            GlobalVars.allButtonsList.append(backup_button)

            analiseDatasetSize_button = MyJButton("<html><center>Analyse Dataset<BR>Objs, Size & Files</center></html>")
            analiseDatasetSize_button.setToolTipText("This quickly analyse the contents of your dataset and show you your Object counts, file sizes, what's taking space, and non-valid files...(show_object_type_quantities.py)")
            analiseDatasetSize_button.addActionListener(self.AnalyseDatasetSizeButtonAction())
            GlobalVars.allButtonsList.append(analiseDatasetSize_button)

            findDataset_button = MyJButton("<html><center>Find My Dataset(s)<BR>and Backups</center></html>")
            findDataset_button.setToolTipText("This will search your hard disk for copies of your Moneydance Dataset(s) - incl Backups.... NOTE: Can be CPU & time intensive..!")
            findDataset_button.addActionListener(self.FindDatasetButtonAction())
            GlobalVars.allButtonsList.append(findDataset_button)

            generalToolsMenu_button = MyJButton("<html><center>MENU: General<BR>tools</center></html>", updateCapable=True)
            generalToolsMenu_button.setToolTipText("Menu containing a variety of general Diagnostics, Fixes and Tools...")
            generalToolsMenu_button.addActionListener(self.GeneralToolsMenuButtonAction())
            GlobalVars.allButtonsList.append(generalToolsMenu_button)

            onlineBankingTools_button = MyJButton("<html><center>MENU: Online Banking<BR>Tools</center></html>", updateCapable=True, advancedCapable=True)
            onlineBankingTools_button.setToolTipText("A selection of tools for Online Banking - SOME OPTIONS CAN CHANGE DATA!")
            onlineBankingTools_button.addActionListener(self.OnlineBankingToolsButtonAction())
            GlobalVars.allButtonsList.append(onlineBankingTools_button)

            # ----------------------------------------------------------------------------------------------------------

            currencySecurityMenu_button = MyJButton("<html><center>MENU: Currency<BR>& Security tools</center></html>", updateCapable=True)
            currencySecurityMenu_button.setToolTipText("Menu containing Currency/Security Diagnostics, Fixes and Tools...")
            currencySecurityMenu_button.addActionListener(self.CurrencySecurityMenuButtonAction())
            GlobalVars.allButtonsList.append(currencySecurityMenu_button)

            accountsCategoryMenu_button = MyJButton("<html><center>MENU: Accounts<BR>& Categories tools</center></html>", updateCapable=True)
            accountsCategoryMenu_button.setToolTipText("Menu containing Account and Category Diagnostics, Fixes and Tools...")
            accountsCategoryMenu_button.addActionListener(self.AccountsCategoriesMenuButtonAction())
            GlobalVars.allButtonsList.append(accountsCategoryMenu_button)

            transactionMenu_button = MyJButton("<html><center>MENU: Transactions<BR>tools</center></html>", updateCapable=True)
            transactionMenu_button.setToolTipText("Menu containing Transactional Diagnostics, Fixes and Tools...")
            transactionMenu_button.addActionListener(self.TransactionMenuButtonAction())
            GlobalVars.allButtonsList.append(transactionMenu_button)

            advancedOptions_button = MyJButton("<html><center>MENU: Advanced<BR>Options</center></html>", updateCapable=True, advancedCapable=True)
            advancedOptions_button.setToolTipText("Menu containing 'Advanced' Tools, options, fixes...")
            advancedOptions_button.addActionListener(self.AdvancedOptionsMenuButtonAction())
            GlobalVars.allButtonsList.append(advancedOptions_button)

            CuriousViewInternalSettings_button = MyJButton("<html><center>CURIOUS?<BR>View Internal Settings</center></html>")
            CuriousViewInternalSettings_button.setToolTipText("This allows you to display very Technical Information on the Moneydance System and many key objects..... READONLY")
            CuriousViewInternalSettings_button.addActionListener(CuriousViewInternalSettingsButtonAction())
            GlobalVars.allButtonsList.append(CuriousViewInternalSettings_button)

            # ----------------------------------------------------------------------------------------------------------

            # These are instant fix buttons
            if not MD_REF.isRegistered():
                RegisterMD_button = MyJButton("<html><center>REGISTER<BR>MONEYDANCE</center></html>", registerMDButton=True)
                RegisterMD_button.setToolTipText("This allows you to enter your registration key")
                RegisterMD_button.addActionListener(self.RegisterMoneydance(RegisterMD_button))
                GlobalVars.allButtonsList.append(RegisterMD_button)

            if (not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()):
                convertSecondary_button = MyJButton("<html><center>FIX: Make me a<BR>Primary dataset</center></html>", adhocButton=True)
                convertSecondary_button.setToolTipText("Promotes this Dataset a Primary / Master Dataset. Enables Sync options. (typically after restore from a synchronised secondary dataset/backup). THIS CHANGES DATA!")
                convertSecondary_button.addActionListener(self.ConvertSecondaryButtonAction())
                convertSecondary_button.setVisible(False)
                GlobalVars.allButtonsList.append(convertSecondary_button)

            if (not check_for_dropbox_folder()):
                createMoneydanceSyncFolder_button = MyJButton("<html><center>FIX: Create Dropbox<BR>Sync Folder</center></html>", adhocButton=True)
                createMoneydanceSyncFolder_button.setToolTipText("This will allow you to add the missing .moneydancesync folder in Dropbox. THIS CREATES A FOLDER!")
                createMoneydanceSyncFolder_button.addActionListener(self.MakeDropBoxSyncFolder(createMoneydanceSyncFolder_button))
                createMoneydanceSyncFolder_button.setVisible(False)
                GlobalVars.allButtonsList.append(createMoneydanceSyncFolder_button)

            # lTabbingModeNeedsChanging = False
            # if (isOSXVersionBigSurOrLater()
            #         and int(MD_REF.getBuild()) < 3065
            #         and not DetectAndChangeMacTabbingMode(True).actionPerformed("quick check")):
            #     lTabbingModeNeedsChanging = True
            #     fixTabbingMode_button = MyJButton("<html><center>FIX: MacOS<BR>Tabbing Mode</center></html>", adhocButton=True)
            #     fixTabbingMode_button.setToolTipText("This allows you to check/fix your MacOS Tabbing Setting")
            #     fixTabbingMode_button.addActionListener(DetectAndChangeMacTabbingMode(False))
            #     fixTabbingMode_button.setVisible(False)
            #     GlobalVars.allButtonsList.append(fixTabbingMode_button)

            lWindowLocationsNeedZapping = False
            if (DetectInvalidWindowLocations(True).actionPerformed("quick_check")):
                lWindowLocationsNeedZapping = True
                fixInvalidWindowLocations_button = MyJButton("<html><center>FIX: Zap Invalid<BR>Window Locations</center></html>", adhocButton=True)
                fixInvalidWindowLocations_button.setToolTipText("This will zap any invalid window locations detected (i.e. they are 'off-screen')")
                fixInvalidWindowLocations_button.addActionListener(DetectInvalidWindowLocations(False))
                fixInvalidWindowLocations_button.setVisible(False)
                GlobalVars.allButtonsList.append(fixInvalidWindowLocations_button)

            if MD_REF.getCurrentAccountBook().getLocalStorage().getStr("migrated.netsync.dropbox.fileid", None):
                FixDropboxOneWaySync_button = MyJButton("<html><center>FIX: Remove Legacy<BR>Dropbox Sync Key</center></html>", adhocButton=True)
                FixDropboxOneWaySync_button.setToolTipText("This removes the key 'migrated.netsync.dropbox.fileid' to fix Dropbox One-way & iCloud Syncing issues (reset_sync_and_dropbox_settings.py)")
                FixDropboxOneWaySync_button.addActionListener(self.FixDropboxOneWaySyncButtonAction(FixDropboxOneWaySync_button))
                FixDropboxOneWaySync_button.setVisible(False)
                GlobalVars.allButtonsList.append(FixDropboxOneWaySync_button)

            lMobileAppTxnFilesFound = False
            if (DetectMobileAppTxnFiles(True).actionPerformed("quick_check")):
                lMobileAppTxnFilesFound = True
                fixDeleteMobileAppTxnFiles_button = MyJButton("<html><center>FIX: Delete mobile<BR>app .txn files</center></html>", adhocButton=True)
                fixDeleteMobileAppTxnFiles_button.setToolTipText("This will delete mobile app .txn files from sync location")
                fixDeleteMobileAppTxnFiles_button.addActionListener(DetectMobileAppTxnFiles(False))
                fixDeleteMobileAppTxnFiles_button.setVisible(False)
                GlobalVars.allButtonsList.append(fixDeleteMobileAppTxnFiles_button)

            # end of instant fix buttons
            # ----------------------------------------------------------------------------------------------------------

            ipady = 0                                                                                                   # noqa
            ipadx = 0                                                                                                   # noqa
            topInset = 5                                                                                                # noqa
            colLeftInset = 5                                                                                            # noqa
            colRightInset = 5                                                                                           # noqa
            colInsetFiller = 0                                                                                          # noqa

            onCol = 0
            onRow = 0
            for iButton in range(0,len(GlobalVars.allButtonsList)):
                if onCol >= 5:
                    onCol = 0
                    onRow += 1
                btn = GlobalVars.allButtonsList[iButton]
                colInsetFiller = 5 if onCol >= 4 else 0
                mainPnl.add(btn, GridC.getc(onCol, onRow).wx(0.1).wy(4.0).leftInset(colLeftInset).rightInset(colInsetFiller).topInset(topInset).fillboth())
                onCol += 1

            # ----------------------------------------------------------------------------------------------------------

            onCol = 0
            onRow += 1

            myDiagText = JTextArea(displayString)
            myDiagText.setEditable(False)
            lineWrap = False
            # if isMDThemeVAQua() and float(MD_REF.getBuild()) < 4077: lineWrap = True    # Bug in VAQua9.. Seems OK in VAQua10
            myDiagText.setLineWrap(lineWrap)
            if lineWrap: myDiagText.setWrapStyleWord(True)
            myDiagText.setFont(getMonoFont())

            mySearchAction = SearchAction(toolbox_frame_,myDiagText)
            toolbox_frame_.getRootPane().getActionMap().put("search-window", mySearchAction)

            topInset = 5
            botInset = 5
            ipady = 15
            ipadx = 5
            colSpan = 5
            colInsetFiller = 5
            colLeftInset = 5

            mainPnl.add(GlobalVars.STATUS_LABEL,
                                     GridC.getc(onCol, onRow).pady(ipady).padx(ipadx).leftInset(colLeftInset).rightInset(colInsetFiller).fillx().colspan(colSpan).topInset(topInset).bottomInset(botInset))
            # ----------------------------------------------------------------------------------------------------------

            self.myScrollPane = JScrollPane(myDiagText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
            # self.myScrollPane.setBorder(BorderFactory.createLineBorder((MD_REF.getUI().getColors()).mainPanelBorderColor, 1))  # This causes VAQua9 bug (OK in VAQua10)
            self.myScrollPane.setViewportBorder(EmptyBorder(1, 5, 5, 5))
            self.myScrollPane.setOpaque(False)
            self.myScrollPane.setWheelScrollingEnabled(True)

            onCol = 0
            onRow += 1
            colSpan = 6
            mainPnl.add(self.myScrollPane, GridC.getc(onCol, onRow).fillboth().colspan(colSpan).wx(99.0).wy(99.0))

            keyToUse = shortcut
            # if Platform.isWindows():
            #     keyToUse = InputEvent.ALT_MASK

            if Platform.isOSX():
                save_useScreenMenuBar= System.getProperty("apple.laf.useScreenMenuBar")
                if save_useScreenMenuBar is None or save_useScreenMenuBar == "":
                    save_useScreenMenuBar= System.getProperty("com.apple.macos.useScreenMenuBar")
                System.setProperty("apple.laf.useScreenMenuBar", "false")
                System.setProperty("com.apple.macos.useScreenMenuBar", "false")
            else:
                save_useScreenMenuBar = "true"

            SetupMDColors.updateUI()

            mb = JMenuBar()
            if Platform.isMac():
                menu1 = JMenu("<html><b>TOOLBOX Options</b></html>")
            else:
                menu1 = JMenu("<html><b><u>T</u>OOLBOX Options</b></html>")     # html breaks the Mnemonic....
            # menu1 = JMenu("TOOLBOX Options")
            menu1.setMnemonic(KeyEvent.VK_T)
            menu1.setForeground(SetupMDColors.FOREGROUND_REVERSED); menu1.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            menuItemD = JCheckBoxMenuItem("Toolbox Debug mode")
            menuItemD.setActionCommand("toolbox_debug")
            menuItemD.setMnemonic(KeyEvent.VK_D)
            menuItemD.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_D, (keyToUse | Event.SHIFT_MASK)))
            menuItemD.addActionListener(doTheMenu)
            menuItemD.setToolTipText("Enables toolbox debug mode - writes extra debug information to help/console (also turns on Moneydance's debug(s)")
            menuItemD.setSelected(debug)
            menu1.add(menuItemD)

            menuItemMD = JMenuItem("Toggle Moneydance Debug(s)")
            menuItemMD.setActionCommand("toggle_moneydance_debugs")
            menuItemMD.addActionListener(doTheMenu)
            menuItemMD.setToolTipText("Toggles Moneydance's internal debug mode(s) - writes extra debug information to help/console")
            menu1.add(menuItemMD)

            menuItemC = JCheckBoxMenuItem("Copy all Output to Clipboard")
            menuItemC.setActionCommand("copy_output_clipboard")
            menuItemC.setMnemonic(KeyEvent.VK_O)  # Can't think of a spare letter to use!!!!
            menuItemC.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, keyToUse))
            menuItemC.addActionListener(doTheMenu)
            menuItemC.setToolTipText("When selected copies the output of all displays to Clipboard")
            menuItemC.setSelected(GlobalVars.lCopyAllToClipBoard_TB)
            menu1.add(menuItemC)

            menuItemP = JCheckBoxMenuItem("Auto Prune Internal Backups")
            menuItemP.setActionCommand("auto_prune_internal_backups")
            menuItemP.setMnemonic(KeyEvent.VK_B)
            menuItemP.addActionListener(doTheMenu)
            menuItemP.setToolTipText("Enables auto pruning of the internal backups that Toolbox makes of config.dict, custom_theme.properties, and ./safe/settings")
            menuItemP.setSelected(GlobalVars.lAutoPruneInternalBackups_TB)
            menu1.add(menuItemP)

            menuItemW = JCheckBoxMenuItem("Disable Backup & Disclaimer warnings")
            menuItemW.setActionCommand("disable_backups_disclaimers")
            menuItemW.addActionListener(doTheMenu)
            menuItemW.setToolTipText("Disables all Toolbox's warnings about backups and disclaimers")
            menuItemW.setSelected(GlobalVars.lBypassAllBackupsAndDisclaimers_TB)
            menu1.add(menuItemW)

            menuItemF = JMenuItem("Find/Search")
            menuItemF.setActionCommand("find_search")
            menuItemF.setMnemonic(KeyEvent.VK_F)
            menuItemF.setToolTipText("Finds text within the main display window..")
            menuItemF.addActionListener(mySearchAction)
            menu1.add(menuItemF)

            menuItemPS = JMenuItem("Page Setup")
            menuItemPS.setActionCommand("page_setup")
            menuItemPS.setMnemonic(KeyEvent.VK_P)
            menuItemPS.setToolTipText("Printer Page Setup")
            menuItemPS.addActionListener(doTheMenu)
            menu1.add(menuItemPS)

            menuItemOB = JCheckBoxMenuItem("Enable Observer (special feature)")
            menuItemOB.setActionCommand(GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER)
            menuItemOB.setToolTipText("Enable special observer mode to capture (weak) references to key objects as they are created (view CMD-/) (extension only)")
            menuItemOB.addActionListener(doTheMenu)
            menuItemOB.setSelected(getExtensionGlobalPreferences().getBoolean(GlobalVars.EXTN_PREF_KEY_ENABLE_OBSERVER, False))
            menuItemOB.setEnabled(MD_EXTENSION_LOADER is not None)
            menu1.add(menuItemOB)

            menuItem2 = JMenuItem("Exit")
            menuItem2.setActionCommand("exit")
            menuItem2.setMnemonic(KeyEvent.VK_E)
            menuItem2.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, keyToUse))
            menuItem2.addActionListener(self.CloseAction(toolbox_frame_))
            menuItem2.setToolTipText("Exit this Toolbox")
            menu1.add(menuItem2)

            mb.add(menu1)

            if Platform.isMac():
                menuH = JMenu("<html><B>Help/About/Info</b></html>")     # html breaks the Mnemonic....
            else:
                menuH = JMenu("<html><B>Help/About/<u>I</u>nfo</b></html>")     # html breaks the Mnemonic....
            # menuH = JMenu("HELP")
            menuH.setMnemonic(KeyEvent.VK_I)
            menuH.setForeground(SetupMDColors.FOREGROUND_REVERSED); menuH.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            menuItemH = JMenuItem("Help/Info")
            menuItemH.setActionCommand("help")
            menuItemH.setMnemonic(KeyEvent.VK_I)
            menuItemH.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_I, keyToUse))
            menuItemH.setToolTipText("Display Help")
            menuItemH.addActionListener(doTheMenu)
            menuH.add(menuItemH)

            menuItemA = JMenuItem("About Toolbox")
            menuItemA.setActionCommand("about_toolbox")
            menuItemA.setMnemonic(KeyEvent.VK_A)
            menuItemA.setToolTipText("About...")
            menuItemA.addActionListener(doTheMenu)
            menuH.add(menuItemA)

            menuItemAMD = JMenuItem("About Moneydance")
            menuItemAMD.setActionCommand("about_moneydance")
            menuItemAMD.setToolTipText("About...")
            menuItemAMD.addActionListener(doTheMenu)
            menuH.add(menuItemAMD)

            mb.add(menuH)

            # ##############

            mb.add(Box.createHorizontalGlue())

            ToolboxMode.addActionListener(doTheMenu)
            ToolboxMode.setForeground(SetupMDColors.FOREGROUND_REVERSED)
            ToolboxMode.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            btnConsole = JButton("Launch Console Window")
            btnConsole.setToolTipText("launches the Moneydance Console Window (and turns DEBUG on).. Useful for extra diagnostics!")

            btnConsole.setOpaque(SetupMDColors.OPAQUE)
            btnConsole.setBackground(SetupMDColors.BACKGROUND)
            btnConsole.setForeground(SetupMDColors.FOREGROUND)

            # btnSaveConsole = JButton("Save Console Log")
            # btnSaveConsole.setToolTipText("Copy/save the Console Error log file to a directory of your choosing..")
            # btnSaveConsole.setOpaque(SetupMDColors.OPAQUE)
            # btnSaveConsole.setBackground(SetupMDColors.BACKGROUND)
            # btnSaveConsole.setForeground(SetupMDColors.FOREGROUND)

            btnOpenMDFolder = JButton("Open MD Folder")
            btnOpenMDFolder.setToolTipText("Open the selected Moneydance (internal) folder in Explorer/Finder window (etc)")
            btnOpenMDFolder.setOpaque(SetupMDColors.OPAQUE)
            btnOpenMDFolder.setBackground(SetupMDColors.BACKGROUND)
            btnOpenMDFolder.setForeground(SetupMDColors.FOREGROUND)

            btnCopyDiagnostics = JButton("Copy/Save/Print Diagnostics below")
            btnCopyDiagnostics.setToolTipText("Option to Copy the contents of the main diagnostics window (below) to the Clipboard.., or save to file, or print...")
            btnCopyDiagnostics.setOpaque(SetupMDColors.OPAQUE)
            btnCopyDiagnostics.setBackground(SetupMDColors.BACKGROUND)
            btnCopyDiagnostics.setForeground(SetupMDColors.FOREGROUND)

            mb.add(ToolboxMode.getJCheckBox())
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnConsole)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            # mb.add(btnSaveConsole)
            # mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnOpenMDFolder)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnCopyDiagnostics)

            mb.add(Box.createRigidArea(Dimension(30, 0)))

            btnConsole.addActionListener(ShowTheConsole())
            # btnSaveConsole.addActionListener(CopyConsoleLogFileButtonAction(MD_REF.getLogFile()))
            btnOpenMDFolder.addActionListener(OpenFolderButtonAction())
            btnCopyDiagnostics.addActionListener(ClipboardButtonAction(displayString))
            # ##############

            toolbox_frame_.setJMenuBar(mb)


            ############################################################################################################
            onCol = 0
            onRow += 1
            colSpan = 6

            bottomPanel = JPanel(GridBagLayout())
            bottomPanel.setBorder(EmptyBorder(10, 10, 10, 10))
            pnl_x = 0
            pnl_y = 0

            setSyncingLabel()
            bottomPanel.add(GlobalVars.mainPnl_syncing_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_debug_lbl.setText("<DEBUG ON>" if debug else "")
            GlobalVars.mainPnl_debug_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_debug_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_backupWarningsDisabled_lbl.setText("<BACKUP/DISCLAIMERS OFF>" if GlobalVars.lBypassAllBackupsAndDisclaimers_TB else "")
            GlobalVars.mainPnl_backupWarningsDisabled_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_backupWarningsDisabled_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_preview_lbl.setText("<PREVIEW BUILD>" if isPreviewBuild() else "")
            GlobalVars.mainPnl_preview_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_preview_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            bottomPanel.add(ToolboxMode.getStatusLabel(), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_toolboxUnlocked_lbl.setText("<TOOLBOX UNLOCKED>" if isToolboxUnlocked() else "")
            GlobalVars.mainPnl_toolboxUnlocked_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_toolboxUnlocked_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            setMemoryLabel()
            pnl_x = 0; pnl_y += 1
            bottomPanel.add(GlobalVars.mainPnl_memory_lbl, GridC.getc(pnl_x, pnl_y).fillx().colspan(12).center()); pnl_x += 1


            ############################################################################################################

            mainPnl.add(bottomPanel, GridC.getc(onCol, onRow).fillx().colspan(colSpan))

            toolbox_frame_.getContentPane().setLayout(BorderLayout())
            toolbox_frame_.getContentPane().add(mainPnl, BorderLayout.CENTER)

            toolbox_frame_.pack()
            toolbox_frame_.setLocationRelativeTo(None)

            try:
                toolbox_frame_.MoneydanceAppListener = MyMoneydanceEventListener(toolbox_frame_)
                MD_REF.addAppEventListener(toolbox_frame_.MoneydanceAppListener)
                myPrint("DB","@@ added AppEventListener() %s @@" %(classPrinter("MoneydanceAppListener", toolbox_frame_.MoneydanceAppListener)))
            except:
                myPrint("B","FAILED to add MD App Listener...")
                dump_sys_error_to_md_console_and_errorlog()

            toolbox_frame_.setVisible(True)     # already on the EDT
            toolbox_frame_.toFront()            # already on the EDT
            toolbox_frame_.isActiveInMoneydance = True

            myPrint("DB","Adding BlinkSwingTimer")
            BlinkSwingTimer(1200, ToolboxMode.getJCheckBox(), getColorRed()).start()

            myPrint("DB","Adding Preferences listener:", self)
            MD_REF.getPreferences().addListener(self)

            if Platform.isOSX():
                System.setProperty("apple.laf.useScreenMenuBar", save_useScreenMenuBar)
                System.setProperty("com.apple.macos.useScreenMenuBar", save_useScreenMenuBar)

            ###################### PERFORM POST-LAUNCH VALIDATION(s) AND POPUP APPROPRIATE ALERTS ######################
            ### MAKE SURE THESE POPUPS ARE NOT MODAL AND THUS DO NOT BLOCK THE EDT!
            ############################################################################################################

            # Look for security txns not properly linked back to the parent investment account
            if detect_non_hier_sec_acct_or_orphan_txns(startupCheck=True) > 0:
                statusTxt = "ERROR - Cross-linked (or Orphaned) security txn(s) detected.. Review Console!"
                output = ">> Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)'..."
                myPrint("B", statusTxt, output)
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus=statusTxt,
                                 theMessage=output,
                                 theTitle="ERROR - Non-Hierarchical Security Acct Txns".upper(),
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=2,
                                 lModal=False).go()

            # Attempt duplicate security detection...
            _countDuplicateSecurities, _duplicateSecurities, output = detect_duplicate_securities()
            if _countDuplicateSecurities > 0:
                statusTxt = "ALERT - Potential duplicate(d) securities found (in Tools>Securities)!"
                myPrint("B", statusTxt, output)
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus=statusTxt,
                                 theMessage=output,
                                 theTitle="ALERT - Potential Duplicate Securities Found".upper(),
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=False).go()
            del _countDuplicateSecurities, _duplicateSecurities, output

            # Check for accounts that have both OFX and MD+ configured.....
            if isMDPlusEnabledBuild():
                output = None
                allAccounts = sorted(AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccountBook(), AcctFilter.ALL_ACCOUNTS_FILTER), key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                for acct in allAccounts:
                    if not acct.canDownloadTxns(): continue
                    lOFXConfigured = lMDPlusConfigured = False
                    for link in acct.getBankingServices():
                        service = link.getService()
                        if service is not None and service.canDownloadTransactionsForAccount(acct):
                            if service.isMoneydancePlusService():
                                lMDPlusConfigured = True
                            else:
                                lOFXConfigured = True
                    if lOFXConfigured and lMDPlusConfigured:
                        if output is None: output = ""
                        output += "%s - %s\n" %(acct.getAccountType(), acct.getFullAccountName())
                    del lOFXConfigured, lMDPlusConfigured
                if output is not None:
                    output += "\n>> Use Online Banking Tools Menu>Delete OFX Banking Service / Logon Profile to remove OFX profile..."
                    statusTxt = "WARNING: You have both OFX and MD+ configured on these Account(s)...:"
                    myPrint("B", statusTxt, "\n", output)
                    MyPopUpDialogBox(toolbox_frame_,
                                     theStatus=statusTxt,
                                     theMessage=output,
                                     theTitle="WARNING - ONLINE BANKING CONFIGURATION",
                                     OKButtonText="ACKNOWLEDGE",
                                     lAlertLevel=2,
                                     lModal=False).go()
                del allAccounts, output


            # Check for base Currency rate != 1.0
            _baseCurr = MD_REF.getCurrentAccountBook().getCurrencies().getBaseType()
            _PARAM_RRATE = "rrate"
            if (_baseCurr.getParameter(_PARAM_RRATE, None) is None
                    or not isGoodRate(_baseCurr.getDoubleParameter(_PARAM_RRATE, 0.0))
                    or _baseCurr.getDoubleParameter(_PARAM_RRATE, 0.0) != 1.0
                    or _baseCurr.getRate(None) != 1.0):

                statusTxt = "ERROR: Your base currency (relative) rate is NOT 1.0!"
                output = ">> Use the 'Diagnose currencies / securities' to diagnose and then run the repair option..."
                myPrint("B", statusTxt, output)
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus=statusTxt,
                                 theMessage=output,
                                 theTitle="ERROR - CURRENCY: BASE (RELATIVE) RATE NOT 1.0",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=2,
                                 lModal=False).go()
            del _baseCurr, _PARAM_RRATE

            # Check for no currencies.. Popup alert message
            # noinspection PyUnresolvedReferences
            allCurrs = [c for c in MD_REF.getCurrentAccountBook().getCurrencies().getAllCurrencies() if c.getCurrencyType() == CurrencyType.Type.CURRENCY]
            if len(allCurrs) < 1:
                MyPopUpDialogBox(toolbox_frame_, "PROBLEM DETECTED",
                                                 "You seem to have no Currencies?!\n" 
                                                 "Please go to Tools/Currencies and add a Currency\n" 
                                                 "This would normally need to be your 'base' currency\n"
                                                 "You should check the currency setup of your accounts too!",
                                                 theTitle="ERROR - NO CURRENCIES EXIST",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=2,
                                                 lModal=False).go()
            del allCurrs

            # Check for problem with java.io.tmpdir - causes missing icons etc.. Popup alert message
            if not detect_broken_critical_javaio_temp_dir_OK():
                MyPopUpDialogBox(toolbox_frame_, "PROBLEM DETECTED",
                                                 "Your 'java.io.tmpdir' setting points to a folder that cannot be accessed\n" 
                                                 "%s\n" 
                                                 "Review console for details and correct problem"
                                                        %(return_critical_javaio_temp_dir_msg()),
                                                 theTitle="ERROR - JAVA TEMP FOLDER",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=2,
                                                 lModal=False).go()

            # Check for problem with 'auto' backup location... Popup alert message
            backupFolder = FileUtils.getBackupDir(MD_REF.getPreferences())
            backupType = MD_REF.getPreferences().getSetting(GlobalVars.Strings.MD_CONFIGDICT_BACKUP_TYPE, "every_x_days")
            autoBackup = (backupType != "no_backup")
            if not autoBackup:
                MyPopUpDialogBox(toolbox_frame_, "AUTO-BACKUP DISABLED",
                                                 "You appear to have disabled auto-backup\n" 
                                                 "If you require automatic backups then...\n" 
                                                 "..you should review menu MD>Preferences>Backups",
                                                 theTitle="WARNING: AUTO BACKUPS DISABLED",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=False).go()

            elif backupFolder is None or not isinstance(backupFolder, File) or not backupFolder.exists():
                MyPopUpDialogBox(toolbox_frame_,"POTENTIAL PROBLEM DETECTED",
                                                 "Your (auto) backup location appears invalid...\n" 
                                                 "..you should review menu MD>Preferences>Backups\n" 
                                                 "Review console for details and correct problem",
                                                 theTitle="ERROR: AUTO-BACKUP FOLDER INVALID",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=False).go()

            # Check for secondary node (potentially restored from backup).. Popup alert message
            if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():

                MyPopUpDialogBox(toolbox_frame_,"INFORMATION ONLY - THIS IS NOT A PROBLEM",
                                                 "This Dataset is running as a 'Secondary Node'\n" 
                                                 "- either you are Synchronising to it,\n" 
                                                 "- or you have restored it from a backup/sync copy.\n" 
                                                 "If these statements are true / OK, then ignore this message...\n" 
                                                 ">>Otherwise, to convert to Primary, select Update Mode.",
                                                 theTitle="SECONDARY DATASET/NODE",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=False).go()

            # Now look for cached downloaded txns that can be purged..
            try:
                countCachedAccount, countCachedTxns = quick_check_cached_online_txns()
                if countCachedTxns > 0:

                    if debug:
                        MyPopUpDialogBox(toolbox_frame_,
                                         theStatus="Cached OFX downloaded bank transactions exist:",
                                         theMessage="You appear to have %s Accounts\n"
                                                    "with %s cached OFX downloaded bank transactions.\n"
                                                    "These should not really be there.\n"
                                                    "Consider using Online Banking Tools menu to delete cached OnlineTxnList txns"
                                                    %(countCachedAccount, countCachedTxns),
                                         theTitle="ALERT: Cached OnlineTxnList records exist",
                                         OKButtonText="ACKNOWLEDGE",
                                         lAlertLevel=1,
                                         lModal=False).go()

                    else:
                        myPrint("B","#########################################################################################################################################################")
                        myPrint("B","### ALERT: You appear to have %s Accounts with %s cached OFX downloaded bank transactions."%(countCachedAccount, countCachedTxns))
                        myPrint("B","### These should not really be there.")
                        myPrint("B","### Consider using Online Banking Tools menu to delete cached OnlineTxnList txns.")
                        myPrint("B","#########################################################################################################################################################\n")
                del countCachedAccount, countCachedTxns
            except: pass

            # # Check to see if Tabbing mode needs changing on a MAc
            # if lTabbingModeNeedsChanging:
            #     MyPopUpDialogBox(toolbox_frame_,
            #                      theStatus="MacOS TABBING MODE WARNING:",
            #                      theMessage="Your Mac has 'Tabbing Mode' set to 'always'\n"
            #                                 "- You can find this in Settings>General>Prefer tabs:,\n"
            #                                 "- THIS CAUSES STRANGE MONEYDANCE FREEZES.\n"
            #                                 ">> To change this setting now, use UPDATE Mode...\n"
            #                                 "........\n",
            #                      theTitle="MacOS TABBING MODE WARNING",
            #                      OKButtonText="ACKNOWLEDGE",
            #                      lAlertLevel=1,
            #                      lModal=False).go()

            # Check to see if any windows are off-screen
            if lWindowLocationsNeedZapping:
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="INVALID WINDOW LOCATIONS WARNING:",
                                 theMessage="Toolbox has detected that you have at least one saved\n"
                                            "Moneydance window location that is invalid / 'off-screen'.\n"
                                            ">> To zap these invalid settings, use UPDATE Mode...\n"
                                            "........\n",
                                 theTitle="INVALID WINDOW LOCATIONS WARNING",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=False).go()

            # Detect any old(er) mobile app sync txn files...
            if lMobileAppTxnFilesFound:
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="MOBILE APP SYNC TXN FILES DETECTED:",
                                 theMessage="Toolbox has detected that you have at least one unprocessed\n"
                                            ".txn file(s) in your sync folder from your mobile app.\n"
                                            "These may be causing an error (review help/console)\n"
                                            ">> To DELETE these files, use UPDATE Mode...\n"
                                            "........\n",
                                 theTitle="MOBILE APP SYNC TXN FILES WARNING",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=False).go()

            # Check whether UserHome is missing - probably on a development platform
            if Platform.isOSX() and System.getProperty(u"UserHome") is None:
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="MacOS UserHome Warning:",
                                 theMessage="Your Mac's System Property 'UserHome' is not set\n"
                                            "Some features in Toolbox may not work as expected",
                                 theTitle="MacOS UserHome Warning",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=False).go()

            # Check whether Dropbox has been migrated to new location on Mac.... Is there a problem with the Alias?
            if detectMigratedDropboxFolderProblem():
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="MacOS Dropbox Location (migration) Warning:",
                                 theMessage="Your Dropbox location appears to have been migrated\n"
                                            ".. but there is problem with the Alias from the old location\n"
                                            "Use 'Update Mode' Menu: Advanced Options to attempt a fix....\n"
                                            "... (you may have to perform a manual fix)...",
                                 theTitle="Dropbox Location Warning",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=False).go()

            # Check for repeated opening of backup files
            try:
                datapath = MD_REF.getCurrentAccountBook().getRootFolder().getCanonicalPath()
                datafile = os.path.basename(datapath)
                datafilenew = datafile.replace(".moneydance", "")
                if len(datafilenew) > 17:
                    searchDash = datafilenew[-3] + datafilenew[-6] + datafilenew[-14] + datafilenew[-17]
                    if searchDash == "----":
                        MyPopUpDialogBox(toolbox_frame_,
                                         "ALERT: Detected multiple dates in dataset filename.",
                                         "This might mean you're opening backup (*.moneydancearchive) files by double-clicking\n"
                                         "...and this may be creating a new dataset everytime as a result... and so on....\n"
                                         ">> If so, please correct your file opening procedure <<\n"
                                         "(But, if you're happy with your procedure & dataset name, then ignore this alert)",
                                         theTitle="POTENTIAL IMPROPER OPENING OF BACKUP FILES",
                                         OKButtonText="ACKNOWLEDGE",
                                         lAlertLevel=1,
                                         lModal=False).go()
            except: pass

            checkForREADONLY()

            # Check for incorrect / invalid processed.dct file (I have seen this appear as a folder!?)...
            PROCESSED_FILES = "tiksync/processed.dct"
            try:
                _testOpen = MD_REF.getCurrentAccountBook().getLocalStorage().openFileForReading(PROCESSED_FILES)
                _testOpen.close()
                myPrint("DB", "Test opening internal '%s' file successful...!" %(PROCESSED_FILES))
                del _testOpen
            except:
                e_type, exc_value, exc_traceback = sys.exc_info()                                                       # noqa
                myPrint("B", "*** CRITICAL ERROR DETECTED. Could not open '%s'.. Error: '%s' >> QUIT MONEYDANCE AND RESOLVE PROBLEM" %(PROCESSED_FILES, exc_value))
                dump_sys_error_to_md_console_and_errorlog()
                MyPopUpDialogBox(toolbox_frame_, "CRITICAL PROBLEM DETECTED",
                                                 "Internal '%s' file could not be opened!\n" 
                                                 "Error: '%s'\n"
                                                 "Review console for more details....\n"
                                                 "(Contact IK Support for help)\n"
                                                 "PLEASE QUIT MONEYDANCE UNTIL THIS ISSUE IS FIXED!\n"
                                                        %(PROCESSED_FILES, exc_value),
                                                 theTitle="CRITICAL ERROR - INTERNAL FILE",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=2,
                                                 lModal=False).go()
                disableToolboxButtons()
            del PROCESSED_FILES


            MD_REF.getUI().setStatus("%s is loaded and running.." %(myModuleID.capitalize()), 0.0)
            ################################################################################################################
            ############# END OF OpenDisplay() #############################################################################
            ################################################################################################################


    if not GlobalVars.i_am_an_extension_so_run_headless: print("""
Script/extension is analysing your moneydance & system settings....
------------------------------------------------------------------------------
>> DISCLAIMER: This script/extension has the ability to change your data
>> Always perform backup first before making any changes!
>> The Author of this script/extension can take no responsibility for any harm caused
>> If you do not accept this, please exit the script/extension
------------------------------------------------------------------------------
""")

    if lFailed_get_StuWareSoftSystems_parameters_from_file:
        myPrint("B", "lFailed_get_StuWareSoftSystems_parameters_from_file() triggered... Perhaps your dataset is closed?")
        myPopupInformationBox(None,
                              "Failed to retrieve saved parameters from file, perhaps your dataset is closed?",
                              "TOOLBOX CANNOT OPEN",
                              JOptionPane.ERROR_MESSAGE)
        try: WelcomeWindow.showWelcomeWindow(MD_REF.getUI())
        except: pass
        cleanup_references()

    else:

        # Check based on fix_restored_accounts.py
        if MD_REF.getRootAccount() is None or MD_REF.getRootAccount().getAccountType() != Account.AccountType.ROOT:     # noqa
            msg = "@@ ERROR: Detected that your ROOT Account is Missing or not type ROOT! Contact support or the Author of Toolbox for a fix"
            myPrint("B", msg)
            myPrint("B", "@@ FYI - there used to be scripts called fix_restored_accounts.py or fix_root_account_type.py for this (but the last time I looked they were broken.)")
            myPopupInformationBox(None, msg, "ROOT ACCOUNT WARNING", JOptionPane.ERROR_MESSAGE)
            cleanup_references()

        else:

            MD_REF.getUI().setStatus(">> Infinite Kind (co-authored by Stuart Beesley: StuWareSoftSystems) - %s launching application......." %(myModuleID.capitalize()), 0)

            class MainAppRunnable(Runnable):
                def __init__(self): pass

                def run(self):                                                                                          # noqa
                    myPrint("DB", "In MainAppRunnable()", inspect.currentframe().f_code.co_name, "()")
                    myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                    if GlobalVars.lBypassAllBackupsAndDisclaimers_TB:
                        myPrint("B", "@@ User has previously DISABLED all warnings regarding backups and disclaimers @@".upper())

                    theDisplay = DiagnosticDisplay()
                    theDisplay.openDisplay()

                    # At this point, Toolbox is running. Put bypass methods here for debug testing
                    # ToolboxMode.setUpdateMode(True); Call a function here if needed for debug

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Main App Not running within the EDT so calling via MainAppRunnable()...")
                SwingUtilities.invokeAndWait(MainAppRunnable())
            else:
                myPrint("DB",".. Main App Already within the EDT so calling naked...")
                MainAppRunnable().run()

            # Download extension version data / requirements from IK and GitHib... Via new Thread in case of slow internet connection...
            _thread = Thread(DownloadExtensionVersionData(), "toolbox_DownloadExtensionVersionData".lower())
            _thread.setDaemon(True)
            _thread.start()
            del _thread

            myPrint("B", "Infinite Kind in conjunction with StuWareSoftSystems - ", GlobalVars.thisScriptName, " launch script ending (application is open/running)......")
