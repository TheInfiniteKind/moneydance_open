#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# ######################################################################################################################
# The Infinite Kind (Moneydance) - Co-authored by Stuart Beesley in collaboration with Moneydance as a support tool
#
# Moneydance Support Tool
# ######################################################################################################################

# toolbox.py build: 1053 - November 2020 thru 2022 onwards - Stuart Beesley StuWareSoftSystems (>1000 coding hours)
# Thanks and credit to Derek Kent(23) for his extensive testing and suggestions....
# Further thanks to Kevin(N), Dan T Davis, and dwg for their testing, input and OFX Bank help/input.....
# Credit of course to Moneydance(Sean) and IK retain all copyright over Moneydance internal code
# Designed to show user a number of settings / fixes / updates they may find useful (some normally hidden)
# Basic mode and Curious (view settings) are readonly and very safe >> They do NOT change any data or settings
# If you switch to Update / Advanced mode(s) then you have the ability to perform fixes, change data, change config etc
# NOTE: Any change that impacts config.dict, custom_theme.properties, LocalStorage() ./safe/settings...
#       will always backup that single config/settings file (in the directory where it's located).
#       This is not the same as backing up your Dataset that contains your financial data.

# NOTE: You will see some usage of globals... I wrote this when I was learning Python and Java... Know I know a lot more,
# I would do this differently, but leaving this as-is for now... (I'll upgrade elements as I make future changes)

# DISCLAIMER >> PLEASE ALWAYS BACKUP YOUR DATA BEFORE MAKING CHANGES (Menu>Create Backup will achieve this).

# Also includes these IK/Moneydance support scripts (but with enhanced capabilities)
# reset_relative_currencies.py                          (from Moneydance support)
# remove_ofx_account_bindings.py                        (from Moneydance support)
# convert_secondary_to_primary_data_set.py              (from Moneydance support)
# remove_one_service.py                                 (from Moneydance support)
# delete_invalid_txns.py                                (from Moneydance support)
# price_history_thinner.py                              (from Moneydance support)
# fix_dropbox_one_way_syncing.py                        (from Moneydance support)
# reset_sync_and_dropbox_settings.py                    (from Moneydance support)
# force_change_account_currency.py                      (from Moneydance support)
# fix_restored_accounts.py (check only)                 (from Moneydance support)
# export_all_attachments.py                             (from Moneydance support)
# fix_account_parent.py                                 (from Moneydance support)
# (... and old check_root_structure.py)                 (from Moneydance support)
# fix_non-hierarchical_security_account_txns.py         (from Moneydance support)
# (... and fix_investment_txns_to_wrong_security.py)    (from Moneydance support)
# remove_ofx_security_bindings.py                       (from Moneydance support)
# show_object_type_quantities.py                        (from Moneydance support)
# delete_intermediate_downloaded_transaction_caches.py  (from Moneydance support)
# delete_orphaned_downloaded_txn_lists.py               (from Moneydance support)
# set_account_type.py                                   (from Moneydance support)
# force_change_all_currencies.py                        (from Moneydance support)
# fix_invalid_currency_rates.py                         (from Moneydance support)
# reverse_txn_amounts.py                                (from Moneydance support)
# reverse_txn_exchange_rates_by_account_and_date.py     (from Moneydance support)
# show_open_tax_lots.py                                 (author unknown)
# MakeFifoCost.py                                       (author unknown)
# change-security-cusip.py                              (from Finite Mobius, LLC / Jason R. Miller)
# https://github.com/finitemobius/moneydance-py

###############################################################################
# MIT License
#
# Copyright (c) 2021-2022 Stuart Beesley - StuWareSoftSystems & Infinite Kind (Moneydance)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
###############################################################################

# NOTE: java.lang.IllegalArgumentException can occur when doing something like '"%s" %(java.util.HashMap)' containing unicode (or calling print on the same HashMap)
#       Should be fixed in Jython 2.7.3 sometime)... Also note that unicode() should be used instead of str() where appropriate....

# build: 1048 - Bugfix deleteOFXService() if no service selected...; Enhanced View OFX data for multiple service options (OFX and MD+)
# build: 1048 - Improved the 'STOP-NOW' command message (suggest to check for upgrade)
# build: 1049 - Updated Zap md+ option to wipe all md+ data from system (including all banking links)
# build: 1049 - Added redactor() to various outputs (especially OFX and curious modes)
# build: 1049 - Fixed calls to .setEscapeKeyCancels() on older MD versions...
# build: 1050 - Added force change currency for categories options...
# build: 1051 - Tweaks to internal code. Improved reset window positions code to pre-close all MD windows....
# build: 1051 - Changed invalid preferences locations/sizes code to zap keys from toolbox_init.py at MD launch.......
# build: 1051 - Improve vmoptions detector.
# build: 1051 - Added 'Rename this dataset (within the same location)' & 'Relocate this dataset back to the default 'internal' location' features
# build: 1051 - Added 'Cleanup MD's File/Open list of 'external' files (does not touch actual files)' feature
# build: 1051 - Moved the Delete internal/external files option to General Tools Menu (and auto purge external orphans)
# build: 1051 - Auto-magically restart MD (same dataset) when needed....; Changed menus so they all exit after each usage
# build: 1051 - Added 'Force MD+ name cache & access tokens rebuild' feature; Tweaked Export/Import/Zap/Wipe MD+ features
# build: 1051 - Added 'REGISTER MONEYDANCE' button (if not registered)...; Fixed invalid locations detection for off-screen negative (left)
# build: 1052 - Small bugfix when debug message crashed merge duplicate securities with java.lang.IllegalArgumentException
# build: 1052 - Updated toolbox_total_selected_transactions.py script; Added Detect/Fix Txns assigned to Root...
# build: 1052 - Enhanced fix_non_hier_sec_acct_txns() with autofix and tweak for concurrent modification of txn list error
# build: 1052 - Change lAutoPruneInternalBackups_TB default to True
# build: 1052 - Redact these keys and also added to remove list: 'netsync.db.access_token_key', 'netsync.db.access_token_secret', 'netsync.db.v2token'
# build: 1052 - Also detect/display/zap 'netsync.download_attachments'; Added 'Toggle Sync Downloading of Attachments' feature
# build: 1052 - Turned off linewrap on main diagnostic display... WATCHOUT FOR SLUGGISH DIAGNOSTICS SCREEN with long lines and wordwrap off! (Probably Mac only)
# build: 1052 - Fixed get_sync_folder() when Dropbox Connection (cloud service has no local folder on disk)
# build: 1052 - Added some more startup diag info to console error log during init and main script
# build: 1052 - Fixed bug with VAQua9 that causes Mac long lines in main display to slow down the scroll and cause memory issues. Don't do this: 'scrollpane.setBorder(BorderFactory.createLineBorder....
# build: 1052 - .... and thus removed the call to System.gc()
# build: 1052 - Tweaked init so that JVM stats captured from new thread after 10 seconds (to allow JVM memory to settle)...
# build: 1052 - Added 'Relocate this dataset to another location' option
# build: 1052 - Added AppleScript File Open selector (for when needed - e.g. trying to open 'special locations' or .moneydance bundle file)
# build: 1052 - Enhanced 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' to self-repair where 'sec' split missing (creates dummy fake security)
# build: 1052 - Added 'FIX: Detect and merge/fix duplicate Securities within same Investment Account(s)'
# build: 1052 - Added check for no currencies at launch... Odd, but has happened!
# build: 1052 - Enhanced Shrink Dataset... Allow 0 days, always delete out/txn-tmp...
# build: 1052 - Fix Merge Duplicate Securities (security split match check); fix apple script check on Mac version
# build: 1053 - Added 'DIAG: Show Securities with 'invalid' LOT Matching (cause of LOT matching popup window)' feature
# build: 1053 - FileDialog() (refer: java.desktop/sun/lwawt/macosx/CFileDialog.java) seems to no longer use "com.apple.macos.use-file-dialog-packages" in favor of "apple.awt.use-file-dialog-packages" since Monterrey...
# build: 1053 - New feature 'Decrypt entire dataset' feature...
# build: 1053 - New feature 'Force Disconnect an MD+ Connection' (also added to view service profiles)
# build: 1053 - Allow md+ payload ids to appear in the view service profile output, unless user selects redacted option...
# build: 1053 - Now clear MDPlus.licenseCache when shutting down the plusPoller...
# build: 1053 - Improved ManuallyCloseAndReloadDataset() to release all references to (old) book, and shutdown more things - memory consumption etc....
# build: 1053 - Added CMD-/ - calls up QuickJVMDiags(); tweaked Common Code...
# build: 1053 - Flip to restart after Import and Zap md+ license (was exit) - now that we reset licenseCache.....
# build: 1053 - Alerts to detect invalid backup locations (or auto-backup off); init code now warns about memory % and invalid backup locations too...
# build: 1053 - Common code update - remove Decimal Grouping Character - not necessary to collect and crashes on newer Java versions (> byte)
# build: 1053 - Added unlock (secret) option 'Close Dataset'; added JVM Memory stats to status line...

# todo - Clone Dataset - stage-2 - date and keep some data/balances (what about Loan/Liability/Investment accounts... (Fake cat for cash)?
# todo - add SwingWorker Threads as appropriate (on heavy duty methods)
# todo - Consider Thread() when downloading data from internet (version checking, extension versions etc) to eliminate launch 'lag'...
# todo - change from str() to unicode() where appropriate...

# NOTE: Toolbox will connect to the internet to gather some data. IT WILL NOT SEND ANY OF YOUR DATA OUT FROM YOUR SYSTEM. This is why:
# 1. At launch it connects to the Author's code site to get information about the latest version of Toolbox and version requirements
# 2. At various times it may connect to the Infinite Kind server to gather information about extensions and versions
# 3. Within the OFX banking menu, it can connect to the Infinite Kind server to get the latest bank connection profiles for viewing
# >> NOTE: This may cause a 'lag' when launching Toolbox if you have a slow internet connection...

# NOTE - I Use IntelliJ IDE - you may see # noinspection Pyxxxx or # noqa comments
# These tell the IDE to ignore certain irrelevant/erroneous warnings being reporting:
# Further options at: https://www.jetbrains.com/help/pycharm/disabling-and-enabling-inspections.html#comments-ref

# CUSTOMIZE AND COPY THIS ##############################################################################################
# CUSTOMIZE AND COPY THIS ##############################################################################################
# CUSTOMIZE AND COPY THIS ##############################################################################################

# SET THESE LINES
myModuleID = u"toolbox"
version_build = "1053"
MIN_BUILD_REQD = 1915                   # Min build for Toolbox 2020.0(1915)
_I_CAN_RUN_AS_MONEYBOT_SCRIPT = True

if u"debug" in globals():
    global debug
else:
    debug = False
global toolbox_frame_
# SET LINES ABOVE ^^^^

# COPY >> START
global moneydance, moneydance_ui, moneydance_extension_loader, moneydance_extension_parameter
MD_REF = moneydance             # Make my own copy of reference as MD removes it once main thread ends.. Don't use/hold on to _data variable
MD_REF_UI = moneydance_ui       # Necessary as calls to .getUI() will try to load UI if None - we don't want this....
if MD_REF is None: raise Exception("CRITICAL ERROR - moneydance object/variable is None?")
if u"moneydance_extension_loader" in globals():
    MD_EXTENSION_LOADER = moneydance_extension_loader
else:
    MD_EXTENSION_LOADER = None

from java.lang import System, Runnable
from javax.swing import JFrame, SwingUtilities, SwingWorker
from java.awt.event import WindowEvent

class QuickAbortThisScriptException(Exception): pass

class MyJFrame(JFrame):

    def __init__(self, frameTitle=None):
        super(JFrame, self).__init__(frameTitle)
        self.disposing = False
        self.myJFrameVersion = 3
        self.isActiveInMoneydance = False
        self.isRunTimeExtension = False
        self.MoneydanceAppListener = None
        self.HomePageViewObj = None

    def dispose(self):
        # This removes all content as VAqua retains the JFrame reference in memory...
        if self.disposing: return
        try:
            self.disposing = True
            self.removeAll()
            if self.getJMenuBar() is not None: self.setJMenuBar(None)
            super(self.__class__, self).dispose()
        except:
            _msg = "%s: ERROR DISPOSING OF FRAME: %s\n" %(myModuleID, self)
            print(_msg); System.err.write(_msg)
        finally:
            self.disposing = False

class GenericWindowClosingRunnable(Runnable):

    def __init__(self, theFrame):
        self.theFrame = theFrame

    def run(self):
        self.theFrame.setVisible(False)
        self.theFrame.dispatchEvent(WindowEvent(self.theFrame, WindowEvent.WINDOW_CLOSING))

class GenericDisposeRunnable(Runnable):
    def __init__(self, theFrame):
        self.theFrame = theFrame

    def run(self):
        self.theFrame.setVisible(False)
        self.theFrame.dispose()

class GenericVisibleRunnable(Runnable):
    def __init__(self, theFrame, lVisible=True, lToFront=False):
        self.theFrame = theFrame
        self.lVisible = lVisible
        self.lToFront = lToFront

    def run(self):
        self.theFrame.setVisible(self.lVisible)
        if self.lVisible and self.lToFront:
            if self.theFrame.getExtendedState() == JFrame.ICONIFIED:
                self.theFrame.setExtendedState(JFrame.NORMAL)
            self.theFrame.toFront()

def getMyJFrame(moduleName):
    try:
        frames = JFrame.getFrames()
        for fr in frames:
            if (fr.getName().lower().startswith(u"%s_main" %moduleName)
                    and (type(fr).__name__ == MyJFrame.__name__ or type(fr).__name__ == u"MyCOAWindow")  # isinstance() won't work across namespaces
                    and fr.isActiveInMoneydance):
                _msg = "%s: Found live frame: %s (MyJFrame() version: %s)\n" %(myModuleID,fr.getName(),fr.myJFrameVersion)
                print(_msg); System.err.write(_msg)
                if fr.isRunTimeExtension:
                    _msg = "%s: ... and this is a run-time self-installed extension too...\n" %(myModuleID)
                    print(_msg); System.err.write(_msg)
                return fr
    except:
        _msg = "%s: Critical error in getMyJFrame(); caught and ignoring...!\n" %(myModuleID)
        print(_msg); System.err.write(_msg)
    return None


frameToResurrect = None
try:
    # So we check own namespace first for same frame variable...
    if (u"%s_frame_"%myModuleID in globals()
            and (isinstance(toolbox_frame_, MyJFrame)                 # EDIT THIS
                 or type(toolbox_frame_).__name__ == u"MyCOAWindow")  # EDIT THIS
            and toolbox_frame_.isActiveInMoneydance):                 # EDIT THIS
        frameToResurrect = toolbox_frame_                             # EDIT THIS
    else:
        # Now check all frames in the JVM...
        getFr = getMyJFrame( myModuleID )
        if getFr is not None:
            frameToResurrect = getFr
        del getFr
except:
    msg = "%s: Critical error checking frameToResurrect(1); caught and ignoring...!\n" %(myModuleID)
    print(msg); System.err.write(msg)

# ############################
# Trap startup conditions here.... The 'if's pass through to oblivion (and thus a clean exit)... The final 'else' actually runs the script
if int(MD_REF.getBuild()) < MIN_BUILD_REQD:     # Check for builds less than 1904 (version 2019.4) or build 3056 accordingly
    msg = "SORRY YOUR MONEYDANCE VERSION IS TOO OLD FOR THIS SCRIPT/EXTENSION (min build %s required)" %(MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try:    MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif frameToResurrect and frameToResurrect.isRunTimeExtension:
    msg = "%s: Sorry - runtime extension already running. Please uninstall/reinstall properly. Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif not _I_CAN_RUN_AS_MONEYBOT_SCRIPT and u"__file__" in globals():
    msg = "%s: Sorry - this script cannot be run in Moneybot console. Please install mxt and run extension properly. Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif not _I_CAN_RUN_AS_MONEYBOT_SCRIPT and u"moneydance_extension_loader" not in globals():
    msg = "%s: Error - moneydance_extension_loader seems to be missing? Must be on build: %s onwards. Now exiting script!\n" %(myModuleID, MIN_BUILD_REQD)
    print(msg); System.err.write(msg)
    try: MD_REF_UI.showInfoMessage(msg)
    except: raise Exception(msg)

elif frameToResurrect:  # and it's active too...
    try:
        msg = "%s: Detected that %s is already running..... Attempting to resurrect..\n" %(myModuleID, myModuleID)
        print(msg); System.err.write(msg)
        SwingUtilities.invokeLater(GenericVisibleRunnable(frameToResurrect, True, True))
    except:
        msg  = "%s: Failed to resurrect main Frame.. This duplicate Script/extension is now terminating.....\n" %(myModuleID)
        print(msg); System.err.write(msg)
        raise Exception(msg)

else:
    del frameToResurrect
    msg = "%s: Startup conditions passed (and no other instances of this program detected). Now executing....\n" %(myModuleID)
    print(msg); System.err.write(msg)

    # COMMON IMPORTS #######################################################################################################
    # COMMON IMPORTS #######################################################################################################
    # COMMON IMPORTS #######################################################################################################

    # NOTE: As of MD2022(4040) python.getSystemState().setdefaultencoding("utf8") is called on the python interpreter at launch...
    import sys
    reload(sys)  # Dirty hack to eliminate UTF-8 coding errors
    sys.setdefaultencoding('utf8')  # Dirty hack to eliminate UTF-8 coding errors. Without this str() fails on unicode strings...

    import os
    import os.path
    import codecs
    import inspect
    import pickle
    import platform
    import csv
    import datetime
    import traceback
    import subprocess

    from org.python.core.util import FileUtil

    from com.moneydance.util import Platform
    from com.moneydance.awt import JTextPanel, GridC, JDateField
    from com.moneydance.apps.md.view.gui import MDImages

    from com.infinitekind.util import DateUtil, CustomDateFormat, StringUtils

    from com.infinitekind.moneydance.model import *
    from com.infinitekind.moneydance.model import AccountUtil, AcctFilter, CurrencyType, CurrencyUtil
    from com.infinitekind.moneydance.model import Account, Reminder, ParentTxn, SplitTxn, TxnSearch, InvestUtil, TxnUtil

    from com.moneydance.apps.md.controller import AccountBookWrapper
    from com.infinitekind.moneydance.model import AccountBook

    from javax.swing import JButton, JScrollPane, WindowConstants, JLabel, JPanel, JComponent, KeyStroke, JDialog, JComboBox
    from javax.swing import JOptionPane, JTextArea, JMenuBar, JMenu, JMenuItem, AbstractAction, JCheckBoxMenuItem, JFileChooser
    from javax.swing import JTextField, JPasswordField, Box, UIManager, JTable, JCheckBox, JRadioButton, ButtonGroup
    from javax.swing.text import PlainDocument
    from javax.swing.border import EmptyBorder
    from javax.swing.filechooser import FileFilter

    exec("from javax.print import attribute")       # IntelliJ doesnt like the use of 'print' (as it's a keyword). Messy, but hey!
    exec("from java.awt.print import PrinterJob")   # IntelliJ doesnt like the use of 'print' (as it's a keyword). Messy, but hey!
    global attribute, PrinterJob

    from java.awt.datatransfer import StringSelection
    from javax.swing.text import DefaultHighlighter
    from javax.swing.event import AncestorListener

    from java.awt import Color, Dimension, FileDialog, FlowLayout, Toolkit, Font, GridBagLayout, GridLayout
    from java.awt import BorderLayout, Dialog, Insets, Point
    from java.awt.event import KeyEvent, WindowAdapter, InputEvent
    from java.util import Date, Locale

    from java.text import DecimalFormat, SimpleDateFormat, MessageFormat
    from java.util import Calendar, ArrayList
    from java.lang import Thread, IllegalArgumentException, String, Integer, Long
    from java.lang import Double, Math, Character, NoSuchFieldException, NoSuchMethodException, Boolean
    from java.lang.reflect import Modifier
    from java.io import FileNotFoundException, FilenameFilter, File, FileInputStream, FileOutputStream, IOException, StringReader
    from java.io import BufferedReader, InputStreamReader
    from java.nio.charset import Charset
    if isinstance(None, (JDateField,CurrencyUtil,Reminder,ParentTxn,SplitTxn,TxnSearch, JComboBox, JCheckBox,
                         AccountBook, AccountBookWrapper, Long, Integer, Boolean,                          
                         JTextArea, JMenuBar, JMenu, JMenuItem, JCheckBoxMenuItem, JFileChooser, JDialog,
                         JButton, FlowLayout, InputEvent, ArrayList, File, IOException, StringReader, BufferedReader,
                         InputStreamReader, Dialog, JTable, BorderLayout, Double, InvestUtil, JRadioButton, ButtonGroup,
                         AccountUtil, AcctFilter, CurrencyType, Account, TxnUtil, JScrollPane, WindowConstants, JFrame,
                         JComponent, KeyStroke, AbstractAction, UIManager, Color, Dimension, Toolkit, KeyEvent, GridLayout,
                         WindowAdapter, CustomDateFormat, SimpleDateFormat, Insets, FileDialog, Thread, SwingWorker)): pass
    if codecs.BOM_UTF8 is not None: pass
    if csv.QUOTE_ALL is not None: pass
    if datetime.MINYEAR is not None: pass
    if Math.max(1,1): pass
    # END COMMON IMPORTS ###################################################################################################

    # COMMON GLOBALS #######################################################################################################
    # All common globals have now been eliminated :->
    # END COMMON GLOBALS ###################################################################################################
    # COPY >> END

    # SET THESE VARIABLES FOR ALL SCRIPTS ##################################################################################
    if "GlobalVars" in globals():   # Prevent wiping if 'buddy' extension - like Toolbox - is running too...
        global GlobalVars
    else:
        class GlobalVars:        # Started using this method for storing global variables from August 2021
            CONTEXT = MD_REF
            defaultPrintService = None
            defaultPrinterAttributes = None
            defaultPrintFontSize = None
            defaultPrintLandscape = None
            defaultDPI = 72     # NOTE: 72dpi is Java2D default for everything; just go with it. No easy way to change
            STATUS_LABEL = None
            DARK_GREEN = Color(0, 192, 0)
            resetPickleParameters = False
            decimalCharSep = "."
            lGlobalErrorDetected = False
            MYPYTHON_DOWNLOAD_URL = "https://yogi1967.github.io/MoneydancePythonScripts/"
            i_am_an_extension_so_run_headless = None
            parametersLoadedFromFile = {}
            thisScriptName = None
            MD_MDPLUS_BUILD = 4040
            MD_ALERTCONTROLLER_BUILD = 4077
            def __init__(self): pass    # Leave empty

            class Strings:
                def __init__(self): pass    # Leave empty

    GlobalVars.thisScriptName = u"%s.py(Extension)" %(myModuleID)

    # END SET THESE VARIABLES FOR ALL SCRIPTS ##############################################################################

    # >>> THIS SCRIPT'S IMPORTS ############################################################################################
    import re
    import fnmatch
    import time
    import shutil
    import threading
    from collections import OrderedDict

    from java.lang import Process, NoClassDefFoundError, OutOfMemoryError, Runtime
    from java.lang.ref import WeakReference

    from org.python.core import PySystemState

    from javax.swing import BorderFactory, JSeparator, DefaultComboBoxModel                                                 # noqa

    from java.io import ByteArrayInputStream, OutputStream, InputStream, BufferedOutputStream
    from java.net import URL, URLEncoder, URLDecoder                                                                        # noqa
    from java.awt import GraphicsEnvironment, Rectangle, GraphicsDevice, Desktop, Event, GridBagConstraints, Window, Frame  # noqa
    from java.awt.event import ComponentAdapter, ItemListener, ItemEvent, HierarchyListener                                 # noqa
    from java.util import UUID, Timer, TimerTask, Map, HashMap, Vector
    from java.util.zip import ZipInputStream, ZipEntry, ZipOutputStream
    from java.nio.charset import StandardCharsets
    from java.nio.file import Paths, Files, StandardCopyOption
    from java.security import MessageDigest, KeyFactory
    from java.security.spec import PKCS8EncodedKeySpec, X509EncodedKeySpec, MGF1ParameterSpec

    from javax.crypto import Cipher, BadPaddingException
    from javax.crypto.spec import SecretKeySpec, OAEPParameterSpec, PSource

    from com.google.gson import Gson

    # renamed in MD build 3067
    if int(MD_REF.getBuild()) >= 3067:
        from com.moneydance.apps.md.view.gui.theme import ThemeInfo                                                     # noqa
    else:
        from com.moneydance.apps.md.view.gui.theme import Theme as ThemeInfo                                            # noqa

    try:
        if Platform.isOSX() and int(MD_REF.getBuild()) >= 3088:
            from com.moneydance.apps.md.view.gui.sync import ICloudSyncConfigurer
            from com.moneydance.apps.md.controller.sync import ICloudContainer
    except: pass

    from com.moneydance.apps.md.view.gui.sync import SyncFolderUtil
    from com.moneydance.apps.md.controller import MDException, Util, AppEventListener, PreferencesListener
    from com.moneydance.apps.md.controller import ModuleLoader, ModuleMetaData, LocalStorageCipher, Common, BalanceType
    from com.moneydance.apps.md.controller.sync import MDSyncCipher
    from com.moneydance.apps.md.controller.io import FileUtils, AccountBookUtil
    from com.moneydance.apps.md.controller.olb import MoneybotURLStreamHandlerFactory
    from com.moneydance.apps.md.controller.olb.ofx import OFXConnection

    from com.infinitekind.util import StreamTable, StreamVector, IOUtils
    from com.infinitekind.tiksync import SyncRecord, SyncableItem, Syncer

    from com.infinitekind.moneydance.model import ReportSpec, AddressBookEntry, OnlineService, MoneydanceSyncableItem
    from com.infinitekind.moneydance.model import OnlinePayeeList, OnlinePaymentList, InvestFields, AbstractTxn
    from com.infinitekind.moneydance.model import CurrencySnapshot, CurrencySplit, OnlineTxnList, CurrencyTable
    from com.infinitekind.moneydance.model import TxnSet, InvestTxnType

    from com.infinitekind.moneydance.online import OnlineTxnMerger, OFXAuthInfo

    from com.moneydance.awt import JCurrencyField, AwtUtil                                                              # noqa
    from com.moneydance.security import SecretKeyCallback
    from com.moneydance.apps.md.view.gui import OnlineUpdateTxnsWindow, MDAccountProxy, ConsoleWindow, AboutWindow
    from com.moneydance.apps.md.view.gui import MainFrame, SecondaryFrame, SecondaryWindow, LicenseKeyWindow            # noqa
    from com.moneydance.apps.md.view.gui import WelcomeWindow, SearchRegTxnListModel, SecondaryDialog
    from com.moneydance.apps.md.view.gui.bot import MoneyBotWindow
    from com.moneydance.apps.md.view.gui.txnreg import TxnDetailsPanel, TxnRegister, TxnRegisterType, InvestRegisterType
    from com.moneydance.apps.md.view.gui.txnreg import DownloadedTxnsView
    from com.moneydance.apps.md.view.gui.extensions import ExtensionsWindow                                             # noqa
    from com.moneydance.apps.md.view.gui.sync import DropboxSyncConfigurer

    try:
        from com.infinitekind.moneydance.model import TxnSortOrder
        lImportOK = True
    except:
        lImportOK = False
    # >>> END THIS SCRIPT'S IMPORTS ########################################################################################

    # >>> THIS SCRIPT'S GLOBALS ############################################################################################
    global __TOOLBOX
    global toolbox_frame_, fixRCurrencyCheck, lCopyAllToClipBoard_TB, _COLWIDTHS
    global lIgnoreOutdatedExtensions_TB, lAutoPruneInternalBackups_TB
    global globalSaveFI_data, globalSave_DEBUG_FI_data
    global TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_BUILD
    global MD_OFX_BANK_SETTINGS_DIR, MD_OFX_DEFAULT_SETTINGS_FILE, MD_OFX_DEBUG_SETTINGS_FILE, MD_EXTENSIONS_DIRECTORY_FILE
    global TOOLBOX_VERSION_VALIDATION_URL, TOOLBOX_STOP_NOW
    global MD_RRATE_ISSUE_FIXED_BUILD, MD_ICLOUD_ENABLED, MD_MULTI_OFX_TXN_DNLD_DATES_BUILD
    global MD_MDPLUS_TEST_UNIQUE_BANKING_SERVICES_BUILD, MD_MDPLUS_GETPLAIDCLIENT_BUILD

    TOOLBOX_MINIMUM_TESTED_MD_VERSION = 2020.0                                                                          # noqa
    TOOLBOX_MAXIMUM_TESTED_MD_VERSION = 2022.5                                                                          # noqa
    TOOLBOX_MAXIMUM_TESTED_MD_BUILD =   4091                                                                            # noqa
    MD_OFX_BANK_SETTINGS_DIR = "https://infinitekind.com/app/md/fis/"                                                   # noqa
    MD_OFX_DEFAULT_SETTINGS_FILE = "https://infinitekind.com/app/md/fi2004.dict"                                        # noqa
    MD_OFX_DEBUG_SETTINGS_FILE = "https://infinitekind.com/app/md.debug/fi2004.dict"                                    # noqa
    MD_EXTENSIONS_DIRECTORY_FILE = "https://infinitekind.com/app/md/extensions.dct"                                     # noqa
    TOOLBOX_VERSION_VALIDATION_URL = "https://raw.githubusercontent.com/yogi1967/MoneydancePythonScripts/master/source/toolbox/toolbox_version_requirements.dict" # noqa
    # Alternatively perhaps use....: "https://raw.githubusercontent.com/TheInfiniteKind/moneydance_open/main/python_scripts/toolbox/toolbox_version_requirements.dict"

    MD_ICLOUD_ENABLED = 3088                                                                                            # noqa
    MD_RRATE_ISSUE_FIXED_BUILD = 3089                                                                                   # noqa
    MD_MDPLUS_TEST_UNIQUE_BANKING_SERVICES_BUILD = 4078                                                                 # noqa
    MD_MULTI_OFX_TXN_DNLD_DATES_BUILD = 4074                                                                            # noqa
    MD_MDPLUS_GETPLAIDCLIENT_BUILD = 4090                                                                               # noqa

    GlobalVars.mainPnl_preview_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_debug_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_syncing_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_updateMode_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_advancedMode_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_toolboxUnlocked_lbl = JLabel("", JLabel.CENTER)
    GlobalVars.mainPnl_memory_lbl = JLabel("", JLabel.CENTER)

    GlobalVars.allButtonsList = []
    GlobalVars.TOOLBOX_UNLOCK = False
    GlobalVars.SCRIPT_RUNNING_LOCK = threading.Lock()

    GlobalVars.UPDATE_MODE = False                                                                                      # Previously Advanced Mode
    GlobalVars.ADVANCED_MODE = False                                                                                    # Previously Hacker Mode

    GlobalVars.Strings.OFX_LAST_TXN_UPDATE = "ofx_last_txn_update"
    GlobalVars.Strings.EXTENSION_QL_ID = "securityquoteload"
    GlobalVars.Strings.EXTENSION_QER_ID = "yahooqt"

    GlobalVars.Strings.TOOLBOX_PREFERENCES_ZAPPER = "toolbox_preferences_zapper"

    GlobalVars.Strings.MD_CONFIGDICT_CURRENT_ACCOUNT_BOOK = "current_accountbook"
    GlobalVars.Strings.MD_CONFIGDICT_BACKUP_TYPE = "backup.backup_type"
    GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES = "external_files"

    GlobalVars.Strings.MD_PLAID_SETTINGS_OBJ_ID = "plaid_settings"

    GlobalVars.redact = True
    GlobalVars.lMustRestartAfterSnapChanges = False

    lCopyAllToClipBoard_TB = False                                                                                      # noqa
    lIgnoreOutdatedExtensions_TB = False                                                                                # noqa
    lAutoPruneInternalBackups_TB = True                                                                                 # noqa
    _COLWIDTHS = ["bank", "cc", "invest", "security", "loan", "misc", "split","rec_credits","rec_debits","secdetail"]   # noqa
    globalSaveFI_data = None                                                                                            # noqa
    globalSave_DEBUG_FI_data = None                                                                                     # noqa
    TOOLBOX_STOP_NOW = False                                                                                            # noqa

    # >>> END THIS SCRIPT'S GLOBALS ############################################################################################

    # COPY >> START
    # COMMON CODE ######################################################################################################
    # COMMON CODE ################# VERSION 108 ########################################################################
    # COMMON CODE ######################################################################################################
    GlobalVars.i_am_an_extension_so_run_headless = False
    try:
        GlobalVars.thisScriptName = os.path.basename(__file__)
    except:
        GlobalVars.i_am_an_extension_so_run_headless = True

    scriptExit = """
----------------------------------------------------------------------------------------------------------------------
Thank you for using %s!
The author has other useful Extensions / Moneybot Python scripts available...:

Extension (.mxt) format only:
Toolbox:                                View Moneydance settings, diagnostics, fix issues, change settings and much more
                                        + Extension Menus: Total selected transactions & Move Investment Transactions
Custom Balances (net_account_balances): Summary Page (HomePage) widget. Display the total of selected Account Balances

Extension (.mxt) and Script (.py) Versions available:
Extract Data:                           Extract various data to screen and/or csv.. Consolidation of:
- stockglance2020                       View summary of Securities/Stocks on screen, total by Security, export to csv 
- extract_reminders_csv                 View reminders on screen, edit if required, extract all to csv
- extract_currency_history_csv          Extract currency history to csv
- extract_investment_transactions_csv   Extract investment transactions to csv
- extract_account_registers_csv         Extract Account Register(s) to csv along with any attachments

List Future Reminders:                  View future reminders on screen. Allows you to set the days to look forward
Accounts Categories Mega Search Window: Combines MD Menu> Tools>Accounts/Categories and adds Quick Search box/capability
Security Performance Graph:             Graphs selected securities, calculating relative price performance as percentage

A collection of useful ad-hoc scripts (zip file)
useful_scripts:                         Just unzip and select the script you want for the task at hand...

Visit: %s (Author's site)
----------------------------------------------------------------------------------------------------------------------
""" %(GlobalVars.thisScriptName, GlobalVars.MYPYTHON_DOWNLOAD_URL)

    def cleanup_references():
        global MD_REF, MD_REF_UI, MD_EXTENSION_LOADER
        # myPrint("DB","About to delete reference to MD_REF, MD_REF_UI and MD_EXTENSION_LOADER....!")
        # del MD_REF, MD_REF_UI, MD_EXTENSION_LOADER

    def load_text_from_stream_file(theStream):
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

        cs = Charset.forName("UTF-8")

        istream = theStream

        if not istream:
            myPrint("B","... Error - the input stream is None")
            return "<NONE>"

        fileContents = ""
        istr = bufr = None
        try:
            istr = InputStreamReader(istream, cs)
            bufr = BufferedReader(istr)
            while True:
                line = bufr.readLine()
                if line is not None:
                    line += "\n"                   # not very efficient - should convert this to "\n".join() to contents
                    fileContents+=line
                    continue
                break
            fileContents+="\n<END>"
        except:
            myPrint("B", "ERROR reading from input stream... ")
            dump_sys_error_to_md_console_and_errorlog()

        try: bufr.close()
        except: pass

        try: istr.close()
        except: pass

        try: istream.close()
        except: pass

        myPrint("DB", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return fileContents

    # P=Display on Python Console, J=Display on MD (Java) Console Error Log, B=Both, D=If Debug Only print, DB=print both
    def myPrint(where, *args):
        if where[0] == "D" and not debug: return

        try:
            printString = ""
            for what in args:
                printString += "%s " %what
            printString = printString.strip()

            if where == "P" or where == "B" or where[0] == "D":
                if not GlobalVars.i_am_an_extension_so_run_headless:
                    try:
                        print(printString)
                    except:
                        print("Error writing to screen...")
                        dump_sys_error_to_md_console_and_errorlog()

            if where == "J" or where == "B" or where == "DB":
                dt = datetime.datetime.now().strftime("%Y/%m/%d-%H:%M:%S")
                try:
                    System.err.write(GlobalVars.thisScriptName + ":" + dt + ": ")
                    System.err.write(printString)
                    System.err.write("\n")
                except:
                    System.err.write(GlobalVars.thisScriptName + ":" + dt + ": "+"Error writing to console")
                    dump_sys_error_to_md_console_and_errorlog()

        except IllegalArgumentException:
            myPrint("B","ERROR - Probably on a multi-byte character..... Will ignore as code should just continue (PLEASE REPORT TO DEVELOPER).....")
            dump_sys_error_to_md_console_and_errorlog()

        return

    def dump_sys_error_to_md_console_and_errorlog(lReturnText=False):

        tb = traceback.format_exc()
        trace = traceback.format_stack()
        theText =  ".\n" \
                   "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n" \
                   "@@@@@ Unexpected error caught!\n".upper()
        theText += tb
        for trace_line in trace: theText += trace_line
        theText += "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"
        myPrint("B", theText)
        if lReturnText: return theText
        return

    def safeStr(_theText): return ("%s" %(_theText))

    def pad(theText, theLength, padChar=u" "):
        if not isinstance(theText, (unicode, str)): theText = safeStr(theText)
        theText = theText[:theLength].ljust(theLength, padChar)
        return theText

    def rpad(theText, theLength, padChar=u" "):
        if not isinstance(theText, (unicode, str)): theText = safeStr(theText)
        theText = theText[:theLength].rjust(theLength, padChar)
        return theText

    def cpad(theText, theLength, padChar=u" "):
        if not isinstance(theText, (unicode, str)): theText = safeStr(theText)
        if len(theText) >= theLength: return theText[:theLength]
        padLength = int((theLength - len(theText)) / 2)
        theText = theText[:theLength]
        theText = ((padChar * padLength)+theText+(padChar * padLength))[:theLength]
        return theText

    myPrint("B", GlobalVars.thisScriptName, ": Python Script Initialising.......", "Build:", version_build)

    def getMonoFont():
        try:
            theFont = MD_REF.getUI().getFonts().code
            # if debug: myPrint("B","Success setting Font set to Moneydance code: %s" %theFont)
        except:
            theFont = Font("monospaced", Font.PLAIN, 15)
            if debug: myPrint("B","Failed to Font set to Moneydance code - So using: %s" %theFont)

        return theFont

    def isOSXVersionAtLeast(compareVersion):
        # type: (basestring) -> bool
        """Pass a string in the format 'x.x.x'. Will check that this MacOSX version is at least that version. The 3rd micro number is optional"""

        try:
            if not Platform.isOSX(): return False

            def convertVersion(convertString):
                _os_major = _os_minor = _os_micro = 0
                _versionNumbers = []

                for versionPart in StringUtils.splitIntoList(convertString, '.'):
                    strippedPart = StringUtils.stripNonNumbers(versionPart, '.')
                    if (StringUtils.isInteger(strippedPart)):
                        _versionNumbers.append(Integer.valueOf(Integer.parseInt(strippedPart)))
                    else:
                        _versionNumbers.append(0)

                if len(_versionNumbers) >= 1: _os_major = max(0, _versionNumbers[0])
                if len(_versionNumbers) >= 2: _os_minor = max(0, _versionNumbers[1])
                if len(_versionNumbers) >= 3: _os_micro = max(0, _versionNumbers[2])

                return _os_major, _os_minor, _os_micro


            os_major, os_minor, os_micro = convertVersion(System.getProperty("os.version", "0.0.0"))
            myPrint("DB", "MacOS Version number(s): %s.%s.%s" %(os_major, os_minor, os_micro))

            if not isinstance(compareVersion, basestring) or len(compareVersion) < 1:
                myPrint("B", "ERROR: Invalid compareVersion of '%s' passed - returning False" %(compareVersion))
                return False

            chk_os_major, chk_os_minor, chk_os_micro = convertVersion(compareVersion)
            myPrint("DB", "Comparing against Version(s): %s.%s.%s" %(chk_os_major, chk_os_minor, chk_os_micro))


            if os_major < chk_os_major: return False
            if os_major > chk_os_major: return True

            if os_minor < chk_os_minor: return False
            if os_minor > chk_os_minor: return True

            if os_micro < chk_os_micro: return False
            return True

        except:
            myPrint("B", "ERROR: isOSXVersionAtLeast() failed - returning False")
            dump_sys_error_to_md_console_and_errorlog()
            return False

    def isOSXVersionCheetahOrLater():       return isOSXVersionAtLeast("10.0")
    def isOSXVersionPumaOrLater():          return isOSXVersionAtLeast("10.1")
    def isOSXVersionJaguarOrLater():        return isOSXVersionAtLeast("10.2")
    def isOSXVersionPantherOrLater():       return isOSXVersionAtLeast("10.3")
    def isOSXVersionTigerOrLater():         return isOSXVersionAtLeast("10.4")
    def isOSXVersionLeopardOrLater():       return isOSXVersionAtLeast("10.5")
    def isOSXVersionSnowLeopardOrLater():   return isOSXVersionAtLeast("10.6")
    def isOSXVersionLionOrLater():          return isOSXVersionAtLeast("10.7")
    def isOSXVersionMountainLionOrLater():  return isOSXVersionAtLeast("10.8")
    def isOSXVersionMavericksOrLater():     return isOSXVersionAtLeast("10.9")
    def isOSXVersionYosemiteOrLater():      return isOSXVersionAtLeast("10.10")
    def isOSXVersionElCapitanOrLater():     return isOSXVersionAtLeast("10.11")
    def isOSXVersionSierraOrLater():        return isOSXVersionAtLeast("10.12")
    def isOSXVersionHighSierraOrLater():    return isOSXVersionAtLeast("10.13")
    def isOSXVersionMojaveOrLater():        return isOSXVersionAtLeast("10.14")
    def isOSXVersionCatalinaOrLater():      return isOSXVersionAtLeast("10.15")
    def isOSXVersionBigSurOrLater():        return isOSXVersionAtLeast("10.16")  # BigSur is officially 11.0, but started at 10.16
    def isOSXVersionMontereyOrLater():      return isOSXVersionAtLeast("12.0")
    def isOSXVersionVenturaOrLater():       return isOSXVersionAtLeast("13.0")

    def get_home_dir():
        homeDir = None

        # noinspection PyBroadException
        try:
            if Platform.isOSX():
                homeDir = System.getProperty(u"UserHome")  # On a Mac in a Java VM, the homedir is hidden
            else:
                # homeDir = System.getProperty("user.home")
                homeDir = os.path.expanduser(u"~")  # Should work on Unix and Windows
                if homeDir is None or homeDir == u"":
                    homeDir = System.getProperty(u"user.home")
                if homeDir is None or homeDir == u"":
                    homeDir = os.environ.get(u"HOMEPATH")
        except:
            pass

        if homeDir is None or homeDir == u"":
            homeDir = MD_REF.getCurrentAccountBook().getRootFolder().getParent()  # Better than nothing!

        if homeDir is None or homeDir == u"":
            homeDir = u""

        myPrint("DB", "Home Directory detected...:", homeDir)
        return homeDir

    def getDecimalPoint():
        decimalFormat = DecimalFormat.getInstance()
        # noinspection PyUnresolvedReferences
        decimalSymbols = decimalFormat.getDecimalFormatSymbols()

        try:
            _decimalCharSep = decimalSymbols.getDecimalSeparator()
            myPrint(u"D",u"Decimal Point Character: %s" %(_decimalCharSep))
            return _decimalCharSep
        except:
            myPrint(u"B",u"Error in getDecimalPoint() routine....?")
            dump_sys_error_to_md_console_and_errorlog()
        return u"error"


    GlobalVars.decimalCharSep = getDecimalPoint()


    def isMacDarkModeDetected():
        darkResponse = "LIGHT"
        if Platform.isOSX():
            try:
                darkResponse = subprocess.check_output("defaults read -g AppleInterfaceStyle", shell=True)
                darkResponse = darkResponse.strip().lower()
            except: pass
        return ("dark" in darkResponse)

    def isMDThemeDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            try:
                if currentTheme.isSystemDark(): return True     # NOTE: Only VAQua has isSystemDark()
            except: pass
            if "dark" in currentTheme.getThemeID().lower(): return True
            if isMDThemeFlatDark(): return True
            if isMDThemeDarcula(): return True
        except: pass
        return False

    def isMDThemeDarcula():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if isMDThemeFlatDark(): return False                    # Flat Dark pretends to be Darcula!
            if "darcula" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeCustomizable():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if currentTheme.isCustomizable(): return True
        except: pass
        return False

    def isMDThemeHighContrast():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "high_contrast" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeDefault():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "default" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeClassic():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "classic" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeSolarizedLight():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "solarized_light" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeSolarizedDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "solarized_dark" in currentTheme.getThemeID(): return True
        except: pass
        return False

    def isMDThemeFlatDark():
        try:
            currentTheme = MD_REF.getUI().getCurrentTheme()
            if "flat dark" in currentTheme.toString().lower(): return True
        except: pass
        return False

    def isMDThemeVAQua():
        if Platform.isOSX():
            try:
                currentTheme = MD_REF.getUI().getCurrentTheme()
                if ".vaqua" in safeStr(currentTheme.getClass()).lower(): return True
            except: pass
        return False

    def isIntelX86_32bit():
        """Detect Intel x86 32bit system"""
        return String(System.getProperty("os.arch", "null").strip()).toLowerCase(Locale.ROOT) == "x86"

    def getMDIcon(startingIcon=None, lAlwaysGetIcon=False):
        if lAlwaysGetIcon or isIntelX86_32bit():
            return MD_REF.getUI().getIcon("/com/moneydance/apps/md/view/gui/glyphs/appicon_64.png")
        return startingIcon

    # JOptionPane.DEFAULT_OPTION, JOptionPane.YES_NO_OPTION, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.OK_CANCEL_OPTION
    # JOptionPane.ERROR_MESSAGE, JOptionPane.INFORMATION_MESSAGE, JOptionPane.WARNING_MESSAGE, JOptionPane.QUESTION_MESSAGE, JOptionPane.PLAIN_MESSAGE

    # Copies MD_REF.getUI().showInfoMessage (but a newer version now exists in MD internal code)
    def myPopupInformationBox(theParent=None, theMessage="What no message?!", theTitle="Info", theMessageType=JOptionPane.INFORMATION_MESSAGE):

        if theParent is None and (theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE):
            icon = getMDIcon(lAlwaysGetIcon=True)
        else:
            icon = getMDIcon(None)
        JOptionPane.showMessageDialog(theParent, JTextPanel(theMessage), theTitle, theMessageType, icon)

    def wrapLines(message, numChars=40):
        charCount = 0
        result=""
        for ch in message:
            if ch == '\n' or ch == '\r':
                charCount = 0
            elif charCount > numChars and not Character.isWhitespace(ch):
                result+="\n"
                charCount = 0
            else:
                charCount+=1
            result+=ch
        return result

    def doesUserAcceptDisclaimer(theParent, theTitle, disclaimerQuestion):
        disclaimer = myPopupAskForInput(theParent,
                                        theTitle,
                                        "DISCLAIMER:",
                                        "%s Type 'IAGREE' to continue.." %(disclaimerQuestion),
                                        "NO",
                                        False,
                                        JOptionPane.ERROR_MESSAGE)
        agreed = (disclaimer == "IAGREE")
        if agreed:
            myPrint("B", "%s: User AGREED to disclaimer question: '%s'" %(theTitle, disclaimerQuestion))
        else:
            myPrint("B", "%s: User DECLINED disclaimer question: '%s' - no action/changes made" %(theTitle, disclaimerQuestion))
        return agreed

    def myPopupAskBackup(theParent=None, theMessage="What no message?!", lReturnTheTruth=False):

        _options=["STOP", "PROCEED WITHOUT BACKUP", "DO BACKUP NOW"]
        response = JOptionPane.showOptionDialog(theParent,
                                                theMessage,
                                                "PERFORM BACKUP BEFORE UPDATE?",
                                                0,
                                                JOptionPane.WARNING_MESSAGE,
                                                getMDIcon(),
                                                _options,
                                                _options[0])

        if response == 2:
            myPrint("B", "User requested to create a backup before update/fix - calling Moneydance's 'Export Backup' routine...")
            MD_REF.getUI().setStatus("%s is creating a backup...." %(GlobalVars.thisScriptName),-1.0)
            MD_REF.getUI().saveToBackup(None)
            MD_REF.getUI().setStatus("%s create (export) backup process completed...." %(GlobalVars.thisScriptName),0)
            return True

        elif response == 1:
            myPrint("B", "User DECLINED to create a backup before update/fix...!")
            if not lReturnTheTruth:
                return True

        return False

    def confirm_backup_confirm_disclaimer(theFrame, theTitleToDisplay, theAction):

        if not myPopupAskQuestion(theFrame,
                                  theTitle=theTitleToDisplay,
                                  theQuestion=theAction,
                                  theOptionType=JOptionPane.YES_NO_OPTION,
                                  theMessageType=JOptionPane.ERROR_MESSAGE):

            txt = "'%s' User did not say yes to '%s' - no changes made" %(theTitleToDisplay, theAction)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(theFrame,"User did not agree to proceed - no changes made...","NO UPDATE",JOptionPane.ERROR_MESSAGE)
            return False

        if not myPopupAskBackup(theFrame, "Would you like to perform a backup before %s" %(theTitleToDisplay)):
            txt = "'%s' - User chose to exit without the fix/update...."%(theTitleToDisplay)
            setDisplayStatus(txt, "R")
            myPrint("B","'%s' User aborted at the backup prompt to '%s' - no changes made" %(theTitleToDisplay, theAction))
            myPopupInformationBox(theFrame,"User aborted at the backup prompt - no changes made...","DISCLAIMER",JOptionPane.ERROR_MESSAGE)
            return False

        if not doesUserAcceptDisclaimer(theFrame, theTitleToDisplay, theAction):
            setDisplayStatus("'%s' - User declined the disclaimer - no changes made...." %(theTitleToDisplay), "R")
            myPrint("B","'%s' User did not say accept Disclaimer to '%s' - no changes made" %(theTitleToDisplay, theAction))
            myPopupInformationBox(theFrame,"User did not accept Disclaimer - no changes made...","DISCLAIMER",JOptionPane.ERROR_MESSAGE)
            return False

        myPrint("B","'%s' - User has been offered opportunity to create a backup and they accepted the DISCLAIMER on Action: %s - PROCEEDING" %(theTitleToDisplay, theAction))
        return True

    # Copied MD_REF.getUI().askQuestion
    def myPopupAskQuestion(theParent=None,
                           theTitle="Question",
                           theQuestion="What?",
                           theOptionType=JOptionPane.YES_NO_OPTION,
                           theMessageType=JOptionPane.QUESTION_MESSAGE):

        if theParent is None and (theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE):
            icon = getMDIcon(lAlwaysGetIcon=True)
        else:
            icon = getMDIcon(None)

        # question = wrapLines(theQuestion)
        question = theQuestion
        result = JOptionPane.showConfirmDialog(theParent,
                                               question,
                                               theTitle,
                                               theOptionType,
                                               theMessageType,
                                               icon)
        return result == 0

    # Copies Moneydance .askForQuestion
    def myPopupAskForInput(theParent,
                           theTitle,
                           theFieldLabel,
                           theFieldDescription="",
                           defaultValue=None,
                           isPassword=False,
                           theMessageType=JOptionPane.INFORMATION_MESSAGE):

        if theParent is None and (theMessageType == JOptionPane.PLAIN_MESSAGE or theMessageType == JOptionPane.INFORMATION_MESSAGE):
            icon = getMDIcon(lAlwaysGetIcon=True)
        else:
            icon = getMDIcon(None)

        p = JPanel(GridBagLayout())
        defaultText = None
        if defaultValue: defaultText = defaultValue
        if isPassword:
            field = JPasswordField(defaultText)
        else:
            field = JTextField(defaultText)
        field.addAncestorListener(RequestFocusListener())

        _x = 0
        if theFieldLabel:
            p.add(JLabel(theFieldLabel), GridC.getc(_x, 0).east())
            _x+=1

        p.add(field, GridC.getc(_x, 0).field())
        p.add(Box.createHorizontalStrut(244), GridC.getc(_x, 0))
        if theFieldDescription:
            p.add(JTextPanel(theFieldDescription), GridC.getc(_x, 1).field().colspan(_x + 1))
        if (JOptionPane.showConfirmDialog(theParent,
                                          p,
                                          theTitle,
                                          JOptionPane.OK_CANCEL_OPTION,
                                          theMessageType,
                                          icon) == 0):
            return field.getText()
        return None

    # APPLICATION_MODAL, DOCUMENT_MODAL, MODELESS, TOOLKIT_MODAL
    class MyPopUpDialogBox():

        def __init__(self,
                     theParent=None,
                     theStatus="",
                     theMessage="",
                     maxSize=Dimension(0,0),
                     theTitle="Info",
                     lModal=True,
                     lCancelButton=False,
                     OKButtonText="OK",
                     lAlertLevel=0):

            self.theParent = theParent
            self.theStatus = theStatus
            self.theMessage = theMessage
            self.maxSize = maxSize
            self.theTitle = theTitle
            self.lModal = lModal
            self.lCancelButton = lCancelButton
            self.OKButtonText = OKButtonText
            self.lAlertLevel = lAlertLevel
            self.fakeJFrame = None
            self._popup_d = None
            self.lResult = [None]
            self.statusLabel = None
            self.messageJText = None
            if not self.theMessage.endswith("\n"): self.theMessage+="\n"
            if self.OKButtonText == "": self.OKButtonText="OK"
            # if Platform.isOSX() and int(float(MD_REF.getBuild())) >= 3039: self.lAlertLevel = 0    # Colors don't work on Mac since VAQua
            if isMDThemeDark() or isMacDarkModeDetected(): self.lAlertLevel = 0

        def updateMessages(self, newTitle=None, newStatus=None, newMessage=None, lPack=True):
            if not newTitle and not newStatus and not newMessage: return
            if newTitle:
                self.theTitle = newTitle
                self._popup_d.setTitle(self.theTitle)
            if newStatus:
                self.theStatus = newStatus
                self.statusLabel.setText(self.theStatus)
            if newMessage:
                self.theMessage = newMessage
                self.messageJText.setText(self.theMessage)
            if lPack: self._popup_d.pack()

        class WindowListener(WindowAdapter):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def windowClosing(self, WindowEvent):                                                                       # noqa
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                myPrint("DB", "JDialog Frame shutting down....")

                self.lResult[0] = False

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class OKButtonAction(AbstractAction):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def actionPerformed(self, event):
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                self.lResult[0] = True

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class CancelButtonAction(AbstractAction):

            def __init__(self, theDialog, theFakeFrame, lResult):
                self.theDialog = theDialog
                self.theFakeFrame = theFakeFrame
                self.lResult = lResult

            def actionPerformed(self, event):
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                self.lResult[0] = False

                # Note - listeners are already on the EDT
                if self.theFakeFrame is not None:
                    self.theDialog.dispose()
                    self.theFakeFrame.dispose()
                else:
                    self.theDialog.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        def kill(self):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(GenericVisibleRunnable(self._popup_d, False))
                if self.fakeJFrame is not None:
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self._popup_d))
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self.fakeJFrame))
                else:
                    SwingUtilities.invokeLater(GenericDisposeRunnable(self._popup_d))
            else:
                self._popup_d.setVisible(False)
                if self.fakeJFrame is not None:
                    self._popup_d.dispose()
                    self.fakeJFrame.dispose()
                else:
                    self._popup_d.dispose()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

        def result(self):
            return self.lResult[0]

        def go(self):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            class MyPopUpDialogBoxRunnable(Runnable):
                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                                      # noqa

                    myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
                    myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                    # Create a fake JFrame so we can set the Icons...
                    if self.callingClass.theParent is None:
                        self.callingClass.fakeJFrame = MyJFrame()
                        self.callingClass.fakeJFrame.setName(u"%s_fake_dialog" %(myModuleID))
                        self.callingClass.fakeJFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)
                        self.callingClass.fakeJFrame.setUndecorated(True)
                        self.callingClass.fakeJFrame.setVisible(False)
                        if not Platform.isOSX():
                            self.callingClass.fakeJFrame.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    if self.callingClass.lModal:
                        # noinspection PyUnresolvedReferences
                        self.callingClass._popup_d = JDialog(self.callingClass.theParent, self.callingClass.theTitle, Dialog.ModalityType.APPLICATION_MODAL)
                    else:
                        # noinspection PyUnresolvedReferences
                        self.callingClass._popup_d = JDialog(self.callingClass.theParent, self.callingClass.theTitle, Dialog.ModalityType.MODELESS)

                    screenSize = Toolkit.getDefaultToolkit().getScreenSize()

                    if isinstance(self.callingClass.maxSize, Dimension)\
                            and self.callingClass.maxSize.height and self.callingClass.maxSize.width:
                        frame_width = min(screenSize.width-20, self.callingClass.maxSize.width)
                        frame_height = min(screenSize.height-20, self.callingClass.maxSize.height)
                        self.callingClass._popup_d.setPreferredSize(Dimension(frame_width,frame_height))

                    self.callingClass._popup_d.getContentPane().setLayout(BorderLayout())

                    self.callingClass._popup_d.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()

                    # Add standard CMD-W keystrokes etc to close window
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    self.callingClass._popup_d.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")
                    self.callingClass._popup_d.getRootPane().getActionMap().put("close-window", self.callingClass.CancelButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult))
                    self.callingClass._popup_d.addWindowListener(self.callingClass.WindowListener(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult))

                    if (not Platform.isMac()):
                        # MD_REF.getUI().getImages()
                        self.callingClass._popup_d.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    self.callingClass.messageJText = JTextArea(self.callingClass.theMessage)
                    self.callingClass.messageJText.setFont(getMonoFont())
                    self.callingClass.messageJText.setEditable(False)
                    self.callingClass.messageJText.setLineWrap(False)
                    self.callingClass.messageJText.setWrapStyleWord(False)

                    _popupPanel = JPanel(BorderLayout())

                    # maxHeight = 500
                    _popupPanel.setBorder(EmptyBorder(8, 8, 8, 8))


                    if self.callingClass.theStatus:
                        _statusPnl = JPanel(BorderLayout())
                        self.callingClass.statusLabel = JLabel(self.callingClass.theStatus)
                        self.callingClass.statusLabel.setForeground(getColorBlue())
                        self.callingClass.statusLabel.setBorder(EmptyBorder(8, 0, 8, 0))
                        _popupPanel.add(self.callingClass.statusLabel, BorderLayout.NORTH)

                    myScrollPane = JScrollPane(self.callingClass.messageJText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
                    myScrollPane.setWheelScrollingEnabled(True)
                    _popupPanel.add(myScrollPane, BorderLayout.CENTER)

                    buttonPanel = JPanel()
                    if self.callingClass.lModal or self.callingClass.lCancelButton:
                        buttonPanel.setLayout(FlowLayout(FlowLayout.CENTER))

                        if self.callingClass.lCancelButton:
                            cancel_button = JButton("CANCEL")
                            cancel_button.setPreferredSize(Dimension(100,40))
                            cancel_button.setBackground(Color.LIGHT_GRAY)
                            cancel_button.setBorderPainted(False)
                            cancel_button.setOpaque(True)
                            cancel_button.setBorder(EmptyBorder(8, 8, 8, 8))

                            cancel_button.addActionListener(self.callingClass.CancelButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame,self.callingClass.lResult) )
                            buttonPanel.add(cancel_button)

                        if self.callingClass.lModal:
                            ok_button = JButton(self.callingClass.OKButtonText)
                            if len(self.callingClass.OKButtonText) <= 2:
                                ok_button.setPreferredSize(Dimension(100,40))
                            else:
                                ok_button.setPreferredSize(Dimension(200,40))

                            ok_button.setBackground(Color.LIGHT_GRAY)
                            ok_button.setBorderPainted(False)
                            ok_button.setOpaque(True)
                            ok_button.setBorder(EmptyBorder(8, 8, 8, 8))
                            ok_button.addActionListener( self.callingClass.OKButtonAction(self.callingClass._popup_d, self.callingClass.fakeJFrame, self.callingClass.lResult) )
                            buttonPanel.add(ok_button)

                        _popupPanel.add(buttonPanel, BorderLayout.SOUTH)

                    if self.callingClass.lAlertLevel>=2:
                        # internalScrollPane.setBackground(Color.RED)
                        self.callingClass.messageJText.setBackground(Color.RED)
                        self.callingClass.messageJText.setForeground(Color.BLACK)
                        self.callingClass.messageJText.setOpaque(True)
                        _popupPanel.setBackground(Color.RED)
                        _popupPanel.setForeground(Color.BLACK)
                        _popupPanel.setOpaque(True)
                        buttonPanel.setBackground(Color.RED)
                        buttonPanel.setOpaque(True)

                    elif self.callingClass.lAlertLevel>=1:
                        # internalScrollPane.setBackground(Color.YELLOW)
                        self.callingClass.messageJText.setBackground(Color.YELLOW)
                        self.callingClass.messageJText.setForeground(Color.BLACK)
                        self.callingClass.messageJText.setOpaque(True)
                        _popupPanel.setBackground(Color.YELLOW)
                        _popupPanel.setForeground(Color.BLACK)
                        _popupPanel.setOpaque(True)
                        buttonPanel.setBackground(Color.YELLOW)
                        buttonPanel.setOpaque(True)

                    self.callingClass._popup_d.add(_popupPanel, BorderLayout.CENTER)
                    self.callingClass._popup_d.pack()
                    self.callingClass._popup_d.setLocationRelativeTo(None)
                    self.callingClass._popup_d.setVisible(True)  # Keeping this modal....

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyPopUpDialogBoxRunnable()...")
                SwingUtilities.invokeAndWait(MyPopUpDialogBoxRunnable(self))
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                MyPopUpDialogBoxRunnable(self).run()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

            return self.lResult[0]

    def play_the_money_sound():

        # Seems to cause a crash on Virtual Machine with no Audio - so just in case....
        try:
            if MD_REF.getPreferences().getSetting("beep_on_transaction_change", "y") == "y":
                MD_REF.getUI().getSounds().playSound("cash_register.wav")
        except:
            pass

        return

    def get_filename_addition():

        cal = Calendar.getInstance()
        hhmm = str(10000 + cal.get(11) * 100 + cal.get(12))[1:]
        nameAddition = "-" + str(DateUtil.getStrippedDateInt()) + "-"+hhmm

        return nameAddition

    def check_file_writable(fnm):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )
        myPrint("DB","Checking path: ", fnm)

        if os.path.exists(fnm):
            myPrint("DB", "path exists..")
            # path exists
            if os.path.isfile(fnm):  # is it a file or a dir?
                myPrint("DB","path is a file..")
                # also works when file is a link and the target is writable
                return os.access(fnm, os.W_OK)
            else:
                myPrint("DB", "path is not a file..")
                return False  # path is a dir, so cannot write as a file
        # target does not exist, check perms on parent dir
        myPrint("DB","path does not exist...")
        pdir = os.path.dirname(fnm)
        if not pdir: pdir = '.'
        # target is creatable if parent dir is writable
        return os.access(pdir, os.W_OK)

    class ExtFilenameFilter(FilenameFilter):
        """File extension filter for FileDialog"""
        def __init__(self, ext): self.ext = "." + ext.upper()                                                           # noqa

        def accept(self, thedir, filename):                                                                             # noqa
            if filename is not None and filename.upper().endswith(self.ext): return True
            return False

    class ExtFileFilterJFC(FileFilter):
        """File extension filter for JFileChooser"""
        def __init__(self, ext): self.ext = "." + ext.upper()

        def getDescription(self): return "*"+self.ext                                                                   # noqa

        def accept(self, _theFile):                                                                                     # noqa
            if _theFile is None: return False
            return _theFile.getName().upper().endswith(self.ext)

    def MDDiag():
        myPrint("D", "Moneydance Build:", MD_REF.getVersion(), "Build:", MD_REF.getBuild())


    MDDiag()

    myPrint("DB","System file encoding is:", sys.getfilesystemencoding() )   # Not used, but interesting. Perhaps useful when switching between Windows/Macs and writing files...

    def checkVersions():
        lError = False
        plat_j = platform.system()
        plat_p = platform.python_implementation()
        python_maj = sys.version_info.major
        python_min = sys.version_info.minor

        myPrint("DB","Platform:", plat_p, plat_j, python_maj, ".", python_min)
        myPrint("DB", sys.version)

        if plat_p != "Jython":
            lError = True
            myPrint("DB", "Error: Script requires Jython")
        if plat_j != "Java":
            lError = True
            myPrint("DB", "Error: Script requires Java  base")
        if (python_maj != 2 or python_min != 7):
            lError = True
            myPrint("DB", "\n\nError: Script was  designed on version 2.7. By all means bypass this test and see what happens.....")

        if lError:
            myPrint("J", "Platform version issue - will terminate script!")
            myPrint("P", "\n@@@ TERMINATING PROGRAM @@@\n")
            raise(Exception("Platform version issue - will terminate script!"))

        return not lError


    checkVersions()

    def setDefaultFonts():
        """Grabs the MD defaultText font, reduces default size down to below 18, sets UIManager defaults (if runtime extension, will probably error, so I catch and skip)"""
        if MD_REF_UI is None: return

        # If a runtime extension, then this may fail, depending on timing... Just ignore and return...
        try:
            myFont = MD_REF.getUI().getFonts().defaultText
        except:
            myPrint("B","ERROR trying to call .getUI().getFonts().defaultText - skipping setDefaultFonts()")
            return

        if myFont is None:
            myPrint("B","WARNING: In setDefaultFonts(): calling .getUI().getFonts().defaultText has returned None (but moneydance_ui was set) - skipping setDefaultFonts()")
            return

        if myFont.getSize()>18:
            try:
                myFont = myFont.deriveFont(16.0)
                myPrint("B", "I have reduced the font size down to point-size 16 - Default Fonts are now set to: %s" %(myFont))
            except:
                myPrint("B","ERROR - failed to override font point size down to 16.... will ignore and continue. Font set to: %s" %(myFont))
        else:
            myPrint("DB", "Attempting to set default font to %s" %myFont)

        try:
            UIManager.getLookAndFeelDefaults().put("defaultFont", myFont )

            # https://thebadprogrammer.com/swing-uimanager-keys/
            UIManager.put("CheckBoxMenuItem.acceleratorFont", myFont)
            UIManager.put("Button.font", myFont)
            UIManager.put("ToggleButton.font", myFont)
            UIManager.put("RadioButton.font", myFont)
            UIManager.put("CheckBox.font", myFont)
            UIManager.put("ColorChooser.font", myFont)
            UIManager.put("ComboBox.font", myFont)
            UIManager.put("Label.font", myFont)
            UIManager.put("List.font", myFont)
            UIManager.put("MenuBar.font", myFont)
            UIManager.put("Menu.acceleratorFont", myFont)
            UIManager.put("RadioButtonMenuItem.acceleratorFont", myFont)
            UIManager.put("MenuItem.acceleratorFont", myFont)
            UIManager.put("MenuItem.font", myFont)
            UIManager.put("RadioButtonMenuItem.font", myFont)
            UIManager.put("CheckBoxMenuItem.font", myFont)
            UIManager.put("OptionPane.buttonFont", myFont)
            UIManager.put("OptionPane.messageFont", myFont)
            UIManager.put("Menu.font", myFont)
            UIManager.put("PopupMenu.font", myFont)
            UIManager.put("OptionPane.font", myFont)
            UIManager.put("Panel.font", myFont)
            UIManager.put("ProgressBar.font", myFont)
            UIManager.put("ScrollPane.font", myFont)
            UIManager.put("Viewport.font", myFont)
            UIManager.put("TabbedPane.font", myFont)
            UIManager.put("Slider.font", myFont)
            UIManager.put("Table.font", myFont)
            UIManager.put("TableHeader.font", myFont)
            UIManager.put("TextField.font", myFont)
            UIManager.put("Spinner.font", myFont)
            UIManager.put("PasswordField.font", myFont)
            UIManager.put("TextArea.font", myFont)
            UIManager.put("TextPane.font", myFont)
            UIManager.put("EditorPane.font", myFont)
            UIManager.put("TabbedPane.smallFont", myFont)
            UIManager.put("TitledBorder.font", myFont)
            UIManager.put("ToolBar.font", myFont)
            UIManager.put("ToolTip.font", myFont)
            UIManager.put("Tree.font", myFont)
            UIManager.put("FormattedTextField.font", myFont)
            UIManager.put("IconButton.font", myFont)
            UIManager.put("InternalFrame.optionDialogTitleFont", myFont)
            UIManager.put("InternalFrame.paletteTitleFont", myFont)
            UIManager.put("InternalFrame.titleFont", myFont)
        except:
            myPrint("B","Failed to set Swing default fonts to use Moneydance defaults... sorry")

        myPrint("DB",".setDefaultFonts() successfully executed...")
        return

    setDefaultFonts()

    def who_am_i():
        try: username = System.getProperty("user.name")
        except: username = "???"
        return username

    def getHomeDir():
        # Yup - this can be all over the place...
        myPrint("D", 'System.getProperty("user.dir")', System.getProperty("user.dir"))
        myPrint("D", 'System.getProperty("UserHome")', System.getProperty("UserHome"))
        myPrint("D", 'System.getProperty("user.home")', System.getProperty("user.home"))
        myPrint("D", 'os.path.expanduser("~")', os.path.expanduser("~"))
        myPrint("D", 'os.environ.get("HOMEPATH")', os.environ.get("HOMEPATH"))
        return

    myPrint("D", "I am user:", who_am_i())
    if debug: getHomeDir()

    # noinspection PyArgumentList
    class JTextFieldLimitYN(PlainDocument):

        limit = 10  # Default
        toUpper = False
        what = ""

        def __init__(self, limit, toUpper, what):

            super(PlainDocument, self).__init__()
            self.limit = limit
            self.toUpper = toUpper
            self.what = what

        def insertString(self, myOffset, myString, myAttr):

            if (myString is None): return
            if self.toUpper: myString = myString.upper()
            if (self.what == "YN" and (myString in "YN")) \
                    or (self.what == "DELIM" and (myString in ";|,")) \
                    or (self.what == "1234" and (myString in "1234")) \
                    or (self.what == "CURR"):
                if ((self.getLength() + len(myString)) <= self.limit):
                    super(JTextFieldLimitYN, self).insertString(myOffset, myString, myAttr)                             # noqa

    def fix_delimiter( theDelimiter ):

        try:
            if sys.version_info.major >= 3: return theDelimiter
            if sys.version_info.major <  2: return str(theDelimiter)

            if sys.version_info.minor >  7: return theDelimiter
            if sys.version_info.minor <  7: return str(theDelimiter)

            if sys.version_info.micro >= 2: return theDelimiter
        except:
            pass

        return str( theDelimiter )

    def get_StuWareSoftSystems_parameters_from_file(myFile="StuWareSoftSystems.dict"):
        global debug    # This global for debug must be here as we set it from loaded parameters

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if GlobalVars.resetPickleParameters:
            myPrint("B", "User has specified to reset parameters... keeping defaults and skipping pickle()")
            GlobalVars.parametersLoadedFromFile = {}
            return

        old_dict_filename = os.path.join("..", myFile)

        # Pickle was originally encrypted, no need, migrating to unencrypted
        migratedFilename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(),myFile)

        myPrint("DB", "Now checking for parameter file:", migratedFilename)

        if os.path.exists( migratedFilename ):

            myPrint("DB", "loading parameters from non-encrypted Pickle file:", migratedFilename)
            myPrint("DB", "Parameter file", migratedFilename, "exists..")
            # Open the file
            try:
                # Really we should open() the file in binary mode and read/write as binary, then we wouldn't get platform differences!
                istr = FileInputStream(migratedFilename)
                load_file = FileUtil.wrap(istr)
                if not Platform.isWindows():
                    load_string = load_file.read().replace('\r', '')    # This allows for files migrated from windows (strip the extra CR)
                else:
                    load_string = load_file.read()

                GlobalVars.parametersLoadedFromFile = pickle.loads(load_string)
                load_file.close()
            except FileNotFoundException:
                myPrint("B", "Error: failed to find parameter file...")
                GlobalVars.parametersLoadedFromFile = None
            except EOFError:
                myPrint("B", "Error: reached EOF on parameter file....")
                GlobalVars.parametersLoadedFromFile = None
            except:
                myPrint("B","Error opening Pickle File (will try encrypted version) - Unexpected error ", sys.exc_info()[0])
                myPrint("B","Error opening Pickle File (will try encrypted version) - Unexpected error ", sys.exc_info()[1])
                myPrint("B","Error opening Pickle File (will try encrypted version) - Line Number: ", sys.exc_info()[2].tb_lineno)

                # OK, so perhaps from older version - encrypted, try to read
                try:
                    local_storage = MD_REF.getCurrentAccountBook().getLocalStorage()
                    istr = local_storage.openFileForReading(old_dict_filename)
                    load_file = FileUtil.wrap(istr)
                    # noinspection PyTypeChecker
                    GlobalVars.parametersLoadedFromFile = pickle.load(load_file)
                    load_file.close()
                    myPrint("B","Success loading Encrypted Pickle file - will migrate to non encrypted")
                except:
                    myPrint("B","Opening Encrypted Pickle File - Unexpected error ", sys.exc_info()[0])
                    myPrint("B","Opening Encrypted Pickle File - Unexpected error ", sys.exc_info()[1])
                    myPrint("B","Error opening Pickle File - Line Number: ", sys.exc_info()[2].tb_lineno)
                    myPrint("B", "Error: Pickle.load() failed.... Is this a restored dataset? Will ignore saved parameters, and create a new file...")
                    GlobalVars.parametersLoadedFromFile = None

            if GlobalVars.parametersLoadedFromFile is None:
                GlobalVars.parametersLoadedFromFile = {}
                myPrint("DB","Parameters did not load, will keep defaults..")
            else:
                myPrint("DB","Parameters successfully loaded from file...")
        else:
            myPrint("J", "Parameter Pickle file does not exist - will use default and create new file..")
            myPrint("D", "Parameter Pickle file does not exist - will use default and create new file..")
            GlobalVars.parametersLoadedFromFile = {}

        if not GlobalVars.parametersLoadedFromFile: return

        myPrint("DB","GlobalVars.parametersLoadedFromFile read from file contains...:")
        for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
            myPrint("DB","...variable:", key, GlobalVars.parametersLoadedFromFile[key])

        if GlobalVars.parametersLoadedFromFile.get("debug") is not None: debug = GlobalVars.parametersLoadedFromFile.get("debug")
        if GlobalVars.parametersLoadedFromFile.get("lUseMacFileChooser") is not None:
            myPrint("B", "Detected old lUseMacFileChooser parameter/variable... Will delete it...")
            GlobalVars.parametersLoadedFromFile.pop("lUseMacFileChooser", None)  # Old variable - not used - delete from parameter file

        myPrint("DB","Parameter file loaded if present and GlobalVars.parametersLoadedFromFile{} dictionary set.....")

        # Now load into memory!
        load_StuWareSoftSystems_parameters_into_memory()

        return

    def save_StuWareSoftSystems_parameters_to_file(myFile="StuWareSoftSystems.dict"):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

        # Don't forget, any parameters loaded earlier will be preserved; just add changed variables....
        GlobalVars.parametersLoadedFromFile["__Author"] = "Stuart Beesley - (c) StuWareSoftSystems"
        GlobalVars.parametersLoadedFromFile["debug"] = debug

        dump_StuWareSoftSystems_parameters_from_memory()

        # Pickle was originally encrypted, no need, migrating to unencrypted
        migratedFilename = os.path.join(MD_REF.getCurrentAccountBook().getRootFolder().getAbsolutePath(),myFile)

        myPrint("DB","Will try to save parameter file:", migratedFilename)

        ostr = FileOutputStream(migratedFilename)

        myPrint("DB", "about to Pickle.dump and save parameters to unencrypted file:", migratedFilename)

        try:
            save_file = FileUtil.wrap(ostr)
            pickle.dump(GlobalVars.parametersLoadedFromFile, save_file, protocol=0)
            save_file.close()

            myPrint("DB","GlobalVars.parametersLoadedFromFile now contains...:")
            for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
                myPrint("DB","...variable:", key, GlobalVars.parametersLoadedFromFile[key])

        except:
            myPrint("B", "Error - failed to create/write parameter file.. Ignoring and continuing.....")
            dump_sys_error_to_md_console_and_errorlog()

            return

        myPrint("DB","Parameter file written and parameters saved to disk.....")

        return

    def get_time_stamp_as_nice_text(timeStamp, _format=None, lUseHHMMSS=True):

        if _format is None: _format = MD_REF.getPreferences().getShortDateFormat()

        humanReadableDate = ""
        try:
            c = Calendar.getInstance()
            c.setTime(Date(timeStamp))
            longHHMMSSText = " HH:mm:ss(.SSS) Z z zzzz" if (lUseHHMMSS) else ""
            dateFormatter = SimpleDateFormat("%s%s" %(_format, longHHMMSSText))
            humanReadableDate = dateFormatter.format(c.getTime())
        except: pass
        return humanReadableDate

    def currentDateTimeMarker():
        c = Calendar.getInstance()
        dateformat = SimpleDateFormat("_yyyyMMdd_HHmmss")
        _datetime = dateformat.format(c.getTime())
        return _datetime

    def destroyOldFrames(moduleName):
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))
        frames = JFrame.getFrames()
        for fr in frames:
            if fr.getName().lower().startswith(moduleName+"_"):
                myPrint("DB","Found old frame %s and active status is: %s" %(fr.getName(),fr.isActiveInMoneydance))
                try:
                    fr.isActiveInMoneydance = False
                    if not SwingUtilities.isEventDispatchThread():
                        SwingUtilities.invokeLater(GenericVisibleRunnable(fr, False, False))
                        SwingUtilities.invokeLater(GenericDisposeRunnable(fr))  # This should call windowClosed() which should remove MD listeners.....
                    else:
                        fr.setVisible(False)
                        fr.dispose()            # This should call windowClosed() which should remove MD listeners.....
                    myPrint("DB","disposed of old frame: %s" %(fr.getName()))
                except:
                    myPrint("B","Failed to dispose old frame: %s" %(fr.getName()))
                    dump_sys_error_to_md_console_and_errorlog()

    def classPrinter(className, theObject):
        try:
            text = "Class: %s %s@{:x}".format(System.identityHashCode(theObject)) %(className, theObject.__class__)
        except:
            text = "Error in classPrinter(): %s: %s" %(className, theObject)
        return text

    def getColorBlue():
        if not isMDThemeDark() and not isMacDarkModeDetected(): return(Color.BLUE)
        return (MD_REF.getUI().getColors().defaultTextForeground)

    def getColorRed(): return (MD_REF.getUI().getColors().errorMessageForeground)

    def getColorDarkGreen(): return (MD_REF.getUI().getColors().budgetHealthyColor)

    def setDisplayStatus(_theStatus, _theColor=None):
        """Sets the Display / Status label on the main diagnostic display: G=Green, B=Blue, R=Red, DG=Dark Green"""

        if GlobalVars.STATUS_LABEL is None or not isinstance(GlobalVars.STATUS_LABEL, JLabel): return

        # GlobalVars.STATUS_LABEL.setText((_theStatus).ljust(800, " "))
        GlobalVars.STATUS_LABEL.setText((_theStatus))

        if _theColor is None or _theColor == "": _theColor = "X"
        _theColor = _theColor.upper()
        if _theColor == "R":    GlobalVars.STATUS_LABEL.setForeground(getColorRed())
        elif _theColor == "B":  GlobalVars.STATUS_LABEL.setForeground(getColorBlue())
        elif _theColor == "DG": GlobalVars.STATUS_LABEL.setForeground(getColorDarkGreen())
        else:                   GlobalVars.STATUS_LABEL.setForeground(MD_REF.getUI().getColors().defaultTextForeground)
        return

    def setJFileChooserParameters(_jf, lReportOnly=False, lDefaults=False, lPackagesT=None, lApplicationsT=None, lOptionsButton=None, lNewFolderButton=None):
        """sets up Client Properties for JFileChooser() to behave as required >> Mac only"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not Platform.isOSX(): return
        if not isinstance(_jf, JFileChooser): return

        _PKG = "JFileChooser.packageIsTraversable"
        _APP = "JFileChooser.appBundleIsTraversable"
        _OPTIONS = "JFileChooser.optionsPanelEnabled"
        _NEWFOLDER = "JFileChooser.canCreateDirectories"

        # JFileChooser defaults: https://violetlib.org/vaqua/filechooser.html
        # "JFileChooser.packageIsTraversable"   default False   >> set "true" to allow Packages to be traversed
        # "JFileChooser.appBundleIsTraversable" default False   >> set "true" to allow App Bundles to be traversed
        # "JFileChooser.optionsPanelEnabled"    default False   >> set "true" to allow Options button
        # "JFileChooser.canCreateDirectories"   default False   >> set "true" to allow New Folder button

        if debug or lReportOnly:
            myPrint("B", "Parameters set: ReportOnly: %s, Defaults:%s, PackagesT: %s, ApplicationsT:%s, OptionButton:%s, NewFolderButton: %s" %(lReportOnly, lDefaults, lPackagesT, lApplicationsT, lOptionsButton, lNewFolderButton))
            txt = ("Before setting" if not lReportOnly else "Reporting only")
            for setting in [_PKG, _APP, _OPTIONS, _NEWFOLDER]: myPrint("DB", "%s: '%s': '%s'" %(pad(txt,14), pad(setting,50), _jf.getClientProperty(setting)))
            if lReportOnly: return

        if lDefaults:
            _jf.putClientProperty(_PKG, None)
            _jf.putClientProperty(_APP, None)
            _jf.putClientProperty(_OPTIONS, None)
            _jf.putClientProperty(_NEWFOLDER, None)
        else:
            if lPackagesT       is not None: _jf.putClientProperty(_PKG, lPackagesT)
            if lApplicationsT   is not None: _jf.putClientProperty(_APP, lApplicationsT)
            if lOptionsButton   is not None: _jf.putClientProperty(_OPTIONS, lOptionsButton)
            if lNewFolderButton is not None: _jf.putClientProperty(_NEWFOLDER, lNewFolderButton)

        for setting in [_PKG, _APP, _OPTIONS, _NEWFOLDER]: myPrint("DB", "%s: '%s': '%s'" %(pad("After setting",14), pad(setting,50), _jf.getClientProperty(setting)))

        return

    def setFileDialogParameters(lReportOnly=False, lDefaults=False, lSelectDirectories=None, lPackagesT=None):
        """sets up System Properties for FileDialog() to behave as required >> Mac only"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not Platform.isOSX(): return

        _TRUE = "true"
        _FALSE = "false"

        _DIRS_FD = "apple.awt.fileDialogForDirectories"        # When True you can select a Folder (rather than a file)
        _PKGS_FD = "apple.awt.use-file-dialog-packages"        # When True allows you to select a 'bundle' as a file; False means navigate inside the bundle
        # "com.apple.macos.use-file-dialog-packages"           # DEPRECATED since Monterrey - discovered this about MD2022.5(4090) - refer: java.desktop/sun/lwawt/macosx/CFileDialog.java

        # FileDialog defaults
        # "apple.awt.fileDialogForDirectories"       default "false" >> set "true"  to allow Directories to be selected
        # "apple.awt.use-file-dialog-packages"       default "true"  >> set "false" to allow access to Mac 'packages'

        if debug or lReportOnly:
            myPrint("B", "Parameters set: ReportOnly: %s, Defaults:%s, SelectDirectories:%s, PackagesT:%s" % (lReportOnly, lDefaults, lSelectDirectories, lPackagesT))
            txt = ("Before setting" if not lReportOnly else "Reporting only")
            for setting in [_DIRS_FD, _PKGS_FD]: myPrint("DB", "%s: '%s': '%s'" %(pad(txt,14), pad(setting,50), System.getProperty(setting)))
            if lReportOnly: return

        if lDefaults:
            System.setProperty(_DIRS_FD,_FALSE)
            System.setProperty(_PKGS_FD,_TRUE)
        else:
            if lSelectDirectories is not None: System.setProperty(_DIRS_FD, (_TRUE if lSelectDirectories   else _FALSE))
            if lPackagesT         is not None: System.setProperty(_PKGS_FD, (_TRUE if lPackagesT           else _FALSE))

        for setting in [_DIRS_FD, _PKGS_FD]: myPrint("DB", "After setting:  '%s': '%s'" %(pad(setting,50), System.getProperty(setting)))

        return

    def getFileFromFileChooser(fileChooser_parent,                  # The Parent Frame, or None
                               fileChooser_starting_dir,            # The Starting Dir
                               fileChooser_filename,                # Default filename (or None)
                               fileChooser_title,                   # The Title (with FileDialog, only works on SAVE)
                               fileChooser_multiMode,               # Normally False (True has not been coded!)
                               fileChooser_open,                    # True for Open/Load, False for Save
                               fileChooser_selectFiles,             # True for files, False for Directories
                               fileChooser_OK_text,                 # Normally None, unless set - use text
                               fileChooser_fileFilterText=None,     # E.g. "txt" or "qif"
                               lForceJFC=False,
                               lForceFD=False,
                               lAllowTraversePackages=None,
                               lAllowTraverseApplications=None,     # JFileChooser only..
                               lAllowNewFolderButton=True,          # JFileChooser only..
                               lAllowOptionsButton=None):           # JFileChooser only..
        """Launches FileDialog on Mac, or JFileChooser on other platforms... NOTE: Do not use Filter on Macs!"""

        _THIS_METHOD_NAME = "Dynamic File Chooser"

        if fileChooser_multiMode:
            myPrint("B","@@ SORRY Multi File Selection Mode has not been coded! Exiting...")
            return None

        if fileChooser_starting_dir is None or fileChooser_starting_dir == "" or not os.path.exists(fileChooser_starting_dir):
            fileChooser_starting_dir = MD_REF.getPreferences().getSetting("gen.data_dir", None)

        if fileChooser_starting_dir is None or not os.path.exists(fileChooser_starting_dir):
            fileChooser_starting_dir = None
            myPrint("B","ERROR: Starting Path does not exist - will start with no starting path set..")

        else:
            myPrint("DB", "Preparing the Dynamic File Chooser with path: %s" %(fileChooser_starting_dir))
            if Platform.isOSX() and "/Library/Containers/" in fileChooser_starting_dir:
                myPrint("DB", "WARNING: Folder will be restricted by MacOSx...")
                if not lForceJFC:
                    txt = ("FileDialog: MacOSx restricts Java Access to 'special' locations like 'Library\n"
                          "Folder: %s\n"
                          "Please navigate to this location manually in the next popup. This grants permission"
                          %(fileChooser_starting_dir))
                else:
                    txt = ("JFileChooser: MacOSx restricts Java Access to 'special' locations like 'Library\n"
                          "Folder: %s\n"
                          "Your files will probably be hidden.. If so, switch to FileDialog()...(contact author)"
                          %(fileChooser_starting_dir))
                MyPopUpDialogBox(fileChooser_parent,
                                 "NOTE: Mac Security Restriction",
                                 txt,
                                 theTitle=_THIS_METHOD_NAME,
                                 lAlertLevel=1).go()

        if (Platform.isOSX() and not lForceJFC) or lForceFD:

            setFileDialogParameters(lPackagesT=lAllowTraversePackages, lSelectDirectories=(not fileChooser_selectFiles))

            myPrint("DB", "Preparing FileDialog() with path: %s" %(fileChooser_starting_dir))
            if fileChooser_filename is not None: myPrint("DB", "... and filename:                 %s" %(fileChooser_filename))

            fileDialog = FileDialog(fileChooser_parent, fileChooser_title)

            fileDialog.setTitle(fileChooser_title)

            if fileChooser_starting_dir is not None:    fileDialog.setDirectory(fileChooser_starting_dir)
            if fileChooser_filename is not None:        fileDialog.setFile(fileChooser_filename)

            fileDialog.setMultipleMode(fileChooser_multiMode)

            if fileChooser_open:
                fileDialog.setMode(FileDialog.LOAD)
            else:
                fileDialog.setMode(FileDialog.SAVE)

            # if fileChooser_fileFilterText is not None and (not Platform.isOSX() or not Platform.isOSXVersionAtLeast("10.13")):
            if fileChooser_fileFilterText is not None and (not Platform.isOSX() or isOSXVersionMontereyOrLater()):
                myPrint("DB",".. Adding file filter for: %s" %(fileChooser_fileFilterText))
                fileDialog.setFilenameFilter(ExtFilenameFilter(fileChooser_fileFilterText))

            fileDialog.setVisible(True)

            setFileDialogParameters(lDefaults=True)

            myPrint("DB", "FileDialog returned File:      %s" %(fileDialog.getFile()))
            myPrint("DB", "FileDialog returned Directory: %s" %(fileDialog.getDirectory()))

            if fileDialog.getFile() is None or fileDialog.getFile() == "": return None

            _theFile = os.path.join(fileDialog.getDirectory(), fileDialog.getFile())

        else:

            myPrint("DB", "Preparing JFileChooser() with path: %s" %(fileChooser_starting_dir))
            if fileChooser_filename is not None: myPrint("DB", "... and filename:                   %s" %(fileChooser_filename))

            if fileChooser_starting_dir is not None:
                jfc = JFileChooser(fileChooser_starting_dir)
            else:
                jfc = JFileChooser()

            if fileChooser_filename is not None: jfc.setSelectedFile(File(fileChooser_filename))
            setJFileChooserParameters(jfc,
                                      lPackagesT=lAllowTraversePackages,
                                      lApplicationsT=lAllowTraverseApplications,
                                      lNewFolderButton=lAllowNewFolderButton,
                                      lOptionsButton=lAllowOptionsButton)

            jfc.setDialogTitle(fileChooser_title)
            jfc.setMultiSelectionEnabled(fileChooser_multiMode)

            if fileChooser_selectFiles:
                jfc.setFileSelectionMode(JFileChooser.FILES_ONLY)         # FILES_ONLY, DIRECTORIES_ONLY, FILES_AND_DIRECTORIES
            else:
                jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)   # FILES_ONLY, DIRECTORIES_ONLY, FILES_AND_DIRECTORIES

            # if fileChooser_fileFilterText is not None and (not Platform.isOSX() or not Platform.isOSXVersionAtLeast("10.13")):
            if fileChooser_fileFilterText is not None and (not Platform.isOSX() or isOSXVersionMontereyOrLater()):
                myPrint("DB",".. Adding file filter for: %s" %(fileChooser_fileFilterText))
                jfc.setFileFilter(ExtFileFilterJFC(fileChooser_fileFilterText))

            if fileChooser_OK_text is not None:
                returnValue = jfc.showDialog(fileChooser_parent, fileChooser_OK_text)
            else:
                if fileChooser_open:
                    returnValue = jfc.showOpenDialog(fileChooser_parent)
                else:
                    returnValue = jfc.showSaveDialog(fileChooser_parent)

            if returnValue == JFileChooser.CANCEL_OPTION \
                    or (jfc.getSelectedFile() is None or jfc.getSelectedFile().getName()==""):
                myPrint("DB","JFileChooser was cancelled by user, or no file was selected...")
                return None

            _theFile = jfc.getSelectedFile().getAbsolutePath()
            myPrint("DB","JFileChooser returned File/path..: %s" %(_theFile))

        myPrint("DB","...File/path exists..: %s" %(os.path.exists(_theFile)))
        return _theFile

    class RequestFocusListener(AncestorListener):
        """Add this Listener to a JTextField by using .addAncestorListener(RequestFocusListener()) before calling JOptionPane.showOptionDialog()"""

        def __init__(self, removeListener=True):
            self.removeListener = removeListener

        def ancestorAdded(self, e):
            component = e.getComponent()
            component.requestFocusInWindow()
            component.selectAll()
            if (self.removeListener): component.removeAncestorListener(self)

        def ancestorMoved(self, e): pass
        def ancestorRemoved(self, e): pass

    class SearchAction(AbstractAction):

        def __init__(self, theFrame, searchJText):
            self.theFrame = theFrame
            self.searchJText = searchJText
            self.lastSearch = ""
            self.lastPosn = -1
            self.previousEndPosn = -1
            self.lastDirection = 0

        def actionPerformed(self, event):
            myPrint("D","in SearchAction(), Event: ", event)

            p = JPanel(FlowLayout())
            lbl = JLabel("Enter the search text:")
            tf = JTextField(self.lastSearch,20)
            p.add(lbl)
            p.add(tf)

            tf.addAncestorListener(RequestFocusListener())

            _search_options = [ "Next", "Previous", "Cancel" ]

            defaultDirection = _search_options[self.lastDirection]

            response = JOptionPane.showOptionDialog(self.theFrame,
                                                    p,
                                                    "Search for text",
                                                    JOptionPane.OK_CANCEL_OPTION,
                                                    JOptionPane.QUESTION_MESSAGE,
                                                    getMDIcon(None),
                                                    _search_options,
                                                    defaultDirection)

            lSwitch = False
            if (response == 0 or response == 1):
                if response != self.lastDirection: lSwitch = True
                self.lastDirection = response
                searchWhat = tf.getText()
            else:
                searchWhat = None

            del p, lbl, tf, _search_options

            if not searchWhat or searchWhat == "": return

            theText = self.searchJText.getText().lower()
            highlighter = self.searchJText.getHighlighter()
            highlighter.removeAllHighlights()

            startPos = 0

            if response == 0:
                direction = "[forwards]"
                if searchWhat == self.lastSearch:
                    startPos = self.lastPosn
                    if lSwitch: startPos=startPos+len(searchWhat)+1
                self.lastSearch = searchWhat

                # if startPos+len(searchWhat) >= len(theText):
                #     startPos = 0
                #
                pos = theText.find(searchWhat.lower(),startPos)     # noqa
                myPrint("DB", "Search %s Pos: %s, searchWhat: '%s', startPos: %s, endPos: %s" %(direction, pos, searchWhat,startPos, -1))

            else:
                direction = "[backwards]"
                endPos = len(theText)-1

                if searchWhat == self.lastSearch:
                    if self.previousEndPosn < 0: self.previousEndPosn = len(theText)-1
                    endPos = max(0,self.previousEndPosn)
                    if lSwitch: endPos = max(0,self.lastPosn-1)

                self.lastSearch = searchWhat

                pos = theText.rfind(searchWhat.lower(),startPos,endPos)     # noqa
                myPrint("DB", "Search %s Pos: %s, searchWhat: '%s', startPos: %s, endPos: %s" %(direction, pos, searchWhat,startPos,endPos))

            if pos >= 0:
                self.searchJText.setCaretPosition(pos)
                try:
                    highlighter.addHighlight(pos,min(pos+len(searchWhat),len(theText)),DefaultHighlighter.DefaultPainter)
                except: pass
                if response == 0:
                    self.lastPosn = pos+len(searchWhat)
                    self.previousEndPosn = len(theText)-1
                else:
                    self.lastPosn = pos-len(searchWhat)
                    self.previousEndPosn = pos-1
            else:
                self.lastPosn = 0
                self.previousEndPosn = len(theText)-1
                myPopupInformationBox(self.theFrame,"Searching %s text not found" %direction)

            return

    def saveOutputFile(_theFrame, _theTitle, _fileName, _theText):

        theTitle = "Select location to save the current displayed output... (CANCEL=ABORT)"
        copyToFile = getFileFromFileChooser(_theFrame,          # Parent frame or None
                                            get_home_dir(),     # Starting path
                                            _fileName,          # Default Filename
                                            theTitle,           # Title
                                            False,              # Multi-file selection mode
                                            False,              # True for Open/Load, False for Save
                                            True,               # True = Files, else Dirs
                                            None,               # Load/Save button text, None for defaults
                                            "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if copyToFile is None or copyToFile == "":
            return
        elif not safeStr(copyToFile).endswith(".txt"):
            myPopupInformationBox(_theFrame, "Sorry - please use a .txt file extension when saving output txt")
            return
        elif ".moneydance" in os.path.dirname(copyToFile):
            myPopupInformationBox(_theFrame, "Sorry, please choose a location outside of the Moneydance location")
            return

        if not check_file_writable(copyToFile):
            myPopupInformationBox(_theFrame, "Sorry, that file/location does not appear allowed by the operating system!?")

        toFile = copyToFile
        try:
            with open(toFile, 'w') as f: f.write(_theText)
            myPrint("B", "%s: text output copied to: %s" %(_theTitle, toFile))

            if os.path.exists(toFile):
                play_the_money_sound()
                txt = "%s: Output text saved as requested to: %s" %(_theTitle, toFile)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(_theFrame, txt)
            else:
                txt = "ERROR - failed to write output text to file: %s" %(toFile)
                myPrint("B", txt)
                myPopupInformationBox(_theFrame, txt)
        except:
            txt = "ERROR - failed to write output text to file: %s" %(toFile)
            dump_sys_error_to_md_console_and_errorlog()
            myPopupInformationBox(_theFrame, txt)

        return

    if MD_REF_UI is not None:       # Only action if the UI is loaded - e.g. scripts (not run time extensions)
        try: GlobalVars.defaultPrintFontSize = eval("MD_REF.getUI().getFonts().print.getSize()")   # Do this here as MD_REF disappears after script ends...
        except: GlobalVars.defaultPrintFontSize = 12
    else:
        GlobalVars.defaultPrintFontSize = 12

    ####################################################################################################################
    # PRINTING UTILITIES...: Points to MM, to Inches, to Resolution: Conversion routines etc
    _IN2MM = 25.4; _IN2CM = 2.54; _IN2PT = 72
    def pt2dpi(_pt,_resolution):    return _pt * _resolution / _IN2PT
    def mm2pt(_mm):                 return _mm * _IN2PT / _IN2MM
    def mm2mpt(_mm):                return _mm * 1000 * _IN2PT / _IN2MM
    def pt2mm(_pt):                 return round(_pt * _IN2MM / _IN2PT, 1)
    def mm2in(_mm):                 return _mm / _IN2MM
    def in2mm(_in):                 return _in * _IN2MM
    def in2mpt(_in):                return _in * _IN2PT * 1000
    def in2pt(_in):                 return _in * _IN2PT
    def mpt2in(_mpt):               return _mpt / _IN2PT / 1000
    def mm2px(_mm, _resolution):    return mm2in(_mm) * _resolution
    def mpt2px(_mpt, _resolution):  return mpt2in(_mpt) * _resolution

    def printDeducePrintableWidth(_thePageFormat, _pAttrs):

        _BUFFER_PCT = 0.95

        myPrint("DB", "PageFormat after user dialog: Portrait=%s Landscape=%s W: %sMM(%spts) H: %sMM(%spts) Paper: %s Paper W: %sMM(%spts) H: %sMM(%spts)"
                %(_thePageFormat.getOrientation()==_thePageFormat.PORTRAIT, _thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE,
                  pt2mm(_thePageFormat.getWidth()),_thePageFormat.getWidth(), pt2mm(_thePageFormat.getHeight()),_thePageFormat.getHeight(),
                  _thePageFormat.getPaper(),
                  pt2mm(_thePageFormat.getPaper().getWidth()), _thePageFormat.getPaper().getWidth(), pt2mm(_thePageFormat.getPaper().getHeight()), _thePageFormat.getPaper().getHeight()))

        if _pAttrs.get(attribute.standard.MediaSizeName):
            myPrint("DB", "Requested Media: %s" %(_pAttrs.get(attribute.standard.MediaSizeName)))

        if not _pAttrs.get(attribute.standard.MediaPrintableArea):
            raise Exception("ERROR: MediaPrintableArea not present in pAttrs!?")

        mediaPA = _pAttrs.get(attribute.standard.MediaPrintableArea)
        myPrint("DB", "MediaPrintableArea settings from Printer Attributes..: w%sMM h%sMM MediaPrintableArea: %s, getPrintableArea: %s "
                % (mediaPA.getWidth(attribute.standard.MediaPrintableArea.MM),
                   mediaPA.getHeight(attribute.standard.MediaPrintableArea.MM),
                   mediaPA, mediaPA.getPrintableArea(attribute.standard.MediaPrintableArea.MM)))

        if (_thePageFormat.getOrientation()==_thePageFormat.PORTRAIT):
            deducedWidthMM = mediaPA.getWidth(attribute.standard.MediaPrintableArea.MM)
        elif (_thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE):
            deducedWidthMM = mediaPA.getHeight(attribute.standard.MediaPrintableArea.MM)
        else:
            raise Exception("ERROR: thePageFormat.getOrientation() was not PORTRAIT or LANDSCAPE!?")

        myPrint("DB","Paper Orientation: %s" %("LANDSCAPE" if _thePageFormat.getOrientation()==_thePageFormat.LANDSCAPE else "PORTRAIT"))

        _maxPaperWidthPTS = mm2px(deducedWidthMM, GlobalVars.defaultDPI)
        _maxPaperWidthPTS_buff = _maxPaperWidthPTS * _BUFFER_PCT

        myPrint("DB", "MediaPrintableArea: deduced printable width: %sMM(%sPTS) (using factor of *%s = %sPTS)" %(round(deducedWidthMM,1), round(_maxPaperWidthPTS,1), _BUFFER_PCT, _maxPaperWidthPTS_buff))
        return deducedWidthMM, _maxPaperWidthPTS, _maxPaperWidthPTS_buff

    def loadDefaultPrinterAttributes(_pAttrs=None):

        if _pAttrs is None:
            _pAttrs = attribute.HashPrintRequestAttributeSet()
        else:
            _pAttrs.clear()

        # Refer: https://docs.oracle.com/javase/7/docs/api/javax/print/attribute/standard/package-summary.html
        _pAttrs.add(attribute.standard.DialogTypeSelection.NATIVE)
        if GlobalVars.defaultPrintLandscape:
            _pAttrs.add(attribute.standard.OrientationRequested.LANDSCAPE)
        else:
            _pAttrs.add(attribute.standard.OrientationRequested.PORTRAIT)
        _pAttrs.add(attribute.standard.Chromaticity.MONOCHROME)
        _pAttrs.add(attribute.standard.JobSheets.NONE)
        _pAttrs.add(attribute.standard.Copies(1))
        _pAttrs.add(attribute.standard.PrintQuality.NORMAL)

        return _pAttrs

    def printOutputFile(_callingClass=None, _theTitle=None, _theJText=None, _theString=None):

        # Possible future modification, leverage MDPrinter, and it's classes / methods to save/load preferences and create printers
        try:
            if _theJText is None and _theString is None: return
            if _theJText is not None and len(_theJText.getText()) < 1: return
            if _theString is not None and len(_theString) < 1: return

            # Make a new one for printing
            if _theJText is not None:
                printJTextArea = JTextArea(_theJText.getText())
            else:
                printJTextArea = JTextArea(_theString)

            printJTextArea.setEditable(False)
            printJTextArea.setLineWrap(True)    # As we are reducing the font size so that the width fits the page width, this forces any remainder to wrap
            # if _callingClass is not None: printJTextArea.setLineWrap(_callingClass.lWrapText)  # Mirror the word wrap set by user
            printJTextArea.setWrapStyleWord(False)
            printJTextArea.setOpaque(False); printJTextArea.setBackground(Color(0,0,0,0)); printJTextArea.setForeground(Color.BLACK)
            printJTextArea.setBorder(EmptyBorder(0, 0, 0, 0))

            # IntelliJ doesnt like the use of 'print' (as it's a keyword)
            try:
                if "MD_REF" in globals():
                    usePrintFontSize = eval("MD_REF.getUI().getFonts().print.getSize()")
                elif "moneydance" in globals():
                    usePrintFontSize = eval("moneydance.getUI().getFonts().print.getSize()")
                else:
                    usePrintFontSize = GlobalVars.defaultPrintFontSize  # Just in case cleanup_references() has tidied up once script ended
            except:
                usePrintFontSize = 12   # Font print did not exist before build 3036

            theFontToUse = getMonoFont()       # Need Monospaced font, but with the font set in MD preferences for print
            theFontToUse = theFontToUse.deriveFont(float(usePrintFontSize))
            printJTextArea.setFont(theFontToUse)

            def computeFontSize(_theComponent, _maxPaperWidth, _dpi):

                # Auto shrink font so that text fits on one line when printing
                # Note: Java seems to operate it's maths at 72DPI (so must factor that into the maths)
                try:
                    _DEFAULT_MIN_WIDTH = mm2px(100, _dpi)   # 100MM
                    _minFontSize = 5                        # Below 5 too small
                    theString = _theComponent.getText()
                    _startingComponentFont = _theComponent.getFont()

                    if not theString or len(theString) < 1: return -1

                    fm = _theComponent.getFontMetrics(_startingComponentFont)
                    _maxFontSize = curFontSize = _startingComponentFont.getSize()   # Max out at the MD default for print font size saved in preferences
                    myPrint("DB","Print - starting font:", _startingComponentFont)
                    myPrint("DB","... calculating.... The starting/max font size is:", curFontSize)

                    maxLineWidthInFile = _DEFAULT_MIN_WIDTH
                    longestLine = ""
                    for line in theString.split("\n"):              # Look for the widest line adjusted for font style
                        _w = pt2dpi(fm.stringWidth(line), _dpi)
                        # myPrint("DB", "Found line (len: %s):" %(len(line)), line)
                        # myPrint("DB", "...calculated length metrics: %s/%sPTS (%sMM)" %(fm.stringWidth(line), _w, pt2mm(_w)))
                        if _w > maxLineWidthInFile:
                            longestLine = line
                            maxLineWidthInFile = _w
                    myPrint("DB","longest line width %s chars; maxLineWidthInFile now: %sPTS (%sMM)" %(len(longestLine),maxLineWidthInFile, pt2mm(maxLineWidthInFile)))

                    # Now shrink the font size to fit.....
                    while (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi) > _maxPaperWidth):
                        myPrint("DB","At font size: %s; (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi):" %(curFontSize), (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), pt2mm(pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), "MM", " >> max width:", _maxPaperWidth)
                        curFontSize -= 1
                        fm = _theComponent.getFontMetrics(Font(_startingComponentFont.getName(), _startingComponentFont.getStyle(), curFontSize))
                        myPrint("DB","... next will be: at font size: %s; (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi):" %(curFontSize), (pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), pt2mm(pt2dpi(fm.stringWidth(longestLine) + 5,_dpi)), "MM")

                        myPrint("DB","... calculating.... length of line still too long... reducing font size to:", curFontSize)
                        if curFontSize < _minFontSize:
                            myPrint("DB","... calculating... Next font size is too small... exiting the reduction loop...")
                            break

                    if not Platform.isMac():
                        curFontSize -= 1   # For some reason, sometimes on Linux/Windows still too big....
                        myPrint("DB","..knocking 1 off font size for good luck...! Now: %s" %(curFontSize))

                    # Code to increase width....
                    # while (pt2dpi(fm.stringWidth(theString) + 5,_dpi) < _maxPaperWidth):
                    #     curSize += 1
                    #     fm = _theComponent.getFontMetrics(Font(_startingComponentFont.getName(), _startingComponentFont.getStyle(), curSize))

                    curFontSize = max(_minFontSize, curFontSize); curFontSize = min(_maxFontSize, curFontSize)
                    myPrint("DB","... calculating.... Adjusted final font size to:", curFontSize)

                except:
                    myPrint("B", "ERROR: computeFontSize() crashed?"); dump_sys_error_to_md_console_and_errorlog()
                    return -1
                return curFontSize

            myPrint("DB", "Creating new PrinterJob...")
            printer_job = PrinterJob.getPrinterJob()

            if GlobalVars.defaultPrintService is not None:
                printer_job.setPrintService(GlobalVars.defaultPrintService)
                myPrint("DB","Assigned remembered PrintService...: %s" %(printer_job.getPrintService()))

            if GlobalVars.defaultPrinterAttributes is not None:
                pAttrs = attribute.HashPrintRequestAttributeSet(GlobalVars.defaultPrinterAttributes)
            else:
                pAttrs = loadDefaultPrinterAttributes(None)

            pAttrs.remove(attribute.standard.JobName)
            pAttrs.add(attribute.standard.JobName("%s: %s" %(myModuleID.capitalize(), _theTitle), None))

            if GlobalVars.defaultDPI != 72:
                pAttrs.remove(attribute.standard.PrinterResolution)
                pAttrs.add(attribute.standard.PrinterResolution(GlobalVars.defaultDPI, GlobalVars.defaultDPI, attribute.standard.PrinterResolution.DPI))

            for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes before user dialog: %s:%s" %(atr.getName(), atr))

            if not printer_job.printDialog(pAttrs):
                myPrint("DB","User aborted the Print Dialog setup screen, so exiting...")
                return

            selectedPrintService = printer_job.getPrintService()
            myPrint("DB", "User selected print service:", selectedPrintService)

            thePageFormat = printer_job.getPageFormat(pAttrs)

            # .setPrintable() seems to modify pAttrs & adds MediaPrintableArea. Do this before printDeducePrintableWidth()
            header = MessageFormat(_theTitle)
            footer = MessageFormat("- page {0} -")
            printer_job.setPrintable(printJTextArea.getPrintable(header, footer), thePageFormat)    # Yes - we do this twice

            for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes **AFTER** user dialog (and setPrintable): %s:%s" %(atr.getName(), atr))

            deducedWidthMM, maxPaperWidthPTS, maxPaperWidthPTS_buff = printDeducePrintableWidth(thePageFormat, pAttrs)

            if _callingClass is None or not _callingClass.lWrapText:

                newFontSize = computeFontSize(printJTextArea, int(maxPaperWidthPTS), GlobalVars.defaultDPI)

                if newFontSize > 0:
                    theFontToUse = theFontToUse.deriveFont(float(newFontSize))
                    printJTextArea.setFont(theFontToUse)

            # avoiding Intellij errors
            # eval("printJTextArea.print(header, footer, False, selectedPrintService, pAttrs, True)")  # If you do this, then native features like print to PDF will get ignored - so print via PrinterJob

            # Yup - calling .setPrintable() twice - before and after .computeFontSize()
            printer_job.setPrintable(printJTextArea.getPrintable(header, footer), thePageFormat)
            eval("printer_job.print(pAttrs)")

            del printJTextArea

            myPrint("DB", "Saving current print service:", printer_job.getPrintService())
            GlobalVars.defaultPrinterAttributes = attribute.HashPrintRequestAttributeSet(pAttrs)
            GlobalVars.defaultPrintService = printer_job.getPrintService()

        except:
            myPrint("B", "ERROR in printing routines.....:"); dump_sys_error_to_md_console_and_errorlog()
        return

    def pageSetup():

        myPrint("DB","Printer Page setup routines..:")

        myPrint("DB", 'NOTE: A4        210mm x 297mm	8.3" x 11.7"	Points: w595 x h842')
        myPrint("DB", 'NOTE: Letter    216mm x 279mm	8.5" x 11.0"	Points: w612 x h791')

        pj = PrinterJob.getPrinterJob()

        # Note: PrintService is not used/remembered/set by .pageDialog

        if GlobalVars.defaultPrinterAttributes is not None:
            pAttrs = attribute.HashPrintRequestAttributeSet(GlobalVars.defaultPrinterAttributes)
        else:
            pAttrs = loadDefaultPrinterAttributes(None)

        for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes before Page Setup: %s:%s" %(atr.getName(), atr))

        if not pj.pageDialog(pAttrs):
            myPrint("DB", "User cancelled Page Setup - exiting...")
            return

        for atr in pAttrs.toArray(): myPrint("DB", "Printer attributes **AFTER** Page Setup: %s:%s" %(atr.getName(), atr))

        if debug: printDeducePrintableWidth(pj.getPageFormat(pAttrs), pAttrs)

        myPrint("DB", "Printer selected: %s" %(pj.getPrintService()))

        GlobalVars.defaultPrinterAttributes = attribute.HashPrintRequestAttributeSet(pAttrs)
        myPrint("DB", "Printer Attributes saved....")

        return

    class SetupMDColors:

        OPAQUE = None
        FOREGROUND = None
        FOREGROUND_REVERSED = None
        BACKGROUND = None
        BACKGROUND_REVERSED = None

        def __init__(self): raise Exception("ERROR - Should not create instance of this class!")

        @staticmethod
        def updateUI():
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

            SetupMDColors.OPAQUE = False

            SetupMDColors.FOREGROUND = GlobalVars.CONTEXT.getUI().getColors().defaultTextForeground
            SetupMDColors.FOREGROUND_REVERSED = SetupMDColors.FOREGROUND

            SetupMDColors.BACKGROUND = GlobalVars.CONTEXT.getUI().getColors().defaultBackground
            SetupMDColors.BACKGROUND_REVERSED = SetupMDColors.BACKGROUND

            if ((not isMDThemeVAQua() and not isMDThemeDark() and isMacDarkModeDetected())
                    or (not isMacDarkModeDetected() and isMDThemeDarcula())):
                SetupMDColors.FOREGROUND_REVERSED = GlobalVars.CONTEXT.getUI().colors.defaultBackground
                SetupMDColors.BACKGROUND_REVERSED = GlobalVars.CONTEXT.getUI().colors.defaultTextForeground

    global ManuallyCloseAndReloadDataset            # Declare it for QuickJFrame/IDE, but not present in common code. Other code will ignore it 

    class GetFirstMainFrame:
        def __init__(self): raise Exception("ERROR: DO NOT CREATE INSTANCE OF GetFirstMainFrame!")

        @staticmethod
        def getSize(defaultWidth=1024, defaultHeight=768):
            try:
                firstMainFrame = MD_REF.getUI().firstMainFrame
                return firstMainFrame.getSize()
            except: pass
            return Dimension(defaultWidth, defaultHeight)

        @staticmethod
        def getSelectedAccount():
            try:
                firstMainFrame = MD_REF.getUI().firstMainFrame
                return firstMainFrame.getSelectedAccount()
            except: pass
            return None

    class QuickJFrame():

        def __init__(self,
                     title,
                     output,
                     lAlertLevel=0,
                     copyToClipboard=False,
                     lJumpToEnd=False,
                     lWrapText=True,
                     lQuitMDAfterClose=False,
                     lRestartMDAfterClose=False,
                     screenLocation=None,
                     lAutoSize=False):
            self.title = title
            self.output = output
            self.lAlertLevel = lAlertLevel
            self.returnFrame = None
            self.copyToClipboard = copyToClipboard
            self.lJumpToEnd = lJumpToEnd
            self.lWrapText = lWrapText
            self.lQuitMDAfterClose = lQuitMDAfterClose
            self.lRestartMDAfterClose = lRestartMDAfterClose
            self.screenLocation = screenLocation
            self.lAutoSize = lAutoSize
            # if Platform.isOSX() and int(float(MD_REF.getBuild())) >= 3039: self.lAlertLevel = 0    # Colors don't work on Mac since VAQua
            if isMDThemeDark() or isMacDarkModeDetected(): self.lAlertLevel = 0

        class QJFWindowListener(WindowAdapter):

            def __init__(self, theFrame, lQuitMDAfterClose=False, lRestartMDAfterClose=False):
                self.theFrame = theFrame
                self.lQuitMDAfterClose = lQuitMDAfterClose
                self.lRestartMDAfterClose = lRestartMDAfterClose
                self.saveMD_REF = MD_REF

            def windowClosing(self, WindowEvent):                                                                       # noqa
                myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", WindowEvent)
                myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                myPrint("DB", "QuickJFrame() Frame shutting down.... Calling .dispose()")
                self.theFrame.dispose()

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

            def windowClosed(self, WindowEvent):                                                                       # noqa
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))

                if self.lQuitMDAfterClose or self.lRestartMDAfterClose:
                    if "ManuallyCloseAndReloadDataset" not in globals():
                        myPrint("DB", "'ManuallyCloseAndReloadDataset' not in globals(), so just exiting MD the easy way...")
                        myPrint("B", "@@ EXITING MONEYDANCE @@")
                        MD_REF.getUI().exit()
                    else:
                        if self.lQuitMDAfterClose:
                            myPrint("B", "Quit MD after Close triggered... Now quitting MD")
                            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False)
                        elif self.lRestartMDAfterClose:
                            myPrint("B", "Restart MD after Close triggered... Now restarting MD")
                            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)
                else:
                    myPrint("DB", "FYI No Quit MD after Close triggered... So doing nothing...")

        class CloseAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):
                myPrint("D","in CloseAction(), Event: ", event)
                myPrint("DB", "QuickJFrame() Frame shutting down....")

                try:
                    if not SwingUtilities.isEventDispatchThread():
                        SwingUtilities.invokeLater(GenericDisposeRunnable(self.theFrame))
                    else:
                        self.theFrame.dispose()
                except:
                    myPrint("B","Error. QuickJFrame dispose failed....?")
                    dump_sys_error_to_md_console_and_errorlog()


        class ToggleWrap(AbstractAction):

            def __init__(self, theCallingClass, theJText):
                self.theCallingClass = theCallingClass
                self.theJText = theJText

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                self.theCallingClass.lWrapText = not self.theCallingClass.lWrapText
                self.theJText.setLineWrap(self.theCallingClass.lWrapText)

        class QuickJFrameNavigate(AbstractAction):

            def __init__(self, theJText, lTop=False, lBottom=False):
                self.theJText = theJText
                self.lTop = lTop
                self.lBottom = lBottom

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if self.lBottom: self.theJText.setCaretPosition(self.theJText.getDocument().getLength())
                if self.lTop:    self.theJText.setCaretPosition(0)

        class QuickJFramePrint(AbstractAction):

            def __init__(self, theCallingClass, theJText, theTitle=""):
                self.theCallingClass = theCallingClass
                self.theJText = theJText
                self.theTitle = theTitle

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                printOutputFile(_callingClass=self.theCallingClass, _theTitle=self.theTitle, _theJText=self.theJText)

        class QuickJFramePageSetup(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                pageSetup()

        class QuickJFrameSaveTextToFile(AbstractAction):

            def __init__(self, theText, callingFrame):
                self.theText = theText
                self.callingFrame = callingFrame

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                saveOutputFile(self.callingFrame, "QUICKJFRAME", "%s_output.txt" %(myModuleID), self.theText)

        def show_the_frame(self):

            class MyQuickJFrameRunnable(Runnable):

                def __init__(self, callingClass):
                    self.callingClass = callingClass

                def run(self):                                                                                                      # noqa
                    screenSize = Toolkit.getDefaultToolkit().getScreenSize()
                    frame_width = min(screenSize.width-20, max(1024,int(round(GetFirstMainFrame.getSize().width *.9,0))))
                    frame_height = min(screenSize.height-20, max(768, int(round(GetFirstMainFrame.getSize().height *.9,0))))

                    # JFrame.setDefaultLookAndFeelDecorated(True)   # Note: Darcula Theme doesn't like this and seems to be OK without this statement...
                    if self.callingClass.lQuitMDAfterClose:
                        extraText =  ">> MD WILL QUIT AFTER VIEWING THIS <<"
                    elif self.callingClass.lRestartMDAfterClose:
                        extraText =  ">> MD WILL RESTART AFTER VIEWING THIS <<"
                    else:
                        extraText = ""

                    jInternalFrame = MyJFrame(self.callingClass.title + " (%s+F to find/search for text)%s" %(MD_REF.getUI().ACCELERATOR_MASK_STR, extraText))
                    jInternalFrame.setName(u"%s_quickjframe" %myModuleID)

                    if not Platform.isOSX(): jInternalFrame.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

                    jInternalFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)
                    jInternalFrame.setResizable(True)

                    shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W,  shortcut), "close-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F,  shortcut), "search-window")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, shortcut),  "print-me")
                    jInternalFrame.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")

                    theJText = JTextArea(self.callingClass.output)
                    theJText.setEditable(False)
                    theJText.setLineWrap(self.callingClass.lWrapText)
                    theJText.setWrapStyleWord(False)
                    theJText.setFont( getMonoFont() )

                    jInternalFrame.getRootPane().getActionMap().put("close-window", self.callingClass.CloseAction(jInternalFrame))
                    jInternalFrame.getRootPane().getActionMap().put("search-window", SearchAction(jInternalFrame,theJText))
                    jInternalFrame.getRootPane().getActionMap().put("print-me", self.callingClass.QuickJFramePrint(self.callingClass, theJText, self.callingClass.title))
                    jInternalFrame.addWindowListener(self.callingClass.QJFWindowListener(jInternalFrame, self.callingClass.lQuitMDAfterClose, self.callingClass.lRestartMDAfterClose))

                    internalScrollPane = JScrollPane(theJText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)

                    if self.callingClass.lAlertLevel>=2:
                        # internalScrollPane.setBackground(Color.RED)
                        theJText.setBackground(Color.RED)
                        theJText.setForeground(Color.BLACK)
                        theJText.setOpaque(True)
                    elif self.callingClass.lAlertLevel>=1:
                        # internalScrollPane.setBackground(Color.YELLOW)
                        theJText.setBackground(Color.YELLOW)
                        theJText.setForeground(Color.BLACK)
                        theJText.setOpaque(True)

                    if not self.callingClass.lAutoSize:
                        jInternalFrame.setPreferredSize(Dimension(frame_width, frame_height))

                    SetupMDColors.updateUI()

                    printButton = JButton("Print")
                    printButton.setToolTipText("Prints the output displayed in this window to your printer")
                    printButton.setOpaque(SetupMDColors.OPAQUE)
                    printButton.setBackground(SetupMDColors.BACKGROUND); printButton.setForeground(SetupMDColors.FOREGROUND)
                    printButton.addActionListener(self.callingClass.QuickJFramePrint(self.callingClass, theJText, self.callingClass.title))

                    if GlobalVars.defaultPrinterAttributes is None:
                        printPageSetup = JButton("Page Setup")
                        printPageSetup.setToolTipText("Printer Page Setup")
                        printPageSetup.setOpaque(SetupMDColors.OPAQUE)
                        printPageSetup.setBackground(SetupMDColors.BACKGROUND); printPageSetup.setForeground(SetupMDColors.FOREGROUND)
                        printPageSetup.addActionListener(self.callingClass.QuickJFramePageSetup())

                    saveButton = JButton("Save to file")
                    saveButton.setToolTipText("Saves the output displayed in this window to a file")
                    saveButton.setOpaque(SetupMDColors.OPAQUE)
                    saveButton.setBackground(SetupMDColors.BACKGROUND); saveButton.setForeground(SetupMDColors.FOREGROUND)
                    saveButton.addActionListener(self.callingClass.QuickJFrameSaveTextToFile(self.callingClass.output, jInternalFrame))

                    wrapOption = JCheckBox("Wrap Contents (Screen & Print)", self.callingClass.lWrapText)
                    wrapOption.addActionListener(self.callingClass.ToggleWrap(self.callingClass, theJText))
                    wrapOption.setForeground(SetupMDColors.FOREGROUND_REVERSED); wrapOption.setBackground(SetupMDColors.BACKGROUND_REVERSED)

                    topButton = JButton("Top")
                    topButton.setOpaque(SetupMDColors.OPAQUE)
                    topButton.setBackground(SetupMDColors.BACKGROUND); topButton.setForeground(SetupMDColors.FOREGROUND)
                    topButton.addActionListener(self.callingClass.QuickJFrameNavigate(theJText, lTop=True))

                    botButton = JButton("Bottom")
                    botButton.setOpaque(SetupMDColors.OPAQUE)
                    botButton.setBackground(SetupMDColors.BACKGROUND); botButton.setForeground(SetupMDColors.FOREGROUND)
                    botButton.addActionListener(self.callingClass.QuickJFrameNavigate(theJText, lBottom=True))

                    closeButton = JButton("Close")
                    closeButton.setOpaque(SetupMDColors.OPAQUE)
                    closeButton.setBackground(SetupMDColors.BACKGROUND); closeButton.setForeground(SetupMDColors.FOREGROUND)
                    closeButton.addActionListener(self.callingClass.CloseAction(jInternalFrame))

                    if Platform.isOSX():
                        save_useScreenMenuBar= System.getProperty("apple.laf.useScreenMenuBar")
                        if save_useScreenMenuBar is None or save_useScreenMenuBar == "":
                            save_useScreenMenuBar= System.getProperty("com.apple.macos.useScreenMenuBar")
                        System.setProperty("apple.laf.useScreenMenuBar", "false")
                        System.setProperty("com.apple.macos.useScreenMenuBar", "false")
                    else:
                        save_useScreenMenuBar = "true"

                    mb = JMenuBar()
                    mb.setBorder(EmptyBorder(0, 0, 0, 0))
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(topButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(botButton)
                    mb.add(Box.createHorizontalGlue())
                    mb.add(wrapOption)

                    if GlobalVars.defaultPrinterAttributes is None:
                        mb.add(Box.createRigidArea(Dimension(10, 0)))
                        mb.add(printPageSetup)                                                                          # noqa

                    mb.add(Box.createHorizontalGlue())
                    mb.add(printButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(saveButton)
                    mb.add(Box.createRigidArea(Dimension(10, 0)))
                    mb.add(closeButton)
                    mb.add(Box.createRigidArea(Dimension(30, 0)))

                    jInternalFrame.setJMenuBar(mb)

                    jInternalFrame.add(internalScrollPane)

                    jInternalFrame.pack()
                    if self.callingClass.screenLocation and isinstance(self.callingClass.screenLocation, Point):
                        jInternalFrame.setLocation(self.callingClass.screenLocation)
                    else:
                        jInternalFrame.setLocationRelativeTo(None)

                    jInternalFrame.setVisible(True)

                    if Platform.isOSX():
                        System.setProperty("apple.laf.useScreenMenuBar", save_useScreenMenuBar)
                        System.setProperty("com.apple.macos.useScreenMenuBar", save_useScreenMenuBar)

                    if "errlog.txt" in self.callingClass.title or self.callingClass.lJumpToEnd:
                        theJText.setCaretPosition(theJText.getDocument().getLength())

                    try:
                        if self.callingClass.copyToClipboard:
                            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(self.callingClass.output), None)
                    except:
                        myPrint("J","Error copying contents to Clipboard")
                        dump_sys_error_to_md_console_and_errorlog()

                    self.callingClass.returnFrame = jInternalFrame

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyQuickJFrameRunnable()...")
                SwingUtilities.invokeAndWait(MyQuickJFrameRunnable(self))
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                MyQuickJFrameRunnable(self).run()

            return (self.returnFrame)

    class AboutThisScript(AbstractAction, Runnable):

        def __init__(self, theFrame):
            self.theFrame = theFrame
            self.aboutDialog = None

        def actionPerformed(self, event):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()", "Event:", event)
            self.aboutDialog.dispose()  # Listener is already on the Swing EDT...

        def go(self):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")

            if not SwingUtilities.isEventDispatchThread():
                myPrint("DB",".. Not running within the EDT so calling via MyAboutRunnable()...")
                SwingUtilities.invokeAndWait(self)
            else:
                myPrint("DB",".. Already within the EDT so calling naked...")
                self.run()

        def run(self):                                                                                                  # noqa
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

            # noinspection PyUnresolvedReferences
            self.aboutDialog = JDialog(self.theFrame, "About", Dialog.ModalityType.MODELESS)

            shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()
            self.aboutDialog.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
            self.aboutDialog.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
            self.aboutDialog.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close-window")

            self.aboutDialog.getRootPane().getActionMap().put("close-window", self)
            self.aboutDialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)

            if (not Platform.isMac()):
                # MD_REF.getUI().getImages()
                self.aboutDialog.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

            aboutPanel = JPanel()
            aboutPanel.setLayout(FlowLayout(FlowLayout.LEFT))
            aboutPanel.setPreferredSize(Dimension(1120, 550))

            _label1 = JLabel(pad("Author: Stuart Beesley", 800))
            _label1.setForeground(getColorBlue())
            aboutPanel.add(_label1)

            _label2 = JLabel(pad("StuWareSoftSystems (2020-2022)", 800))
            _label2.setForeground(getColorBlue())
            aboutPanel.add(_label2)

            _label3 = JLabel(pad("Script/Extension: %s (build: %s)" %(GlobalVars.thisScriptName, version_build), 800))
            _label3.setForeground(getColorBlue())
            aboutPanel.add(_label3)

            displayString=scriptExit
            displayJText = JTextArea(displayString)
            displayJText.setFont( getMonoFont() )
            displayJText.setEditable(False)
            displayJText.setLineWrap(False)
            displayJText.setWrapStyleWord(False)
            displayJText.setMargin(Insets(8, 8, 8, 8))

            aboutPanel.add(displayJText)

            self.aboutDialog.add(aboutPanel)

            self.aboutDialog.pack()
            self.aboutDialog.setLocationRelativeTo(None)
            self.aboutDialog.setVisible(True)

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def isGoodRate(theRate):

        if Double.isNaN(theRate) or Double.isInfinite(theRate) or theRate == 0:
            return False
        return True

    def safeInvertRate(theRate):

        if not isGoodRate(theRate):
            return theRate
        return (1.0 / theRate)

    def convertBytesGBs(_size): return round((_size/(1000.0*1000.0*1000)),1)

    def convertBytesMBs(_size): return round((_size/(1000.0*1000.0)),1)

    def convertBytesKBs(_size): return round((_size/(1000.0)),1)

    def convertMDShortDateFormat_strftimeFormat(lIncludeTime=False, lForceYYMMDDHMS=False):
        """Returns a Python strftime format string in accordance with MD Preferences for Date Format"""
        # https://strftime.org

        _MDFormat = MD_REF.getPreferences().getShortDateFormat()

        rtnFormat = "%Y-%m-%d"

        if lForceYYMMDDHMS:
            lIncludeTime = True
        else:
            if _MDFormat == "MM/dd/yyyy":
                rtnFormat = "%m/%d/%Y"
            elif _MDFormat == "MM.dd.yyyy":
                rtnFormat = "%m.%d.%Y"
            elif _MDFormat == "yyyy/MM/dd":
                rtnFormat = "%Y/%m/%d"
            elif _MDFormat == "yyyy.MM.dd":
                rtnFormat = "%Y.%m.%d"
            elif _MDFormat == "dd/MM/yyyy":
                rtnFormat = "%d/%m/%Y"
            elif _MDFormat == "dd.MM.yyyy":
                rtnFormat = "%d.%m.%Y"

        if lIncludeTime: rtnFormat += " %H:%M:%S"
        return rtnFormat

    def getHumanReadableDateTimeFromTimeStamp(_theTimeStamp, lIncludeTime=False, lForceYYMMDDHMS=False):
        return datetime.datetime.fromtimestamp(_theTimeStamp).strftime(convertMDShortDateFormat_strftimeFormat(lIncludeTime=lIncludeTime, lForceYYMMDDHMS=lForceYYMMDDHMS))

    def getHumanReadableModifiedDateTimeFromFile(_theFile, lIncludeTime=True, lForceYYMMDDHMS=True):
        return getHumanReadableDateTimeFromTimeStamp(os.path.getmtime(_theFile), lIncludeTime=lIncludeTime, lForceYYMMDDHMS=lForceYYMMDDHMS)

    def convertStrippedIntDateFormattedText(strippedDateInt, _format=None):

        # if _format is None: _format = "yyyy/MM/dd"
        if _format is None: _format = MD_REF.getPreferences().getShortDateFormat()

        if strippedDateInt is None or strippedDateInt == 0:
            return "<not set>"

        try:
            c = Calendar.getInstance()
            dateFromInt = DateUtil.convertIntDateToLong(strippedDateInt)
            c.setTime(dateFromInt)
            dateFormatter = SimpleDateFormat(_format)
            convertedDate = dateFormatter.format(c.getTime())
        except:
            return "<error>"

        return convertedDate

    def selectHomeScreen():

        try:
            currentViewAccount = MD_REF.getUI().firstMainFrame.getSelectedAccount()
            if currentViewAccount != MD_REF.getRootAccount():
                myPrint("DB","Switched to Home Page Summary Page (from: %s)" %(currentViewAccount))
                MD_REF.getUI().firstMainFrame.selectAccount(MD_REF.getRootAccount())
        except:
            myPrint("B","@@ Error switching to Summary Page (Home Page)")

    def fireMDPreferencesUpdated():
        """This triggers MD to firePreferencesUpdated().... Hopefully refreshing Home Screen Views too"""
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        class FPSRunnable(Runnable):
            def __init__(self): pass

            def run(self):
                myPrint("DB",".. Inside FPSRunnable() - calling firePreferencesUpdated()...")
                myPrint("B","Triggering an update to the Summary/Home Page View")
                MD_REF.getPreferences().firePreferencesUpdated()

        if not SwingUtilities.isEventDispatchThread():
            myPrint("DB",".. Not running within the EDT so calling via FPSRunnable()...")
            SwingUtilities.invokeLater(FPSRunnable())
        else:
            myPrint("DB",".. Already running within the EDT so calling FPSRunnable() naked...")
            FPSRunnable().run()
        return

    def decodeCommand(passedEvent):
        param = ""
        uri = passedEvent
        command = uri
        theIdx = uri.find('?')
        if(theIdx>=0):
            command = uri[:theIdx]
            param = uri[theIdx+1:]
        else:
            theIdx = uri.find(':')
            if(theIdx>=0):
                command = uri[:theIdx]
                param = uri[theIdx+1:]
        return command, param

    def getFieldByReflection(theObj, fieldName, isInt=False):
        try: theClass = theObj.getClass()
        except TypeError: theClass = theObj     # This catches where the object is already the Class
        reflectField = None
        while theClass is not None:
            try:
                reflectField = theClass.getDeclaredField(fieldName)
                break
            except NoSuchFieldException:
                theClass = theClass.getSuperclass()
        if reflectField is None: raise Exception("ERROR: could not find field: %s in class hierarchy" %(fieldName))
        if Modifier.isPrivate(reflectField.getModifiers()): reflectField.setAccessible(True)
        elif Modifier.isProtected(reflectField.getModifiers()): reflectField.setAccessible(True)
        isStatic = Modifier.isStatic(reflectField.getModifiers())
        if isInt: return reflectField.getInt(theObj if not isStatic else None)
        return reflectField.get(theObj if not isStatic else None)

    def invokeMethodByReflection(theObj, methodName, params, *args):
        try: theClass = theObj.getClass()
        except TypeError: theClass = theObj     # This catches where the object is already the Class
        reflectMethod = None
        while theClass is not None:
            try:
                if params is None:
                    reflectMethod = theClass.getDeclaredMethod(methodName)
                    break
                else:
                    reflectMethod = theClass.getDeclaredMethod(methodName, params)
                    break
            except NoSuchMethodException:
                theClass = theClass.getSuperclass()
        if reflectMethod is None: raise Exception("ERROR: could not find method: %s in class hierarchy" %(methodName))
        reflectMethod.setAccessible(True)
        return reflectMethod.invoke(theObj, *args)

    def setFieldByReflection(theObj, fieldName, newValue):
        try: theClass = theObj.getClass()
        except TypeError: theClass = theObj     # This catches where the object is already the Class
        reflectField = None
        while theClass is not None:
            try:
                reflectField = theClass.getDeclaredField(fieldName)
                break
            except NoSuchFieldException:
                theClass = theClass.getSuperclass()
        if reflectField is None: raise Exception("ERROR: could not find field: %s in class hierarchy" %(fieldName))
        if Modifier.isPrivate(reflectField.getModifiers()): reflectField.setAccessible(True)
        elif Modifier.isProtected(reflectField.getModifiers()): reflectField.setAccessible(True)
        isStatic = Modifier.isStatic(reflectField.getModifiers())
        return reflectField.set(theObj if not isStatic else None, newValue)

    def find_feature_module(theModule):
        # type: (str) -> bool
        """Searches Moneydance for a specific extension loaded"""
        fms = MD_REF.getLoadedModules()
        for fm in fms:
            if fm.getIDStr().lower() == theModule:
                myPrint("DB", "Found extension: %s" %(theModule))
                return fm
        return None

    def isMDPlusEnabledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_MDPLUS_BUILD)

    def isAlertControllerEnabledBuild(): return (float(MD_REF.getBuild()) >= GlobalVars.MD_ALERTCONTROLLER_BUILD)

    def shutdownMDPlusPoller():
        if isMDPlusEnabledBuild():
            myPrint("DB", "Shutting down the MD+ poller")
            plusPoller = MD_REF.getUI().getPlusController()
            if plusPoller is not None:
                invokeMethodByReflection(plusPoller, "shutdown", None)
                setFieldByReflection(MD_REF.getUI(), "plusPoller", None)

            myPrint("DB", "... Clearing out the in-memory license cache...")
            licenseCache = getFieldByReflection(MDPlus, "licenseCache")
            if licenseCache is not None: licenseCache.clear()

            myPrint("DB", "... MD+ poller shutdown...")

    def shutdownMDAlertController():
        if isAlertControllerEnabledBuild():
            myPrint("DB", "Shutting down the Alert Controller")
            alertController = MD_REF.getUI().getAlertController()
            if alertController is not None:
                invokeMethodByReflection(alertController, "shutdown", None)
                setFieldByReflection(MD_REF.getUI(), "alertController", None)

    # END COMMON DEFINITIONS ###############################################################################################
    # END COMMON DEFINITIONS ###############################################################################################
    # END COMMON DEFINITIONS ###############################################################################################
    # COPY >> END

    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    def load_StuWareSoftSystems_parameters_into_memory():

        # >>> THESE ARE THIS SCRIPT's PARAMETERS TO LOAD
        global __TOOLBOX, lCopyAllToClipBoard_TB, lIgnoreOutdatedExtensions_TB, lAutoPruneInternalBackups_TB

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )
        myPrint("DB", "Loading variables into memory...")

        if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

        if GlobalVars.parametersLoadedFromFile.get("__TOOLBOX") is not None: __TOOLBOX = GlobalVars.parametersLoadedFromFile.get("__TOOLBOX")
        if GlobalVars.parametersLoadedFromFile.get("lCopyAllToClipBoard_TB") is not None: lCopyAllToClipBoard_TB = GlobalVars.parametersLoadedFromFile.get("lCopyAllToClipBoard_TB")
        if GlobalVars.parametersLoadedFromFile.get("lIgnoreOutdatedExtensions_TB") is not None: lIgnoreOutdatedExtensions_TB = GlobalVars.parametersLoadedFromFile.get("lIgnoreOutdatedExtensions_TB")
        if GlobalVars.parametersLoadedFromFile.get("lAutoPruneInternalBackups_TB") is not None: lAutoPruneInternalBackups_TB = GlobalVars.parametersLoadedFromFile.get("lAutoPruneInternalBackups_TB")

        # No longer needed as button will be ever-present...
        if GlobalVars.parametersLoadedFromFile.get("lGeekOutModeEnabled_TB") is not None: GlobalVars.parametersLoadedFromFile.pop("lGeekOutModeEnabled_TB")

        myPrint("DB","GlobalVars.parametersLoadedFromFile{} set into memory (as variables).....")

        return

    # >>> CUSTOMISE & DO THIS FOR EACH SCRIPT
    def dump_StuWareSoftSystems_parameters_from_memory():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        # NOTE: Parameters were loaded earlier on... Preserve existing, and update any used ones...
        # (i.e. other StuWareSoftSystems programs might be sharing the same file)

        if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

        GlobalVars.parametersLoadedFromFile["__TOOLBOX"] = version_build
        GlobalVars.parametersLoadedFromFile["lCopyAllToClipBoard_TB"] = lCopyAllToClipBoard_TB
        GlobalVars.parametersLoadedFromFile["lIgnoreOutdatedExtensions_TB"] = lIgnoreOutdatedExtensions_TB
        GlobalVars.parametersLoadedFromFile["lAutoPruneInternalBackups_TB"] = lAutoPruneInternalBackups_TB

        myPrint("DB","variables dumped from memory back into GlobalVars.parametersLoadedFromFile{}.....")

        return

    lFailed_get_StuWareSoftSystems_parameters_from_file = False
    try:
        get_StuWareSoftSystems_parameters_from_file()
    except:
        lFailed_get_StuWareSoftSystems_parameters_from_file = True
        myPrint("B", "ERROR: Failed on get_StuWareSoftSystems_parameters_from_file()...  ** IS YOUR DATASET CLOSED? **")
        dump_sys_error_to_md_console_and_errorlog()

    # clear up any old left-overs....
    destroyOldFrames(myModuleID)

    myPrint("DB", "DEBUG IS ON..")

    if SwingUtilities.isEventDispatchThread():
        myPrint("DB", "FYI - This script/extension is currently running within the Swing Event Dispatch Thread (EDT)")
    else:
        myPrint("DB", "FYI - This script/extension is NOT currently running within the Swing Event Dispatch Thread (EDT)")

    def cleanup_actions(theFrame=None):
        myPrint("DB", "In", inspect.currentframe().f_code.co_name, "()")
        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

        if theFrame is not None and not theFrame.isActiveInMoneydance:
            destroyOldFrames(myModuleID)

        try:
            MD_REF.getUI().setStatus(">> Infinite Kind (co-authored by Stuart Beesley: StuWareSoftSystems) - Thanks for using Toolbox.......",0)
        except:
            pass  # If this fails, then MD is probably shutting down.......

        if not GlobalVars.i_am_an_extension_so_run_headless: print(scriptExit)

        cleanup_references()

    # .moneydance_invoke_called() is used via the _invoke.py script as defined in script_info.dict. Not used for runtime extensions
    def moneydance_invoke_called(theCommand):
        # ... modify as required to handle .showURL() events sent to this extension/script...
        myPrint("B","INVOKE - Received extension command: '%s'" %(theCommand))
        cmd, param = decodeCommand(theCommand)
        try:
            class QuickTmpRunnable(Runnable):
                def __init__(self, _cmd, _param):
                    self.cmd = _cmd
                    self.param = _param

                def run(self): setDisplayStatus("Received unknown event command ('%s' : '%s')" %(self.cmd, self.param), "B")

            quickRun = QuickTmpRunnable(cmd, param)
            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(quickRun)
            else:
                quickRun.run()
        except: pass

    GlobalVars.defaultPrintLandscape = True
    # END ALL CODE COPY HERE ###############################################################################################
    # END ALL CODE COPY HERE ###############################################################################################
    # END ALL CODE COPY HERE ###############################################################################################

    # Prevent usage later on... We use MD_REF
    if "moneydance" in globals(): del moneydance

    def isMDThread(threadName):
        for checkName in ["TIKSync", "MD Background Ops", "MDPlus", "MD+", "TaskIndicator"]:
            if threadName.lower().startswith(checkName.lower()): return True
        return False

    def getYN(_bool=False): return "Y" if _bool else "N"

    def getJVMThreadInformation(_thread, _addNewLine=False):
        if _thread is None or not isinstance(_thread, Thread): return
        try:
            _txt = ("%s%s (id: %s) State: %s isAlive: %s isInterrupted: %s isDaemon: %s Priority: %s ThreadGroup: %s"
                            %(pad("**" if (isMDThread(_thread.getName())) else "", 2),
                              pad(_thread.getName(),70), rpad(_thread.getId(),4),
                              pad(_thread.getState(),15), getYN(_thread.isAlive()), getYN(_thread.isInterrupted()),
                              getYN(_thread.isDaemon()), rpad(_thread.getPriority(),2), _thread.getThreadGroup()))
        except: _txt = "**ERROR translating Thread information**"
        if _addNewLine: _txt += "\n"
        return _txt

    def getJVMUsageStatistics(memoryUsageStats=True, maxMemoryStats=False, availableProcessorsStats=False):

        runTime = Runtime.getRuntime()
        maxMemory = Runtime.getRuntime().maxMemory()

        countParams = 0
        if memoryUsageStats:         countParams += 1
        if maxMemoryStats:           countParams += 1
        if availableProcessorsStats: countParams += 1

        statsText = u""; lineEnd = u""
        if countParams > 1:
            lineEnd = u"\n"
            statsText += (u"Java JVM Resources" + lineEnd)

        if availableProcessorsStats:
            statsText += (u"JVM - Available processor cores: %s" %(runTime.availableProcessors()) + lineEnd)

        if maxMemoryStats:
            statsText += (u"JVM - Maximum memory possible:   %s" %(u"{}".format(u"no limit") if (Long(maxMemory) == Long.MAX_VALUE) else u"{:,} GB".format(convertBytesGBs(maxMemory))) + lineEnd)

        if memoryUsageStats:
            statsText += (u"JVM - Total memory allocated:    {:,} GB (used {:,} GB / free {:,} GB)"
                .format(convertBytesGBs(runTime.totalMemory()),
                        convertBytesGBs(runTime.totalMemory() - runTime.freeMemory()),
                        convertBytesGBs(runTime.freeMemory()))
                + lineEnd)

        return statsText

    class ManuallyCloseAndReloadDataset(Runnable):

        @staticmethod
        def closeSecondaryWindows():
            myPrint("DB", "In ManuallyCloseAndReloadDataset.closeSecondaryWindows()")
            if not SwingUtilities.isEventDispatchThread(): return False
            if not ManuallyCloseAndReloadDataset.isSafeToCloseDataset(): return False
            return invokeMethodByReflection(MD_REF.getUI(), "closeSecondaryWindows", [Boolean.TYPE], [False])

        @staticmethod
        def isSafeToCloseDataset():
            # type: () -> bool
            """Checks with MD whether all the Secondary Windows report that they are in a state to close"""
            myPrint("DB", "In ManuallyCloseAndReloadDataset.isSafeToCloseDataset()")
            if not SwingUtilities.isEventDispatchThread(): return False
            return invokeMethodByReflection(MD_REF.getUI(), "isOKToCloseFile", None)

        @staticmethod
        def clearWindowBookReferences(lClearCurrentBookToo=False):
            # type: (bool) -> bool
            """Iterates all known AWT Windows, searching for 'book' and sets to None"""
            for _win in Window.getWindows():
                try:
                    ref_book = getFieldByReflection(_win, "book")
                    if (ref_book is not None
                            and (lClearCurrentBookToo or ref_book is not MD_REF.getCurrentAccountBook())):
                        if isinstance(_win, (SecondaryWindow, SecondaryFrame, SecondaryDialog)): clearTxt = "CLEARING"
                        else: clearTxt = "IGNORING"
                        myPrint("DB", "%s 'book' reference from: %s '%s' : %s @{:x} %s (Owner: %s:%s)\n".format(System.identityHashCode(ref_book))
                                                                        %(clearTxt, type(_win), _win.getName(),
                                                                        "** THIS BOOK **" if (ref_book is MD_REF.getCurrentAccountBook()) else "!! OLD BOOK !! ",
                                                                        ref_book,
                                                                        type(_win.getOwner()), (None if (_win.getOwner()) is None else _win.getOwner().getName())))
                        if isinstance(_win, (SecondaryWindow, SecondaryFrame, SecondaryDialog)): setFieldByReflection(_win, "book", None)
                    del ref_book
                except: pass
            return True

        @staticmethod
        def startBackgroundSyncing():
            """Start a new Background Ops Thread.. Does nothing if 'backgroundThread' is not None and isRunning()"""
            myPrint("DB", "... launching a new BackgroundOpsThread if old one dead or not running...")
            invokeMethodByReflection(MD_REF, "startBackgroundSyncing", None)

        @staticmethod
        def moneydanceExitOrRestart(lRestart=True, lAllowSaveWorkspace=True):
            # type: (bool, bool) -> bool
            """Checks with MD whether all the Secondary Windows report that they are in a state to close"""
            myPrint("DB", "In ManuallyCloseAndReloadDataset.moneydanceExitOrRestart() - lRestart: %s, lAllowSaveWorkspace: %s" %(lRestart, lAllowSaveWorkspace))

            if lRestart and not lAllowSaveWorkspace: raise Exception("Sorry: you cannot use lRestart=True and lAllowSaveWorkspace=False together...!")

            if lRestart:
                myPrint("B", "@@ RESTARTING MONEYDANCE >> RELOADING SAME DATASET @@")
                Thread(ManuallyCloseAndReloadDataset(), "toolbox_moneydanceExitOrRestart").start()
            else:
                if lAllowSaveWorkspace:
                    myPrint("B", "@@ EXITING MONEYDANCE @@")
                    MD_REF.getUI().exit()
                else:
                    myPrint("B", "@@ SHUTTING DOWN MONEYDANCE >> NOT SAVING 'WORKSPACE' @@")
                    MD_REF.getUI().shutdownApp(False)

        @staticmethod
        def manuallyCloseDataset(theBook, lCloseWindows=True, lKillAllSyncers=False, lKillAllFramesWithBookReferences=False):
            # type: (AccountBook, bool, bool, bool) -> bool
            """Mimics .setCurrentBook(None) but avoids the Auto Backup 'issue'. Also closes open SecondaryWindows, pauses MD+ etc
            You should decide whether to run this on the EDT or on a new background thread when calling this method. This will also
            force kill Syncer thread(s) found... parameter: lKillAllSyncers:False will only kill this dataset's Syncer (True = kill all Syncers found)"""

            myPrint("DB", "In ManuallyCloseAndReloadDataset.manuallyCloseDataset(), lCloseWindows: %s, lKillAllSyncers: %s lKillAllFramesWithBookReferences: %s" %(lCloseWindows, lKillAllSyncers, lKillAllFramesWithBookReferences))

            wr_bookToClose = WeakReference(theBook)
            del theBook

            wr_oldSyncer = WeakReference(wr_bookToClose.get().getSyncer())                                              # noqa

            Syncer.DEBUG = True

            if debug: myPrint("B", getJVMUsageStatistics())

            if lCloseWindows:
                if not SwingUtilities.isEventDispatchThread():
                    raise Exception("ERROR: you must run manuallyCloseDataset() on the EDT if you wish to also call closeSecondaryWindows()...!")
                if not ManuallyCloseAndReloadDataset.closeSecondaryWindows():
                    myPrint("B", "manuallyCloseDataset().closeSecondaryWindows() returned False?")
                    return False

            # Shutdown the MD+ poller... When we open a new dataset it should reset itself.....
            shutdownMDPlusPoller()

            # Shutdown the Alert Controller... When we open a new dataset it should reset itself.....
            shutdownMDAlertController()

            MD_REF.getUI().closeBotInterface()

            wr_bookToClose.get().setUndoManager(None)                                                                   # noqa

            if debug:
                myPrint("B", "... pre-close getSyncer(): %s isRunningInBackground: %s isSyncing: %s" %(wr_oldSyncer.get(), wr_oldSyncer.get().isRunningInBackground(), wr_oldSyncer.get().isSyncing()))    # noqa
                for t in [t for t in Thread.getAllStackTraces().keySet() if "sync" in t.getName()]: myPrint("B", "... Current Syncer Threads...:", getJVMThreadInformation(t, True))

            myPrint("DB", "... closing SyncManager / settings window etc..")
            if MD_REF.getUI().getSyncManager() is not None:
                MD_REF.getUI().getSyncManager().dataFileWasLoaded(None)  # Essentially will close Sync Manager settings window if open...

            myPrint("DB", "... setting 'olMgr' to None..")
            setFieldByReflection(MD_REF.getUI(), "olMgr", None)

            myPrint("DB", "... saving LocalStorage..")
            wr_bookToClose.get().getLocalStorage().save()                                                               # noqa

            myPrint("DB", "... Mimicking .setCurrentBook(None).... (without auto-backup etc)....")

            MD_REF.fireAppEvent("md:file:closing")
            MD_REF.saveCurrentAccount()                         # Flush any current txns in memory and start a new sync record..

            MD_REF.fireAppEvent("md:file:closed")

            myPrint("DB", "... calling .cleanUp() ....")
            # This will call syncer.stopSyncing() and syncer.compressLocalStorage()
            wr_bookToClose.get().cleanUp()                                                                              # noqa

            # myPrint("DB", "... setting syncer's syncFolder to None ....")
            # if wr_oldSyncer.get() is not None:
            #     setFieldByReflection(wr_oldSyncer.get(), "syncFolder", None);   # com.infinitekind.tiksync.Syncer.syncFolder : SyncFolder

            # myPrint("DB", "... setting syncer to None ....")
            # setFieldByReflection(wr_bookToClose.get(), "syncer", None);         # com.infinitekind.moneydance.model.AccountBook.syncer : Syncer

            myPrint("B", "... waiting for background tasks to complete... (shutting down 'backgroundThread'....)...")
            MD_REF.getBackgroundThread().waitForAllTasksToFinish()   # This will actually shut down the Thread.....
            setFieldByReflection(MD_REF, "backgroundThread", None)   # com.moneydance.apps.md.controller.Main.backgroundThread : BackgroundOpsThread

            # Force kill all Syncer Threads. Should not need to do this, but something in MD can keep these alive. Syncer must NOT run after we move a dataset (for example)
            wr_syncerThread = syncerThreadId = None
            if wr_oldSyncer.get() is not None:
                wr_syncerThread = WeakReference(getFieldByReflection(wr_oldSyncer.get(), "syncThread"))
                if wr_syncerThread.get() is not None:
                    syncerThreadId = wr_syncerThread.get().getId()                                                      # noqa

            if syncerThreadId is not None:
                myPrint("DB", "Current book's Syncer: %s, SyncerThread: %s (id: %s)" %(wr_oldSyncer.get(), wr_syncerThread.get(), syncerThreadId))
            else:
                myPrint("DB", "Current book's Syncer's details not found....")

            iSyncerChecks = 0
            if wr_oldSyncer.get() is not None:
                myPrint("B", "... waiting for syncer background tasks to complete...")
                while wr_oldSyncer.get().isRunningInBackground() or wr_oldSyncer.get().isSyncing():                     # noqa

                    if wr_syncerThread.get() is None or not wr_syncerThread.get().isAlive():                            # noqa
                        myPrint("B", "...... syncer's thread appears to have died already.... will proceed....")
                        break

                    iSyncerChecks += 1
                    if iSyncerChecks <= 16:
                        myPrint("B", "...... syncer still running.... waiting....")
                        try:
                            Thread.sleep(250)
                            continue
                        except: myPrint("B", "......... Caught exception during sleep... will proceed....")
                    else: myPrint("B", "......... giving up after 16 checks (4 seconds)...")
                    break

                myPrint("B", "...... syncer appears to have finished (or I gave up waiting).....")

            for t in [t for t in Thread.getAllStackTraces().keySet() if t.getName() == "TIKSync async thread"]:
                if lKillAllSyncers or t.getId() == syncerThreadId:
                    myPrint("B", "... Force killing Syncer Thread:", t, t.getId())
                    try: t.stop()    # This is a deprecated method (and bad practice)....
                    except: myPrint("B", "...... Caught exception during stop() command.... Continuing...")
            del wr_syncerThread, syncerThreadId

            if debug:
                myPrint("B", "... after-kill syncer threads getSyncer(): %s isRunningInBackground: %s isSyncing: %s" %(wr_oldSyncer.get(), wr_oldSyncer.get().isRunningInBackground(), wr_oldSyncer.get().isSyncing()))    # noqa
                for t in [t for t in Thread.getAllStackTraces().keySet() if "sync" in t.getName()]: myPrint("B", "... Current Syncer Threads...:", getJVMThreadInformation(t, True))

            myPrint("DB", "... setting Main's 'currentBook' to None...")
            setFieldByReflection(MD_REF, "currentBook", None)

            myPrint("B", "Closed current dataset (book: %s)" %(wr_bookToClose.get()))

            if lKillAllFramesWithBookReferences:
                myPrint("DB", "... clearing out old references to 'book' from Windows/Frames/JFrames etc....")
                ManuallyCloseAndReloadDataset.clearWindowBookReferences()

            if debug: myPrint("B", getJVMUsageStatistics())

            myPrint("B", "... FINISHED Closing down the dataset")
            return True

        class DisplayErrorMsg(Runnable):
            def __init__(self, _msg): self.msg = _msg
            def run(self): myPopupInformationBox(None, self.msg, "ERROR", JOptionPane.ERROR_MESSAGE)

        THIS_APPS_FRAME_REFERENCE = None

        def __init__(self, lQuitThisAppToo=True):
            self.lQuitThisAppToo = (lQuitThisAppToo and self.__class__.THIS_APPS_FRAME_REFERENCE is not None)
            self.result = None

        def getResult(self): return self.result     # Caution - only call this when you have waited for Thread to complete..... ;->

        def run(self):
            # type: () -> bool
            self.result = self.manuallyCloseAndReloadDataset()

        def manuallyCloseAndReloadDataset(self):
            # type: () -> bool
            """Manually closes current dataset, then reloads the same dataset.. Use when you want to refresh MD's internals"""

            if SwingUtilities.isEventDispatchThread(): raise Exception("ERROR - you must run manuallyCloseAndReloadDataset() from a new non-EDT thread!")

            cswResult = [None]
            class CloseSecondaryWindows(Runnable):
                def __init__(self, result): self.result = result
                def run(self): self.result[0] = ManuallyCloseAndReloadDataset.closeSecondaryWindows()

            SwingUtilities.invokeAndWait(CloseSecondaryWindows(cswResult))
            if not cswResult[0]: return False

            fCurrentFilePath = MD_REF.getCurrentAccountBook().getRootFolder()

            if not ManuallyCloseAndReloadDataset.manuallyCloseDataset(MD_REF.getCurrentAccountBook(), lKillAllSyncers=True, lCloseWindows=False, lKillAllFramesWithBookReferences=True):
                myPrint("B", "manuallyCloseDataset() returned False?")
                return False

            if debug: myPrint("B", getJVMUsageStatistics())
            myPrint("DB", "Calling garbage collection after releasing references...")
            System.gc()
            Thread.sleep(100)
            if debug: myPrint("B", getJVMUsageStatistics())

            ManuallyCloseAndReloadDataset.startBackgroundSyncing()

            newWrapper = AccountBookWrapper.wrapperForFolder(fCurrentFilePath)
            if newWrapper is None: raise Exception("ERROR: 'AccountBookWrapper.wrapperForFolder' returned None")
            myPrint("DB", "Successfully obtained 'wrapper' for dataset: %s\n" %(fCurrentFilePath.getCanonicalPath()))

            Syncer.DEBUG = True

            openResult = None                                                                                           # noqa
            try:
                # .setCurrentBook() always pushes mdGUI().dataFileOpened() on the EDT (if not already on the EDT)....
                myPrint("B", "Opening dataset: %s" %(fCurrentFilePath.getCanonicalPath()))
                openResult = MD_REF.setCurrentBook(newWrapper)
            except OutOfMemoryError:
                myPrint("B", "@@@ CRITICAL ERROR <<OUT OF MEMORY>> setCurrentBook() has crashed whilst (re)opening dataset!?")
                dump_sys_error_to_md_console_and_errorlog()
                myPrint("B", getJVMUsageStatistics())
                SwingUtilities.invokeAndWait(self.DisplayErrorMsg("TOOLBOX: OUT OF MEMORY whilst (re)opening dataset. WILL SHUT DOWN MD (review Console/errlog.txt)"))
                MD_REF.getUI().shutdownApp(False)
                return False
            except:
                myPrint("B", "@@@ CRITICAL ERROR - .setCurrentBook() has crashed whilst (re)opening dataset!?")
                dump_sys_error_to_md_console_and_errorlog()
                SwingUtilities.invokeAndWait(self.DisplayErrorMsg("TOOLBOX: ERROR: whilst (re)opening dataset.  WILL SHUT DOWN MD (review Console/errlog.txt)"))
                MD_REF.getUI().shutdownApp(False)
                return False

            if debug: myPrint("B", getJVMUsageStatistics())

            if not openResult or newWrapper.getBook() is None:
                txt = "Failed to open Dataset (wrong password?).... Will show the Welcome Window...."
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                WelcomeWindow.showWelcomeWindow(MD_REF.getUI())

                if self.lQuitThisAppToo:
                    # Remember... the file opened event closes my extensions with app listeners, so do this if file could not be opened....
                    if self.__class__.THIS_APPS_FRAME_REFERENCE is not None:
                        if isinstance(self.__class__.THIS_APPS_FRAME_REFERENCE, JFrame):
                            # Do this after .setCurrentBook() so-as not to co-modify listeners.....
                            SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.__class__.THIS_APPS_FRAME_REFERENCE))

                return False
            return True


    def isQER_running(): return find_feature_module(GlobalVars.Strings.EXTENSION_QER_ID)

    def isQuoteLoader_running():
        # type: () -> int
        """Returns None if not detected/loaded, 0=Detected and NOT busy, 1=Detected but needs manual checks, 2=Detected and is BUSY, 3=Detected, but reflection failed"""

        QL_ID_MIN_VER = 3047        # Mike Bray added special variables for Toolbox to check in QL build 3047

        QL_NOTFOUND = None; QL_NOTBUSY = 0; QL_TOOOLD = 1; QL_BUSY = 2; QL_ERROR = 3                                    # noqa

        foundQLfm = find_feature_module(GlobalVars.Strings.EXTENSION_QL_ID)
        if foundQLfm is None:
            myPrint("DB","QL NOT detected...")
            return QL_NOTFOUND

        if foundQLfm.getBuild() < QL_ID_MIN_VER:                                                                                        # noqa
            myPrint("DB","QL(%s) detected... (but too old for special reflection checks) User to check manually" %(foundQLfm.getBuild()))  # noqa
            return QL_TOOOLD

        try:
            myPrint("DB","Reflecting... Detecting QuoteLoader.....:")
            ql_isGUIOpen = getFieldByReflection(foundQLfm, "isGUIOpen")
            ql_isUpdating = getFieldByReflection(foundQLfm, "isUpdating")
            ql_isQuotesRunning = getFieldByReflection(foundQLfm, "isQuotesRunning")

            myPrint("DB","...QL isGUIOpen:       %s" %(ql_isGUIOpen))
            myPrint("DB","...QL isUpdating:      %s" %(ql_isUpdating))
            myPrint("DB","...QL isQuotesRunning: %s" %(ql_isQuotesRunning))

            if ql_isGUIOpen or ql_isUpdating or ql_isQuotesRunning:
                myPrint("DB",">> Detected QL appears to be BUSY...")
                return QL_BUSY

            myPrint("DB",">> QL was detected, but appears NOT busy")

        except:
            myPrint("DB","@@ QL detected but reflection check failed! (please contact Toolbox author)")
            dump_sys_error_to_md_console_and_errorlog()
            return QL_ERROR

        return QL_NOTBUSY

    def perform_qer_quote_loader_check(_frame, _txt, lDialogs=True):
        # type: (JFrame, str, bool) -> int
        """Checks for QER or QL extensions running, pops up a message if needed asking user to check. Response of True = SAFE"""

        resultQER = isQER_running()

        QL_NOTFOUND = None; QL_NOTBUSY = 0; QL_TOOOLD = 1; QL_BUSY = 2; QL_ERROR = 3                                    # noqa

        # Returns None if not detected/loaded, 0=Detected and NOT busy, 1=Detected but needs manual checks, 2=Detected and is BUSY, 3=Detected, but reflection failed"""
        resultQL = isQuoteLoader_running()

        lSafeToProceed = True
        if not resultQER and not resultQL:
            txt = "Q&ER / QuoteLoader are not detected/running - proceeding...."
            setDisplayStatus(txt, "B")
            return lSafeToProceed

        lSafeToProceed = False
        if not lDialogs: return lSafeToProceed

        QER_text = "Q&ER detected. " if (resultQER) else ""

        QL_text = "QL detected" if (resultQL) else ""
        if resultQL == QL_BUSY: QL_text += " and appears BUSY. "
        else: QL_text += ". "

        if not resultQER and resultQL == QL_BUSY:
            txt = "Sorry: QL appears busy (try again later)"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(_frame, txt, "Quote Loader detection", theMessageType=JOptionPane.WARNING_MESSAGE)
            return lSafeToProceed

        saveYES = UIManager.get("OptionPane.yesButtonText"); saveNO = UIManager.get("OptionPane.noButtonText")
        UIManager.put("OptionPane.yesButtonText", "OK - CONTINUE"); UIManager.put("OptionPane.noButtonText", "STOP - I NEED TO CHECK")
        ask = myPopupAskQuestion(_frame,"Q&ER / QUOTE LOADER DETECTION","%s%s Confirm that they're not updating before running '%s'?" %(QER_text, QL_text, _txt))
        UIManager.put("OptionPane.yesButtonText", saveYES); UIManager.put("OptionPane.noButtonText", saveNO)

        if not ask:
            txt = "Q&ER / QuoteLoader loaded (or busy). Please verify they're not updating before running '%s' - no changes made" %(_txt)
            setDisplayStatus(txt, "R")
            return lSafeToProceed

        txt = "User verified that Q&ER / QuoteLoader are not running - proceeding...."
        setDisplayStatus(txt, "B")

        lSafeToProceed = True
        return lSafeToProceed

    class MyJScrollPaneForJOptionPane(JScrollPane, HierarchyListener):   # Allows a scrollable/resizeable menu in JOptionPane
        def __init__(self, _component, _max_w=800, _max_h=600):
            super(JScrollPane, self).__init__(_component)
            self.maxWidth = _max_w
            self.maxHeight = _max_h
            self.borders = 90
            self.screenSize = Toolkit.getDefaultToolkit().getScreenSize()
            self.setOpaque(False)
            self.setViewportBorder(EmptyBorder(5, 5, 5, 5))
            self.addHierarchyListener(self)

        def getPreferredSize(self):
            frame_width = int(round((toolbox_frame_.getSize().width - self.borders) *.9,0))
            frame_height = int(round((toolbox_frame_.getSize().height - self.borders) *.9,0))
            return Dimension(min(self.maxWidth, frame_width), min(self.maxHeight, frame_height))

        def hierarchyChanged(self, e):
            if e: pass
            dialog = SwingUtilities.getWindowAncestor(self)
            if isinstance(dialog, Dialog):
                if not dialog.isResizable():
                    dialog.setResizable(True)

    def getTheSetting(what, _padLength=0):
        _x = MD_REF.getPreferences().getSetting(what, None)
        if not _x or _x == u"": return None
        if _padLength < 1: return u"%s: %s" %(what, _x)
        return u"%s%s" %(pad("%s:" %(what),_padLength), _x)

    def isPreviewBuild():
        if MD_EXTENSION_LOADER is not None:
            try:
                stream = MD_EXTENSION_LOADER.getResourceAsStream("/_PREVIEW_BUILD_")
                if stream is not None:
                    myPrint("B", "@@ PREVIEW BUILD (%s) DETECTED @@" %(version_build))
                    stream.close()
                    return True
            except: pass
        return False

    def isToolboxUnlocked(): return GlobalVars.TOOLBOX_UNLOCK

    def isMDPlusUniqueBankingServicesEnabledBuild(): return (float(MD_REF.getBuild()) >= MD_MDPLUS_TEST_UNIQUE_BANKING_SERVICES_BUILD)

    def isMDPlusGetPlaidClientEnabledBuild(): return (float(MD_REF.getBuild()) >= MD_MDPLUS_GETPLAIDCLIENT_BUILD)

    if isMDPlusEnabledBuild():
        from com.moneydance.apps.md.controller import MDPlus
        from com.infinitekind.moneydance.model import OnlineServiceLink

    if isMDPlusGetPlaidClientEnabledBuild():
        from com.infinitekind.moneydance.model import OnlineAccountMapping
        from com.moneydance.apps.md.controller.olb.plaid import PlaidConnection
        from com.plaid.client.request import ItemRemoveRequest

    def getMDPlusLicenseInfoForBook():
        _licenseObject = MD_REF.getCurrentAccountBook().getItemForID("tik.mdplus-license")	    # type: MoneydanceSyncableItem
        return _licenseObject

    def getMDPlusPlaidSettings():
        _plaidSettings = MD_REF.getCurrentAccountBook().getItemForID(GlobalVars.Strings.MD_PLAID_SETTINGS_OBJ_ID)	    # type: MoneydanceSyncableItem
        return _plaidSettings

    def isMDPlusLicenseActivated():
        if isMDPlusEnabledBuild():
            _licenseObject = getMDPlusLicenseInfoForBook()
            if _licenseObject is not None:
                mdplus_email = _licenseObject.getParameter("mdplus.account_email", None)
                mdplus_signup_status = _licenseObject.getParameter("signup_status", None)

                # noinspection PyUnresolvedReferences
                if (mdplus_email and len(mdplus_email) > 0
                        and mdplus_signup_status and mdplus_signup_status.lower() == "activated"):
                    return True
        return False

    def getFileFromAppleScriptFileChooser(fileChooser_parent,                  # The Parent Frame, or None
                                          fileChooser_starting_dir,            # The Starting Dir
                                          fileChooser_filename,                # Default filename (or None)
                                          fileChooser_title,                   # The Title (with FileDialog, only works on SAVE)
                                          fileChooser_multiMode,               # Normally False (True has not been coded!)
                                          fileChooser_open,                    # True for Open/Load, False for Save
                                          fileChooser_selectFiles,             # True for files, False for Directories
                                          fileChooser_OK_text,                 # Normally None, unless set - use text
                                          fileChooser_fileFilterText=None,     # E.g. "txt" or "qif"
                                          lForceJFC=False,
                                          lForceFD=False,
                                          lAllowTraversePackages=None,
                                          lAllowTraverseApplications=None,     # JFileChooser only..
                                          lAllowNewFolderButton=True,          # JFileChooser only..
                                          lAllowOptionsButton=None):           # JFileChooser only..
        # type: (JFrame, str, str, str, bool, bool, bool, str, str, bool, bool, bool, bool, bool, bool) -> str
        """If on a Mac and AppleScript exists then will attempt to load AppleScript file/folder chooser, else calls getFileFromFileChooser() which loads JFileChooser() or FileDialog() accordingly"""

        if not Platform.isOSX() or not File("/usr/bin/osascript").exists() or not isOSXVersionBigSurOrLater():
            return getFileFromFileChooser(fileChooser_parent,
                                          fileChooser_starting_dir,
                                          fileChooser_filename,
                                          fileChooser_title,
                                          fileChooser_multiMode,
                                          fileChooser_open,
                                          fileChooser_selectFiles,
                                          fileChooser_OK_text,
                                          fileChooser_fileFilterText,
                                          lForceJFC, lForceFD,
                                          lAllowTraversePackages, lAllowTraverseApplications,
                                          lAllowNewFolderButton, lAllowOptionsButton)

        myPrint("B", "Mac: switching to AppleScript for folder/file selector..:")

        _TRUE = "true"; _FALSE = "false"
        appleScript = "/usr/bin/osascript"

        lAllowInvisibles = False
        multipleSelectionsAllowed = _TRUE if fileChooser_multiMode else _FALSE
        showPackageContents = _TRUE if lAllowTraversePackages else _FALSE
        showInvisibles = _TRUE if lAllowInvisibles else _FALSE

        cmdTitle = ""
        cmdDefaultPath = ""
        cmdExtension = ""
        cmdInvisibles = ""
        cmdMultipleSelections = ""
        cmdShowPackageContents = ""
        cmdNewName = ""

        cmdChooseWhat = "file " if fileChooser_selectFiles else "folder "

        if fileChooser_title is not None and isinstance(fileChooser_title, basestring) and len(fileChooser_title) > 0:
            cmdTitle = "with prompt \"%s\" " %(fileChooser_title)

        lRequestingNewName = (not fileChooser_open and fileChooser_selectFiles)
        if lRequestingNewName:
            cmdChooseWhat = "file name "
            if fileChooser_filename is not None and isinstance(fileChooser_filename, basestring) and len(fileChooser_filename) > 0:
                cmdNewName = "default name \"%s\" " %(fileChooser_filename)
        else:
            if (fileChooser_fileFilterText is not None and fileChooser_selectFiles):
                cmdExtension = "of type {\"%s\"} " %(fileChooser_fileFilterText)
            cmdInvisibles = "invisibles %s " %(showInvisibles)
            cmdMultipleSelections = "multiple selections allowed %s " %(multipleSelectionsAllowed)
            cmdShowPackageContents = "showing package contents %s " %(showPackageContents)

        if File(fileChooser_starting_dir).exists():
            cmdDefaultPath = "default location (POSIX file \"%s\") " %(fileChooser_starting_dir)

        cmdStr = ["%s" %(appleScript),
                 "-e",
                 "return POSIX path of (choose %s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                    "%s"
                  ")"
                  %(cmdChooseWhat, cmdTitle, cmdExtension, cmdNewName, cmdDefaultPath, cmdInvisibles, cmdMultipleSelections, cmdShowPackageContents),
                ]

        try:
            myPrint("DB", "AppleScript Command: '%s'" %(cmdStr))

            process = None
            exec("process = Runtime.getRuntime().exec(cmdStr)")         # Use exec to avoid Intellij [invalid] code error
            if isinstance(process, Process): pass
            result = process.waitFor()
            err = BufferedReader(InputStreamReader(process.getErrorStream())).readLine()
            if err is not None and isinstance(err, basestring) and ("user cancelled" in err.lower() or "(-128)" in err):
                myPrint("DB", "** AppleScript: USER CANCELLED FILE SELECTION ** ")
                return None
            if result != 0:
                myPrint("B", "ERROR: AppleScript returned error:", result, err)
                return None
            _theFile = BufferedReader(InputStreamReader(process.getInputStream())).readLine()
            myPrint("DB", "AppleScript - User selected file:", _theFile, "Exists:", File(_theFile).exists())
            return _theFile

        except:
            myPrint("B", "ERROR: getFileFromAppleScriptFileChooser() has crashed?!")
            dump_sys_error_to_md_console_and_errorlog()
            return None

    def calculateMoneydanceDatasetSize(_lReturnMBs=False, whichBook=None):
        """Calculates and returns the size of the Moneydance dataset in bytes (or MBs when _lReturnMBs=True), and file count"""

        if whichBook is None or not isinstance(whichBook, AccountBook):
            book = MD_REF.getCurrentAccount().getBook()
        else:
            book = whichBook

        total_size_MBs = 0.0
        count_files = total_size = 0

        try:
            startDir = book.getRootFolder().getCanonicalPath()

            for path, dirs, files in os.walk(startDir):
                for f in files:
                    fp = os.path.join(path, f)
                    count_files += 1
                    total_size += os.path.getsize(fp)

            if total_size > 0: total_size_MBs = convertBytesMBs(total_size)

        except:
            myPrint("B", "ERROR: Crashed whilst calculating dataset size?!")
            dump_sys_error_to_md_console_and_errorlog()
            return (0.0,0)

        myPrint("DB", "Calculated dataset size as %s bytes, %sMBs (containing: %s files)" %(total_size, total_size_MBs, count_files))

        if _lReturnMBs: return (total_size_MBs, count_files)
        return (total_size, count_files)

    def removeEmptyDirs(_pathToSearch):
        """Given a valid path, this method searches for and then removes all empty sub-directories"""

        # Failsafe checks....
        if not isinstance(_pathToSearch, (unicode, str)):   return False
        if _pathToSearch is None:                           return False
        if not os.path.exists(_pathToSearch):               return False
        if not os.path.isdir(_pathToSearch):                return False
        if len(_pathToSearch) < len(".moneydance"):         return False

        lOK = True
        countDeleted = 0
        storeEmptyDirs = []
        try:
            for root, dirs, files in os.walk(_pathToSearch, topdown=False):
                for name in dirs:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp): continue
                    if not os.path.isdir(fp): continue
                    if len(os.listdir(fp)) < 1: storeEmptyDirs.append(fp)

            myPrint("DB", "removeEmptyDirs(%s) Found %s empty directories" %(_pathToSearch, len(storeEmptyDirs)))
            for f in storeEmptyDirs:
                try:
                    os.removedirs(f)    # This actually deletes up the tree until a non empty dir is found..... (I hope..)
                    myPrint("DB", ".. removed structure for: %s" %(f))
                    countDeleted += 1
                except:
                    lOK = False
                    myPrint("B", ".. ERROR removing structure for: %s" %(f))
        except:
            lOK = False
            myPrint("B","ERROR: removeEmptyDirs(%s) crashed" %(_pathToSearch))
            dump_sys_error_to_md_console_and_errorlog()

        if not lOK: myPrint("B","ERROR: 1 or more directory structures could not be removed...")
        myPrint("B","%s: %s directory structures sucessfully deleted" %(_pathToSearch, countDeleted))
        return lOK

    def is_file_older_than_x_days(_file, _days=1):
        file_time = os.path.getmtime(_file) 	# Check against 24 hours
        if ((time.time() - file_time) / 3600) > (24 * _days):
            return True
        return False

    # noinspection PyBroadException
    def downloadStuWareSoftSystemsExtensions( what ):

        myPrint("B","#########################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to the master Toolbox code repository to check if an updated version is available - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","#########################################################################################################################################################")

        dictInfo = StreamTable()

        inx = None
        theDict = "https://raw.githubusercontent.com/yogi1967/MoneydancePythonScripts/master/source/%s/meta_info.dict" %what

        try:
            myPrint("DB","About to open url: %s" %theDict)
            urlDict = URL(theDict)
            inx = BufferedReader(InputStreamReader(urlDict.openStream(), "UTF8"))
            dictInfo.readFrom(inx)
        except:
            myPrint("J","")
            myPrint("B", "ERROR downloading meta-info.dict from GitHub... ")
            if debug: dump_sys_error_to_md_console_and_errorlog()
            return False

        finally:
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing URL stream (%s)" %theDict)
                    dump_sys_error_to_md_console_and_errorlog()

        return dictInfo

    def detect_broken_critical_javaio_temp_dir_OK():
        KEY = "java.io.tmpdir"                                                                                          # noqa
        javaTmpDir = System.getProperty(KEY)
        if javaTmpDir is None or javaTmpDir == "":
            myPrint("B","'%s' property missing!?" %(KEY))
            return False
        tmpDir = File(javaTmpDir)
        try:
            f = File.createTempFile("TOOLBOX-TEST-TEMP_DIR", str(System.currentTimeMillis() % 10000L), tmpDir)
            f.delete()
            myPrint("DB","Successfully created temp file in '%s':" %(KEY), f.getCanonicalPath())

        except IOException as e:
            myPrint("B","ERROR with property '%s' - Could not create file in temp dir:" %(KEY), tmpDir.getCanonicalPath(), "Message:", e.getMessage())
            return False

        except:
            myPrint("B","ERROR with property '%s' - Could not create file in temp dir:" %(KEY), tmpDir.getCanonicalPath())
            dump_sys_error_to_md_console_and_errorlog()
            return False

        return True

    def return_critical_javaio_temp_dir_msg():
        KEY = "java.io.tmpdir"                                                                                          # noqa
        javaTmpDir = System.getProperty(KEY)

        if detect_broken_critical_javaio_temp_dir_OK():
            if debug:
                rtnMsg = u"\nImportant java temp folder looks OK ('%s' = '%s')\n" %(KEY, javaTmpDir)
            else:
                rtnMsg = u""
        else:
            rtnMsg = u"\n** ERROR >> Problem with important java temp folder - review console\n" \
                     u"('%s' = '%s')\n" %(KEY, javaTmpDir)
        return rtnMsg

    class DetectAndChangeMacTabbingMode(AbstractAction):

        def __init__(self, lQuickCheckOnly):
            self.lQuickCheckOnly = lQuickCheckOnly

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            if not Platform.isOSX():
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - This can only be run on a Mac!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not isOSXVersionBigSurOrLater():
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - You are not running Big Sur - no changes made!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if (float(MD_REF.getBuild()) > 1929 and float(MD_REF.getBuild()) < 2008):                                         # noqa
                txt = "You are running 2021.build %s - This version has problems with DUAL MONITORS - Upgrade to at least 2021. build 2012: https://infinitekind.com/preview" %(MD_REF.getBuild())
                setDisplayStatus(txt, "R")
                txt = "Change Mac Tabbing Mode - You are running 2021.build %s - This version has problems with DUAL MONITORS\nPlease upgrade to at least 2021. build 2012:\nhttps://infinitekind.com/preview" %(MD_REF.getBuild())
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            prefFile = os.path.join(System.getProperty("UserHome", "Library/Preferences/.GlobalPreferences.plist"))
            if not os.path.exists(prefFile):
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - Sorry - For some reason I could not find: %s - no changes made!" %(prefFile)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            try:
                tabbingMode = subprocess.check_output("defaults read -g AppleWindowTabbingMode", shell=True)
            except:
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - Sorry - error getting your Tabbing mode! - no changes made!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                dump_sys_error_to_md_console_and_errorlog()
                return

            tabbingMode=tabbingMode.strip().lower()
            if not (tabbingMode == "fullscreen" or tabbingMode == "manual" or tabbingMode == "always"):
                if self.lQuickCheckOnly: return True
                txt = "Change Mac Tabbing Mode - Sorry - I don't understand your tabbing mode: %s - no changes made!" %(tabbingMode)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if tabbingMode == "fullscreen" or tabbingMode == "manual":
                if self.lQuickCheckOnly:
                    myPrint("J","Quick check of MacOS tabbing showed it's OK and set to: %s" %tabbingMode)
                    return True
                txt = "Change Mac Tabbing Mode - NO PROBLEM FOUND - Your tabbing mode is: %s - no changes made!" %(tabbingMode)
                setDisplayStatus(txt, "B")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt)
                return

            if self.lQuickCheckOnly:
                myPrint("J","Quick check of MacOS tabbing showed it's NEEDS CHANGING >> It's set to: %s" %tabbingMode)
                return False

            myPrint("B","More information here: https://support.apple.com/en-gb/guide/mac-help/mchla4695cce/mac")

            myPrint("B", "@@@ PROBLEM - Your Tabbing Mode is set to: %s - NEEDS CHANGING" %tabbingMode)
            myPopupInformationBox(toolbox_frame_,"@@@ PROBLEM - Your Tabbing Mode is set to: %s\nTHIS NEEDS CHANGING!" %tabbingMode,theMessageType=JOptionPane.ERROR_MESSAGE)
            myPopupInformationBox(toolbox_frame_,"Info:\n<https://support.apple.com/en-gb/guide/mac-help/mchla4695cce/mac>\nPress OK to select new mode...",theMessageType=JOptionPane.ERROR_MESSAGE)

            mode_options = ["fullscreen", "manual"]
            selectedMode = JOptionPane.showInputDialog(toolbox_frame_,
                                                        "TABBING MODE", "Select the new Tabbing Mode?",
                                                        JOptionPane.WARNING_MESSAGE,
                                                        getMDIcon(lAlwaysGetIcon=True),
                                                        mode_options,
                                                        None)
            if selectedMode is None:
                txt = "Change Mac Tabbing Mode - No new Tabbing Mode was selected - aborting.."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt)
                return

            if not doesUserAcceptDisclaimer(toolbox_frame_, "TABBING MODE", "Are you really sure you want to change MacOS system setting>>Tabbing Mode?"):
                txt = "Change Mac Tabbing Mode - User declined the disclaimer - no changes made...."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            try:
                tabbingModeChanged = subprocess.check_output('defaults write -g AppleWindowTabbingMode -string "%s"' %selectedMode, shell=True)
                if tabbingModeChanged.strip() != "":
                    myPrint("B", "Tabbing mode change output>>>>")
                    myPrint("B", tabbingModeChanged)
                myPrint("B","!!! Your tabbing mode has been changed to %s - MONEYDANCE WILL NOW RESTART" %selectedMode)
            except:
                txt = "Change Mac Tabbing Mode - Sorry - error setting your Tabbing mode! - no changes made!"
                myPrint("B", txt)
                dump_sys_error_to_md_console_and_errorlog()
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if tabbingModeChanged.strip() != "":
                myPopupInformationBox(toolbox_frame_,"Change Mac Tabbing Mode: Response: %s" %tabbingModeChanged, JOptionPane.WARNING_MESSAGE)

            txt = "MacOS Tabbing Mode: OK I Made the Change to your Mac Tabbing Mode: MONEYDANCE WILL NOW RESTART"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    class MyPopupRegister(SecondaryDialog):

        class MyTxnRegisterType(TxnRegisterType):
            def __init__(self, mdGUI, editableRegister=False, showCashBalance=False):
                self.editableRegister = editableRegister
                self.showCashBalance = showCashBalance
                super(self.__class__, self).__init__(mdGUI)
            def isEditable(self): return self.editableRegister
            def getNumColumns(self):
                defaultCols = super(self.__class__, self).getNumColumns()
                if not self.showCashBalance: defaultCols -= 1
                return defaultCols

        class MyInvestRegisterType(InvestRegisterType):
            def __init__(self, mdGUI, editableRegister=False, showCashBalance=False):
                self.editableRegister = editableRegister
                self.showCashBalance = showCashBalance
                self.cashColumn = 8
                super(self.__class__, self).__init__(mdGUI)
            def isEditable(self): return self.editableRegister
            def getPreferredFieldWidth(self, info, col):
                if not self.showCashBalance and col == self.cashColumn: return 0
                return super(self.__class__, self).getPreferredFieldWidth(info, col)
            def getColMinWidth(self, info, col):
                if not self.showCashBalance and col == self.cashColumn: return 0
                return super(self.__class__, self).getColMinWidth(info, col)
            def getColPreferredWidth(self, info, col):
                if not self.showCashBalance and col == self.cashColumn: return 0
                return super(self.__class__, self).getColPreferredWidth(info, col)

        def __init__(self, title, registerType, txnSearchFilter, parent=None, editableRegister=False, showCashBalance=False, modal=True, singleLineMode=False, escapeCancels=True):
            # type: (str, type, TxnSearch, JComponent, bool, bool, bool, bool, bool) -> None
            mdGUI = MD_REF.getUI()
            title += " >> EDITING ENABLED - BE CAREFUL! <<" if editableRegister else " -- READONLY MODE --"
            super(self.__class__, self).__init__(mdGUI, parent, title, modal)
            self.setEscapeKeyCancels(escapeCancels)
            book = MD_REF.getCurrentAccountBook()

            if registerType == InvestRegisterType:
                txnRegister = TxnRegister(mdGUI, book, MyPopupRegister.MyInvestRegisterType(mdGUI, editableRegister=editableRegister, showCashBalance=showCashBalance))
            else:
                if registerType != TxnRegisterType:
                    myPrint("B", "@@ ERROR: MyPopupRegister() registerType incorrect:", registerType, ">> Defaulting to TxnRegisterType @@")
                txnRegister = TxnRegister(mdGUI, book, MyPopupRegister.MyTxnRegisterType(mdGUI, editableRegister=editableRegister, showCashBalance=showCashBalance))

            txnRegister.setDetailPanels([TxnDetailsPanel(mdGUI, txnRegister)])
            txnRegister.setSingleLineMode(singleLineMode)
            txnResultSet = SearchRegTxnListModel(book, txnSearchFilter, TxnSortOrder.DATE)
            txnRegister.setTxnModel(txnResultSet)
            self.add(txnRegister)

        def setEscapeKeyCancels(self, escapeKeyCancels):
            try: super(self.__class__, self).setEscapeKeyCancels(escapeKeyCancels)
            except:
                # This was a new method in a recent build....
                if escapeKeyCancels:
                    self.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "close_window")
                else:
                    self.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).remove(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0))

    class DetectInvalidWindowLocations(AbstractAction):

        def __init__(self, lQuickCheckOnly):
            self.lQuickCheckOnly = lQuickCheckOnly

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            _THIS_METHOD_NAME = "Detect invalid window locations/sizes".upper()

            virtualBounds = Rectangle(0, 0, 0, 0)
            ge = GraphicsEnvironment.getLocalGraphicsEnvironment()  # type: GraphicsEnvironment
            lstGDs = ge.getScreenDevices()                          # type: [GraphicsDevice]
            for gd in lstGDs:
                print gd, gd.getDefaultConfiguration(), gd.getDefaultConfiguration().getBounds()
                virtualBounds.add(gd.getDefaultConfiguration().getBounds())

            output = "%s:\n" \
                     "---------------------------------\n" %(_THIS_METHOD_NAME)

            txt = "*** Found: %s screens, with Virtual Bounds of: %s" %(len(lstGDs), virtualBounds)

            output += "%s\n\n" %(txt)
            myPrint("DB", txt)

            prefs = MD_REF.getPreferences()

            invalidLocns = []
            invalidSizes = []

            prefSt, prefKeys = read_preferences_file(True)
            for theKey in prefKeys:
                value = prefSt.get(theKey)
                if not check_for_window_display_data(theKey, value): continue
                lFoundLocation = check_for_just_locations_window_display_data(theKey, value)
                lFoundSize = check_for_just_sizes_window_display_data(theKey, value)
                if lFoundLocation:
                    livePrefValue = prefs.getXYSetting(theKey, 0, 0)
                    if livePrefValue.x == 0 and livePrefValue.y == 0: continue
                    if ((livePrefValue.x > virtualBounds.width or livePrefValue.y > virtualBounds.height)
                            or (livePrefValue.x < virtualBounds.x or livePrefValue.y < virtualBounds.y)):
                        invalidLocns.append(theKey)
                        txt = "Found INVALID location outside current virtual bounds: %s (%s)" %(theKey, livePrefValue)
                        output += "%s\n" %(txt)
                        myPrint("B", txt)
                    continue

                if lFoundSize:
                    livePrefValue = prefs.getSizeSetting(theKey, 0, 0)
                    if livePrefValue.width > 100 and livePrefValue.height > 50: continue
                    invalidSizes.append(theKey)
                    txt = "Found INVALID size (too small): %s (%s)" %(theKey, livePrefValue)
                    output += "%s\n" %(txt)
                    myPrint("B", txt)
                    continue

            output += "\n"

            if self.lQuickCheckOnly:
                if invalidLocns:
                    myPrint("B","*** %s invalid saved window location(s) detected (use 'UPDATE MODE' to zap these)...." %(len(invalidLocns)))
                else:
                    myPrint("B","No invalid saved window locations detected....")

                if invalidSizes:
                    myPrint("B","*** %s invalid saved window size(s) detected (use 'UPDATE MODE' to zap these)...." %(len(invalidSizes)))
                else:
                    myPrint("B","No invalid saved window sizes detected....")
                return (invalidLocns or invalidSizes)

            if not invalidLocns and not invalidSizes:
                output += "NO INVALID LOCATIONS / SIZES DETECTED - no changes made\n<END>\n"
                QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
                return False

            output += "ALERT: %s invalid saved window location(s) / size(s) detected\n\n" %(len(invalidLocns) + len(invalidSizes))
            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True, lAlertLevel=1).show_the_frame()

            if not GlobalVars.i_am_an_extension_so_run_headless:
                myPopupInformationBox(jif, "PLEASE RUN THIS AS AN EXTENSION TO PROCEED", _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
                return

            ask = MyPopUpDialogBox(jif,
                                   theStatus="%s invalid saved window location(s) / size(s) detected!" %(len(invalidLocns) + len(invalidSizes)),
                                   theMessage=output,
                                   theTitle=_THIS_METHOD_NAME,
                                   lAlertLevel=1,
                                   lCancelButton=True,
                                   OKButtonText="ZAP INVALID LOCATIONS")
            if not ask.go():
                txt = "%s: User declined to zap invalid saved window location(s) / size(s) - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                return

            if not doesUserAcceptDisclaimer(jif, _THIS_METHOD_NAME, "Are you really sure you want to zap %s invalid saved window location(s)/size(s)?" %(len(invalidLocns) + len(invalidSizes))):
                txt = "%s: User declined the disclaimer - no changes made...." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not backup_config_dict():
                txt = "%s: ERROR making backup of config.dict - no changes made!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            jif.dispose()
            output += "User accepted disclaimer and is proceeding with zap of invalid window locations/sizes...\n\n"

            lAddMainWindowKeysToo = False
            invalidKeysToZap = StreamVector()
            if isinstance(invalidKeysToZap, Vector): pass
            for sizes_locations in [invalidSizes, invalidLocns]:
                for zapKey in sizes_locations:
                    invalidKeysToZap.add(zapKey)
                    if "mainwindow" in zapKey: lAddMainWindowKeysToo = True

            if lAddMainWindowKeysToo:
                for zapThisToo in ["gui.is_maximized-mainwindow", "gui.source_list_width+mainwindow", "gui.winloc-mainwindow", "gui.winsize-mainwindow"]:
                    invalidKeysToZap.add(zapThisToo)

            MD_REF.getPreferences().setSetting(GlobalVars.Strings.TOOLBOX_PREFERENCES_ZAPPER, invalidKeysToZap)

            ##### FORCE CLOSE ALL WINDOWS SO THEY DO NOT SAVE THEIR SETTINGS AFTER TOOLBOX CHANGES #####################
            # try:
            #     forceCloseMoneydanceWindows()
            # except:
            #     dump_sys_error_to_md_console_and_errorlog()
            #     myPopupInformationBox(toolbox_frame_, "ERROR: forceCloseMoneydanceWindows() crashed (will continue anyway)", _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
            #
            # for sizes_locations in [invalidSizes, invalidLocns]:
            #     for locSizeKey in list(sizes_locations):
            #         output += "Zapping: %s\n" %(locSizeKey)
            #         myPrint("B", "Zapping: %s\n" %(locSizeKey))
            #         MD_REF.getPreferences().setSetting(locSizeKey, None)
            #
            # MD_REF.savePreferences()    # save config.dict

            txt = "%s: %s invalid saved window location(s) / size(s) zapped.... MONEYDANCE WILL EXIT - PLEASE RESTART MD" %(_THIS_METHOD_NAME, len(invalidLocns) + len(invalidSizes))
            output += "\n\n%s\n<END>" %(txt)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            play_the_money_sound()
            MyPopUpDialogBox(toolbox_frame_, txt, output, theTitle="INVALID LOCATION(S)/SIZE(S) ZAPPED", lAlertLevel=1).go()

            myPrint("B","Requesting Moneydance shuts down now...")
            ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False, lAllowSaveWorkspace=False)

    def find_other_datasets():
        output = ""
        output+=("\nQUICK SEARCH FOR OTHER DATASETS:\n"
                 "---------------------------------\n")

        try:
            md_extn = ".moneydance"
            md_archive = ".moneydancearchive"

            saveFiles = {}
            saveArchiveFiles = {}

            myDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

            errorDirs = []

            internalDir = Common.getDocumentsDirectory().getCanonicalPath()
            try:
                dirList =  os.listdir(internalDir)
                for fileName in dirList:
                    fullPath = os.path.join(internalDir,fileName)
                    if fileName.endswith(md_extn):
                        saveFiles[fullPath] = True
                    elif fileName.endswith(md_archive):
                        saveArchiveFiles[fullPath] = True
                del dirList
            except OSError:
                myPrint("B","@@ Error accessing internalDir: '%s' - skipping...." %(internalDir))
                errorDirs.append(internalDir)

            parentofDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getParent()
            if os.path.exists(parentofDataset):
                try:
                    dirList =  os.listdir(parentofDataset)
                    for fileName in dirList:
                        fullPath = os.path.join(parentofDataset,fileName)
                        if fileName.endswith(md_extn):
                            saveFiles[fullPath] = True
                        elif fileName.endswith(md_archive):
                            saveArchiveFiles[fullPath] = True
                    del dirList
                except OSError:
                    myPrint("B","@@ Error accessing dataset's folder: '%s' - skipping...." %(parentofDataset))
                    errorDirs.append(parentofDataset)
            del parentofDataset

            externalFiles = AccountBookUtil.getExternalAccountBooks()
            for wrapper in externalFiles:
                saveFiles[wrapper.getBook().getRootFolder().getCanonicalPath()] = True
                externalDir = wrapper.getBook().getRootFolder().getParent()
                if os.path.exists(externalDir):
                    try:
                        dirList =  os.listdir(externalDir)
                        for fileName in dirList:
                            fullPath = os.path.join(externalDir,fileName)
                            if fileName.endswith(md_extn):
                                saveFiles[fullPath] = True
                            elif fileName.endswith(md_archive):
                                saveArchiveFiles[fullPath] = True
                        del dirList
                    except OSError:
                        myPrint("B","@@ Error accessing externalDir: '%s' - skipping...." %(externalDir))
                        errorDirs.append(externalDir)

            del externalFiles

            for backupLocation in [ FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath(),
                                    MD_REF.getUI().getPreferences().getSetting("backup.location",""),
                                    MD_REF.getUI().getPreferences().getSetting("backup.last_saved",""),
                                    MD_REF.getUI().getPreferences().getSetting("backup.last_browsed","")]:
                if backupLocation is not None and backupLocation != "" and os.path.exists(backupLocation):
                    try:
                        dirList =  os.listdir(backupLocation)
                        for fileName in dirList:
                            fullPath = os.path.join(backupLocation,fileName)
                            if fileName.endswith(md_extn):
                                if saveFiles.get(fileName) is not None:
                                    saveFiles[fullPath] = True
                            elif fileName.endswith(md_archive):
                                saveArchiveFiles[fullPath] = True
                        del dirList
                    except OSError:
                        myPrint("B","@@ Error accessing backupLocationDir: '%s' - skipping...." %(backupLocation))
                        errorDirs.append(backupLocation)
            del backupLocation

            saveFiles[myDataset] = None

            listTheFiles=sorted(saveFiles.keys())
            listTheArchiveFiles=sorted(saveArchiveFiles.keys())

            for _f in listTheFiles:
                if saveFiles[_f] is not None:
                    output+=("Dataset: Mod: %s %s\n"
                             % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(_f)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), _f))
            del listTheFiles

            output+=("\nBACKUP FILES\n"
                     "-------------\n")

            for _f in listTheArchiveFiles:
                if saveArchiveFiles[_f] is not None:
                    output+=("Archive: Mod: %s %s\n"
                             % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(_f)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), _f))
            del listTheArchiveFiles

            output+=("\nSYNC FOLDERS FOUND:\n"
                     "---------------------\n")

            saveSyncFolder=None
            try:
                # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
                # Also, MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
                syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
                syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

                if syncMethod is not None and syncMethod.getSyncFolder() is not None:
                    # noinspection PyUnresolvedReferences
                    syncBaseFolder = syncMethod.getSyncFolder().getSyncBaseFolder()

                    saveSyncFolder = syncBaseFolder.getCanonicalPath()
                    dirList =  os.listdir(saveSyncFolder)

                    for fileName in dirList:
                        fullPath = os.path.join(saveSyncFolder,fileName)
                        if len(fileName)>32:
                            output+=("Sync Folder: %s %s\n"
                                     % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(fullPath)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), fullPath))
                else:
                    output+=("<NONE FOUND>\n")

                del syncMethod, syncMethods
            except:
                pass

            dropboxPath = tell_me_if_dropbox_folder_exists()
            if dropboxPath and dropboxPath is not None and dropboxPath != saveSyncFolder:

                output+=("\nDROPBOX FOLDERS FOUND:\n"
                         "-----------------------\n")
                dirList =  os.listdir(dropboxPath)

                for fileName in dirList:
                    fullPath = os.path.join(dropboxPath,fileName)
                    if len(fileName)>32:
                        output+=("Dropbox Sync Folder: %s %s\n"
                                 % (pad(datetime.datetime.fromtimestamp(os.path.getmtime(fullPath)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)), 11), fullPath))
            del dropboxPath

            if len(errorDirs) > 0:
                output += ("\nERROR ACCESSING DIRECTORY:\n"
                           "---------------------------\n")
                for errorDir in errorDirs: output += (" @@ %s\n" %(errorDir))

            output+="\n\n(for a more extensive search please use Toolbox - Find my Datasets and Backups button\n\n"

        except:
            myPrint("B","@@ ERROR: Failed in find_other_datasets()?")
            output += dump_sys_error_to_md_console_and_errorlog(lReturnText=True)

        return output

    def count_database_objects(whichBook=None):
        # type: (AccountBook) -> str
        """Analyses the objects contained in the specified AccountBook. Returns a printable string"""

        if whichBook is None or not isinstance(whichBook, AccountBook):
            book = MD_REF.getCurrentAccount().getBook()
        else:
            book = whichBook
        if book is None: return "<NO ACCOUNT BOOK SPECIFIED OR FOUND>"

        output = ""
        output+=("\nDATABASE OBJECT COUNT        (count) (est.size KBs): %s\n"
                 "------------------------------------------------------\n" %("" if whichBook is None else "(Book: "+book.getName()+"):"))
        foundStrange=0
        types={}

        onlineTxns=0
        onlineTxnsCharacters=0
        onlinePayees=0
        onlinePayments=0

        if book.getSyncer() is None or book.getSyncer().getSyncedDocument() is None:
            output += "\n** WARNING: Book's getSyncer() or getSyncedDocument() was None **\n"
            return output

        for mdItem in book.getSyncer().getSyncedDocument().allItems():
            if isinstance(mdItem, MoneydanceSyncableItem):

                if isinstance(mdItem, OnlineTxnList):
                    onlineTxns +=mdItem.getTxnCount()
                    for olKey in mdItem.getParameterKeys():
                        onlineTxnsCharacters += len(olKey)
                        onlineTxnsCharacters += len(mdItem.getParameter(olKey))

                if isinstance(mdItem, OnlinePayeeList):     onlinePayees    += mdItem.getPayeeCount()
                if isinstance(mdItem, OnlinePaymentList):   onlinePayments  += mdItem.getPaymentCount()

                getTheSavedData = types.get(mdItem.getParameter("obj_type", "UNKNOWN"))
                if getTheSavedData is not None:
                    x,theLength = getTheSavedData
                else:
                    x = 0
                    theLength = 0

                theSyncInfo = mdItem.getSyncInfo()
                theDescription = theSyncInfo.toMultilineHumanReadableString()  # format is "key: data\n" but file is '&key=data'
                theLength += len( ("mod.%s:" %(mdItem.getParameter("obj_type",""))) )
                theLength += len(theDescription)
                theLength -= len(mdItem.getParameterKeys())  # remove the number of "\n"s

                types[mdItem.getParameter("obj_type", "UNKNOWN")] = [x+1, theLength]
            else:
                foundStrange += 1
        i = 0
        charCount = 0
        for x in types.keys():
            i += types[x][0]
            charCount += types[x][1]
            extraText = ""
            if x == "oltxns":
                if onlineTxns:
                    extraText = "(containing %s Online Txns consuming %s KBs)" %(onlineTxns, round(onlineTxnsCharacters/1000.0,1))
            elif x == "olpayees":
                if onlinePayees:
                    extraText = "(containing %s Online Payees)" %(onlinePayees)
            elif x == "olpmts":
                if onlinePayments:
                    extraText = "(containing %s Online Payments)" %(onlinePayments)

            output += ("Object: %s %s   %s %s\n" %(pad(x,15),rpad(types[x][0],12),rpad(round(types[x][1] / (1000.0),1),12), extraText))

        if foundStrange:
            output += ("\n@@ I also found %s non Moneydance Syncable Items?! Why? @@\n" %(foundStrange))

        output += (" ==========\n TOTAL:                 %s   %s\n\n" %(rpad(i,12),rpad(round(charCount/(1000.0),1),12)))
        return output

    def getShouldDownloadAllAttachments():
        return MD_REF.getCurrentAccountBook().getLocalStorage().getBoolean("netsync.download_attachments", True)

    def buildDiagText():

        textArray = []                                                                                                  # noqa

        if isPreviewBuild(): textArray.append(u"*** PREVIEW BUILD (%s) DETECTED ***\n" %(version_build))

        x = getMonoFont()
        textArray.append(u"FONT USED FOR TOOLBOX OUTPUT/DISPLAY(can be changed): %s(%s)" %(x.getFontName(), x.getSize()))
        try:
            loc = MD_REF.getUI().getPreferences().getLocale()
            if loc is not None and \
                    (loc.getLanguage() in (loc.CHINESE.getLanguage(), loc.JAPANESE.getLanguage(), loc.KOREAN.getLanguage(), loc.SIMPLIFIED_CHINESE.getLanguage(), loc.TRADITIONAL_CHINESE.getLanguage())
                     or loc.getCountry() in (loc.CHINA.getCountry(), loc.JAPAN.getCountry(), loc.KOREA.getCountry(), loc.TAIWAN.getCountry()) ):
                textArray.append(u"** if Toolbox display/outputs do not show your language's double-byte characters properly, then change to a Monospaced Font that supports your character set **")
                textArray.append(u"** (Update Mode) General Tools, Set MD Fonts: Change 'code' Font (please only use Monospaced fonts for text alignment!) **")
        except:
            myPrint("B",u"@@ ERROR: Failed to detect MD Locale..?")
            dump_sys_error_to_md_console_and_errorlog()

        textArray.append(return_critical_javaio_temp_dir_msg())

        textArray.append(u"Moneydance Version / Build:          %s" %(MD_REF.getVersion()) + u"  Build: %s" %(MD_REF.getBuild()))
        textArray.append(u"Moneydance Config file reports:      %s" %MD_REF.getUI().getPreferences().getSetting(u"current_version", u""))
        textArray.append(u"Moneydance updater version to track: %s" %MD_REF.getUI().getPreferences().getSetting(u"updater.version_to_track",u""))
        textArray.append(u"")

        currLicense = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2022",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2021",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2019",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2017",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2015",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2014",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2011",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2010",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2008",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2004",
                                                                MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key",u"?")))))))))))

        license2022 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2022", None)                               # noqa
        license2021 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2021", None)                               # noqa
        license2019 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2019", None)
        license2017 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2017", None)
        license2015 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2015", None)
        license2014 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2014", None)
        license2011 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2011", None)
        license2010 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2010", None)
        license2008 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2008", None)
        license2004 = MD_REF.getUI().getPreferences().getSetting(u"gen.lic_key2004", None)

        if not isMDPlusEnabledBuild():      # The start of MD+ and new licensing....
            if MD_REF.isRegistered():
                textArray.append(u"LICENSED: %s" %(currLicense))
            else:
                textArray.append(u"UNLICENSED!")

        else:
            licenseInfo = MD_REF.getLicenseInfo()
            x = pad((u"UNLICENSED:" if (not licenseInfo.isRegistered()) else u"LICENSED:"),12)
            textArray.append(u"%s%s (key version: %s, key status: %s, isUpgradeable: %s)"
                             %(x, licenseInfo.getLicenseKey(), licenseInfo.getKeyVersion(), licenseInfo.getStatus(), licenseInfo.isUpgradeable()))

            licenseInfo = getMDPlusLicenseInfoForBook()     # type: MoneydanceSyncableItem

            if licenseInfo is None:
                textArray.append(u"Moneydance+ License: NOT FOUND...")
            else:
                mdplus_email = licenseInfo.getParameter(u"mdplus.account_email", None)
                mdplus_pend_email = licenseInfo.getParameter(u"mdplus.pending_email", None)
                mdplus_signup_status = licenseInfo.getParameter(u"signup_status", None)
                mdplus_keyRegenDate = licenseInfo.getLongParameter(u"mdplus.date", 0L)
                mdplus_refreshDate = licenseInfo.getLongParameter(u"mdplus.refresh_date", 0L)
                mdplus_keypairCreated = licenseInfo.getLongParameter(u"mdplus.keypair_created", 0L)
                mdplus_privKeyHex = licenseInfo.getParameter(u"mdplus.priv", None)
                mdplus_pubKeyHex = licenseInfo.getParameter(u"mdplus.pub", None)

                if mdplus_email or mdplus_pend_email or mdplus_signup_status or mdplus_keyRegenDate or mdplus_refreshDate or mdplus_keypairCreated or mdplus_privKeyHex or mdplus_pubKeyHex:
                    textArray.append(u"")
                    textArray.append(u"Moneydance+ License information:")
                    if mdplus_email:            textArray.append(u"Email:            %s" %(mdplus_email))
                    if mdplus_email is None or mdplus_email == u"":
                        if mdplus_pend_email:       textArray.append(u"Email pending:    %s" %(mdplus_pend_email))
                    if mdplus_signup_status:    textArray.append(u"Signup status:    %s" %(mdplus_signup_status))
                    if mdplus_keyRegenDate:     textArray.append(u"MD+ date:         %s" %(get_time_stamp_as_nice_text(mdplus_keyRegenDate)))
                    if mdplus_refreshDate:      textArray.append(u"MD+ refresh date: %s" %(get_time_stamp_as_nice_text(mdplus_refreshDate)))
                    if mdplus_keypairCreated:   textArray.append(u"MD+ keypair date: %s" %(get_time_stamp_as_nice_text(mdplus_keypairCreated)))
                    if mdplus_privKeyHex:       textArray.append(u"MD+ Private Key:  %s (length: %s)" %(u"****** hidden ******", len(mdplus_privKeyHex)))
                    if mdplus_pubKeyHex:        textArray.append(u"MD+ Public Key:   %s (length: %s)" %(u"****** hidden ******", len(mdplus_pubKeyHex)))
                    textArray.append(u"")
                else:
                    textArray.append(u"Moneydance+ License: NOT FOUND...")

                del licenseInfo

        if license2021:      textArray.append(u" >old licenses (2021): " + license2021)
        if license2019:      textArray.append(u" >old licenses (2019): " + license2019)
        if license2017:      textArray.append(u" >old licenses (2017): " + license2017)
        if license2015:      textArray.append(u" >old licenses (2015): " + license2015)
        if license2014:      textArray.append(u" >old licenses (2014): " + license2014)
        if license2011:      textArray.append(u" >old licenses (2011): " + license2011)
        if license2010:      textArray.append(u" >old licenses (2010): " + license2010)
        if license2008:      textArray.append(u" >old licenses (2008): " + license2008)
        if license2004:      textArray.append(u" >old licenses (2004): " + license2004)

        if not MD_REF.getCurrentAccount().getBook(): textArray.append(u"Moneydance datafile is empty")
        x = MD_REF.getUI().getPreferences().getSetting(GlobalVars.Strings.MD_CONFIGDICT_CURRENT_ACCOUNT_BOOK, None)
        y = MD_REF.getUI().getPreferences().getSetting(u"current_account_file", None)

        theExtn = os.path.splitext((MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()))

        if x:
            textArray.append(u"\n"
                             u"Current Dataset:               %s" %(x))
        if y:
            textArray.append(u"\n"
                             u"Current Dataset:               %s" %(y))

        textArray.append(u"Full location of this Dataset: %s" %(MD_REF.getCurrentAccount().getBook().getRootFolder()))

        x = find_the_program_install_dir()
        if x and Platform.isOSX() and System.getProperty(u"install4j.exeDir","") != "":     # Special 'not normal' check.... will normally never trigger
            textArray.append(u"Application Install Directory (Mac running manual launch script): %s" %(x))
        elif x:
            textArray.append(u"Application Install Directory: %s" %(x))
        else:
            textArray.append(u"UNABLE TO DETERMINE Application's Install Directory! (are you running Moneydance by manually executing the .jar file?)")


        lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
        if lDropbox:
            textArray.append(u"\n@@ WARNING: You have your dataset installed in Dropbox - This can damage your data!")
            if lSuppressed:
                textArray.append(u"@@ WARNING: You have also SUPPRESSED the warning messages - THIS IS AT YOUR OWN RISK!")
            textArray.append(u"@@ The recommendation is to move your Dataset to your local drive (out of Dropbox) and a) use MD's internal Sync feature, or b) set Dropbox as the location for MD Backups\n")

        # MD2021.2(3088) adds this capability.....
        grabEnvPassphrases = findEnvironmentPassphrases()
        if grabEnvPassphrases:
            textArray.append(u"\nENVIRONMENT PASSPHRASE(S) STORED TO BYPASS POPUP ENCRYPTION PROMPTS")
            for k, v in grabEnvPassphrases:
                textArray.append(u"Environment key: %s <Stored Passphrase: ******>"  %(k))
        del grabEnvPassphrases

        textArray.append(u"")
        x, y = calculateMoneydanceDatasetSize(True)
        textArray.append(u"Dataset size: %sMBs (%s files)\n" %(x,y))
        myPrint("B", "Dataset size: %sMBs (%s files)\n" %(x,y))

        storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()
        fileUUID = storage.getStr(u"netsync.dropbox.fileid", u"MISSING")
        migratedFileUUID = storage.getStr(u"migrated.netsync.dropbox.fileid", u"")

        textArray.append(u"Dataset internal UUID: %s" %(fileUUID))
        myPrint("B", "Dataset internal UUID: %s" %(fileUUID))

        if migratedFileUUID != "":
            textArray.append(u"Dataset old migrated UUID: %s" %(migratedFileUUID))
            myPrint("B", "Dataset old migrated UUID: %s" %(migratedFileUUID))
        del storage

        cos = count_database_objects()
        textArray.append(cos)
        myPrint("B", "\n.\n.", cos, "-------------------------------------------------------------------")

        textArray.append(u"Master Node (dataset): %s" %(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))
        myPrint("B", "Master Node (dataset): %s" %(MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))

        textArray.append(u"\nENCRYPTION")
        x = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
        if x is None or x == u"":
            x = u"Encryption not set! - This means an internal Moneydance passphrase is being used to encrypt your dataset!".upper()
        else:
            x = u"***************"
        textArray.append(u"'Master' / Encryption Passphrase: %s" %x)

        x = u"Encryption Store Online Banking (OFX) Passwords in File: %s" %(isCachingPasswords())
        if isCachingPasswords():
            textArray.append(x+u" (This means you are able to save your online banking passwords)")
        else:
            textArray.append(x+u"\n>>You cannot save online banking passwords until you set a 'Master' (encryption) password **AND** select 'Store Online Passwords in File'\n")

        x = MD_REF.getUI().getCurrentAccounts().getEncryptionHint()
        if x is None or x == u"":
            x = u"Encryption passphrase hint not set!".upper()
        else:
            x = u"***************"
        textArray.append(u"Encryption passphrase hint: %s" %x)

        if MD_REF.getCurrentAccount().getBook().getLocalStorage().getString("md.crypto_level", None):
            x = u"Encryption level - Moneydance reports 'md.crypto_level' set as: %s" %(MD_REF.getCurrentAccount().getBook().getLocalStorage().getString("md.crypto_level", None))
            textArray.append(x)

        x = u"Toolbox's actual 'test' of your Encryption key/passphrase reports: %s\n" %(getMDEncryptionKey())

        x += u"I understand the dataset encryption is: AES 128-bit. Passphrase encrypted using PBKDF2WithHmacSHA512 " \
             u"(fixed internal salt, high iteration) and then your (secure/random) key is encrypted and used to encrypt " \
             u"data to disk using AES/CBC/PKCS5Padding with a fixed internal IV"
        textArray.append(x)

        textArray.append(u"\nSYNC DETAILS")
        # SYNC details
        x = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()
        if x is None or x == u"":
            x = u"Sync passphrase not set!"
        else:
            x = u"***************"
        textArray.append(u"Sync Password:                 %s" %x)

        try:
            # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
            # MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            noSyncOption = SyncFolderUtil.configurerForIDFromList(u"none", syncMethods)
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)
            if syncMethod is None:
                syncMethod = noSyncOption
            else:
                syncMethod = syncMethod
            textArray.append(u"Sync Method:                   %s" %(syncMethod.getSyncFolder()))
            myPrint("B", "Sync Method: %s" %(syncMethod.getSyncFolder()))
            x = get_sync_folder()
            if x:
                textArray.append(u"Sync local disk base location: %s" %(x))
                myPrint("B", "Sync local disk base location: %s" %(x))
        except:
            textArray.append(u"Sync Method: *** YOU HAVE A PROBLEM WITH YOUR DROPBOX CONFIGURATION! ***")
            myPrint("B",u"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            myPrint("B",u"!! WARNING - You have a Dropbox configuration issue which is crashing .getSyncFolder() !!")
            myPrint("B",u"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            MyPopUpDialogBox(toolbox_frame_,
                             u"WARNING - DROPBOX ERROR",
                             u"You seem to have a Dropbox configuration issue!?\n"
                             u"(or you have launched from command line, not the code-signed app bundle)\n"
                             u"Toolbox cannot fix this for you - please review your console logs\n"
                             u"and contact the online support forum for help....\n"
                             u"(if you find a fix, please inform the Toolbox author)",
                             theTitle=u"DROPBOX ERROR",
                             lModal=False,
                             lAlertLevel=2).go()

        if not getShouldDownloadAllAttachments(): textArray.append(u"** Sync downloading of attachments is disabled **")

        if not check_for_dropbox_folder():
            textArray.append(u"Sync WARNING: Dropbox sync will not work until you add the missing .moneydancesync folder - use update mode to fix!")

        textArray.append(u"\nTHEMES")

        try:  x = u"'%s' : %s" %(MD_REF.getUI().getCurrentTheme(),UIManager.getLookAndFeel())
        except:  x = u"failed to get Theme details"

        y = u"(DARK THEME)" if (isMDThemeDark()) else u""
        z = u"(Mac Dark Mode detected)" if (Platform.isOSX() and isMacDarkModeDetected()) else u""

        textArray.append(u"Your selected Theme: %s (%s) %s %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID), x, y, z))
        myPrint("B", "Your selected Theme: %s (%s) %s %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID), x, y, z))

        # noinspection PyUnresolvedReferences
        x = ThemeInfo.customThemeFile.getCanonicalPath()
        if not os.path.exists(x):
            x = u"custom_theme.properties file DOES NOT EXIST!"
        textArray.append(u"Custom Theme File:   %s" %(x))
        # noinspection PyUnresolvedReferences
        textArray.append(u"Available themes:    %s" %(ThemeInfo.getAllThemes()))

        textArray.append(u"\nRUNTIME ENVIRONMENT")

        textArray.append(u"Java version:                        %s"  %(System.getProperty(u"java.version")))
        textArray.append(u"Java vendor:                         %s"  %(System.getProperty(u"java.vendor")))

        textArray.append(u"Platform:                            %s %s %s.%s" %(platform.python_implementation(), platform.system(), sys.version_info.major, sys.version_info.minor))

        textArray.append(u"SandBoxed:                           %s" %(MD_REF.getPlatformHelper().isSandboxed()))
        textArray.append(u"Restricted:                          %s" %(MD_REF.getPlatformHelper().isConstrainedToSandbox()))

        if MD_REF.getExecutionMode() == MD_REF.EXEC_MODE_APP:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()) + u" = APP (Normal App)")
        elif MD_REF.getExecutionMode() == MD_REF.EXEC_MODE_APPLET:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()) + u" = APPLET (probably from an AppStore?")
        else:
            textArray.append(u"MD Execution Mode:                   %s" %(MD_REF.getExecutionMode()))

        textArray.append(u"MD Debug Mode:                       %s" %(MD_REF.DEBUG))
        textArray.append(u"Beta Features:                       %s" %(MD_REF.BETA_FEATURES))
        textArray.append(u"Architecture:                        %s%s" %(System.getProperty(u"os.arch"),
                                                                        u" (Intel 32-bit)" if isIntelX86_32bit() else u""))

        if theExtn and theExtn[1].strip() != u"":
            textArray.append(u"File Extension:                      %s" %theExtn[1])
        else:
            textArray.append(u"File Extension:                      %s" %(MD_REF.FILE_EXTENSION))

        # NOTE: As of MD2022(4040) python.getSystemState().setdefaultencoding("utf8") is called on the python interpreter at launch...
        textArray.append(u"Operating System file encoding:      %s" %(Charset.defaultCharset()))
        textArray.append(u"File system default encoding:        %s, Python default encoding: %s (overridden from ASCII)"
                         %(sys.getfilesystemencoding(), PySystemState().getdefaultencoding()))

        try:
            # New for MD2020.2012
            x = MD_REF.getUI().getFonts().code
        except:
            myPrint("B",u"Failed to get Moneydance code font (must be older version), loading older mono")
            x = MD_REF.getUI().getFonts().mono

        textArray.append(u"Python default display font:         %s(%s)" %(x.getFontName(), x.getSize()))


        textArray.append(u"\nENVIRONMENT")

        try:
            username = System.getProperty(u"user.name")
        except:
            username = u"???"
        textArray.append(u"Username:                            %s" %username)

        textArray.append(u"OS Platform:                         %s" %System.getProperty(u"os.name") + u"OS Version: %s" %(System.getProperty(u"os.version")))

        textArray.append(u"Home Directory:                      %s" %(get_home_dir()))
        if System.getProperty(u"user.dir"): textArray.append(u"  user.dir:                          %s" %System.getProperty(u"user.dir"))
        if System.getProperty(u"UserHome"): textArray.append(u"  UserHome:                          %s" %System.getProperty(u"UserHome"))
        if os.path.expanduser(u"~"):        textArray.append(u"  ~:                                 %s" %os.path.expanduser(u"~"))
        if os.environ.get(u"HOMEPATH"):     textArray.append(u"  HOMEPATH:                          %s" %os.environ.get(u"HOMEPATH"))

        textArray.append(u"Moneydance decimal point:            %s" %MD_REF.getUI().getPreferences().getSetting(u"decimal_character", u"."))
        textArray.append(u"System Locale Decimal Point:         %s" %(getDecimalPoint()))
        if MD_REF.getUI().getPreferences().getSetting(u"decimal_character", u".") != getDecimalPoint():
            textArray.append(u"NOTE - MD Decimal point is DIFFERENT to the Locale decimal point!!!")
        textArray.append(u"MD User set Locale Country:          %s" %(MD_REF.getUI().getPreferences().getSetting(u"locale.country", u"")))
        textArray.append(u"MD User set Locale Language:         %s" %(MD_REF.getUI().getPreferences().getSetting(u"locale.language", u"")))

        loc = Locale.getDefault(); loc_c = loc.getCountry(); loc_l = loc.getLanguage()
        # noinspection PyUnresolvedReferences
        if (loc_c.lower() != MD_REF.getUI().getPreferences().getSetting(u"locale.country", u"_unknown_").lower()) \
                or (loc_l.lower() != MD_REF.getUI().getPreferences().getSetting(u"locale.language", u"_unknown_").lower()):
            textArray.append(u"NOTE - MD User set Locale details are different to System Locale details!!!")
            textArray.append(u"(System Locale Country:              %s)" %(loc_c))
            textArray.append(u"(System Locale Language:             %s)" %(loc_l))
        del loc, loc_c, loc_l

        textArray.append(u"\nFOLDER / FILE LOCATIONS")

        textArray.append(u"MD Dataset internal top level (root) Directory: %s" %(MD_REF.getCurrentAccount().getBook().getRootFolder().getParent()))
        textArray.append(u"Auto Backup Folder:                             %s " %(FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath() ) )
        textArray.append(u"(Last backup location:                          %s)" %(MD_REF.getUI().getPreferences().getSetting(u"backup.last_saved", u"")))

        internalFiles = AccountBookUtil.getInternalAccountBooks()
        externalFiles = AccountBookUtil.getExternalAccountBooks()

        if internalFiles.size() + externalFiles.size() > 1:
            textArray.append(u"\nOther MD Datasets I am aware of...:")

        for wrapper in internalFiles:
            if MD_REF.getUI().getCurrentAccounts() is not None and MD_REF.getUI().getCurrentAccounts().getBook() == wrapper.getBook():
                pass
            else:
                textArray.append(u"Internal file:           %s" %(wrapper.getBook().getRootFolder().getCanonicalPath()))

        for wrapper in externalFiles:
            if (MD_REF.getUI().getCurrentAccounts() is not None and MD_REF.getUI().getCurrentAccounts().getBook() == wrapper.getBook()):
                pass
            else:
                textArray.append(u"External file:           %s" %(wrapper.getBook().getRootFolder().getCanonicalPath()))

        if internalFiles.size() + externalFiles.size() > 1:
            textArray.append(u"\n")

        textArray.append(u"MD System Root Directory:    %s" %(Common.getRootDirectory().getCanonicalPath()))

        textArray.append(u"MD Log file:                 %s" %(MD_REF.getLogFile().getCanonicalPath()))
        textArray.append(u"Preferences File:            %s" %(Common.getPreferencesFile().getCanonicalPath()))

        if os.path.exists((Common.getArchiveDirectory().getCanonicalPath())):
            textArray.append(u"Archive Directory:           %s" %(Common.getArchiveDirectory().getCanonicalPath()))
        if os.path.exists((Common.getFeatureModulesDirectory().getCanonicalPath())):
            textArray.append(u"Extensions Directory:        %s" %(Common.getFeatureModulesDirectory().getCanonicalPath()))
        if os.path.exists((Common.getCertificateDirectory().getCanonicalPath())):
            textArray.append(u"Certificates Directory:      %s" %(Common.getCertificateDirectory().getCanonicalPath()))
        if os.path.exists((Common.getDocumentsDirectory().getCanonicalPath())):
            textArray.append(u"Documents Directory:         %s" %(Common.getDocumentsDirectory().getCanonicalPath()))

        if getTheSetting(u"gen.report_dir"):
            textArray.append(getTheSetting(u"gen.report_dir", 29))
        if getTheSetting(u"gen.data_dir"):
            textArray.append(getTheSetting(u"gen.data_dir", 29))
        if getTheSetting(u"gen.import_dir"):
            textArray.append(getTheSetting(u"gen.import_dir", 29))

        textArray.append(u"\n")
        if os.path.exists((Common.getPythonDirectory().getCanonicalPath())):
            textArray.append(u"Python Directory:                %s" %(Common.getPythonDirectory().getCanonicalPath()))
        if getTheSetting(u"gen.last_ext_file_dir"):
            textArray.append(getTheSetting(u"gen.last_ext_file_dir", 33))
        if getTheSetting(u"gen.python_default_file"):
            textArray.append(getTheSetting(u"gen.python_default_file", 33))
        if getTheSetting(u"gen.python_dir"):
            textArray.append(getTheSetting(u"gen.python_dir", 33))
        if getTheSetting(u"gen.graph_dir"):
            textArray.append(getTheSetting(u"gen.graph_dir", 33))
        if getTheSetting(u"gen.recent_files"):
            textArray.append(getTheSetting(u"gen.recent_files", 33))

        textArray.append(u"System 'python.path':            %s" %System.getProperty(u"python.path"))
        textArray.append(u"System 'python.cachedir':        %s" %System.getProperty(u"python.cachedir"))
        textArray.append(u"System 'python.cachedir.skip':   %s" %System.getProperty(u"python.cachedir.skip"))

        try:
            textArray.append(u"\nEXTENSIONS / EDITORS / VIEWS")

            textArray.append(u"Extensions enabled:                          %s" %MD_REF.getSourceInformation().getExtensionsEnabled())

            x = MD_REF.getExternalAccountEditors()
            for y in x:
                textArray.append(u"External Account Editor:                     %s" %(y))
            x = MD_REF.getExternalViews()
            for y in x:
                textArray.append(u"External View(HomePage widget):              %s" %(y))
            x = MD_REF.getLoadedModules()
            for y in x:
                textArray.append(u"Extension Loaded:                            %s" %(y.getDisplayName()))
            x = MD_REF.getSuppressedExtensionIDs()
            for y in x:
                textArray.append(u"Internal/suppressed/secret/unloadable extns: %s" %(y))
            if float(MD_REF.getBuild()) < 3051:
                # .getOutdatedExtensionIDs() name changed prior to 3051
                x = MD_REF.getOutdatedExtensionIDs()                                                                    # noqa
            else:
                x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
            for y in x:
                textArray.append(u"Outdated extensions (not loaded):            %s" %(y))

            try:
                theUpdateList = get_extension_update_info()

                for key in theUpdateList.keys():
                    updateInfo = theUpdateList[key]
                    textArray.append(u"** UPDATABLE EXTENSION: %s to version: %s" %(pad(key,20),(updateInfo[0].getBuild())) )
            except:
                textArray.append(u"ERROR: Failed to retrieve / download Extension update list....")
                dump_sys_error_to_md_console_and_errorlog()

        except:
            pass

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            textArray.append(u"\nCONGRATULATIONS - NO ORPHAN EXTENSIONS DETECTED!!\n")
        else:
            textArray.append(u"\nWARNING: Orphan Extensions detected (%s in config.dict) & (%s in .MXT files)\n" %(len(orphan_prefs)+len(orphan_confirmed_extn_keys),len(orphan_files)))
            myPrint(u"B", u"WARNING: Orphan Extensions detected (%s in config.dict) & (%s in .MXT files)\n" %(len(orphan_prefs)+len(orphan_confirmed_extn_keys),len(orphan_files)))


        textArray.append(u"\n ======================================================================================")
        textArray.append(u"USER PREFERENCES")
        textArray.append(u"-----------------")
        textArray.append(u">> GENERAL")
        textArray.append(u"Show Full Account Paths:             %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"show_full_account_path", True)))
        textArray.append(u"Register Follows Recorded Txns:      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.register_follows_txns", True)))
        textArray.append(u"Use VAT/GST:                         %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.use_vat", False)))
        textArray.append(u"Case Sensitive Auto-Complete:        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.case_sensitive_ac", False)))
        textArray.append(u"Auto Insert Decimal Points:          %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.quickdecimal", False)))
        textArray.append(u"Auto Create New Transactions:        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.new_txn_on_record", True)))
        textArray.append(u"Separate Tax Date for Transactions:  %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.separate_tax_date", False)))
        textArray.append(u"Show All Accounts in Popup:          %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gui.show_all_accts_in_popup", False)))
        textArray.append(u"Beep when Transactions Change:       %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"beep_on_transaction_change", True)))
        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"Theme: %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID)))
        textArray.append(u"Show Selection Details:              %s" %(MD_REF.getUI().getPreferences().getSetting(u"details_view_mode", u"inwindow")))
        textArray.append(u"Side Bar Balance Type:               %s" %(MD_REF.getUI().getPreferences().getSideBarBalanceType()))
        textArray.append(u"Date Format:                         %s" %(MD_REF.getUI().getPreferences().getSetting(u"date_format", None)))
        # this.prefs.getShortDateFormat());
        textArray.append(u"Decimal Character:                   %s" %(MD_REF.getUI().getPreferences().getSetting(u"decimal_character", ".")))
        # this.prefs.getDecimalChar()));
        textArray.append(u"Locale:                              %s" %(MD_REF.getUI().getPreferences().getLocale()))

        i = MD_REF.getUI().getPreferences().getIntSetting(u"gen.fiscal_year_start_mmdd", 101)
        if i == 101: i = u"January 1"
        elif i == 201: i = u"February 1"
        elif i == 301: i = u"March 1"
        elif i == 401: i = u"April 1"
        elif i == 406: i = u"April 6 (UK Tax Year Start Date)"
        elif i == 501: i = u"May 1"
        elif i == 601: i = u"June 1"
        elif i == 701: i = u"July 1"
        elif i == 801: i = u"August 1"
        elif i == 901: i = u"September 1"
        elif i == 1001: i = u"October 1"
        elif i == 1101: i = u"November 1"
        elif i == 1201: i = u"December 1"
        else: i = i
        textArray.append(u"Fiscal Year Start:                   %s" %(i))

        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"Font Size:                           +%s" %(MD_REF.getUI().getPreferences().getIntSetting(u"gui.font_increment", 0)))

        if float(MD_REF.getBuild()) >= 3032:
            textArray.append(u"\n>> APPEARANCE")
            textArray.append(u"Theme:                               %s" %(MD_REF.getUI().getPreferences().getSetting(u"gui.current_theme", ThemeInfo.DEFAULT_THEME_ID)))
            if (MD_REF.getUI().getPreferences().getSetting(u"main_font")) != u"null":
                textArray.append(u"Font:                                %s" %(MD_REF.getUI().getPreferences().getSetting(u"main_font")))
            else:
                textArray.append(u"Font:                                (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"mono_font")) != u"null":
                textArray.append(u"Numeric Font:                        %s" %(MD_REF.getUI().getPreferences().getSetting(u"mono_font")))
            else:
                textArray.append(u"Numeric Font:                        (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"code_font")) != u"null":
                textArray.append(u"Moneybot Coding (monospaced) Font:   %s" %(MD_REF.getUI().getPreferences().getSetting(u"code_font")))
            else:
                textArray.append(u"Moneybot Coding (monospaced) Font:   (None/Default)")

            if (MD_REF.getUI().getPreferences().getSetting(u"print.font_name")) != u"null":
                textArray.append(u"Printing Font:                       %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_name")))
            else:
                textArray.append(u"Printing Font:                       (None/Default)")

            textArray.append(u"Print Font Size:                     %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_size", u"12")))
            textArray.append(u"Screen Font Size:                    +%s" %(MD_REF.getUI().getPreferences().getIntSetting(u"gui.font_increment", 0)))

        textArray.append(u"\n>> NETWORK")
        textArray.append(u"Automatically Download in Background:                             %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.auto_download", False)))
        textArray.append(u"Automatically Merge Downloaded Transactions:                      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"gen.preprocess_dwnlds", False)))
        textArray.append(u"Mark Transactions as Cleared When Confirmed:                      %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.clear_confirmed_txns", False)))
        textArray.append(u"Use Bank Dates for Merged Transactions:                           %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"olb.prefer_bank_dates", False)))
        textArray.append(u"Ignore Transaction Types in Favor of Amount Signs:                %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"prefer_amt_sign_to_txn_type", False)))

        dataStorage = MD_REF.getCurrentAccount().getBook().getLocalStorage()
        autocommit = not dataStorage or dataStorage.getBoolean(u"do_autocommits",MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
        textArray.append(u"Auto-Commit Reminders (applies to current file on this computer): %s" %(autocommit))

        textArray.append(u"Use Proxy:                                                        %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.use_proxy", False)))
        textArray.append(u" Proxy Host:                                                      %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_host", "")))
        textArray.append(u" Proxy Port:                                                      %s" %(MD_REF.getUI().getPreferences().getIntSetting(u"net.proxy_port", 80)))
        textArray.append(u"Proxy Requires Authentication:                                    %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"net.auth_proxy", False)))
        textArray.append(u" Proxy Username:                                                  %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_user", "")))
        textArray.append(u" Proxy Password:                                                  %s" %(MD_REF.getUI().getPreferences().getSetting(u"net.proxy_pass", "")))
        textArray.append(u"Observe Online Payment Date Restrictions:                         %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"ofx.observe_bp_window", True)))
        i = MD_REF.getUI().getPreferences().getIntSetting(u"net.downloaded_txn_date_window", -1)
        if i < 0: i = u"Default"
        textArray.append(u"Only Match downloaded transactions when they are at most %s days apart" %(i))

        textArray.append(u"\n>> CHEQUE PRINTING")
        textArray.append(u"preferences not listed here...")

        if float(MD_REF.getBuild()) < 3032:
            textArray.append(u"\n>> PRINTING")
            textArray.append(u"Font:      %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_name", u"")))
            textArray.append(u"Font Size: %s" %(MD_REF.getUI().getPreferences().getSetting(u"print.font_size", u"12")))

        textArray.append(u"\n>> BACKUPS")

        destroyBackupChoices = MD_REF.getUI().getPreferences().getSetting(u"backup.destroy_number", u"5")
        returnedBackupType = MD_REF.getUI().getPreferences().getSetting(GlobalVars.Strings.MD_CONFIGDICT_BACKUP_TYPE, u"every_x_days")
        if returnedBackupType == u"every_time":
            dailyBackupCheckbox = True
            destroyBackupChoices = 1
        elif returnedBackupType == u"every_x_days":
            dailyBackupCheckbox = True
        else:
            dailyBackupCheckbox = False

        textArray.append(u"Save Backups Daily:     %s" %(dailyBackupCheckbox))
        textArray.append(u"Keep no more than       %s" %(destroyBackupChoices) + u" backups")

        textArray.append(u"separate Backup Folder: %s" %(MD_REF.getUI().getPreferences().getBoolSetting(u"backup.location_selected", True)))
        textArray.append(u"Backup Folder:          %s " %(FileUtils.getBackupDir(MD_REF.getPreferences()).getCanonicalPath() ))

        textArray.append(u"\n>> SUMMARY PAGE")
        textArray.append(u"preferences not listed here...")
        textArray.append(u" ======================================================================================\n")

        textArray.append(u"\nHOME SCREEN USER SELECTED PREFERENCES")
        textArray.append(u"----------------------------")
        textArray.append(u"Home Screen Configured:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.configured", u"NOT SET"))

        if MD_REF.getUI().getPreferences().getSetting(u"sidebar_bal_type", False):
            textArray.append(u"Side Bar Balance Type:           %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"sidebar_bal_type",0))))
        textArray.append(u"Dashboard Item Selected:         %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.dashboard.item", u"NOT SET"))
        textArray.append(u"Quick Graph Selected:            %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.quick_graph_type", u"NOT SET"))
        textArray.append(u"Budget Bar Date Range Selected:  %s" %MD_REF.getUI().getPreferences().getSetting(u"budgetbars_date_range", u"NOT SET"))
        textArray.append(u"Reminders View:                  %s" %MD_REF.getUI().getPreferences().getSetting(u"upcoming_setting", u"NOT SET"))

        textArray.append(u"Exchange Rates View - Invert?:   %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.invert_rates", u"NOT SET"))

        textArray.append(u"BANK Accounts Expanded:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.bank_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.bank_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.bank_bal_type",0))))

        textArray.append(u"LOAN Accounts Expanded:          %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.loan_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.loan_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.loan_bal_type",0))))

        textArray.append(u"LIABILITY Accounts Expanded:     %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.liability_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.liability_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.liability_bal_type",0))))

        textArray.append(u"INVESTMENT Accounts Expanded:    %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.invst_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.invst_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.invst_bal_type",0))))

        textArray.append(u"CREDIT CARD Accounts Expanded:   %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.cc_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.cc_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.cc_bal_type",0))))

        textArray.append(u"ASSET Accounts Expanded:         %s" %MD_REF.getUI().getPreferences().getSetting(u"gui.home.asset_expanded", u"NOT SET"))
        if MD_REF.getUI().getPreferences().getSetting(u"gui.home.asset_bal_type", False):
            textArray.append(u">Balance Displayed:              %s" %(BalanceType.fromInt(MD_REF.getUI().getPreferences().getIntSetting(u"gui.home.asset_bal_type",0))))


        textArray.append(u" ======================================================================================\n")

        try:
            textArray.append(u"\nFONTS")
            textArray.append(u">> Swing Manager default:     %s" %(UIManager.getFont("Label.font")))
            textArray.append(u">> Moneydance default:        %s" %(MD_REF.getUI().getFonts().defaultSystemFont))
            textArray.append(u">> Moneydance mono:           %s" %(MD_REF.getUI().getFonts().mono))
            textArray.append(u">> Moneydance default text:   %s" %(MD_REF.getUI().getFonts().defaultText))
            textArray.append(u">> Moneydance default title:  %s" %(MD_REF.getUI().getFonts().detailTitle))
            textArray.append(u">> Moneydance calendar title: %s" %(MD_REF.getUI().getFonts().calendarTitle))
            textArray.append(u">> Moneydance header:         %s" %(MD_REF.getUI().getFonts().header))
            textArray.append(u">> Moneydance register:       %s" %(MD_REF.getUI().getFonts().register))
            textArray.append(u">> Moneydance report header:  %s" %(MD_REF.getUI().getFonts().reportHeader))
            textArray.append(u">> Moneydance report title:   %s" %(MD_REF.getUI().getFonts().reportTitle))

            textArray.append(u">> Moneydance code:           %s" %(getMonoFont()))

        except:
            myPrint(u"B",u"Error getting fonts..?")
            dump_sys_error_to_md_console_and_errorlog()

        textArray.append(u"\n>> OTHER INTERESTING SETTINGS....")

        if getTheSetting(u"net.default_browser"):
            textArray.append(getTheSetting(u"net.default_browser", 29))
        if getTheSetting(u"gen.import_dt_fmt_idx"):
            textArray.append(getTheSetting(u"gen.import_dt_fmt_idx", 29))
        if getTheSetting(u"txtimport_datefmt"):
            textArray.append(getTheSetting(u"txtimport_datefmt", 29))
        if getTheSetting(u"txtimport_csv_delim"):
            textArray.append(getTheSetting(u"txtimport_csv_delim", 29))
        if getTheSetting(u"txtimport_csv_decpoint"):
            textArray.append(getTheSetting(u"txtimport_csv_decpoint", 29))

        textArray.append(u"")

        if getTheSetting(u"ofx.app_id"):
            textArray.append(getTheSetting(u"ofx.app_id", 29))
        if getTheSetting(u"ofx.app_version"):
            textArray.append(getTheSetting(u"ofx.app_version", 29))
        if getTheSetting(u"ofx.bp_country"):
            textArray.append(getTheSetting(u"ofx.bp_country", 29))
        if getTheSetting(u"ofx.app_version"):
            textArray.append(getTheSetting(u"ofx.app_version", 29))

        textArray.append(u"")
        x = getJVMUsageStatistics(memoryUsageStats=True, maxMemoryStats=True, availableProcessorsStats=True)
        textArray.append(x)
        myPrint(u"B", x)

        textArray.append(u"")
        textArray.append(u"Java JVM System Properties containing references to Moneydance")
        for x in System.getProperties():

            # noinspection PyUnresolvedReferences
            if u"moneydance" in System.getProperty(x).lower():
                textArray.append(u">> %s%s" %(pad(x,50), System.getProperty(x)))

        textArray.append(u"\n\n<END>\n")

        # This catches exceptions.UnicodeDecodeError 'utf-8' codec can't decode byte 0xa0 in position 46: unexpected code byte'
        # First spotted with South African Locale and nbsp used for decimal grouping character....

        try:
            returnString = u"\n".join(textArray)
            myPrint(u"DB",u"Success joining diagnostics text array.....")
        except:
            myPrint(u"B",u"UH-OH - Seems like we probably caught an utf8 error... trying to rectify")
            myPrint(u"B", dump_sys_error_to_md_console_and_errorlog(True))
            returnString = u""
            for i in range(0, len(textArray)):
                for char in textArray[i]:
                    if ord(char)>=128:
                        myPrint(u"B",u"char ord(%s) found in row %s; position %s" %(ord(char),i,textArray[i].find(char)))
                        myPrint(u"B",u"@@ FAILING ROW STARTS: '%s'" %(textArray[i][:textArray[i].find(char)]))
                        break
                returnString += (u"".join(char for char in textArray[i] if ord(char) < 128) )+u"\n"
            returnString += u"\n(** NOTE: I had to strip non ASCII characters **)\n"

        return returnString

    def get_list_memorised_reports():
        # Build a quick virtual file of Memorized reports and graphs to display
        memz = []

        iCount = 0
        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedGraphs():
            iCount+=1
            memz.append("Graph: %s" % (x.getName()))

        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedReports():
            iCount+=1
            memz.append("Report: %s" % (x.getName()))

        memz = sorted(memz, key=lambda sort_x: ((sort_x[0]).upper()))

        memz.insert(0,"YOUR MEMORIZED REPORTS\n ======================\n")

        memz.append("\nYOUR MEMORIZED REPORTS in detail\n ======================\n")

        iGs = 0
        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedGraphs():
            if iGs:
                memz.append("\n ---")
            iGs+=1
            memz.append("Graph:           %s" % (x.getName()))
            memz.append(">> SyncItemType: %s" %(x.getSyncItemType()))
            # memz.append(">> Graph ID:     %s" %(x.getReportID()))
            memz.append(">> Graph Genr:   %s" %(x.getReportGenerator()))
            y = x.getReportParameters()
            for yy in y:
                if yy.lower().strip() == "accounts" or yy.lower().strip() == "source_accts":
                    memz.append(">> Parameter key: %s: %s" %(yy, "<not displayed - but contains %s accounts>" %(y.get(yy).count(",")+1)))
                else:
                    memz.append(">> Parameter key: %s: %s" %(yy, y.get(yy)))

        iRs = 0
        for x in MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedReports():
            if iRs or iGs:
                memz.append("\n ---")
            iRs+=1
            memz.append("Report           %s" % (x.getName()))
            memz.append(">> SyncItemType: %s" %(x.getSyncItemType()))
            # memz.append(">> Report ID:    %s" %(x.getReportID()))
            memz.append(">> Report Genr:  %s" %(x.getReportGenerator()))
            y = x.getReportParameters()
            for yy in y:
                if yy.lower().strip() == "accounts" or yy.lower().strip() == "source_accts":
                    memz.append(">> Parameter key: %s: %s" %(yy, "<not displayed - but contains %s accounts>" %(y.get(yy).count(",")+1)))
                else:
                    memz.append(">> Parameter key: %s: %s" %(yy, y.get(yy)))

        memz.append("\n\n\n====== DEFAULT REPORTS SETTINGS/PARAMETERS (from Local Storage) RAW DUMP ======\n")
        LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

        last = None
        keys=sorted(LS.keys())
        for theKey in keys:
            value = LS.get(theKey)
            if not theKey.lower().startswith("report_params."): continue
            split_key = theKey.split(".",2)
            if split_key[1] != last:
                memz.append("")
                last = split_key[1]

            if theKey.lower().strip().endswith(".accounts") or theKey.lower().strip().endswith(".source_accts"):
                memz.append("Key:%s Value: %s" % (pad(theKey,70), "<not displayed - but contains %s accounts>" %(value.count(",")+1)))
            else:
                memz.append("Key:%s Value: %s" % (pad(theKey,70), value.strip()))

        x=LS.get("grfRepDefaultParams")
        if x:
            memz.append("\n\nDefault Parameters: 'grfRepDefaultParams' (Probably Legacy keys)")
            memz.append("%s" %x)
            memz.append("")

        memz.append("\n<END>")

        for i in range(0, len(memz)):
            memz[i] = memz[i] + "\n"
        memz = "".join(memz)

        QuickJFrame("Memorized Reports and Graphs", memz, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def view_extensions_details():
        global lIgnoreOutdatedExtensions_TB     # Global as we set this here

        theData = []

        theData.append("EXTENSION(s) DETAILS")
        theData.append(" =====================\n")

        if len(MD_REF.getExternalViews()) > 0:
            theData.append("External Views (HomePage widgets) views:\n")

            for ev in MD_REF.getExternalViews():
                theData.append("   - %s" %(ev.getID()))

            theData.append("\n")

        theData.append("Extensions enabled: %s\n" %MD_REF.getSourceInformation().getExtensionsEnabled())

        theUpdateList = get_extension_update_info()

        # noinspection PyBroadException
        try:
            x = MD_REF.getLoadedModules()
            for y in x:
                isUpdatable= "(latest version)"
                updateInfo = theUpdateList.get(y.getIDStr().lower())
                if updateInfo:
                    isUpdatable = ("\t******* Updatable to version: %s *******" % (updateInfo[0].getBuild())).upper()
                theData.append("Extension ID:           %s" %y.getIDStr())
                theData.append("Extension Name:         %s" %y.getName())
                theData.append("Extension Display Name: %s" %y.getDisplayName())
                theData.append("Extension Description:  %s" %y.getDescription())
                theData.append("Extension Version:      %s" %(y.getBuild()) + isUpdatable)
                theData.append("Extension Source File:  %s" %(y.getSourceFile()))
                theData.append("Extension Vendor:       %s" %y.getVendor())
                theData.append("Extension isBundled:    %s" %(y.isBundled()))
                theData.append("Extension isVerified:   %s" %(y.isVerified()))
                if MD_REF.getUI().getPreferences().getSetting("confirmedext."+str(y.getName()).strip(), None):
                    theData.append("** User has Confirmed this unsigned Extension can run - version: " + MD_REF.getUI().getPreferences().getSetting("confirmedext."+str(y.getName()).strip(), None))
                theData.append("\n\n")

            x = MD_REF.getSuppressedExtensionIDs()
            for y in x:
                theData.append("Internal/suppressed/secret extensions: %s" %(y))

            if float(MD_REF.getBuild()) < 3051:
                # .getOutdatedExtensionIDs() name changed prior to 3051
                x = MD_REF.getOutdatedExtensionIDs()                                                                    # noqa
            else:
                x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
            for y in x:
                theData.append("Outdated / unloadable extensions (not loaded): %s" %(y))
        except:
            theData.append("\nERROR READING EXTENSION DATA!!!!\n")
            dump_sys_error_to_md_console_and_errorlog()

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            theData.append("\nCONGRATULATIONS - NO ORPHAN EXTENSIONS DETECTED!!\n")

        else:
            theData.append("\nLISTING EXTENSIONS ORPHANED IN CONFIG.DICT OR FILES (*.MXT)\n")

            for x in orphan_prefs.keys():
                theData.append("%s Extension: %s is %s" %(pad("config.dict:",40),pad(x,40),pad(orphan_prefs[x],40)))

            theData.append("")

            for x in orphan_confirmed_extn_keys.keys():
                _theVersion = MD_REF.getUI().getPreferences().getSetting(orphan_confirmed_extn_keys[x][1],None)
                theData.append("%s Extension: %s Key: %s (build: %s) is %s" %(pad("config.dict:",40),pad(x,40),pad(orphan_confirmed_extn_keys[x][1],40),_theVersion, pad(orphan_confirmed_extn_keys[x][0],40)))

            theData.append("")

            for x in orphan_files.keys():
                theData.append("%s Extension: %s is %s" %(pad("File: "+orphan_files[x][1],40),pad(x,40),pad(orphan_files[x][0],40)))

        theData.append("\n<END>")

        # Build a quick virtual 'file' of Memorized reports and graphs to display
        for i in range(0, len(theData)):
            theData[i] = theData[i] + "\n"
        theData = "".join(theData)

        jif = QuickJFrame("View Extension(s) details / data", theData, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

        if lIgnoreOutdatedExtensions_TB:
            if myPopupAskQuestion(jif,
                                  "CHECK FOR OUTDATED EXTENSIONS",
                                  "Turn startup warnings back on for Outdated Extensions?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.QUESTION_MESSAGE):

                txt = "OUTDATED EXTENSIONS - Startup warnings re-enabled"
                setDisplayStatus(txt, "B")
                myPrint("B", txt)
                lIgnoreOutdatedExtensions_TB = False
                try:
                    save_StuWareSoftSystems_parameters_to_file()
                except:
                    myPrint("B", "Error - failed to save parameters to pickle file...!")
                    dump_sys_error_to_md_console_and_errorlog()


    class ToolboxBuildInfo:

        def __init__(self, buildObject):
            self.obj =                                  buildObject
            self.build =                                buildObject.getInt("build", 0)
            self.disable =                              buildObject.getBoolean("disable", False)
            self.TOOLBOX_MINIMUM_TESTED_MD_VERSION =    float(buildObject.getStr("TOOLBOX_MINIMUM_TESTED_MD_VERSION", "0.0"))
            self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =    float(buildObject.getStr("TOOLBOX_MAXIMUM_TESTED_MD_VERSION", "0.0"))
            self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =      buildObject.getInt("TOOLBOX_MAXIMUM_TESTED_MD_BUILD", 0)
            self.MD_OFX_BANK_SETTINGS_DIR =             buildObject.getStr("MD_OFX_BANK_SETTINGS_DIR", "")
            self.MD_OFX_DEFAULT_SETTINGS_FILE =         buildObject.getStr("MD_OFX_DEFAULT_SETTINGS_FILE", "")
            self.MD_OFX_DEBUG_SETTINGS_FILE =           buildObject.getStr("MD_OFX_DEBUG_SETTINGS_FILE", "")
            self.MD_EXTENSIONS_DIRECTORY_FILE =         buildObject.getStr("MD_EXTENSIONS_DIRECTORY_FILE", "")
            self.MYPYTHON_DOWNLOAD_URL =                buildObject.getStr("MYPYTHON_DOWNLOAD_URL", "")

            # noinspection PyChainedComparsons
            if self.build > 1000 and self.build < 9999 and self.disable: return                                             # noqa

            # noinspection PyChainedComparsons
            if (self.build < 1000 or self.build > 9999
                    or (self.TOOLBOX_MINIMUM_TESTED_MD_VERSION > 0  and self.TOOLBOX_MINIMUM_TESTED_MD_VERSION < 2020.0)    # noqa
                    or (self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION > 0  and self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION < 2021.1)    # noqa
                    or (self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD > 0    and self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD   < 3034)      # noqa
                    or (len(self.MD_OFX_BANK_SETTINGS_DIR) > 0      and len(self.MD_OFX_BANK_SETTINGS_DIR)     < 10)        # noqa
                    or (len(self.MD_OFX_DEFAULT_SETTINGS_FILE) > 0  and len(self.MD_OFX_DEFAULT_SETTINGS_FILE) < 10)        # noqa
                    or (len(self.MD_OFX_DEBUG_SETTINGS_FILE) > 0    and len(self.MD_OFX_DEBUG_SETTINGS_FILE)   < 10)        # noqa
                    or (len(self.MD_EXTENSIONS_DIRECTORY_FILE) > 0  and len(self.MD_EXTENSIONS_DIRECTORY_FILE) < 10)        # noqa
                    or (len(self.MYPYTHON_DOWNLOAD_URL) > 0         and len(self.MYPYTHON_DOWNLOAD_URL) < 10)):             # noqa

                myPrint("DB","Error with toolbox downloaded data - invalidating it - was: %s" %(self.obj))
                self.build =                                0
                self.disable =                              False
                self.TOOLBOX_MINIMUM_TESTED_MD_VERSION =    None
                self.TOOLBOX_MAXIMUM_TESTED_MD_VERSION =    None
                self.TOOLBOX_MAXIMUM_TESTED_MD_BUILD =      None
                self.MD_OFX_BANK_SETTINGS_DIR =             None
                self.MD_OFX_DEFAULT_SETTINGS_FILE =         None
                self.MD_OFX_DEBUG_SETTINGS_FILE =           None
                self.MD_EXTENSIONS_DIRECTORY_FILE =         None
                self.MYPYTHON_DOWNLOAD_URL =                None


        def __str__(self):
            return "Toolbox build info Obj. Build: %s Disabled: %s {%s}" %(self.build,self.disable, self.obj)

        def __repr__(self):
            return "Toolbox build info Obj. Build: %s Disabled: %s {%s}" %(self.build,self.disable, self.obj)

    def download_toolbox_version_info():

        # These globals must be here as they are set here too...
        global TOOLBOX_STOP_NOW
        global TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_BUILD
        global MD_OFX_BANK_SETTINGS_DIR, MD_OFX_DEFAULT_SETTINGS_FILE, MD_OFX_DEBUG_SETTINGS_FILE, MD_EXTENSIONS_DIRECTORY_FILE

        myPrint("B","##################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to the master Toolbox code repository to check version / build information - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","##################################################################################################################################################")

        this_toolbox_build = int(version_build)
        if this_toolbox_build < 1000:
            myPrint("B", "ERROR with Toolbox build %s  - will just proceed without safeguards" %(this_toolbox_build))
            return

        downloadBuilds = StreamTable()

        inx = None
        try:
            url = URL(TOOLBOX_VERSION_VALIDATION_URL)
            inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
            downloadBuilds.readFrom(inx)
            myPrint("DB","Success getting online version/build info for Toolbox....")
        except:
            myPrint("J","")
            myPrint("B", "ERROR downloading version/build info from Toolbox website...: %s" %(TOOLBOX_VERSION_VALIDATION_URL))
        finally:
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing Toolbox Version/build info URL stream: %s" %(TOOLBOX_VERSION_VALIDATION_URL))

        if not downloadBuilds or downloadBuilds is None:
            myPrint("B", "Error: Toolbox version/build info after download is Empty - will just proceed without safeguards")
            return

        lastUpdated = downloadBuilds.getStr("last_updated", "UNKNOWN")
        myPrint("DB","Last Updated: %s" %(lastUpdated))

        TOOLBOX_STOP_NOW = downloadBuilds.getBoolean("disable_all", False)
        if TOOLBOX_STOP_NOW:
            myPrint("B","Uh-oh... disable_all has been set by the Developer.... Toolbox must close... Sorry")
            return
        else:
            myPrint("DB","Phew! disable_all NOT set....")

        buildList = downloadBuilds.get("builds", None)                   # type: StreamVector
        if not buildList or buildList is None:
            myPrint("B","Error - failed to download or decode build list - will just proceed without safeguards")
            return

        buildTable=[]

        try:
            for buildObj in buildList:                                      # type: StreamTable
                if not (isinstance(buildObj, StreamTable)):
                    myPrint("DB", "ERROR - Retrieved toolbox build info is not a StreamTable(). It's %s %s" %(type(buildObj),buildObj))
                    continue

                # myPrint("D", "BuildObj contains: %s" %(buildObj))
                buildTable.append(ToolboxBuildInfo(buildObj))

        except:
            dump_sys_error_to_md_console_and_errorlog()
            myPrint("B", "ERROR decoding downloading toolbox version/build data! - will just proceed without safeguards...")
            return

        if len(buildTable)<1:
            myPrint("B", "ERROR decoded downloaded toolbox version/build data is empty! - will just proceed without safeguards...")
            return

        buildTable = sorted(buildTable, key=lambda _x: (_x.build), reverse=True)          # type: [ToolboxBuildInfo]
        # Already sorted - newest build first
        for moduleBuild in buildTable:          # type: ToolboxBuildInfo
            if moduleBuild.build < 1000:
                myPrint("DB","Found INVALID downloaded module build %s (ignoring and stopping search)... (%s)" %(moduleBuild.build, moduleBuild.obj ))
                return
            elif moduleBuild.build > this_toolbox_build:
                myPrint("DB","Found NEWER downloaded module build %s (ignoring and continuing search).. (%s)" %(moduleBuild.build, moduleBuild.obj ))
                continue
            elif moduleBuild.build == this_toolbox_build:
                myPrint("DB","Found EXACT-HIT downloaded module build %s OVERRIDING PROGRAM's DEFAULTS....! (%s)" %(moduleBuild.build, moduleBuild.obj ))

                if debug:
                    myPrint("DB","Program defaults were...:")
                    myPrint("DB"," TOOLBOX_STOP_NOW:                     %s"     %(TOOLBOX_STOP_NOW))
                    myPrint("DB"," TOOLBOX_MINIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MINIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_BUILD:      %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_BUILD))
                    myPrint("DB"," MD_OFX_BANK_SETTINGS_DIR:             %s"     %(MD_OFX_BANK_SETTINGS_DIR))
                    myPrint("DB"," MD_OFX_DEFAULT_SETTINGS_FILE:         %s"     %(MD_OFX_DEFAULT_SETTINGS_FILE))
                    myPrint("DB"," MD_OFX_DEBUG_SETTINGS_FILE:           %s"     %(MD_OFX_DEBUG_SETTINGS_FILE))
                    myPrint("DB"," MD_EXTENSIONS_DIRECTORY_FILE:         %s"     %(MD_EXTENSIONS_DIRECTORY_FILE))
                    myPrint("DB"," MYPYTHON_DOWNLOAD_URL:                %s"     %(GlobalVars.MYPYTHON_DOWNLOAD_URL))

                TOOLBOX_STOP_NOW = moduleBuild.disable
                if moduleBuild.TOOLBOX_MINIMUM_TESTED_MD_VERSION > 0:
                    TOOLBOX_MINIMUM_TESTED_MD_VERSION =     moduleBuild.TOOLBOX_MINIMUM_TESTED_MD_VERSION
                if moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_VERSION:
                    TOOLBOX_MAXIMUM_TESTED_MD_VERSION =     moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_VERSION
                if moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_BUILD > 0:
                    TOOLBOX_MAXIMUM_TESTED_MD_BUILD =       moduleBuild.TOOLBOX_MAXIMUM_TESTED_MD_BUILD
                if len(moduleBuild.MD_OFX_BANK_SETTINGS_DIR) > 0:
                    MD_OFX_BANK_SETTINGS_DIR =              moduleBuild.MD_OFX_BANK_SETTINGS_DIR
                if len(moduleBuild.MD_OFX_DEFAULT_SETTINGS_FILE) > 0:
                    MD_OFX_DEFAULT_SETTINGS_FILE =          moduleBuild.MD_OFX_DEFAULT_SETTINGS_FILE
                if len(moduleBuild.MD_OFX_DEBUG_SETTINGS_FILE) > 0:
                    MD_OFX_DEBUG_SETTINGS_FILE =            moduleBuild.MD_OFX_DEBUG_SETTINGS_FILE
                if len(moduleBuild.MD_EXTENSIONS_DIRECTORY_FILE) > 0:
                    MD_EXTENSIONS_DIRECTORY_FILE =          moduleBuild.MD_EXTENSIONS_DIRECTORY_FILE
                if len(moduleBuild.MYPYTHON_DOWNLOAD_URL) > 0:
                    GlobalVars.MYPYTHON_DOWNLOAD_URL =      moduleBuild.MYPYTHON_DOWNLOAD_URL

                if debug:
                    myPrint("DB","Program variables are now...:")
                    myPrint("DB"," TOOLBOX_STOP_NOW:                     %s"     %(TOOLBOX_STOP_NOW))
                    myPrint("DB"," TOOLBOX_MINIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MINIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_VERSION:    %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_VERSION))
                    myPrint("DB"," TOOLBOX_MAXIMUM_TESTED_MD_BUILD:      %s"     %(TOOLBOX_MAXIMUM_TESTED_MD_BUILD))
                    myPrint("DB"," MD_OFX_BANK_SETTINGS_DIR:             %s"     %(MD_OFX_BANK_SETTINGS_DIR))
                    myPrint("DB"," MD_OFX_DEFAULT_SETTINGS_FILE:         %s"     %(MD_OFX_DEFAULT_SETTINGS_FILE))
                    myPrint("DB"," MD_OFX_DEBUG_SETTINGS_FILE:           %s"     %(MD_OFX_DEBUG_SETTINGS_FILE))
                    myPrint("DB"," MD_EXTENSIONS_DIRECTORY_FILE:         %s"     %(MD_EXTENSIONS_DIRECTORY_FILE))
                    myPrint("DB"," MYPYTHON_DOWNLOAD_URL:                %s"     %(GlobalVars.MYPYTHON_DOWNLOAD_URL))

                if TOOLBOX_STOP_NOW:
                    myPrint("B","Uh-oh... disable has been set by the Developer for this build.... Toolbox must close... Sorry")

                return

            else:
                myPrint("D","Found LOWER downloaded module build %s - so I will keep program's defaults, and ignore these - exiting search... (%s) " %(moduleBuild.build, moduleBuild.obj ))
                return

        myPrint("D","No suitable module build info found.. (so I will keep program's defaults, and ignore these - exiting search)")

        return

    def downloadExtensions():

        myPrint("B","#######################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind servers to check for extension(s) version data - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","#######################################################################################################################################")

        downloadInfo = StreamTable()
        if MD_REF.getSourceInformation().getExtensionsEnabled():
            inx = None
            try:
                url = URL(System.getProperty("moneydance.extension_list_url", MD_EXTENSIONS_DIRECTORY_FILE))
                inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
                downloadInfo.readFrom(inx)
            except:
                myPrint("B", "ERROR downloading from Moneydance extensions list website... ")
                dump_sys_error_to_md_console_and_errorlog()

            finally:
                if inx:
                    try:
                        inx.close()
                    except:
                        myPrint("B", "Error closing URL stream")
                        dump_sys_error_to_md_console_and_errorlog()
            return downloadInfo
        else:
            myPrint("B", "@@ Extensions not enabled!!?? @@")
        return False

    def check_if_key_string_valid(test_str):
        # http://docs.python.org/library/re.html
        # re.search returns None if no position in the string matches the pattern
        # pattern to search for any character other than "._-A-Za-z0-9"
        pattern = r'[^a-zA-Z0-9-_.:&=;,@]'
        if re.search(pattern, test_str):
            myPrint("DB","Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","Valid: %r" %(test_str))
            return True

    def check_if_key_data_string_valid(test_str):
        # http://docs.python.org/library/re.html
        # re.search returns None if no position in the string matches the pattern
        # pattern to search for any character other than "._-A-Za-z0-9"
        pattern = r"[^a-zA-Z0-9-' _.:&=;,@/\\]"
        if re.search(pattern, test_str):
            myPrint("DB","Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","Valid: %r" %(test_str))
            return True

    def get_extension_update_info():
        availableExtensionInfo=downloadExtensions()
        moduleList = availableExtensionInfo.get(u"feature_modules")      # StreamVector

        installed = MD_REF.getLoadedModules()          # FeatureModule[]
        excludedIDs = MD_REF.getSuppressedExtensionIDs()            # List<String>
        for installedMod in installed:
            if installedMod.isBundled():
                excludedIDs.add(installedMod.getIDStr().lower())

        miniUpdateList={}

        try:
            if moduleList:
                for obj in moduleList:
                    if not (isinstance(obj, StreamTable)):
                        myPrint(u"J", u"ERROR - Retrieved data is not a StreamTable()", obj)
                        continue

                    extInfo = ModuleMetaData(obj)       # ModuleMetaData

                    # Mirrors code from com.moneydance.apps.md.view.gui.extensions.ExtensionsWindow lines 290-317 (ish)....

                    # noinspection PyUnresolvedReferences
                    if excludedIDs.contains(extInfo.getModuleID().lower()):     # Probably internal modules like Python/Jython
                        continue
                    if not ((float(MD_REF.getBuild())) >= extInfo.getMinimumSupportedBuild() and (float(MD_REF.getBuild())) <= extInfo.getMaximumSupportedBuild()):  # noqa
                        continue
                    if not (extInfo.getMinimumSupportedBuild() >= 1000):
                        continue
                    if (extInfo.isMacSandboxFriendly() or not Platform.isMac() or not MD_REF.getPlatformHelper().isConstrainedToSandbox()):
                        pass
                    else:
                        continue
                    existingMod = None          # FeatureModule
                    for mod in installed:

                        # noinspection PyUnresolvedReferences
                        if mod.getIDStr().lower() == extInfo.getModuleID().lower():
                            existingMod = mod
                            break
                    isInstalled = (existingMod is not None)     # boolean
                    isUpdatable = (existingMod is not None and existingMod.getBuild() < extInfo.getBuild())
                    if existingMod and isInstalled and isUpdatable:

                        # noinspection PyUnresolvedReferences
                        miniUpdateList[extInfo.getModuleID().lower()] = [extInfo, isInstalled, isUpdatable]

            else:
                myPrint(u"J", u"ERROR - Failed to download module list!)")
        except:
            myPrint(u"B", u"ERROR decoding downloaded module list!)")
            dump_sys_error_to_md_console_and_errorlog()

        return miniUpdateList

    def get_register_txn_sort_orders():

        # Flush in memory settings to disk
        MD_REF.savePreferences()

        theSortData = []                                                                                                # noqa

        theSortData.append("VIEW REGISTER TXN SORT ORDERS (for Accounts - excluding legacy keys)")
        theSortData.append(" ==================================================================\n")

        theSortData.append("DEFAULTS (from config.dict)\n")

        for x in _COLWIDTHS:

            if      x == "bank":        theType = "Bank"
            elif    x == "cc":          theType = "Credit Card"
            elif    x == "invest":      theType = "Investment"
            elif    x == "loan":        theType = "Loan"
            elif    x == "security":    theType = "Security"
            elif    x == "misc":        theType = "Asset/Liability/Expense/Income/Other"
            elif    x == "rec_credits": theType = "Reconciling window - credits"
            elif    x == "rec_debits":  theType = "Reconciling window - debits"
            elif    x == "secdetail":   theType = "Security Detail"
            elif    x == "split":       theType = "Split Window"
            else:                       theType = "????"

            result = loadMDPreferences(None,x)
            if result:
                oneLineMode = result[0]
                splitReg    = result[1]
                splitSz     = result[2]
                sortID      = result[3]
                position    = result[4]
                ascending   = result[5]
                widths      = result[6]
                position2   = result[7]

                theSortData.append("\nType: %s (%s) Register Sort Data:"%(theType,x))
                theSortData.append(">> Sort Order: %s" %sortID)
                theSortData.append(">> Ascending: %s" %ascending)
                theSortData.append(">> One Line View: %s" %oneLineMode)
                theSortData.append(">> Split Register View: %s (%s)" %(splitReg,splitSz))
                theSortData.append(">> Position: %s Widths: %s Position2 %s\n" %(position, widths, position2))


        theSortData.append("\nDATA SAVED INTERNALLY BY (ACTIVE) ACCOUNT")
        theSortData.append("-----------------------------------------\n")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(1))
        for acct in accounts:

            for x in _COLWIDTHS:

                if      x == "bank":        theType = "Bank"
                elif    x == "cc":          theType = "Credit Card"
                elif    x == "invest":      theType = "Investment"
                elif    x == "loan":        theType = "Loan"
                elif    x == "security":    theType = "Security"
                elif    x == "misc":        theType = "Asset/Liability/Expense/Income/Other"
                elif    x == "rec_credits": theType = "Reconciling window - credits"
                elif    x == "rec_debits":  theType = "Reconciling window - debits"
                elif    x == "secdetail":   theType = "Security Detail"
                elif    x == "split":       theType = "Split Window"
                else:                       theType = "????"

                result = loadMDPreferences(acct,x, False)

                if result:
                    oneLineMode = result[0]
                    splitReg    = result[1]
                    splitSz     = result[2]
                    sortID      = result[3]
                    position    = result[4]
                    ascending   = result[5]
                    widths      = result[6]
                    position2   = result[7]

                    theSortData.append("\nAccount: %s Account Type: %s Key Type: %s (%s) Register Sort Data:"%(acct.getAccountName(), acct.getAccountType(),theType,x))
                    theSortData.append(">> Sort Order: %s" %sortID)
                    theSortData.append(">> Ascending: %s" %ascending)
                    theSortData.append(">> One Line View: %s" %oneLineMode)
                    theSortData.append(">> Split Register View: %s (%s)" %(splitReg,splitSz))
                    theSortData.append(">> Position: %s Widths: %s Position2 %s\n" %(position, widths, position2))

        theSortData.append("\n<END>")

        for i in range(0, len(theSortData)):
            theSortData[i] = theSortData[i] + "\n"
        theSortData = "".join(theSortData)

        QuickJFrame("Register TXN Sort Orders etc", theSortData, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def view_check_num_settings():
        try:
            from com.infinitekind.moneydance.model import CheckNumSettings
        except:
            txt = "Your version of MD is too early to use this function, must be at least Moneydance 2020.1 (1925)"
            setDisplayStatus(txt, "R")
            return

        theData = []                                                                                                    # noqa

        theData.append("CHECK NUMBER SETTINGS")
        theData.append(" =====================\n")

        acct = root = MD_REF.getCurrentAccountBook().getRootAccount()
        x = root.getCheckNumSettings(True)  # False means don't return defaults
        theData.append("\nMaster Dataset & defaults (root account): " + MD_REF.getCurrentAccountBook().getName())
        if not x:  # Assume old style check numbers
            theData.append(
                " >>Old style Check numbers as default: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
            theData.append("\n\n")
        else:
            theData.append(" >>Fixed Chq Items: %s" %(x.getPopupStrings()))
            theData.append(
                " >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
            y = x.getRecentsOption()

            # noinspection PyUnresolvedReferences
            if y == CheckNumSettings.IncludeRecentsOption.ACCOUNT: y = "Include from Same Account"
            elif y == CheckNumSettings.IncludeRecentsOption.GLOBAL: y = "Include from All Accounts"
            elif y == CheckNumSettings.IncludeRecentsOption.NONE: y = "Don't Include"

            theData.append(" >>Recent Entries:          %s" %(y))
            theData.append(" >>Max Entries:             %s" %(x.getMaximumRecents()))
            theData.append(" >>Show Next-Check Number:  %s" %(x.getIncludeNextCheckNumber()))
            theData.append(" >>Show Print-Check Option: %s" %(x.getIncludePrintCheckMarker()))
            theData.append("\n")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(3))

        for acct in accounts:

            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.ROOT: continue

            x = acct.getCheckNumSettings(False)  # False means don't return defaults

            if not x:
                theData.append("Account: " + acct.getFullAccountName() + " (Settings: NONE/Default)")
                theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))
                theData.append("\n")
            else:
                theData.append("Account: " + pad(acct.getFullAccountName(), 80))
                theData.append(" >>Fixed Chq Items: %s" %(x.getPopupStrings()))
                if acct.getAccountType() != Account.AccountType.ROOT:                                               # noqa
                    theData.append(" >>Complete list of all Items in Chq Popup: %s" %(MD_REF.getUI().getResources().getCheckNumberList(acct)))

                y = x.getRecentsOption()
                if y == CheckNumSettings.IncludeRecentsOption.ACCOUNT:                                              # noqa
                    y = "Include from Same Account"
                elif y == CheckNumSettings.IncludeRecentsOption.GLOBAL:                                             # noqa
                    y = "Include from All Accounts"
                elif y == CheckNumSettings.IncludeRecentsOption.NONE:                                               # noqa
                    y = "Don't Include"

                theData.append(" >>Recent Entries:          %s" %(y))
                theData.append(" >>Max Entries:             %s" %(x.getMaximumRecents()))
                theData.append(" >>Show Next-Check Number:  %s" %(x.getIncludeNextCheckNumber()))
                theData.append(" >>Show Print-Check Option: %s" %(x.getIncludePrintCheckMarker()))
                theData.append("\n")
                # CheckNumSettings.IncludeRecentsOption

        theData.append(("\n<END>"))

        # Build a quick virtual file of Memorized reports and graphs to display
        for i in range(0, len(theData)):
            theData[i] = theData[i] + "\n"
        theData = "".join(theData)
        QuickJFrame("View Check Number Settings:", theData, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    def isUserEncryptionPassphraseSet():
        try:
            keyFile = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), "key")
            keyInfo = SyncRecord()
            fin = FileInputStream(keyFile)
            keyInfo.readSet(fin)
            fin.close()
            return keyInfo.getBoolean("userpass", False)
        except: pass
        return False

    def isCachingPasswords():
        return (isUserEncryptionPassphraseSet() and MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage().getBoolean("store_passwords", False))

    def getMDEncryptionKey():

        try:
            keyFile = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), u"key")

            keyInfo = SyncRecord()
            fin = FileInputStream(keyFile)
            keyInfo.readSet(fin)
            fin.close()

            # noinspection PyUnresolvedReferences
            cipherLevel = LocalStorageCipher.MDCipherLevel.GOOD

            keyString=keyInfo.getString(u"key",None)
            test_with_random = u"E6520436865636B2C2062616279206F6E65203220312074776F4D6963726F7068306E6520436865636B204D6963723070686F6"
            y=StringUtils.decodeHex(test_with_random[int(len(test_with_random)/2):]+test_with_random[:int(len(test_with_random)/2)])
            z=""
            for x in y: z+=chr(x)
            newPassphrase = z
            encryptedKeyBytes = StringUtils.decodeHex(keyString)
            if keyInfo.getBoolean(u"userpass", False):
                newPassphrase = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
                if not newPassphrase:
                    return u"Not sure: Error retrieving your Encryption key!"
            try:

                # This next line triggers a message in the console error log file: "loading with 128 bit encryption key"
                myPrint(u"J",u"Checking encryption key....")
                key = LocalStorageCipher.encryptionKeyFromBytesAndPassword(encryptedKeyBytes, list(newPassphrase), cipherLevel)
                # cipher = LocalStorageCipher(key, cipherLevel)
            except:
                return u"Not sure: could not validate your encryption!"

            theFormat  = key.getFormat()
            theAlg = key.getAlgorithm()
        except:
            return u"Not sure: Error in decryption routine - oh well!!"


        return u"%s / %s" % (theFormat, theAlg)

    def check_dropbox_and_suppress_warnings():

        dataFile = MD_REF.getCurrentAccount().getBook().getRootFolder()
        suppressFile = File(dataFile, "suppress_file_in_dropbox_restriction.txt")

        fileIsUnderDropbox = False
        suppressionFileExists = suppressFile.exists()
        parent = dataFile
        while parent is not None:
            if "dropbox" in parent.getName().lower():
                fileIsUnderDropbox = True
                break
            parent = parent.getParentFile()

        return fileIsUnderDropbox, suppressionFileExists

    def isMulti_OFXLastTxnUpdate_build(): return (float(MD_REF.getBuild()) >= MD_MULTI_OFX_TXN_DNLD_DATES_BUILD)

    def OFX_view_all_last_txn_download_dates():
        accountsDL = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(21))
        accountsDL = sorted(accountsDL, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        outputDates = "\nBANK OFX: LAST DOWNLOADED TRANSACTION DATE(s)\n" \
                      "--------------------------------------------\n\n"

        if isMulti_OFXLastTxnUpdate_build():
            outputDates += "NOTE: Multiple OFXLastTxnUpdate dates (i.e. per OFX/MD+ connection) are possible with this build...\n\n"

        for acct in accountsDL:
            theOnlineTxnRecord = MyGetDownloadedTxns(acct)     # Use my version to prevent creation of default record(s)
            if theOnlineTxnRecord is None:
                humanReadableOFXLastTxnDate = "Never downloaded = 'Download all available dates'"
                outputDates += "%s %s %s\n" %(pad(repr(acct.getAccountType()),12),
                                              pad(acct.getFullAccountName(),40),
                                              humanReadableOFXLastTxnDate)
            else:
                #  Since build 4074, .getOFXLastTxnUpdate() can be multi connection... But prior is single (all with same key)
                for k in theOnlineTxnRecord.getParameterKeys():
                    if not k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE): continue
                    # theCurrentDate = theOnlineTxnRecord.getOFXLastTxnUpdate()
                    theCurrentDate = theOnlineTxnRecord.getLongParameter(k, 0)

                    if theCurrentDate != 0:
                        humanReadableOFXLastTxnDate = get_time_stamp_as_nice_text(theCurrentDate, lUseHHMMSS=False)
                    else:
                        if isMDPlusEnabledBuild():
                            humanReadableOFXLastTxnDate = "IS SET TO ZERO (MD will prompt for start date)"
                        else:
                            humanReadableOFXLastTxnDate = "IS SET TO ZERO = 'Download all available dates'"

                    outputDates += "%s %s %s %s\n" %(pad(repr(acct.getAccountType()),12),
                                                     pad(acct.getFullAccountName(),40),
                                                     humanReadableOFXLastTxnDate,
                                                     k[len(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):])

        outputDates += "\n<END>"
        QuickJFrame("OFX LAST DOWNLOAD DATES", outputDates,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False,lAutoSize=True).show_the_frame()

        txt = "OFX: All your last txn download txn dates have been retrieved and displayed...."
        setDisplayStatus(txt, "B")


    def OFX_view_reconcile_AsOf_Dates():

        # Code copied from com.moneydance.apps.md.view.gui.PreReconcilerWindow

        _THIS_METHOD_NAME = "OFX - View accounts' calculated reconcile 'as_of' dates".upper()
        _KEY_ASOF_PREF = "gen.rec_asof_enabled"

        output = "\n%s\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, ("-"*len(_THIS_METHOD_NAME)))

        allActiveAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(0))

        count = 0

        if len(allActiveAccounts) < 1:
            output += "No active Bank/Credit card/Investment accounts found\n\n"

        else:

            wait = MyPopUpDialogBox(toolbox_frame_,theStatus="PLEASE WAIT - CALCULATING THE AS_OF DATES...", theTitle="PLEASE WAIT",lModal=False)
            wait.go()

            if isMulti_OFXLastTxnUpdate_build():
                output += "NOTE: Multiple OFXLastTxnUpdate dates (i.e. per OFX/MD+ connection) are possible with this build...\n\n"

            output += "Processing %s active accounts\n\n" %(len(allActiveAccounts))
            output += "Diagnosing the Reconcile: as_of date:\n\n"

            MD_decimal = MD_REF.getPreferences().getDecimalChar()

            for acct in allActiveAccounts:
                txns = acct.getDownloadedTxns()

                if acct.getPreference(_KEY_ASOF_PREF, None) is None:
                    asOfPref = "<not set>"  # Deliberately find out if not set
                else:
                    asOfPref = acct.getPreferenceBoolean(_KEY_ASOF_PREF, True)

                lastUpdate = txns.getOnlineLedgerBalanceDate()

                val_ledgerDate = txns.getOnlineLedgerBalanceDate()

                val_lastTxnUpdateDate = txns.getMostRecentTxnUpdate() if isMulti_OFXLastTxnUpdate_build() else txns.getOFXLastTxnUpdate()

                if lastUpdate == 0:
                    lastUpdate = txns.getMostRecentTxnUpdate() if isMulti_OFXLastTxnUpdate_build() else txns.getOFXLastTxnUpdate()

                OFXLastTxnUpdate_dates = []
                if isMulti_OFXLastTxnUpdate_build():
                    for k in txns.getParameterKeys():
                        if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                            value = txns.getLongParameter(k, 0)
                            OFXLastTxnUpdate_dates.append([k, "<not set>" if value == 0 else get_time_stamp_as_nice_text(value, lUseHHMMSS=False)])

                tset = acct.getBook().getTransactionSet()

                # This is the moneydance code
                if lastUpdate == 0:
                    txnDate = 0
                    for txn in tset.iterableTxns():
                        if not acct.isAncestorOf(txn.getAccount()): continue
                        if txn.getDateInt() <= txnDate or not TxnUtil.wasTxnDownloaded(txn): continue
                        txnDate = txn.getDateInt()
                    if txnDate != 0:
                        lastUpdate = Util.convertIntDateToLong(txnDate).getTime()

                # Do it again so we can show the last txn date too
                txnDate = 0
                txnLastUpdate = None
                for txn in tset.iterableTxns():
                    if not acct.isAncestorOf(txn.getAccount()): continue
                    if txn.getDateInt() <= txnDate or not TxnUtil.wasTxnDownloaded(txn): continue
                    txnDate = txn.getDateInt()
                if txnDate != 0:
                    txnLastUpdate = Util.convertIntDateToLong(txnDate).getTime()

                hasAsOfOption = lastUpdate != 0
                if not hasAsOfOption: continue
                asOfEnabled = True
                asOfDate = lastUpdate
                asOfEndBalance = txns.getOnlineLedgerBalance()
                count += 1

                output += "Account: %s\n" %(acct.getFullAccountName())
                output += "   as_of enabled:           %s\n" %(safeStr(asOfEnabled))
                output += "   calculated 'as_of' date: %s\n" %(get_time_stamp_as_nice_text(asOfDate, lUseHHMMSS=False))
                output += "   as_of end balance:       %s\n" %("" if asOfEndBalance == 0 else rpad(acct.getCurrencyType().formatFancy(asOfEndBalance,MD_decimal),10))
                output += "         as_of Preference:                 %s\n" %(pad(asOfPref,9))
                output += "         OFXLedgerDate:                    %s\n" %("" if val_ledgerDate == 0 else get_time_stamp_as_nice_text(val_ledgerDate, lUseHHMMSS=False))
                output += "         Most Recent Downloaded Txn Date:  %s\n" %("" if txnLastUpdate == 0 else get_time_stamp_as_nice_text(txnLastUpdate, lUseHHMMSS=False))

                if isMulti_OFXLastTxnUpdate_build():
                    output += "         Most recent OFXLastTxnUpdateDate: %s\n" %("" if val_lastTxnUpdateDate == 0 else get_time_stamp_as_nice_text(val_lastTxnUpdateDate, lUseHHMMSS=False))
                else:
                    output += "         OFXLastTxnUpdateDate:             %s\n" %("" if val_lastTxnUpdateDate == 0 else get_time_stamp_as_nice_text(val_lastTxnUpdateDate, lUseHHMMSS=False))

                for k,v in OFXLastTxnUpdate_dates:
                    output += "         ... Multi keys found:             %s %s\n" %(v, k)

                output += "\n"

            wait.kill()

        if count < 1:
            output += "No enabled as_of dates were detected\n\n"
        else:
            output += "To zap the OFXLedgerDate, use Toolbox>Online Banking (OFX) Tools Menu\n" \
                      "                          option 'Delete Single cached OnlineTxnList Record/Txns'\n" \
                      "                          and delete whole record\n\n" \
                      "To change OFXLastTxnDownloadDate, use Toolbox>Update OFX Last Txn Update Date (Downloaded) field for an account\n" \
                      "                          and edit the date (or if available Toolbox>Reset ALL OFX Last Txn Update Dates)\n\n"

        output += "\n<END>"

        QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

        txt = "OFX: Your active accounts' calculated reconcile as_of dates have been displayed...."
        setDisplayStatus(txt, "B")


    def OFX_view_CUSIP_settings():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "OFX: View Security's hidden CUSIP settings"

        PARAM_CURRID = "curr_id."

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, " "*len(_THIS_METHOD_NAME))

        output += "The hidden link between your Financial Institution Investment Securities and your MD Securities when downloading\n" \
                  "is stored as a hidden setting against your security in a key known as the CUSIP. For USA Customers this is the USA\n" \
                  "standard called CUSIP and all Securities have a unique number. In other markets this might be called ISIN for example.\n" \
                  "When matching Securities on Download, this setting needs to be blank or match the CUSIP. Your OFX download will contain\n" \
                  "the tags '<UNIQUEIDTYPE>' (which normally contains 'CUSIP') and '<UNIQUEID>' (which contains the CUSIP number).\n" \
                  "If your MD Security already contains a different CUSIP number, then it will NOT appear in the match list.\n" \
                  "You can edit your hidden CUSIP data in Update Mode.\n\n"

        output += " SECURITIES\n" \
                  " ==========\n\n"

        output += "%s %s %s %s %s\n" % (pad("Security", 45),
                                        pad("ID", 15),
                                        pad("Ticker Symbol", 15),
                                        pad("SCHEME", 12),
                                        pad("IDENTIFIER (CUSIP)", 20))

        output += "%s %s %s %s %s\n" % ("-" * 45,
                                        "-" * 15,
                                        "-" * 15,
                                        "-" * 12,
                                        "-" * 20)

        output += "\n"

        securities = sorted(MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies(),
                            key=lambda x: (x.getCurrencyType(), x.getName().upper()))

        iCountFound = 0
        for sec in securities:
            if sec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                       # noqa
            for key in sec.getParameterKeys():

                if key.startswith(PARAM_CURRID):

                    theScheme = key[len(PARAM_CURRID):]
                    theCUSIP = sec.getIDForScheme(theScheme)

                    if not theCUSIP: raise Exception("ERROR: %s - empty CUSIP returned? Security: %s, Scheme: %s" %(_THIS_METHOD_NAME, sec, theScheme))

                    iCountFound += 1
                    output += "%s %s %s %s %s %s %s\n" % (pad(sec.getName(), 45),
                                                    pad(sec.getIDString(), 15),
                                                    pad(sec.getTickerSymbol(), 15),
                                                    pad(theScheme, 12),
                                                    theCUSIP,
                                                    ("** CUSIP & TICKER ARE DIFFERENT **" if (theCUSIP.strip() != sec.getTickerSymbol().strip()) else (""*34)),
                                                    ("id: "+sec.getUUID() if (debug) else ("")))

        if not iCountFound:
            output += "\nNONE FOUND!\n"
        else:
            output += "\n\n%s Security hidden CUSIP record(s) found\n" %(iCountFound)

        output += "\n<END>"

        QuickJFrame(_THIS_METHOD_NAME.upper(), output,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False,lAutoSize=True).show_the_frame()

        txt = "OFX: Your Security's hidden CUSIP settings have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    def OFX_view_online_txns_payees_payments():

        _OBJOFXTXNS     =  0
        _OBJOFXOLPAYEES =  1
        _OBJOFXOLPAYMNT =  2

        objWhat = [
                    "OFX Online Transactions",                  # onlineTxnList             "oltxns"
                    "OFX Online Payees",                        # onlinePayeeList           "olpayees"
                    "OFX Online Payments"                       # onlinePaymentList         "olpmts"
            ]

        selectedAcct = None
        selectedObject = None
        textType = ""

        while True:

            selectedObjType = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the type of Online data you want to view",
                                                       "OFX View Online Data",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       objWhat,
                                                       None)
            if not selectedObjType:
                txt = "No online data type was selected to view .."
                setDisplayStatus(txt, "R")
                return

            if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(16))
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(17))
            else: continue

            accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))
            selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Acct to view Online Data:",
                                                       "Select ACCOUNT",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       accountsListForOlTxns,
                                                       None)  # type: Account
            if not selectedAcct: continue

            textType = ""
            if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                selectedObject = MyGetDownloadedTxns(selectedAcct)           # Use my version to prevent creation of default record(s)
                textType = "Online Txns"
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                selectedObject = MyGetOnlinePayees(selectedAcct)             # Use my version to prevent creation of default record(s)
                textType = "Online Payees"
            elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                selectedObject = MyGetOnlinePayments(selectedAcct)           # Use my version to prevent creation of default record(s)
                textType = "Online Payments"
            else: continue

            break

        output = "VIEW SAVED ONLINE DATA: %s\n" \
                 " ===================================\n\n" %(textType.upper())

        output += "Object Type: %s\n\n" %(type(selectedObject))

        # noinspection PyUnresolvedReferences
        output += "Linked Account Type: %s Acct Name: %s\n" %(selectedAcct.getAccountType(), selectedAcct.getFullAccountName())

        if isinstance(selectedObject, OnlineTxnList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlineTxnList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getTxnCount():",50),                        selectedObject.getTxnCount()  )
            output += "%s %s\n" % (pad("hasOnlineAvailBalance():",50),              selectedObject.hasOnlineAvailBalance()  )
            output += "%s %s\n" % (pad("getOnlineAvailBalance():",50),              selectedObject.getOnlineAvailBalance()  )
            output += "%s %s (%s)\n" % (pad("getOnlineAvailBalanceDate():",50),     selectedObject.getOnlineAvailBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineAvailBalanceDate()))  )
            output += "%s %s\n" % (pad("hasOnlineLedgerBalance():",50),             selectedObject.hasOnlineLedgerBalance()  )
            output += "%s %s\n" % (pad("getOnlineLedgerBalance():",50),             selectedObject.getOnlineLedgerBalance()  )
            output += "%s %s (%s)\n" % (pad("getOnlineLedgerBalanceDate():",50),    selectedObject.getOnlineLedgerBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineLedgerBalanceDate()))  )

            if isMulti_OFXLastTxnUpdate_build():
                output += "%s %s (%s)\n" % (pad("getMostRecentTxnUpdate():",50),
                                            selectedObject.getMostRecentTxnUpdate(),
                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getMostRecentTxnUpdate()))  )
                for k in selectedObject.getParameterKeys():
                    if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                        value = selectedObject.getLongParameter(k, 0)
                        output += "... Key: %s %s (%s)\n" %(pad(k,75), value, convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(value)))
            else:
                output += "%s %s (%s)\n" % (pad("getOFXLastTxnUpdate():",50),
                                            selectedObject.getOFXLastTxnUpdate(),
                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOFXLastTxnUpdate()))  )

        if isinstance(selectedObject, OnlinePayeeList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlinePayeeList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getPayeeCount():",50),             selectedObject.getPayeeCount()  )

        if isinstance(selectedObject, OnlinePaymentList):
            output += "\n\nMD User Representation of Data Held by this Account/OnlinePaymentList record:\n"
            output += " ==========================================================================  \n"
            output += "%s %s\n" % (pad("getPaymentCount():",50),           selectedObject.getPaymentCount()  )

        output+="\n"

        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
            if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

        keys = sorted(selectedObject.getParameterKeys())
        for theKey in keys:
            # noinspection PyUnresolvedReferences
            value = selectedObject.getParameter(theKey)
            output += pad("Key:%s" %theKey,50)+" Value: '%s'\n" %(value.strip())

        output+="\n\n<END>"

        QuickJFrame("VIEW SAVED ONLINE DATA",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        txt = "OFX: Your Online saved Txns, Payees, Payments have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    # replicates com.moneydance.apps.md.view.gui.MDAccountProxy.getAccountKey()
    def my_get_account_key(acct):
        acctNum = acct.getAccountNum()
        if acctNum <= 0:
            return acct.getUUID()
        return str(acctNum)

    def redactor(_what, lRedactFirstChar=False):
        # type: (str, bool) -> str
        if not GlobalVars.redact: return _what
        if not isinstance(_what, (str, unicode)): _what = safeStr((_what))
        #_what = _what.strip()
        if lRedactFirstChar:
            keepFirstChar = False
        else:
            keepFirstChar = (len(_what) > 1)
        return (_what[:1] if keepFirstChar else "") + ("*" * (len(_what) - (1 if keepFirstChar else 0)))

    def redactAuth(originalAuthToRedact):
        if GlobalVars.redact:
            saveAuthKey = MyOFXAuthInfo.fromCacheString(originalAuthToRedact)
            redactedAuthKey = MyOFXAuthInfo(redactor(saveAuthKey.getUserId()), redactor(saveAuthKey.getPasswd()), saveAuthKey.getExtraAuth(), None, saveAuthKey.getAuthType())
            originalAuthToRedact = redactedAuthKey.toCacheString()
        return originalAuthToRedact

    def ofx_view_service_profile_data():

        _THIS_METHOD_NAME = "OFX: View your installed Bank / Service Profiles"

        OFX = []

        lCachePasswords = isCachingPasswords()

        GlobalVars.redact = myPopupAskQuestion(toolbox_frame_, _THIS_METHOD_NAME, "Redact confidential information?")

        OFX.append("VIEW YOUR INSTALLED OFX SERVICE / BANK LOGON PROFILES\n"
                   " ====================================================\n\n")

        if GlobalVars.redact:
            OFX.append("** Confidential data will be redacted **\n")
        else:
            OFX.append("** WARNING: Confidential data will be visible **\n")

        if lCachePasswords:
            OFX.append("MD Will allow you to Cache your Authentication (means you have set an encryption key and selected store passwords..")
        else:
            OFX.append("MD Cache Authentication ** DISABLED ** (either no user encryption key or store passwords = no)")

        OFX.append("")

        if not isMDPlusEnabledBuild() and getPlaidService():
            OFX.append("NOTE: Account linkages for MD+/Plaid Services may be incomplete as you are running an older version of Moneydance...!\n")

        # Build a list of Moneydance accounts that are enabled for download and have a service profile linked....
        listAccountMDProxies=[]
        olAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(11))
        if len(olAccounts) > 0:
            for acctObj in olAccounts:
                acct = acctObj                                 # type: Account
                svcBank = acct.getBankingFI()                  # type: OnlineService
                svcBP = acct.getBillPayFI()                    # type: OnlineService
                if acct.getBankingFI() is not None:
                    listAccountMDProxies.append([MDAccountProxy(acct, False),svcBank,False])
                if acct.getBillPayFI() is not None:
                    listAccountMDProxies.append([MDAccountProxy(acct, True),svcBP,True])

        OFX.append("MD Accounts enabled for OFX Downloads with linked Service / Bank logon profiles:")
        if len(listAccountMDProxies)<1:
            OFX.append("<NONE FOUND>")
        else:
            for olAcct in listAccountMDProxies:
                if not olAcct[2]:
                    OFX.append("- {:40} ('Key': {:15}) OFXAccNum: {:15} Bank Profile: {}".format(olAcct[0].getAccount().getFullAccountName(), olAcct[0].getAccountKey(), redactor(olAcct[0].getOFXAccountNumber()), olAcct[1]))
                else:
                    OFX.append("- {:40} ('Key': {:15}) OFXAccNum: {:15} BillPay Prof: {}".format(olAcct[0].getAccount().getFullAccountName(), olAcct[0].getAccountKey(), redactor(olAcct[0].getOFXAccountNumber()), olAcct[1]))
        OFX.append("")

        if isMDPlusEnabledBuild() and isMDPlusUniqueBankingServicesEnabledBuild():
            OFX.append("MD Accounts >> listing enabled banking services per account:")
            if len(olAccounts) < 1:
                OFX.append("<NONE FOUND>")
            else:
                for acctObj in olAccounts:
                    gbs = acctObj.getBankingServices()
                    if gbs.size() < 1: continue
                    for bs in gbs:
                        OFX.append("- Account: {:40} Banking Service (out of {}) {:40}".format(acctObj.getFullAccountName(),
                                                                                               gbs.size(),
                                                                                               bs.getService()))
        OFX.append("")

        for service in MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices():

            # Find the MD accounts specifically linked to this service profile
            thisServiceMDAccountProxies=[]
            for olacct in listAccountMDProxies:
                if olacct[1] == service:
                    thisServiceMDAccountProxies.append(olacct)

            OFX.append(" ================================================================================================================================================")
            OFX.append(" ================================================================================================================================================")
            OFX.append(pad("Service/Profile:".upper(),40)       + safeStr(service))
            OFX.append(pad("----------------",40))
            OFX.append(pad(">>Moneydance TIK Service ID:",40)   + safeStr(service.getTIKServiceID()))
            OFX.append(pad(">>Profile's UUID:",40)              + safeStr(service.getUUID()))
            if isMDPlusEnabledBuild():
                OFX.append(pad(">>Protocol:",40)                + safeStr(service.getProtocol()))
                OFX.append(pad(">>isMoneydancePlusService:",40) + safeStr(service.isMoneydancePlusService()))
            OFX.append(pad(">>OFX Version:",40)                 + safeStr(service.getOFXVersion()))
            OFX.append(pad(">>Service Id:",40)                  + safeStr(service.getServiceId()))
            OFX.append(pad(">>Service Type:",40)                + safeStr(service.getServiceType()))
            OFX.append(pad(">>Realms:",40)                      + safeStr(service.getRealms()))
            OFX.append(pad(">>Bootstrap URL:",40)               + safeStr(service.getBootstrapURL()))

            OFX.append(pad(">>Needs FI Profile Check()?:",40)   + safeStr(service.needsFIProfileCheck()))

            mappingObject = None                                                                                        # noqa
            if isMDPlusEnabledBuild():
                OFX.append(pad("\n>>MD2022+ Online Banking Mapping table entries...:",120))
                mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")
                if mappingObject is not None:
                    OFX.append(special_toMultilineHumanReadableString(mappingObject,lSkipSecrets=GlobalVars.redact,sFilterServiceID=service.getTIKServiceID(),lRedact=GlobalVars.redact))
                else: OFX.append("<NONE>")
            del mappingObject

            if service.getTIKServiceID() == "md:plaid":
                tokens = MD_REF.getCurrentAccountBook().getLocalStorage().getSublist("access_tokens")
                OFX.append(pad("\n>>Moneydance+ Access Tokens (local storage 'access_tokens')...:",120))
                if len(tokens) > 0:
                    for token in tokens:
                        for token_key in token:
                            txtAppendTxt = "(Confidential: '_payloadid', 'timestamp', 'token' values have been hidden for security reasons)"
                            if token_key != "item": continue
                            OFX.append("Key: %s AccountRef: %s %s" %(token_key, token.get(token_key), txtAppendTxt if GlobalVars.redact else token))
                else:
                    OFX.append("<NONE>")
                del tokens

                mdp_cache = MD_REF.getCurrentAccountBook().getLocalStorage().getSubset("mdp_items")
                OFX.append(pad("\n>>Moneydance+ Plaid Cache (local storage 'mdp_items')...:",120))
                if len(mdp_cache) > 0:
                    for cacheItem in mdp_cache:
                        OFX.append("Key: %s Value: %s" %(cacheItem, mdp_cache.get(cacheItem)))
                else:
                    OFX.append("<NONE>")
                del mdp_cache

                if not GlobalVars.redact:
                    # This will not disconnect anything, just reproduce the md+ connection information...
                    OFX.append(forceDisconnectMDPlusConnection(lReturnConnectionInfoOnly=True))

            OFX.append(pad("\n>>Accounts configured within bank profile:",120))
            if len(service.getAvailableAccounts())<1:
                OFX.append("<NONE FOUND>")
            else:
                _availableAccounts = service.getAvailableAccounts()
                if GlobalVars.redact:
                    _redactedAvailableAccounts = "["
                    onAccount = 0
                    for _aa in _availableAccounts:
                        if onAccount > 0: _redactedAvailableAccounts += ", "
                        _redactedAvailableAccounts += (_aa.getDescription() + " " + redactor(_aa.getAccountNumber().strip()))
                        onAccount += 1
                    _redactedAvailableAccounts += "]"
                    OFX.append(" -- List All accounts configured in profile: %s\n" %(_redactedAvailableAccounts))
                else:
                    OFX.append(" -- List All accounts configured in profile: %s\n" %(service.getAvailableAccounts()))

                for availAccount in service.getAvailableAccounts():
                    OFX.append(">> ACCOUNT: %s (%s) ('Key': %s)" %(availAccount.getDescription(),redactor(availAccount.getAccountNumber()),availAccount.getAccountKey()))

                    if service.getTIKServiceID() != "md:plaid":         # Don't bother with MD+ as these are all empty anyway...
                        try:
                            # Rather than listing all methods by hand, just iterate and call them all.. I have checked they are all safe...
                            meths = availAccount.getClass().getDeclaredMethods()
                            for meth in meths:
                                if not Modifier.isPublic(meth.getModifiers()): continue
                                if meth.getName().lower().startswith("get") or meth.getName().lower().startswith("is") \
                                        and meth.getParameterCount() < 1:
                                    result = meth.invoke(availAccount)
                                    if GlobalVars.redact:
                                        for checkKey in ["mapping", "balance", "number", "key"]:
                                            if checkKey in meth.getName().lower():
                                                result = redactor(result)
                                                break
                                    if result is not None:
                                        OFX.append(" >> %s %s" %(pad(meth.getName(), 40),result) )
                            OFX.append("\n")
                        except:
                            pass

            OFX.append("")

            OFX.append(pad("\n>>MD Accounts linked to this service / bank profile:",120))
            if len(thisServiceMDAccountProxies)<1:
                OFX.append("<NONE FOUND>")
            else:
                for olacct in thisServiceMDAccountProxies:
                    if not olacct[2]:
                        OFX.append(" >> Banking: %s ('Key': %s) (OfxAcctNum: %s)" %(olacct[0].getAccount().getFullAccountName(), olacct[0].getAccountKey(), redactor(olacct[0].getOFXAccountNumber())))
                    else:
                        OFX.append(" >> BillPay: %s ('Key': %s) (OfxAcctNum: %s)" %(olacct[0].getAccount().getFullAccountName(), olacct[0].getAccountKey(), redactor(olacct[0].getOFXAccountNumber())))

            OFX.append("")

            if service.getTIKServiceID() != "md:plaid":         # Don't bother with MD+ as these are all empty anyway...
                try:
                    authenticationCachePrefix = invokeMethodByReflection(service, "getAuthenticationCachePrefix", None)
                    OFX.append(pad("AuthenticationCachePrefix:",33) + (safeStr(authenticationCachePrefix)))

                    sessionCookiePrefix = invokeMethodByReflection(service, "getSessionCookiePrefix", None)
                    OFX.append(pad("SessionCookiePrefix:",33) + (safeStr(sessionCookiePrefix)))
                except:
                    myPrint("B", "ERROR: getting getAuthenticationCachePrefix() or getSessionCookiePrefix()... (continuing)")
                    dump_sys_error_to_md_console_and_errorlog()

                OFX.append(pad("\n>>ROOT Data associated with service profile:",120))
                authKeyPrefix = "ofx.client_uid"
                root = MD_REF.getRootAccount()
                iCount = 0
                for rk in list(root.getParameterKeys()):
                    if rk.startswith(authKeyPrefix) and (service.getTIKServiceID() in rk):
                        rk_redact = rk
                        val_redact = root.getParameter(rk)
                        if GlobalVars.redact:
                            redactSearch = authKeyPrefix+"::"+service.getTIKServiceID()+"::"
                            if rk.startswith("ofx.client_uid_default_user::"):
                                val_redact = redactor(val_redact)
                            elif rk.startswith(redactSearch):
                                rk_redact = rk[:len(redactSearch)] + redactor(rk[len(redactSearch):])
                        OFX.append("Root key: '%s' value: '%s'" %(rk_redact, val_redact))
                        iCount += 1
                if not iCount: OFX.append("<NONE>")
                del root, iCount, authKeyPrefix

                OFX.append(pad("\n>>REALMs configured:",120))
                realmsToCheck = service.getRealms()
                if "DEFAULT" not in realmsToCheck:
                    realmsToCheck.insert(0,"DEFAULT")

                for realm in realmsToCheck:

                    realmUserID = service.getUserId(realm, None)
                    if realmUserID is not None and realmUserID != "":
                        OFX.append("Realm: %s User ID: %s" %(realm, redactor(service.getUserId(realm, None))))

                    for olacct in thisServiceMDAccountProxies:

                        userID = service.getUserId(realm, olacct[0])
                        if userID is not None and userID != "":
                            OFX.append("Realm: %s Account's UserID: %s" %(realm, redactor(userID)))

                        if not lCachePasswords:
                            OFX.append("** NOTE: Any Cached Authentication Keys listed below will not be saved when you exit **")

                        authKey = "ofx:" + realm
                        authObj = service.getCachedAuthentication(authKey)
                        if authObj is not None and authObj != "":
                            OFX.append("Realm: %s Cached Authentication: %s" %(realm, redactAuth(authObj)))

                        authKey = "ofx:" + (realm + "::" + olacct[0].getAccountKey())
                        authObj = service.getCachedAuthentication(authKey)
                        if authObj is not None and authObj != "":
                            OFX.append("Realm: %s Account Key: %s (Key: %s / AccNum: %s) Cached Authentication: %s" %(realm, olacct[0].getAccountKey(), olacct[0].getOFXAccountKey(), redactor(olacct[0].getOFXAccountNumber()), redactAuth(authObj)))

                        if service.getSessionCookie(userID) is not None:
                            OFX.append("Session Cookie: %s" %(service.getSessionCookie(userID)))

                OFX.append("getFIId()                        %s" %(service.getFIId()                             ))
                if service.getUpdatedFIId() != service.getFIId():
                    OFX.append("getUpdatedFIId()             %s" %(service.getUpdatedFIId()                      ))
                OFX.append("getFIName()                      %s" %(service.getFIName()                           ))
                OFX.append("getFIOrg()                       %s" %(service.getFIOrg()                            ))
                if service.getUpdatedFIOrg() != service.getUpdatedFIOrg():
                    OFX.append("getUpdatedFIOrg()            %s" %(service.getUpdatedFIOrg()                     ))
                OFX.append("usesFITag()                      %s" %(service.usesFITag()                           ))
                OFX.append("usesPTTAcctIDField()             %s" %(service.usesPTTAcctIDField()                  ))
                OFX.append("getFIUrl()                       %s" %(service.getFIUrl()                            ))
                OFX.append("getFIUrlIsRedirect()             %s" %(service.getFIUrlIsRedirect()                  ))

                OFX.append("getIgnoreTxnsBeforeLastUpdate()  %s" %(service.getIgnoreTxnsBeforeLastUpdate()       ))

                OFX.append("getTxnDownloadOverlap()          %s" %(service.getTxnDownloadOverlap()               ))
                OFX.append("getDateAvailAcctsUpdated()       %s" %(service.getDateAvailAcctsUpdated()            ))
                OFX.append("getAlwaysSendDateRange()         %s" %(service.getAlwaysSendDateRange()              ))


                OFX.append("getUseProfileRequest()           %s" %(service.getUseProfileRequest()                ))
                OFX.append("getUseClientSpecificUIDS()       %s" %(service.getUseClientSpecificUIDS()            ))
                OFX.append("getUseFileUIDs()                 %s" %(service.getUseFileUIDs()                      ))
                OFX.append("getUseBPFileUIDs()               %s" %(service.getUseBPFileUIDs()                    ))
                OFX.append("useTerribleTLSV1Hack()           %s" %(service.useTerribleTLSV1Hack()                ))
                OFX.append("getFIEmail()                     %s" %(service.getFIEmail()                          ))
                OFX.append("getTechServicePhone()            %s" %(service.getTechServicePhone()                 ))

                OFX.append("getInvstBrokerID()               %s" %(service.getInvstBrokerID()                    ))

                OFX.append("usesBillPayExtendedAcctTo()      %s" %(service.usesBillPayExtendedAcctTo()           ))

                OFX.append("getServiceType()                 %s" %(service.getServiceType()                      ))

                OFX.append("getUseShortDates()               %s" %(service.getUseShortDates()                    ))
                OFX.append("shouldDecrementLastTxnDate()     %s" %(service.shouldDecrementLastTxnDate()          ))

                OFX.append("getSignupAcctsAvail()            %s" %(service.getSignupAcctsAvail()                 ))
                OFX.append("getSignupCanActivateAcct()       %s" %(service.getSignupCanActivateAcct()            ))
                OFX.append("getSignupCanChgUserInfo()        %s" %(service.getSignupCanChgUserInfo()             ))
                OFX.append("getSignupCanPreauth()            %s" %(service.getSignupCanPreauth()                 ))
                OFX.append("getSignupClientAcctNumReq()      %s" %(service.getSignupClientAcctNumReq()           ))
                OFX.append("getSignupViaClient()             %s" %(service.getSignupViaClient()                  ))
                OFX.append("getSignupViaOther()              %s" %(service.getSignupViaOther()                   ))
                OFX.append("getSignupViaOtherMsg()           %s" %(service.getSignupViaOtherMsg()                ))
                OFX.append("getSignupViaWeb()                %s" %(service.getSignupViaWeb()                     ))
                OFX.append("getSignupViaWebUrl()             %s" %(service.getSignupViaWebUrl()                  ))
                OFX.append("getStopChkCanUseDescription()    %s" %(service.getStopChkCanUseDescription()         ))
                OFX.append("getStopChkCanUseRange()          %s" %(service.getStopChkCanUseRange()               ))
                OFX.append("getStopChkFee()                  %s" %(service.getStopChkFee()                       ))
                OFX.append("getStopChkProcessingDaysOff()    %s" %(service.getStopChkProcessingDaysOff()         ))
                OFX.append("getStopChkProcessingEndTime()    %s" %(service.getStopChkProcessingEndTime()         ))

                for x in service.getRealms():
                    OFX.append("getClientIDRequired(x)           %s" %(service.getClientIDRequired(x)             ))
                    OFX.append("getUserCanChangePIN(x)           %s" %(service.getUserCanChangePIN(x)             ))
                    OFX.append("getMaxPasswdLength(x)            %s" %(service.getMaxPasswdLength(x)              ))
                    OFX.append("getMinPasswdLength(x)            %s" %(service.getMinPasswdLength(x)              ))
                    OFX.append("getMustChngPINFirst(x)           %s" %(service.getMustChngPINFirst(x)             ))
                    OFX.append("getPasswdCanHaveSpaces(x)        %s" %(service.getPasswdCanHaveSpaces(x)          ))
                    OFX.append("getPasswdCanHaveSpecialChars(x)  %s" %(service.getPasswdCanHaveSpecialChars(x)    ))
                    OFX.append("getPasswdCaseSensitive(x)        %s" %(service.getPasswdCaseSensitive(x)          ))
                    OFX.append("getPasswdCharType(x)             %s" %(service.getPasswdCharType(x)               ))
                    OFX.append("getPasswdType(x)                 %s" %(service.getPasswdType(x)                   ))

                OFX.append("getDateUpdated()                 %s (%s)" %(service.getDateUpdated(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(service.getDateUpdated()))))
                OFX.append("getLastTransactionID()           %s" %(service.getLastTransactionID()                  ))
                OFX.append("getMaxFITIDLength()              %s" %(service.getMaxFITIDLength()                     ))
                OFX.append("getInvalidAcctTypes()            %s" %(service.getInvalidAcctTypes()                   ))

                for msgType in (0,1,3,4,5,6,7,8,9,10,11,12):
                    if service.supportsMsgSet(msgType) or msgType == 0:
                        tag = invokeMethodByReflection(service, "getMsgSetTag", [Integer.TYPE], [msgType])
                        OFX.append("---")
                        OFX.append("  Supports Message Tag:            %s" %(tag))
                        OFX.append("  getMsgSetLanguage(msgType)       %s" %(service.getMsgSetLanguage(msgType)             ))
                        OFX.append("  getMsgSetRspnsFileErrors(msgType)%s" %(service.getMsgSetRspnsFileErrors(msgType)      ))
                        OFX.append("  getMsgSetSecurity(msgType)       %s" %(service.getMsgSetSecurity(msgType)             ))
                        OFX.append("  getMsgSetSignonRealm(msgType)    %s" %(service.getMsgSetSignonRealm(msgType)          ))
                        OFX.append("  getMsgSetSyncMode(msgType)       %s" %(service.getMsgSetSyncMode(msgType)             ))
                        OFX.append("  getMsgSetTransportSecure(msgType)%s" %(service.getMsgSetTransportSecure(msgType)      ))
                        OFX.append("  getMsgSetURL(msgType)            %s" %(service.getMsgSetURL(msgType)                  ))
                        OFX.append("  getMsgSetVersion(msgType)        %s" %(service.getMsgSetVersion(msgType)              ))

                OFX.append("---")

                OFX.append("getCreditCardClosingAvail()      %s" %(service.getCreditCardClosingAvail()           ))
                OFX.append("getCustServicePhone()            %s" %(service.getCustServicePhone()                 ))
                OFX.append("getBankClosingAvail()            %s" %(service.getBankClosingAvail()                 ))
                OFX.append("getBankXfrCanModifyModels()      %s" %(service.getBankXfrCanModifyModels()           ))
                OFX.append("getBankXfrCanModifyTransfers()   %s" %(service.getBankXfrCanModifyTransfers()        ))
                OFX.append("getBankXfrCanScheduleRecurring() %s" %(service.getBankXfrCanScheduleRecurring()      ))
                OFX.append("getBankXfrCanScheduleTransfers() %s" %(service.getBankXfrCanScheduleTransfers()      ))
                OFX.append("getBankXfrDaysWithdrawn()        %s" %(service.getBankXfrDaysWithdrawn()             ))
                OFX.append("getBankXfrDefaultDaysToPay()     %s" %(service.getBankXfrDefaultDaysToPay()          ))
                OFX.append("getBankXfrModelWindow()          %s" %(service.getBankXfrModelWindow()               ))
                OFX.append("getBankXfrNeedsTAN()             %s" %(service.getBankXfrNeedsTAN()                  ))
                OFX.append("getBankXfrProcessingDaysOff()    %s" %(service.getBankXfrProcessingDaysOff()         ))
                OFX.append("getBankXfrProcessingEndTime()    %s" %(service.getBankXfrProcessingEndTime()         ))
                OFX.append("getBankXfrSupportsDTAvail()      %s" %(service.getBankXfrSupportsDTAvail()           ))
                OFX.append("getBillPayCanAddPayee()          %s" %(service.getBillPayCanAddPayee()               ))
                OFX.append("getBillPayCanModPayments()       %s" %(service.getBillPayCanModPayments()            ))
                OFX.append("getBillPayDaysWithdrawn()        %s" %(service.getBillPayDaysWithdrawn()             ))
                OFX.append("getBillPayDefaultDaysToPay()     %s" %(service.getBillPayDefaultDaysToPay()          ))
                OFX.append("getBillPayHasExtendedPmt()       %s" %(service.getBillPayHasExtendedPmt()            ))
                OFX.append("getBillPayNeedsTANPayee()        %s" %(service.getBillPayNeedsTANPayee()             ))
                OFX.append("getBillPayNeedsTANPayment()      %s" %(service.getBillPayNeedsTANPayment()           ))
                OFX.append("getBillPayPostProcessingWindow() %s" %(service.getBillPayPostProcessingWindow()      ))
                OFX.append("getBillPayProcessingDaysOff()    %s" %(service.getBillPayProcessingDaysOff()         ))
                OFX.append("getBillPayProcessingEndTime()    %s" %(service.getBillPayProcessingEndTime()         ))
                OFX.append("getBillPaySupportsDifftFirstPmt()%s" %(service.getBillPaySupportsDifftFirstPmt()     ))
                OFX.append("getBillPaySupportsDifftLastPmt() %s" %(service.getBillPaySupportsDifftLastPmt()      ))
                OFX.append("getBillPaySupportsDtAvail()      %s" %(service.getBillPaySupportsDtAvail()           ))
                OFX.append("getBillPaySupportsPmtByAddr()    %s" %(service.getBillPaySupportsPmtByAddr()         ))
                OFX.append("getBillPaySupportsPmtByPayeeId() %s" %(service.getBillPaySupportsPmtByPayeeId()      ))
                OFX.append("getBillPaySupportsPmtByXfr()     %s" %(service.getBillPaySupportsPmtByXfr()          ))
                OFX.append("getBillPaySupportsStatusModRs()  %s" %(service.getBillPaySupportsStatusModRs()       ))
                OFX.append("getBillPayXfrDaysWith()          %s" %(service.getBillPayXfrDaysWith()               ))
                OFX.append("getBillPayXfrDefaultDaysToPay()  %s" %(service.getBillPayXfrDefaultDaysToPay()       ))
                OFX.append("getEmailSupportsGeneric()        %s" %(service.getEmailSupportsGeneric()             ))
                OFX.append("getEmailSupportsGetMime()        %s" %(service.getEmailSupportsGetMime()             ))
                OFX.append("getInvstCanDownloadBalances()    %s" %(service.getInvstCanDownloadBalances()         ))
                OFX.append("getInvstCanDownloadOOs()         %s" %(service.getInvstCanDownloadOOs()              ))
                OFX.append("getInvstCanDownloadPositions()   %s" %(service.getInvstCanDownloadPositions()        ))
                OFX.append("getInvstCanDownloadTxns()        %s" %(service.getInvstCanDownloadTxns()             ))
                OFX.append("getInvstCanEmail()               %s" %(service.getInvstCanEmail()                    ))
                OFX.append("getSecListCanDownloadSecurities()%s" %(service.getSecListCanDownloadSecurities()     ))

            OFX.append("")

            sortKeys=sorted(service.getParameterKeys())
            OFX.append(pad("Raw Parameter keys:",40))
            for x in sortKeys:
                val = service.getParameter(x,None)
                for checkKey in ["balance", "account_num", "branch_id", "routing_num", "so_user_id"]:
                    if checkKey in x:
                        val = redactor(val, ("balance" in x))
                        break
                OFX.append("%s %s" %(pad(x,40), val))

            OFX.append("\n------------------------------------------------------------------\n\n")

        OFX.append("\n<END>")
        for i in range(0, len(OFX)):
            OFX[i] = OFX[i] + "\n"
        OFX = "".join(OFX)

        QuickJFrame("VIEW INSTALLED SERVICE / BANK LOGON PROFILES",OFX,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        txt = "OFX: Your installed Service / Bank logon profiles have been displayed...."
        setDisplayStatus(txt, "B")

    def load_help_file():
        myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

        if u"__file__" not in globals():
            myPrint("DB", " __file__ not found in globals()")
            return None

        helpfile = os.path.splitext(__file__)[0]+"_readme.txt"
        if not os.path.exists(helpfile):
            myPrint("DB", " file: %s not found.." %(helpfile))
            return None

        try:
            fis = FileInputStream(File(helpfile))
        except:
            myPrint("DB", " Error opening file: %s .." %(helpfile))
            dump_sys_error_to_md_console_and_errorlog()
            return None

        return fis

    class DisplayHelp(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):                                                                               # noqa
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()" )

            def getHelpData():
                localHelpFileStream = None                                                                              # noqa
                stream = None                                                                                           # noqa

                if MD_EXTENSION_LOADER is None:
                    localHelpFileStream = load_help_file()
                    if localHelpFileStream is None:
                        if debug:
                            return "moneydance_extension_loader is None:\nInternal mxt and also local Help file not found (please run as extension)\n(note: feature only enabled from Moneydance build 3051 onwards)"
                        else:
                            return "Internal mxt and also local Help file not found (please run as extension)\n(note: feature only enabled from Moneydance build 3051 onwards)"

                if MD_EXTENSION_LOADER is not None:
                    stream = MD_EXTENSION_LOADER.getResourceAsStream("/%s_readme.txt" %(myModuleID))
                    if stream is None:
                        localHelpFileStream = load_help_file()
                        if localHelpFileStream is None:
                            if debug:
                                return "getResourceAsStream() returned None:\nInternal mxt and also local Help file not found (please run as extension)"
                            else:
                                return "Internal mxt and also local Help file not found (please run as extension)"

                if stream is not None:
                    myPrint("DB",".. loading help file from mxt internal stream")
                    return load_text_from_stream_file(stream)

                elif localHelpFileStream is not None:
                    myPrint("DB",".. loading help file from local file stored with the .py file")
                    return load_text_from_stream_file(localHelpFileStream)

                else:
                    if debug:
                        return "all streams are None:\nInternal mxt and also local Help file not found (please run as extension)"
                    else:
                        return "Internal mxt and also local Help file not found (please run as extension)"

            output = getHelpData()
            QuickJFrame("HELP DOCUMENTATION", output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

    # noinspection PyArgumentList
    class MyTxnSearchFilter(TxnSearch):

        def __init__(self,dateStart,dateEnd):
            super(TxnSearch, self).__init__()

            self.dateStart = dateStart
            self.dateEnd = dateEnd

        def matchesAll(self):                                                                                           # noqa
            return False

        def matches(self, txn):

            if txn.getDateInt() >= self.dateStart and txn.getDateInt() <= self.dateEnd:                                 # noqa
                return True
            return False

    class MyAcctFilter(AcctFilter):
        selectType = 0

        def __init__(self, selectType=0):
            self.selectType = selectType

        def matches(self, acct):
            if self.selectType == 0:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

            if self.selectType == 10:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

                if acct.getParameter("ofx_import_acct_num", None) is not None \
                        or acct.getParameter("ofx_import_remember_acct_num", None) is not None:
                    return True
                return False

            if self.selectType == 1:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.ROOT
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

            if self.selectType == 2:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.SECURITY: return True
                else: return False

            if self.selectType == 3:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.ROOT):
                    return False

            if self.selectType == 4:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.EXPENSE
                        or acct.getAccountType() == Account.AccountType.INCOME):
                    return False
                return True

            if self.selectType == 5:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            if self.selectType == 6:
                # if not (acct.getAccountType() == Account.AccountType.BANK
                #         or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                #         or acct.getAccountType() == Account.AccountType.LOAN
                #         or acct.getAccountType() == Account.AccountType.ASSET
                #         or acct.getAccountType() == Account.AccountType.ROOT
                #         or acct.getAccountType() == Account.AccountType.LIABILITY
                #         or acct.getAccountType() == Account.AccountType.INVESTMENT):
                #     return False
                return True

            if self.selectType == 7:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            if self.selectType == 8:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.EXPENSE
                        or acct.getAccountType() == Account.AccountType.INCOME):
                    return False
                return True

            if self.selectType == 9:
                # noinspection PyUnresolvedReferences
                if not acct.getAccountType() == Account.AccountType.SECURITY:
                    return False
                return True

            if self.selectType == 11:
                if acct.canDownloadTxns() and not acct.getAccountIsInactive():
                    return True
                else:
                    return False

            if self.selectType == 12:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.ROOT:
                    return True
                else:
                    return False

            if self.selectType == 13:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() != Account.AccountType.SECURITY: return False
                if not acct.getUsesAverageCost(): return False
                else: return True

            if self.selectType == 14:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() != Account.AccountType.SECURITY: return False
                if not acct.getUsesAverageCost():
                    return True
                else:
                    # Check for accounts using avg cost control with LOTS set....
                    txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTransactionsForAccount(acct)
                    for theTxn in txnSet:
                        if (InvestUtil.isSaleTransaction(theTxn.getParentTxn().getInvestTxnType())
                                and (theTxn.getParameter("cost_basis", None) is not None)):
                            myPrint("DB","MyAcctFilter: Account: %s Found LOT Tags %s" %(acct,theTxn.getParameter("cost_basis", None)))
                            return True

                # OK, No LOTs found on average cost controlled accounts.....
                return False

            if self.selectType == 15 or self.selectType == 16 or self.selectType == 17 or self.selectType == 18:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False

                if self.selectType == 15:
                    x = MyGetDownloadedTxns(acct)
                    if x is not None and x.getTxnCount() >= 0:          # change to > 0 for only those with txns etc
                        return True
                elif self.selectType == 18:
                    x = MyGetDownloadedTxns(acct)
                    if x is not None and x.getTxnCount() >= 0:
                        return True
                elif self.selectType == 16:
                    x = MyGetOnlinePayees(acct)
                    if x is not None and x.getPayeeCount() >= 0:        # change to > 0 for only those with payees etc
                        return True
                elif self.selectType == 17:
                    x = MyGetOnlinePayments(acct)
                    if x is not None and x.getPaymentCount() >= 0:      # change to > 0 for only those with payments etc
                        return True

                return False

            if self.selectType == 19:
                # noinspection PyUnresolvedReferences
                if acct.getAccountType() == Account.AccountType.SECURITY or acct.getAccountType() == Account.AccountType.ROOT: return False
                else: return True

            if self.selectType == 20:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.LIABILITY):
                    return False
                return True

            if self.selectType == 21:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.LOAN
                        or acct.getAccountType() == Account.AccountType.ASSET
                        or acct.getAccountType() == Account.AccountType.INVESTMENT
                        or acct.getAccountType() == Account.AccountType.LIABILITY):
                    return False

            # Security sub accounts for stock holdings
            if self.selectType == 22:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.SECURITY):
                    return False
                return True

            # Investment Accounts only
            if self.selectType == 23:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                return True

            # Security sub accounts for stock holdings where the relative currency is None - i.e. not properly linked to it's Security Master
            if self.selectType == 24:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.SECURITY):
                    return False
                acctCurr = acct.getCurrencyType()
                if (acctCurr is None or acctCurr.getCurrencyType() != CurrencyType.Type.SECURITY                        # noqa
                        or acct.getParameter("curr", None) is None or acct.getParameter("currid", None) is None):
                    return True
                return False

            # ALL
            if self.selectType == 25:
                return True

            if self.selectType == 26:
                # noinspection PyUnresolvedReferences
                if not (acct.getAccountType() == Account.AccountType.BANK
                        or acct.getAccountType() == Account.AccountType.CREDIT_CARD
                        or acct.getAccountType() == Account.AccountType.INVESTMENT):
                    return False
                else:
                    return True

            if (acct.getAccountOrParentIsInactive()): return False
            if (acct.getHideOnHomePage() and acct.getBalance() == 0): return False

            return True

    def MyGetOnlinePayees(theAcct):     # Use my version to prevent creation of default record(s)
        payeesListID = theAcct.getParameter("ol_payees_list_id", None)

        if payeesListID is not None:
            payeesObj = MD_REF.getCurrentAccount().getBook().getItemForID(payeesListID)    # type: SyncableItem
            if payeesObj is not None and isinstance(payeesObj, OnlinePayeeList):
                return payeesObj    # type: OnlinePayeeList

        # payees = OnlinePayeeList(MD_REF.getCurrentAccount().getBook())   # type: OnlinePayeeList
        # MD_REF.getCurrentAccount().getBook().logModifiedItem(payees)
        # theAcct.setOnlinePayees(payees)
        # return payees

        return None

    def MyGetOnlinePayments(theAcct):       # Use my version to prevent creation of default record(s)
        paymentsListID = theAcct.getParameter("ol_payments_list_id", None)
        if paymentsListID is not None:
            paymentsObj = MD_REF.getCurrentAccount().getBook().getItemForID(paymentsListID)      # type: SyncableItem
            if paymentsObj is not None and isinstance(paymentsObj, OnlinePaymentList):
                return paymentsObj  # type: OnlinePaymentList

        # payments = OnlinePaymentList(MD_REF.getCurrentAccount().getBook())   # type: OnlinePaymentList
        # MD_REF.getCurrentAccount().getBook().logModifiedItem(payments)
        # theAcct.setOnlinePayments(payments)
        # return payments

        return None

    def MyGetDownloadedTxns(theAcct):       # Use my version to prevent creation of default record(s)

        myID = theAcct.getParameter("id", None)
        defaultTxnsListID = myID + ".oltxns"

        if myID is not None and myID != "":
            defaultTxnList = MD_REF.getCurrentAccount().getBook().getItemForID(defaultTxnsListID)   # type: SyncableItem
            if defaultTxnList is not None and isinstance(defaultTxnList, OnlineTxnList):
                return defaultTxnList

        txnsListID = theAcct.getParameter("ol_txns_list_id", None)
        if txnsListID is None or txnsListID == "":
            if myID is not None and myID != "":
                txnsListID = defaultTxnsListID

        if txnsListID is not None and txnsListID != "":
            txnsObj = MD_REF.getCurrentAccount().getBook().getItemForID(txnsListID)              # type: SyncableItem
            if (txnsObj is not None and isinstance(txnsObj, OnlineTxnList)):
                return txnsObj

        # WE DON'T WANT TO DO THIS!
        # if myID is not None and myID != "":
        #     txns = OnlineTxnList(MD_REF.getCurrentAccount().getBook())                 # type: OnlineTxnList
        #     txns.setParameter("id", defaultTxnsListID)
        #     MD_REF.getCurrentAccount().getBook().logModifiedItem(txns)
        #     return txns
        #
        return None

    class ClipboardButtonAction(AbstractAction):

        def __init__(self, theString):
            self.theString = theString

        def actionPerformed(self, event):

            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            _THIS_METHOD_NAME = "DIAGNOSTIC OUTPUT"

            options = ["Copy the diagnostics to the Clipboard",
                       "Save the diagnostics to a text file",
                       "Print the diagnostics to your printer"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         _THIS_METHOD_NAME.upper(), "Select Option:",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(lAlwaysGetIcon=True),
                                                         options, None)
            if not selectedOption: return

            optionIndex = options.index(selectedOption)
            if optionIndex == 0:
                x = StringSelection(self.theString)
                Toolkit.getDefaultToolkit().getSystemClipboard().setContents(x, None)
                txt = "Contents of all text below copied to Clipboard.."
                setDisplayStatus(txt, "B")
                return

            if optionIndex == 1:
                saveOutputFile(toolbox_frame_, _THIS_METHOD_NAME.upper(), "toolbox_diagnostics.txt", self.theString)
                return

            if optionIndex == 2:
                printOutputFile(_callingClass=None, _theTitle=_THIS_METHOD_NAME.upper(), _theJText=None, _theString=self.theString)
                return

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    class ShowTheConsole(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):
            myPrint("D","In ", inspect.currentframe().f_code.co_name, "()", "Event:", event)

            ConsoleWindow.showConsoleWindow(MD_REF.getUI())

            txt = "Standard Moneydance Console Window Launched...."
            setDisplayStatus(txt, "B")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    class CopyConsoleLogFileButtonAction(AbstractAction):

        def __init__(self, theFile): self.theFile = theFile

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            _theFileAsStr = safeStr(self.theFile)
            if not os.path.exists(_theFileAsStr):
                txt = "Sorry, the file does not seem to exist: %s" %(_theFileAsStr)
                setDisplayStatus(txt, "R")
                return

            theTitle = "Select location to copy Console Log file to... (CANCEL=ABORT)"
            theFileName = "copy_of_errlog.txt"
            copyToFile = getFileFromFileChooser(toolbox_frame_,     # Parent frame or None
                                                get_home_dir(),     # Starting path
                                                theFileName,        # Default Filename
                                                theTitle,           # Title
                                                False,              # Multi-file selection mode
                                                False,              # True for Open/Load, False for Save
                                                True,               # True = Files, else Dirs
                                                None,               # Load/Save button text, None for defaults
                                                "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=True,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

            if (copyToFile is None) or copyToFile == "":
                txt = "User did not select file location - no copy performed"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return
            elif not safeStr(copyToFile).endswith(".txt"):
                txt = "Sorry - please use a .txt file extension when copying  console log file"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return
            elif ".moneydance" in os.path.dirname(copyToFile):
                txt = "Sorry, please choose a location outside of the  Moneydance location"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt)
                return

            if not check_file_writable(copyToFile):
                txt = "Sorry, that file/location does not appear allowed by the operating system!?"
                setDisplayStatus(txt, "R")

            toFile = File(copyToFile)
            try:
                IOUtils.copy(self.theFile, toFile)
                myPrint("B", "%s copied to %s" %(_theFileAsStr, copyToFile))
                if os.path.exists(copyToFile):
                    play_the_money_sound()
                    txt = "Console Log file save as requested to: %s" %(copyToFile)
                    setDisplayStatus(txt, "B")
                else:
                    myPrint("B", "ERROR - failed to copy file %s to %s" %(_theFileAsStr, copyToFile))
                    txt = "Sorry, failed to save console log file?!"
                    setDisplayStatus(txt, "R")
            except:
                myPrint("B", "ERROR - failed to copy file %s to %s" %(_theFileAsStr, copyToFile))
                dump_sys_error_to_md_console_and_errorlog()
                txt = "Sorry, failed to save console log file?!"
                setDisplayStatus(txt, "R")

            return

    class DisplayPickleFile(AbstractAction):

        def __init__(self): pass

        # noinspection PyUnusedLocal
        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

            if GlobalVars.parametersLoadedFromFile is None: GlobalVars.parametersLoadedFromFile = {}

            params = []
            for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
                params.append("Key: " + pad(safeStr(key),50) + " Type: " + pad(safeStr(type(GlobalVars.parametersLoadedFromFile[key])), 20) + "Value: " + safeStr(GlobalVars.parametersLoadedFromFile[key]) + "\n")

            params.append("\n<END>")
            params = "".join(params)

            jif = QuickJFrame("StuWareSoftSystems Pickle Parameter File:", params, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

            if not myPopupAskQuestion(jif,
                                      "STUWARESOFTSYSTEMS' SAVED PARAMETERS PICKLE FILE",
                                      "Would you like to RESET/DELETE/EDIT saved parameters?",
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.WARNING_MESSAGE):
                return

            _PICKLEDELALL          = 0
            _PICKLECHGONE          = 1
            _PICKLEDELONE          = 2
            _PICKLEADDONE          = 3

            what = ["PICKLE: DELETE ALL","PICKLE: CHANGE one variable","PICKLE: DELETE one variable", "PICKLE: ADD one variable"]

            while True:

                lAdd = lChg = lDelAll = lDelOne = False
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "Select the type of change you want to make?",
                                                           "STUWARESOFTSYSTEMS' SAVED PARAMETERS PICKLE FILE",
                                                           JOptionPane.WARNING_MESSAGE,
                                                           getMDIcon(None),
                                                           what,
                                                           None)

                if not selectedWhat:
                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()
                    return

                if selectedWhat == what[_PICKLEADDONE]: lAdd = True
                if selectedWhat == what[_PICKLECHGONE]: lChg = True
                if selectedWhat == what[_PICKLEDELONE]: lDelOne = True
                if selectedWhat == what[_PICKLEDELALL]: lDelAll = True

                if lDelAll:
                    GlobalVars.parametersLoadedFromFile = {}
                    txt = "STUWARESOFTSYSTEMS' PARAMETERS SAVED TO PICKLE FILE DELETED/RESET"
                    setDisplayStatus(txt, "DG")
                    myPrint("B", txt)

                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()
                    return

                text = ""
                if lChg: text = "CHANGE"
                if lDelOne: text = "DELETE"

                if lAdd:
                    addKey = myPopupAskForInput(jif,
                                                "PICKLE: ADD KEY",
                                                "KEY NAME:",
                                                "Carefully enter the name of the key you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                                "",
                                                False,
                                                JOptionPane.WARNING_MESSAGE)

                    if not addKey or len(addKey.strip()) < 1: continue
                    addKey = addKey.strip()

                    if not check_if_key_string_valid(addKey):
                        myPopupInformationBox(jif, "ERROR: Key %s is NOT valid!" % addKey, "PICKLE: ADD", JOptionPane.ERROR_MESSAGE)
                        continue    # back to menu

                    testKeyExists = GlobalVars.parametersLoadedFromFile.get(addKey)

                    if testKeyExists:
                        myPopupInformationBox(jif, "ERROR: Key %s already exists - cannot add - aborting..!" % addKey, "PICKLE: ADD", JOptionPane.ERROR_MESSAGE)
                        continue    # back to menu

                    addValue = myPopupAskForInput(jif,
                                                  "PICKLE: ADD KEY VALUE",
                                                  "KEY VALUE:",
                                                  "Carefully enter the key value you want to add (STRINGS ONLY!):",
                                                  "",
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not addValue or len(addValue.strip()) <1: continue
                    addValue = addValue.strip()

                    if not check_if_key_data_string_valid(addValue):
                        myPopupInformationBox(toolbox_frame_, "ERROR: Key value %s is NOT valid!" % addValue, "PICKLE: ADD ", JOptionPane.ERROR_MESSAGE)
                        continue    # back to menu

                    GlobalVars.parametersLoadedFromFile[addKey] = addValue
                    myPrint("B","@@ PICKLEMODE: key: %s value: %s added @@" %(addKey,addValue))
                    myPopupInformationBox(jif,
                                          "SUCCESS: Key %s added!" % (addKey),
                                          "PICKLE: ADD ",
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                pickleKeys=sorted(GlobalVars.parametersLoadedFromFile.keys())
                # OK, so we are changing or deleting
                if lChg or lDelOne:
                    selectedKey = JOptionPane.showInputDialog(jif,
                                                              "Select the key/setting you want to %s" % (text),
                                                              "PICKLE",
                                                              JOptionPane.WARNING_MESSAGE,
                                                              getMDIcon(None),
                                                              pickleKeys,
                                                              None)
                    if not selectedKey: continue

                    value = GlobalVars.parametersLoadedFromFile.get(selectedKey)
                    chgValue = None

                    if lChg:
                        chgValue = myPopupAskForInput(jif,
                                                      "PICKLE: CHANGE KEY VALUE",
                                                      "KEY VALUE:",
                                                      "Carefully enter the new key value (as type: %s):" %type(value),
                                                      str(value),
                                                      False,
                                                      JOptionPane.WARNING_MESSAGE)

                        if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                        chgValue = chgValue.strip()

                        if isinstance(value, (int, float, bool, list)):
                            try:
                                if isinstance(eval(chgValue), type(value) ):
                                    chgValue = eval(chgValue)
                                else:
                                    myPopupInformationBox(jif,"ERROR: you must match the variable type to %s" %(type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                    continue
                            except:
                                myPopupInformationBox(jif,"ERROR: *EVAL* Could not set Key value %s - type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                continue
                        elif isinstance(value,(str,unicode)):
                            if not check_if_key_data_string_valid(chgValue):
                                myPopupInformationBox(jif,"ERROR: Key value %s is NOT valid!" %chgValue,"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                                continue    # back to menu
                        else:
                            myPopupInformationBox(jif,"SORRY: I cannot change Key value %s as it's type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                            continue    # back to menu

                    if lDelOne:
                        GlobalVars.parametersLoadedFromFile.pop(selectedKey)
                    if lChg:
                        try:
                            GlobalVars.parametersLoadedFromFile[selectedKey] = chgValue
                        except:
                            myPopupInformationBox(jif,"ERROR: *set* Could not set Key value %s - type %s" %(chgValue,type(value)),"PICKLE: CHANGE",JOptionPane.ERROR_MESSAGE)
                            continue

                    if lDelOne:
                        myPrint("B","@@ PICKLEMODE: key: %s DELETED (old value: %s) @@" %(selectedKey,value))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s DELETED (old value: %s)" %(selectedKey,value),
                                              "PICKlE: DELETE",
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        myPrint("B","@@ PICKLERMODE: key: %s CHANGED to %s @@" %(selectedKey,chgValue))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s CHANGED to %s" %(selectedKey,chgValue),
                                              "PICKLE: CHANGE",
                                              JOptionPane.WARNING_MESSAGE)
                    continue


    def can_I_delete_currency():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("B", "Analysing whether you can delete a Currency, or show where it's used....")
        myPrint("P", "------------------------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()

        currOutput = ""

        def accountHasCurrency(acct, curr):

            localOutput = ""

            currCount = 0

            if acct is None: return currCount

            for i in range(0,acct.getSubAccountCount()):

                subAcct = acct.getSubAccount(i)
                if subAcct.getCurrencyType() == curr:
                    currCount += 1
                    localOutput += ".. Account: %s Name: %s is using %s\n" %(subAcct.getAccountType(), subAcct.getFullAccountName(), curr)

                local_i, local_str = accountHasCurrency(subAcct, curr)
                currCount += local_i
                localOutput += local_str

                i+=1

            return currCount, localOutput

        currs = []
        securities = []

        for currency in allCurrencies:
            if currency.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                # noqa
                currs.append(currency)
            if currency.getCurrencyType() == CurrencyType.Type.SECURITY:                                                # noqa
                securities.append(currency)

        currs = sorted(currs, key=lambda x: (x.getName().upper()))
        securities = sorted(securities, key=lambda x: (x.getName().upper()))

        selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select Currency", "Select the currency to analyse",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       currs,
                                                       None)
        if selectedCurrency is None:
            txt = "No currency was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        currOutput += "\nYou want me to look for Currency: %s \n" %(selectedCurrency)

        myPrint("B", "Looking for Currency: %s %s" %(selectedCurrency, selectedCurrency.getName()) )                    # noqa

        base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

        lFailTests = False
        if selectedCurrency == base:
            lFailTests = True
            currOutput += "\n** Currency is set as the base - Deletion not possible!! **\n\n"

        currOutput += "\nReviewing all Account/Category records for currency...:\n"
        foundCurrCount, outputBuild = accountHasCurrency(MD_REF.getCurrentAccount(), selectedCurrency)
        currOutput += outputBuild
        if foundCurrCount > 0:
            currOutput += "<%s ACCOUNTS / CATS FOUND USING CURRENCY>\n" %(foundCurrCount)
        else:
            currOutput += "<NO ACCOUNTS / CATS FOUND USING CURRENCY>\n"
        currOutput += "\n"

        currOutput += "\nReviewing security records for currency...:\n"
        secCount = 0
        for sec in securities:
            if sec.getRelativeCurrency() == selectedCurrency:
                secCount += 1
                currOutput += "Security: %s is using %s\n" %(sec, selectedCurrency)
        if secCount > 0:
            currOutput += "<%s SECURITIES FOUND USING CURRENCY>\n" %(secCount)
        else:
            currOutput += "<NO SECURITIES FOUND USING CURRENCY>\n"
        currOutput += "\n"

        if foundCurrCount or secCount or lFailTests:
            txt = "Currency %s ** IS BEING USED ** - Deletion not possible!" %(selectedCurrency)
            currOutput += "\n%s\n" %(txt)
            myPrint("B",txt)
            setDisplayStatus(txt, "R")
        else:
            txt = "Currency %s is NOT being used - deletion should be possible...."  %(selectedCurrency)
            currOutput += "\n%s\n" %(txt)
            myPrint("B", txt)
            setDisplayStatus(txt, "B")

        currOutput += "\n<END>"

        QuickJFrame("CAN I DELETE A CURRENCY?", currOutput, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def can_I_delete_security():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("B", "Script running to analyse whether you can delete a Security, or show where it's used....")
        myPrint("P", "----------------------------------------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        usageCount = 0
        sumShares = 0

        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()

        securities = []

        for currency in allCurrencies:
            # noinspection PyUnresolvedReferences
            if currency.getCurrencyType() == CurrencyType.Type.SECURITY:
                securities.append(currency)

        securities = sorted(securities, key=lambda x: (x.getName().upper()))

        selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select Security", "Select the security to analyse",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       securities,
                                                       None)
        if selectedSecurity is None:
            txt = "No security was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        output = "\nYou want me to look for Security: %s\n" %(selectedSecurity)

        accountsList = AccountUtil.allMatchesForSearch(book, MyAcctFilter(2))
        output += "Searching through %s security (sub) accounts.." % (len(accountsList)) + "\n"

        for account in accountsList:
            if account.getCurrencyType() == selectedSecurity:
                # noinspection PyUnresolvedReferences
                output += "   >> Security: %s is used in Account: %s - Share holding balance: %s" \
                          % (selectedSecurity, account.getParentAccount().getAccountName(),
                             selectedSecurity.getDoubleValue(account.getBalance())) + "\n"
                # noinspection PyUnresolvedReferences
                sumShares += selectedSecurity.getDoubleValue(account.getBalance())
                usageCount += 1

        if not usageCount:
            output += "   >> Security not found in any accounts.\n"

        output += "\nChecking security for price history...:\n"

        # noinspection PyUnresolvedReferences
        secSnapshots = selectedSecurity.getSnapshots()
        countPriceHistory = secSnapshots.size()
        if countPriceHistory > 0:
            output += "   >> Security has %s historical prices!" % (secSnapshots.size()) + "\n"
        else:
            output += "   >> Security has no historical prices. \n"

        output += "-----------------------------------------------------------------\n"
        if usageCount:
            output += "\nUSAGE FOUND: You are using security: %s in %s accounts!\n... with a share balance of: %s. These would need to be removed before security deletion" \
                      % (selectedSecurity, usageCount, sumShares) + "\n"
            myPrint("J", ">> NO - Security cannot be deleted as it's being used: %s" %(selectedSecurity))

        if countPriceHistory:
            output += "\nPRICE HISTORY FOUND: You have %s price records - If you delete Security then these will be lost..." \
                      % countPriceHistory + "\n"

        if not usageCount and not countPriceHistory:
            txt = "No usage of security %s found! You should be able to safely delete the Security" %(selectedSecurity)
        else:
            txt = "Sorry - usage of Security: %s found - refer to script output for details.." %(selectedSecurity)

        output += "\n%s\n" %(txt)
        setDisplayStatus(txt, "R")

        output += "\n<END>"
        QuickJFrame("CAN I DELETE A SECURITY?", output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def list_security_currency_decimal_places():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("B", "Script is analysing your (hidden) Currency/Security decimal place settings...........")
        myPrint("P", "-------------------------------------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        iWarnings = 0
        myLen = 50

        decimalPoint_MD = MD_REF.getPreferences().getDecimalChar()

        currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()

        currs = sorted(currs, key=lambda x: safeStr(x.getName()).upper())

        output = "List Currency/Security (hidden) Decimal Places setting and related data:\n" \
                 " =======================================================================\n"

        output += "** NOTE: The hidden 'Decimal Places' (dpc) setting is set when you create a new Currency/Security.\n" \
                  "         - This can not normally be changed once set in the Moneydance menus.\n" \
                  "         - However - Toolbox extension has a menu feature to allow you to do this\n" \
                  "         - For a Currency, the dpc controls the decimal precision of both balances and stored values on transactions\n" \
                  "         - For a Security, the dpc controls ONLY the qty of shares/units held and it does NOT affect the stored dpc of prices/rates.\n" \
                  "\n"

        def get_curr_sec_name(curr_sec):
            if curr_sec.getName() is not None and len(curr_sec.getName().strip()) > 0:
                return curr_sec.getName()
            return (curr_sec.getIDString() + ":" + curr_sec.getIDString())

        def analyse_curr(theCurr, theType):
            output = ""                                                                                                 # noqa
            iWarn = 0
            for sec_curr in theCurr:
                if str(sec_curr.getCurrencyType()) != theType: continue

                foo = str(round(CurrencyUtil.getUserRate(sec_curr, sec_curr.getRelativeCurrency()), 30))
                priceDecimals = min(30, len(foo.split(decimalPoint_MD)[-1]))

                output += pad(get_curr_sec_name(sec_curr),myLen) + "\tDPC: " + \
                          str(sec_curr.getDecimalPlaces()) + \
                          "\t" + \
                          "Relative to: " + safeStr(sec_curr.getRelativeCurrency())[:20].ljust(20, " ") + \
                          "\t" + \
                          "Current rate: " + str(foo)[:20].ljust(20, " ") + \
                          "\tRate dpc: " + str(priceDecimals)

                # if (sec_curr.getDecimalPlaces() < priceDecimals and theType == "SECURITY") and \
                #         not foo.endswith(".0"):
                #     iWarn += 1
                #     output += " ***\n"
                # else:
                #     output += "\n"

                output += "\n"
            return iWarn, output

        output += " ==============\n"
        output += " --- SECURITIES ----\n"
        output += " ==============\n"

        result = analyse_curr(currs, "SECURITY")
        iWarnings += result[0]
        output += result[1]

        output += "\n" \
                  " ==============\n"
        output += " --- CURRENCIES ----\n"
        output += " ==============\n"
        result = analyse_curr(currs, "CURRENCY")
        iWarnings += result[0]
        output += result[1]

        output += "\n" \
                  "-----------------------------------------------------------------"
        output += "\n<END>"

        txt = "DIAG: Currency/Security Decimal Places report executed"
        setDisplayStatus(txt, "DG")

        QuickJFrame("LIST SECURITY / CURRENCY DECIMAL PLACES", output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def manually_edit_price_date_field():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (GlobalVars.UPDATE_MODE): return

        currencies = list_security_currency_price_date(autofix=False, justProvideFilter=True)
        if currencies is None:
            txt = "No Currency/Security filter option was selected.."
            setDisplayStatus(txt, "R")
            return

        currs = []
        for curr in currencies:
            currs.append(StoreCurrencySecurity(curr))

        selectedCurrSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Currency/Security to edit the current price hidden 'price_date' field:",
                                                      "Edit price_date - Select CURRENCY/SECURITY",
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      getMDIcon(lAlwaysGetIcon=True),
                                                      currs,
                                                      None)
        if not selectedCurrSec:
            txt = "No Currency/Security was selected.."
            setDisplayStatus(txt, "R")
            return

        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
        if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD and not checkCurrencyRawRatesOK(selectedCurrSec.obj):                                                            # noqa
            txt = "@@ ERROR: Old format Currency record detected (empty relative rate). Please use 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to fix - No changes allowed!"
            setDisplayStatus(txt, "R")
            myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        currPriceDate = selectedCurrSec.obj.getLongParameter("price_date", 0L)                                          # noqa

        if currPriceDate > 0:
            theCurrentDatePretty = get_time_stamp_as_nice_text(currPriceDate)
        else:
            theCurrentDatePretty = "NOT SET"

        newestSnapshotDate = 0
        newestSnapshotPrice = 0
        relCurr = selectedCurrSec.obj.getRelativeCurrency()                                                             # noqa
        currentPrice = selectedCurrSec.obj.getRelativeRate()                                                            # noqa
        currSnapshots = selectedCurrSec.obj.getSnapshots()                                                              # noqa
        if len(currSnapshots)>0:
            newestSnapshotDate = currSnapshots[-1].getDateInt()
            newestSnapshotPrice = currSnapshots[-1].getRate()

        if newestSnapshotDate > 0:
            theLatestSnapshotDatePretty = "%s" %(convertStrippedIntDateFormattedText(newestSnapshotDate))
        else:
            theLatestSnapshotDatePretty = "NOT SET"

        if isGoodRate(newestSnapshotPrice):
            txtLatestSnapshotPrice = "%s" %(safeInvertRate(newestSnapshotPrice))
        else:
            txtLatestSnapshotPrice = "NOT SET"

        MyPopUpDialogBox(toolbox_frame_,
                         "FOR INFO: Currency/Security details:",
                         "Current price hidden 'price_date' is currently: %s\n"
                         "(which means: %s)\n"
                         "Latest dated price history date: %s\n"
                         "Current Price: %s\n"
                         "Latest Dated History Price: %s"
                         %(currPriceDate, theCurrentDatePretty, theLatestSnapshotDatePretty,safeInvertRate(currentPrice),txtLatestSnapshotPrice),
                         theTitle="MANUALLY EDIT HIDDEN PRICE_DATE FIELD").go()

        labelUpdateDate = JLabel("Select the new current price hidden 'price_date':")
        user_selectDateStart = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
        if newestSnapshotDate > 0:
            user_selectDateStart.setDateInt(min(newestSnapshotDate,DateUtil.getStrippedDateInt()))
        else:
            user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())

        labelUpdatePrice = JLabel("Choose which current price to use (ie. existing price or latest history price")

        user_selectCurrentPrice = user_selectHistoryPrice = None
        if isGoodRate(newestSnapshotPrice):
            user_selectCurrentPrice = JRadioButton("Keep Current Price: %s" %(safeInvertRate(currentPrice)), True)
            user_selectHistoryPrice = JRadioButton("Switch to Latest History Price: %s" %(safeInvertRate(newestSnapshotPrice)), False)
            bg = ButtonGroup()
            bg.add(user_selectCurrentPrice)
            bg.add(user_selectHistoryPrice)

        datePanel = JPanel(GridLayout(0, 1))
        datePanel.add(labelUpdateDate)
        datePanel.add(user_selectDateStart)
        if isGoodRate(newestSnapshotPrice):
            datePanel.add(JLabel(""))
            datePanel.add(JLabel("----"))
            datePanel.add(labelUpdatePrice)
            datePanel.add(user_selectCurrentPrice)
            datePanel.add(user_selectHistoryPrice)

        options = ["Cancel", "OK"]

        userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                  datePanel,
                                                  "Enter new current price hidden 'price_date' / price/rate fields:",
                                                  JOptionPane.OK_CANCEL_OPTION,
                                                  JOptionPane.QUESTION_MESSAGE,
                                                  getMDIcon(None),
                                                  options,
                                                  options[0])

        if userAction != 1:
            txt = "User cancelled entering a new current price hidden 'price_date' - exiting"
            setDisplayStatus(txt, "R")
            return

        if user_selectDateStart.getDateInt() < 20150101 or user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt():

            if user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt() \
                    and myPopupAskQuestion(toolbox_frame_,"Enter Future Date?","Do you really want to enter a future current price hidden 'price_date'?"):
                pass
            else:
                txt = "User cancelled by entering an invalid hidden price_date..."
                setDisplayStatus(txt, "R")
                return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"CURRENCY/SECURITY - UPDATE 'price_date'",
                                                 "Update the current price hidden 'price_date' field to %s?"%(convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt()))):
            return

        newDate = DateUtil.convertIntDateToLong(user_selectDateStart.getDateInt()).getTime()

        selectedCurrSec.obj.setEditingMode()                                                                            # noqa
        selectedCurrSec.obj.setParameter("price_date", newDate)                                                         # noqa
        if isGoodRate(newestSnapshotPrice) and user_selectHistoryPrice and user_selectHistoryPrice.isSelected():
            selectedCurrSec.obj.setRate(Util.safeRate(newestSnapshotPrice),relCurr)                                     # noqa
        selectedCurrSec.obj.syncItem()                                                                                  # noqa

        play_the_money_sound()
        _msg = "Edit of current price hidden 'price_date' field for curr/sec: %s successfully set to: %s (%s)" %(selectedCurrSec,newDate,convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt()))
        setDisplayStatus(_msg, "R")
        myPrint("B", _msg)
        if isGoodRate(newestSnapshotPrice) and user_selectHistoryPrice and user_selectHistoryPrice.isSelected():
            myPrint("B", "... current price also updated to: %s" %(safeInvertRate(newestSnapshotPrice)))
        myPopupInformationBox(toolbox_frame_,_msg,"Edit current price hidden 'price_date' field",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def checkCurrencyRawRatesOK(theCurr):

        # Check of 'rate' disabled as this is a legacy field and I no longer try to fix it.. Not required.. Especially since 2021.2 onwards

        # checkRate = theCurr.getParameter("rate", None)
        # checkRateDouble = theCurr.getDoubleParameter("rate", 0.0)

        # if checkRate is None or not isGoodRate(checkRateDouble):
        #     myPrint("DB", "WARNING: checkCurrencyRawRatesOK() 'rate' check failed on %s - checking stopped here" %(theCurr))
        #     return False

        checkRRate = theCurr.getParameter("rrate", None)
        checkRRateDouble = theCurr.getDoubleParameter("rrate", 0.0)

        if checkRRate is None or not isGoodRate(checkRRateDouble):
            myPrint("DB", "WARNING: checkCurrencyRawRatesOK() 'rrate' check failed on %s - checking stopped here" %(theCurr))
            return False

        return True

    def check_all_currency_raw_rates_ok(filterType=None):

        _currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for _curr in _currs:
            if filterType and _curr.getCurrencyType() != filterType: continue
            if not checkCurrencyRawRatesOK(_curr):
                return False

        return True

    def list_security_currency_price_date(autofix=False, justProvideFilter=False):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        if justProvideFilter: autofix = False

        if MD_REF.getCurrentAccount().getBook() is None: return None

        listCurrs = []
        currs_to_fix = []

        lMustRunFixCurrenciesFirst = False

        if not justProvideFilter:
            myPrint("B", "Script is analysing your Currency & Security current price hidden 'price_date' fields...........")
            myPrint("P", " -----------------------------------------------------------------------------------------------")

            txt = "Current Price (Hidden) 'price_date' fix"
            if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


        options = ["All (both Currencies & Securities)",
                   "All - Shown on Summary Page Only",
                   "Currencies - All",
                   "Currencies - Shown on Summary Page Only",
                   "Securities - All",
                   "Securities - Shown on Summary Page Only",
                   "Securities - With holdings Only",
                   "All - include OK objects too"]

        displayText = ["REPORT OPTIONS (list objects with error)", "Select your report filters/options"]
        if justProvideFilter:
            displayText = ["EDIT OPTIONS (lists objects with errors)", "Select filters/options for Edit List"]

        selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                       displayText[0], displayText[1],
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options,                                                         # noqa
                                                       None)

        if not selectedOption:
            if justProvideFilter: return None
            txt = "No report option was selected - aborting.."
            setDisplayStatus(txt, "R")
            return

        lAll = lSummaryScreenOnly = lCurrencyOnly = lSecurityOnly = lSecurityHoldings = lEverything = False
        optionIndex = options.index(selectedOption)
        if optionIndex in (0,1,7):  lAll = True
        if optionIndex in (2,3):    lCurrencyOnly = True
        if optionIndex in (4,5,6):  lSecurityOnly = True
        if optionIndex in (1,3,5):  lSummaryScreenOnly = True
        if optionIndex == 6:        lSecurityHoldings = True
        if optionIndex == 7:        lEverything = True

        iWarnings = 0

        currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        currs = sorted(currs, key=lambda x: (x.getCurrencyType(), x.getName().upper()))

        if justProvideFilter and lEverything: return currs

        output = "\nDiagnosing your Security / Currency's current price hidden 'price_date' fields (Normally showing errors only)\n" \
                 " ==============================================================================================================\n\n"

        def get_curr_sec_name(curr_sec):
            if curr_sec.getName() is not None and len(curr_sec.getName().strip()) > 0:
                return curr_sec.getName()
            return (curr_sec.getIDString() + ":" + curr_sec.getIDString())

        MD_decimal = MD_REF.getPreferences().getDecimalChar()
        base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

        def analyse_curr(theCurr, theType):
            output = ""                                                                                                 # noqa
            iWarn = 0
            _lMustRunFixCurrenciesFirst = False
            nowTimeMS = System.currentTimeMillis()
            intNowTime = DateUtil.convertLongDateToInt(nowTimeMS)

            for sec_curr in theCurr:
                if sec_curr == base: continue
                if sec_curr.getCurrencyType() != theType: continue
                if lSummaryScreenOnly and sec_curr.getHideInUI(): continue

                qtyHeld = 0
                if sec_curr.getCurrencyType() == CurrencyType.Type.SECURITY:                                            # noqa
                    qtyHeld = get_security_holdings(sec_curr)
                    if lSecurityHoldings and qtyHeld == 0: continue

                currPriceDate = sec_curr.getLongParameter("price_date", 0L)

                newestRate = newestSnapshotDate = intLatestSnapDate = 0
                currSnapshots = sec_curr.getSnapshots()
                snap = None
                if len(currSnapshots)>0:
                    snap = currSnapshots[-1]
                    newestRate = snap.getRate()
                    intLatestSnapDate = newestSnapshotDate = snap.getDateInt()

                if newestSnapshotDate > 0:
                    newestSnapshotDate = DateUtil.convertIntDateToLong(newestSnapshotDate)

                lSkip = False
                if currPriceDate < 1:
                    lSkip = True
                else:
                    if newestSnapshotDate > 0:
                        if (DateUtil.convertDateToInt(newestSnapshotDate) <= DateUtil.convertLongDateToInt(nowTimeMS)
                                and DateUtil.convertLongDateToInt(currPriceDate) <= DateUtil.convertLongDateToInt(nowTimeMS)
                                and DateUtil.convertLongDateToInt(currPriceDate) == DateUtil.convertDateToInt(newestSnapshotDate)):
                            lSkip = True
                    else:
                        if DateUtil.convertLongDateToInt(currPriceDate) <= DateUtil.convertLongDateToInt(nowTimeMS):
                            lSkip = True

                if not lEverything and lSkip: continue

                if justProvideFilter:
                    listCurrs.append(sec_curr)
                    continue

                if lEverything and not lSkip:
                    output += "** "

                output += "{}".format(get_curr_sec_name(sec_curr))
                if sec_curr.getCurrencyType() == CurrencyType.Type.SECURITY:                                            # noqa
                    output += " ({}:{})".format(sec_curr.getTickerSymbol(),sec_curr.getIDString())
                    if qtyHeld != 0:
                        output += "\tQty Held: {}".format(sec_curr.formatSemiFancy(qtyHeld, MD_decimal))
                else:
                    output += " ({})".format(sec_curr.getIDString())

                if lSkip:
                    if currPriceDate < 1:
                        niceDate = "NOT SET"
                    else:
                        niceDate = get_time_stamp_as_nice_text(currPriceDate)
                    output += " - OK (price_date = %s)\n\n" %(niceDate)
                    continue

                lUpdateRequired = False
                output += "\nprice_date (%s) = %s\n" %(currPriceDate,get_time_stamp_as_nice_text(currPriceDate))

                if DateUtil.convertLongDateToInt(currPriceDate) > DateUtil.convertLongDateToInt(nowTimeMS):
                    lUpdateRequired = True
                    output += "@@ WARNING: Your current price hidden 'price_date' field is future dated! **\n"

                if DateUtil.convertLongDateToInt(currPriceDate) < DateUtil.convertDateToInt(newestSnapshotDate):
                    output += "@@ WARNING: Your current price hidden 'price_date' field is older than latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                    if DateUtil.convertLongDateToInt(currPriceDate) < DateUtil.convertLongDateToInt(nowTimeMS):
                        lUpdateRequired = True

                if newestSnapshotDate > 0 and (DateUtil.convertDateToInt(newestSnapshotDate) > DateUtil.convertLongDateToInt(nowTimeMS)):
                    output += "@@ WARNING: Your price history date(s) are future dated! **\n"
                    output += "... latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                if newestSnapshotDate > 0 and (DateUtil.convertLongDateToInt(currPriceDate) > DateUtil.convertDateToInt(newestSnapshotDate)):
                    lUpdateRequired = True
                    output += "@@ WARNING: current price hidden 'price_date' field is newer than your latest dated price history date....\n"
                    output += "... latest dated price history date: %s\n" %(convertStrippedIntDateFormattedText(DateUtil.convertDateToInt(newestSnapshotDate)))

                if not isGoodRate(sec_curr.getRelativeRate()):
                    output += "@@ WARNING: current price/rate is not a valid number: %s\n" %(sec_curr.getRelativeRate())

                if snap and not isGoodRate(snap.getRate()):
                    output += "@@ WARNING: Latest dated price history price/rate is not a valid number: %s\n" %(snap.getRate())

                if lUpdateRequired and snap and sec_curr.getRelativeRate() != snap.getRate():
                    output +=  "... current price/rate %s, latest dated price history price/rate %s\n" %(safeInvertRate(sec_curr.getRelativeRate()), safeInvertRate(snap.getRate()))

                if lUpdateRequired:
                    # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
                    if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD and not checkCurrencyRawRatesOK(sec_curr):
                        output += "@@@ ERROR: Currency object has an old underlying format (empty 'rate' / 'rrate' fields); please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to fix (skipping....) @@@\n"
                        _lMustRunFixCurrenciesFirst = True
                        lUpdateRequired = False

                iWarn += 1
                output += "\n\n"

                if autofix:
                    if not lSkip and snap and lUpdateRequired and currPriceDate > 0 and intLatestSnapDate > 0:
                        relCurr = sec_curr.getRelativeCurrency()
                        currs_to_fix.append([sec_curr,
                                             DateUtil.convertIntDateToLong(min(intNowTime,intLatestSnapDate)).getTime(),
                                             Util.safeRate(newestRate),
                                             relCurr])

            return iWarn, output, _lMustRunFixCurrenciesFirst

        if lAll or lSecurityOnly:
            output += " ===================\n"
            output += " --- SECURITIES ----\n"
            output += " ===================\n"

            # noinspection PyUnresolvedReferences
            result = analyse_curr(currs, CurrencyType.Type.SECURITY)
            iWarnings += result[0]
            output += result[1]
            if result[2]: lMustRunFixCurrenciesFirst = True

        if lAll or lCurrencyOnly:
            output += " ===================\n"
            output += " --- CURRENCIES ----\n"
            output += " ===================\n"

            # noinspection PyUnresolvedReferences
            result = analyse_curr(currs, CurrencyType.Type.CURRENCY)
            iWarnings += result[0]
            output += result[1]
            if result[2]: lMustRunFixCurrenciesFirst = True

        if justProvideFilter: return listCurrs

        output += "-----------------------------------------------------------------"
        if iWarnings:
            output += "\nYou have %s Warning(s)..\n" % iWarnings
            output += "These are where your current price hidden 'price_date' field is future dated, or newer/older than your latest dated price history date\n"
            if not autofix:
                output += "To Fix a Warning use Update Mode, MENU: FIX: Manually edit a currency/ security's current price hidden 'price_date' field (will also allow you to fix the current price/rate)\n" \
                          "or consider using FIX: Diagnose then fix your currency / security's current price hidden 'price_date' field (along with the current price/rate)\n"
            _msg = "price_date: You have %s Warning(s).. Refer diagnostic file..." %(iWarnings)
            setDisplayStatus(_msg, "R")
            myPrint("J", _msg)
        else:
            _msg = "All good, current price hidden 'price_date' looks clean! Congratulations!"
            output += "\n%s\n" %(_msg)
            myPrint("J", _msg)
            setDisplayStatus(_msg, "DG")

        output += "\n\n\nReport Parameters:\n"
        output += "All (Both Securities and Currencies): %s\n" %(lAll)
        output += "Securities Only:                      %s\n" %(lSecurityOnly)
        output += "Currencies Only:                      %s\n" %(lCurrencyOnly)
        output += "Shown on Summary Page Only Filter:    %s\n" %(lSummaryScreenOnly)
        output += "Securities with Holdings Only Filter: %s\n" %(lSecurityHoldings)
        output += "All including OK Objects too:         %s\n" %(lEverything)
        output += "-----------------------------------------------------------------\n"

        if not autofix: output += "\n<END>"

        jif = QuickJFrame("DIAGNOSE SECURITY/CURRENCY CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD(S)", output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

        if lMustRunFixCurrenciesFirst:
            txt = "@@ ERROR: old format Currency record(s) detected (review output). Consider running Fix relative currencies option @@"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not autofix: return

        if len(currs_to_fix) < 1:
            myPopupInformationBox(jif,"There are no warnings to fix / can be fixed - will exit without changes","AUTOFIX HIDDEN CURRENT PRICE 'PRICE_DATE' FIELD")
            return

        MyPopUpDialogBox(jif,
                         "Proceed to autofix?",
                         "At the next screen you will be asked whether to proceed with the change(s), to backup, and to accept the disclaimer\n"
                         "Clicking YES will fix all the WARNINGS identified/displayed.\n"
                         "It will also then ask you whether you wish to update any Current Prices if they are different from the Last Dated History Price.\n",
                         theTitle="HIDDEN PRICE DATE FIELD AUTOFIX",
                         OKButtonText="NEXT STEP").go()

        if not confirm_backup_confirm_disclaimer(jif, "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELDS",
                                                 "EXECUTE AUTOFIX on %s CURRENCY/SECURITY HIDDEN 'PRICE_DATE' RECORDS?" %(len(currs_to_fix))):
            return

        lUpdatePricesToo = myPopupAskQuestion(jif,"AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELDS","Shall I update the current price(s) to match the latest price history at the same time?")

        jif.dispose()

        myPrint("B","AUTOFIX Currency / Security current price hidden 'price_date' fields running on %s records..." %(len(currs_to_fix)))
        output += "\n\n\nAUTOFIX log....\n ===============\n\n"

        txt = "AUTOFIX: User Response: Update current price to match latest dated history price too: %s" %(lUpdatePricesToo)
        myPrint("B",txt)
        output += ("\n" + txt + "\n\n")

        _CURRS_FIX_CURR = 0
        _CURRS_FIX_DATE = 1
        _CURRS_FIX_NEWRATE = 2
        _CURRS_FIX_RELCURR = 3

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for fix_reqd in currs_to_fix:
            curr = fix_reqd[_CURRS_FIX_CURR]
            newDateLong = fix_reqd[_CURRS_FIX_DATE]
            newRate = fix_reqd[_CURRS_FIX_NEWRATE]
            rCurr = fix_reqd[_CURRS_FIX_RELCURR]
            oldRate = curr.getRelativeRate()

            lUpdateThisPrice = lUpdatePricesToo
            if newRate == 0 or newRate == oldRate or not isGoodRate(newRate):
                lUpdateThisPrice = False

            myPrint("B","")
            myPrint("B", "@@ FIXING: %s (relative curr: %s)." %(curr, rCurr))
            output += ("@@ FIXING: %s (relative curr: %s).\n" %(curr, rCurr))

            myPrint("B", "...Updating current price hidden 'price_date' to %s" %(get_time_stamp_as_nice_text(newDateLong)))
            output += ("...Updating current price hidden 'price_date' to %s\n" %(get_time_stamp_as_nice_text(newDateLong)))

            if lUpdateThisPrice:
                myPrint("B", "...Updating current rate from %s to %s" %(safeInvertRate(oldRate), safeInvertRate(newRate)))
                output += ("...Updating current rate from %s to %s\n" %(safeInvertRate(oldRate), safeInvertRate(newRate)))

            myPrint("B","")
            output += "\n"

            curr.setEditingMode()
            curr.setParameter("price_date", newDateLong)
            if lUpdateThisPrice:
                curr.setRate(Util.safeRate(newRate),rCurr)
            curr.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "AUTOFIX: %s records updated" %(len(currs_to_fix))
        myPrint("B",txt)
        output += txt
        output += "\n<END>\n"

        jif = QuickJFrame("AUTOFIX SECURITY/CURRENCY CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD(S)", output,
                          copyToClipboard=lCopyAllToClipBoard_TB, lRestartMDAfterClose=True, lWrapText=False, lAutoSize=True).show_the_frame()

        _msg = "AUTOFIX: %s records fixed" %(len(currs_to_fix))
        setDisplayStatus(_msg, "DG")
        play_the_money_sound()
        myPopupInformationBox(jif,_msg,"AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD")

        myPopupInformationBox(jif,"RESTART OF MONEYDANCE REQUIRED - MD WILL RESTART AFTER VIEWING THIS OUTPUT",
                              "AUTOFIX CURRENT PRICE HIDDEN 'PRICE_DATE' FIELD",
                              theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def read_preferences_file(lSaveFirst=False):

        cf = Common.getPreferencesFile()

        if lSaveFirst:
            MD_REF.savePreferences()

        try:
            st = StreamTable()
            st.readFromFile(str(cf))
            tk = st.getKeyArray()
            tk = sorted(tk)
        except:
            st, tk = None, None
            dump_sys_error_to_md_console_and_errorlog()

        return st,tk

    def check_for_window_display_data(theKey, theValue):

        if not isinstance(theValue, (str,unicode)):             return False
        if theKey.startswith("gui.current_theme"):              return False
        if theKey.startswith("gui.dashboard.item"):             return False
        if theKey.startswith("gui.font_increment"):             return False
        if theKey.startswith("gui.new_txn_on_record"):          return False
        if theKey.startswith("gui.quickdecimal"):               return False
        if theKey.startswith("gui.register_follows_txns"):      return False
        if theKey.startswith("gui.show_all_accts_in_popup"):    return False
        if theKey.startswith("gui.source_list_visible"):        return False

        # Preferences Home Screen options
        if theKey.startswith("gui.home"):                       return False

        if not (theKey.startswith("ext_mgmt_win")
                or theKey.startswith("security_list")
                or theKey.startswith("curr_list")
                or theKey.startswith("ratioSettings.")
                or theKey.startswith("ol_acct_map_win")
                or theKey.startswith("moneybot_py_divider")
                or theKey.startswith("mbot.loc")
                or theKey.startswith("mbot.size")
                or theKey.startswith("gui.")
                or theKey.endswith("rec_reg.credit")
                or theKey.endswith("rec_reg.debit")
                or "col_widths." in theKey
                or ("sel_" in theKey and theKey.endswith("_filter"))
                or "sel_inv_view" in theKey):
            return False

        if not ("window" in theKey
                or "win_loc" in theKey
                or "_list_loc" in theKey
                or "_win.loc" in theKey
                or "_report_loc" in theKey
                or "width" in theKey
                or "isopen" in theKey
                or "winloc" in theKey
                or "winsize" in theKey
                or "winsz" in theKey
                or "win.sz" in theKey
                or "divider" in theKey
                or "location" in theKey
                or "size" in theKey
                or "rec_reg.credit" in theKey
                or "rec_reg.debit" in theKey
                or "mbot.loc" in theKey
                or "_expanded" in theKey
                or "_filter" in theKey
                or "maximized" in theKey
                or "sel_inv_view" in theKey):
            return False

        return True

    def check_for_just_locations_window_display_data(theKey, theValue):

        # Assumes you have called check_for_window_display_data() first!

        # Locations are  number x number - e.g. 10x100
        if "x" not in theValue.lower(): return False

        if not ("win_loc" in theKey
                or "_list_loc" in theKey
                or "_win.loc" in theKey
                or "_report_loc" in theKey
                or "winloc" in theKey
                or "location" in theKey
                or "mbot.loc" in theKey):
            return False

        return True

    def check_for_just_sizes_window_display_data(theKey, theValue):

        # Assumes you have called check_for_window_display_data() first!

        # Sizes are  number x number - e.g. 10x100
        if "x" not in theValue.lower(): return False
        if "font" in theValue.lower(): return False

        if not ("win_size" in theKey
                or "size" in theKey
                or "winsize" in theKey
                or "winsz" in theKey
                or "win.sz" in theKey
                or "location" in theKey
                or "mbot.size" in theKey):
            return False

        return True

    # noinspection PyUnusedLocal
    def check_for_just_register_filters_window_display_data( theKey, theValue ):

        # Assumes you have called check_for_window_display_data() first!

        if  not ("sel_" in theKey and theKey.endswith("_filter") ):
            return False

        return True

    # noinspection PyUnusedLocal
    def check_for_just_initial_view_filters_window_display_data( theKey, theValue ):

        if  not ("sel_" in theKey and theKey.endswith("_view") ):
            return False

        return True

    # copied from Moneydance TxnRegister.class
    def loadMDPreferences(dataObject,  preferencesKey, lGetDefaultForObject=True):   # dataObject should always = Account.

        preferencesKey = preferencesKey

        if not preferencesKey:
            dataPrefKey = "col_widths"
        else:
            dataPrefKey = "col_widths." + preferencesKey

        colWidthPrefs = None

        if dataObject:
            colWidthPrefs = dataObject.getPreference(dataPrefKey, None)

        if not lGetDefaultForObject and dataObject and not colWidthPrefs: return None

        if StringUtils.isBlank(colWidthPrefs) and preferencesKey:
            colWidthPrefs = MD_REF.getUI().getPreferences().getSetting(dataPrefKey, None)

        if not colWidthPrefs or StringUtils.isBlank(colWidthPrefs):
            return None

        if not colWidthPrefs.startswith(":"):
            colWidthPrefs = ":" + colWidthPrefs

        params = SyncRecord()
        try:
            params.readSet(StringReader(colWidthPrefs))
        except IOException:
            myPrint("B", "Error parsing register settings: " + colWidthPrefs + " key=" + preferencesKey)
            return None

        widths = params.getIntArray("cols")                                                     # int[]

        if params.getBoolean("splitreg", False):
            splitReg = True
            splitSz = Dimension(10, Math.max(0, params.getInt("splitsz", 100)))                   # Dimension
        else:
            splitSz = None
            splitReg = False

        ascending = params.getBoolean("ascending", True)
        sortID = TxnSortOrder.fromInt(params.getInt("sort", -1), ascending)                     # TxnSortOrder

        if sortID:
            pass

        oneLineMode = params.getBoolean("oneline", False)                                     # boolean

        position = params.getString("position", params.getString("offset", None))               # String
        if position:
            pass

        position2 = params.getString("position2", params.getString("offset2", None))            # String
        if position2:
            pass

        theUUID = None
        if dataObject: theUUID = dataObject.getUUID()

        if debug:
            myPrint("D","Object: ", dataObject, theUUID)
            myPrint("D","Analysing the key: %s" %preferencesKey)
            myPrint("D",":oneline:", oneLineMode, type(oneLineMode))
            myPrint("D","splitreg:", splitReg, type(splitReg))
            myPrint("D","splitsz:", splitSz, type(splitSz))
            myPrint("D","sort:", sortID, type(sortID))
            myPrint("D","position:", position, type(position))
            myPrint("D","ascending:", ascending, type(ascending))
            myPrint("D","cols:", widths, type(widths))
            myPrint("D","position2:", position2, type(position2))

        return [oneLineMode, splitReg, splitSz, sortID, position, ascending, widths, position2]

    def extract_StuWareSoftSystems_version(theVersionToCheck):

        _MAJOR = 0
        _MINOR = 1

        theVersionToCheck = str(theVersionToCheck).strip()

        if len(theVersionToCheck) < 1: return [0,0]

        if len(theVersionToCheck) == 1: return [int(theVersionToCheck),0]

        if "." in theVersionToCheck:
            x = theVersionToCheck.split(".")
            return [int(x[0]),x[1]]

        major = minor = ""

        for char in theVersionToCheck:
            if (not minor) and (char >= "0" and char <= "9"): # noqa
                major += char
                continue
            minor+=char

        if debug:
            myPrint("D","Decoded: %s.%s" %(major,minor))

        try:
            return [int(major),minor]
        except:
            return [0,0]

    def check_for_updatable_extensions_on_startup():
        global lIgnoreOutdatedExtensions_TB     # global must be here as we can set it

        Toolbox_version = 0

        displayData = u"\nALERT INFORMATION ABOUT YOUR EXTENSIONS:\n\n"

        try:
            theUpdateList = get_extension_update_info()

            if not theUpdateList or len(theUpdateList)<1:
                return Toolbox_version

            for key in theUpdateList.keys():
                updateInfo = theUpdateList[key]
                displayData+=u"** UPGRADEABLE EXTENSION: %s to version: %s\n" %(pad(key,20),(updateInfo[0].getBuild()))
                myPrint(u"B", u"** UPGRADEABLE EXTENSION: %s to version: %s" %(pad(key,20),(updateInfo[0].getBuild())))
                if key.lower() == u"%s" %myModuleID and int(updateInfo[0].getBuild()) > 0:
                    Toolbox_version = int(updateInfo[0].getBuild())
        except:
            dump_sys_error_to_md_console_and_errorlog()
            return Toolbox_version

        displayData+=u"\n<END>\n"

        howMany = int(len(theUpdateList))

        if not lIgnoreOutdatedExtensions_TB:
            txt = u"ALERT - YOU HAVE %s EXTENSION(S) THAT CAN BE UPGRADED!..." %(howMany)
            setDisplayStatus(txt, "B")
            jif = QuickJFrame(u"EXTENSIONS ALERT!", displayData, lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
            options=[u"OK (keep reminding me)",u"OK - DON'T TELL ME AGAIN ON STARTUP!"]
            response = JOptionPane.showOptionDialog(jif,
                                                    u"INFO: You have %s older Extensions that can be upgraded" %howMany,
                                                    u"OUTDATED EXTENSIONS",
                                                    0,
                                                    JOptionPane.QUESTION_MESSAGE,
                                                    getMDIcon(None),
                                                    options,
                                                    options[0])

            if response:
                myPrint(u"B",u"User requested to ignore Outdated warning extensions going forward..... Acknowledged!!")
                lIgnoreOutdatedExtensions_TB = True
                try:
                    save_StuWareSoftSystems_parameters_to_file()
                except:
                    myPrint(u"B", u"Error - failed to save parameters to pickle file...!")
                    dump_sys_error_to_md_console_and_errorlog()

        else:
            txt = u"ALERT - YOU HAVE %s EXTENSION(S) THAT CAN BE UPGRADED!...STARTUP POPUP WARNINGS SUPPRESSED (by you)" %(howMany)
            setDisplayStatus(txt, "B")

        return Toolbox_version

#     def check_for_old_StuWareSoftSystems_scripts():
#         lVersionWarning = False
#
#         if not GlobalVars.parametersLoadedFromFile and not GlobalVars.lPickle_version_warning:
#             return
#
#         displayData = "\nStuWareSoftSystems: ALERT INFORMATION ABOUT SCRIPTS:\n\n"
#
#         if GlobalVars.lPickle_version_warning:
#             displayData += "I detected an older (encrypted) version of saved parameter file for use with my Python scripts\n"
#             displayData += ".... but no problem, I have updated / converted it.\n\n"
#
#         _MAJOR = 0
#         _MINOR = 1
#         iCountOldScripts = 0
#
#         if GlobalVars.parametersLoadedFromFile:
#
#             for key in sorted(GlobalVars.parametersLoadedFromFile.keys()):
#                 if key.startswith("__") and key != "__Author":
#                     myPrint("DB","Decoding old script versions for key: %s version_build: %s" %(key,GlobalVars.parametersLoadedFromFile[key]))
#                     theVersion = extract_StuWareSoftSystems_version(GlobalVars.parametersLoadedFromFile[key])
#                     if key == "__extract_currency_history_csv":
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key.lower() == "__StockGlance2020".lower():
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key == "__extract_reminders_to_csv":     # Old key - renamed... but see if it's around....
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key == "__extract_reminders_csv":
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     elif key == "__extract_investment_transactions":
#                         if theVersion[_MAJOR] <  1000:
#                             pass
#                         else: continue
#                     else: continue
#                     displayData+="ALERT: Script: %s is out of date - you have version_build: %s_%s\n" %(key,theVersion[_MAJOR],theVersion[_MINOR])
#                     myPrint("DB", "Script %s is out of date - PLEASE UPDATE"%key)
#                     iCountOldScripts+=1
#                     lVersionWarning = True
#
#
#         if GlobalVars.lPickle_version_warning or lVersionWarning:
#             displayData+="""
#
# The current versions are available as Extensions from the MD Menu >> Manage Extensions....
#
# NOTE: extract_data is a consolidation of all prior extract scripts - including:
# - stockglance2020.py:
# - extract_reminders_csv.py:
# - extract_currency_history_csv.py:
# - extract_investment_transactions_csv.py:
# - extract_account_registers_csv
#
# Please update any that you use before proceeding....
# """
#
#             jif = QuickJFrame("StuWareSoftSystems - Scripts alert!", displayData, 1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
#
#             txt = "PLEASE UPDATE OLDER VERSIONS OF STUWARESOFTSYSTEMS SCRIPTS!..."
#             setDisplayStatus(txt, "B")
#
#             myPopupInformationBox(jif, "You have %s older StuWareSoftSystems scripts - please upgrade them!" %(iCountOldScripts), "STUWARESOFTSYSTEMS' SCRIPTS", JOptionPane.WARNING_MESSAGE)
#
#         return

    def get_vmoptions_path():

        DEFAULT_NAME = "Moneydance.vmoptions"
        EXTENSION = ".vmoptions"

        grabProgramDir = find_the_program_install_dir()
        if grabProgramDir == "": return ""

        defaultPath = os.path.join(grabProgramDir, DEFAULT_NAME)

        launchName = System.getProperty("exe4j.launchName","")
        if not os.path.exists(launchName): return defaultPath

        baseName = os.path.basename(launchName)
        splitBaseName = os.path.splitext(baseName)

        vmoptionsPath = os.path.join(grabProgramDir, splitBaseName[0] + EXTENSION)
        if not os.path.exists(vmoptionsPath): return defaultPath

        return vmoptionsPath


    def find_the_program_install_dir():

        theDir = ""                                                                                                     # noqa

        if Platform.isOSX():
            # Derive from these - not great, but OK: java.home, java.library.path, sun.boot.library.path

            test = System.getProperty("java.home","").strip()
            _i = test.lower().find(".app/")                                                                             # noqa
            if _i > 0:
                theDir = test[:_i+4]
            else:
                theDir = System.getProperty("install4j.exeDir","").strip()
        else:
            theDir = System.getProperty("install4j.exeDir","").strip()

        if not os.path.exists(theDir):
            theDir = ""

        return theDir

    def get_orphaned_extension():

        extension_prefs = MD_REF.getUI().getPreferences().getTableSetting("gen.fmodules",StreamTable())

        # Get all keys in config dict
        st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
        confirmed_extn_keys = {}
        for theKey in tk:
            if not theKey.lower().startswith("confirmedext."):
                continue    # skip
            confirmed_extn_keys[theKey.split('.')[1].lower().strip()]  = theKey

        outdated={}
        if float(MD_REF.getBuild()) < 3051:
            # .getOutdatedExtensionIDs() name changed prior to 3051
            x = MD_REF.getOutdatedExtensionIDs()                                                                        # noqa
        else:
            x = MD_REF.getUnloadableExtensionIDs()  # now includes 'extension too new' extns....
        for y in x: outdated[y.lower().strip()] = True

        ok={}
        x = MD_REF.getLoadedModules()
        for y in x: ok[str(y.getIDStr()).lower().strip()] = True
        x = MD_REF.getSuppressedExtensionIDs()
        for y in x: ok[str(y).lower().strip()] = True

        orphan_outdated_prefs = {}
        for extn_pref in extension_prefs:
            if not ok.get(extn_pref.lower().strip()) and not outdated.get(extn_pref.lower().strip()):
                orphan_outdated_prefs[extn_pref] = "ORPHAN"
            elif outdated.get(extn_pref.lower().strip()):
                orphan_outdated_prefs[extn_pref] = "OUTDATED"

        orphan_confirmed_extn_keys = {}
        for extn_pref in confirmed_extn_keys:
            if not ok.get(extn_pref.lower().strip()) and not outdated.get(extn_pref.lower().strip()):
                orphan_confirmed_extn_keys[extn_pref] = ["ORPHAN",confirmed_extn_keys.get(extn_pref.lower().strip())]
            elif outdated.get(extn_pref.lower().strip()):
                orphan_confirmed_extn_keys[extn_pref] = ["OUTDATED",confirmed_extn_keys.get(extn_pref.lower().strip())]

        orphan_outdated_files={}
        extn_files_found=[]

        extensionDir = Common.getFeatureModulesDirectory()
        if extensionDir:
            # noinspection PyTypeChecker
            for root, dirs, files in os.walk(extensionDir.getAbsolutePath()):
                for filename in files:
                    for extn in ModuleLoader.FEATURE_MODULE_EXTENSIONS:
                        if filename.endswith("."+extn):
                            # got an Extension
                            extn_files_found.append([os.path.splitext(filename)[0].lower().strip(),filename])
                            pass

        for extn_file in extn_files_found:
            if not ok.get(extn_file[0]):
                if outdated.get(extn_file[0]):
                    orphan_outdated_files[extn_file[0]] = ["OUTDATED",extn_file[1]]
                else:
                    orphan_outdated_files[extn_file[0]] = ["ORPHAN",extn_file[1]]

        myPrint("DB","OK Extensions:", ok)
        myPrint("DB","OUTDATED: Extensions:", outdated)
        myPrint("DB","ORPHAN/OUTDATED Extension Preferences:", orphan_outdated_prefs)
        myPrint("DB","ORPHAN/OUTDATED Extension Files:", orphan_outdated_files)
        return [orphan_outdated_prefs, orphan_outdated_files, orphan_confirmed_extn_keys]

    # noinspection PyUnresolvedReferences
    def diagnose_currencies(lFix=False):

        # MD2017.10 backwards did not use the 'rrate' parameter. It only used 'rate'
        # 'rate' was the raw rate expressed as a factor of the difference in decimal places relative to the base currency.
        # From MD2019 onwards, the 'relative' currency setup changed and 'rrate' was created. 'rrate' stored the actual rate.
        # It was supposed to be the case that MD2019+ would see the missing 'rrate' field and convert the legacy rate in memory
        # Even though new 'rrate' was now in memory (in a variable), the data was not stored back to the parameter 'rrate', and was always missing
        # Once you actually edited a price using Tools/Currencies, then the new 'rrate' parameter would be created...
        # BUT, there is a bug and in fact as well as the new 'rrate' the old 'rate' was changed too. So, backwards compatibility to 2017 was lost.

        # Example: Stock: Price £6.25 Old 'rate' was stored as 16 (2dpc) in MD2017. In MD2019 new 'rrate' is 0.16.
        # Old 'rate' was supposed to always stay as 16, but once edited in MD2019 it became 0.16 too (BUG).
        # This does not matter for MD2019 onwards as it's legacy and ignored.
        # However, if you go back to MD2017, then you will see your Current Price become £625 as 'rate' is now wrong....
        # Also, if you use the edit decimal places function in Toolbox, then you will also have a rate dpc issue if you go back to 2017.

        # There was another bug, in that if you edited any part of the CurrencyType record where the 'rrate' was missing,
        # then .itemWasUpdated() would run and reload the new rate in memory (from 'rrate') which was missing. This then corrupted the rate
        # This was addressed in MD2021.2(3089), and .itemWillSync() was changed so that 'rrate' parameter is set (in memory) if missing.
        # It appears that upon opening a dataset in MD2021.2(3089) onwards, that this change updates all missing rrate parameters in memory.....
        # These in memory changes are not saved by calling .syncIntem(), thus they only exist in memory unless a subsequent update is made and .syncItem() called
        # .... so the change does not exist in trunk or any .txn file until a subsequent change..
        # And so, updating the record in MD2021.2(3089) onwards is not an issue.
        # I'm assuming as these are not sync'd that sync copies must also run the matching MD version and will self-apply the same in memory fixes...

        # Given this knowledge, I have disabled any updates to legacy 'rate', and I now only touch 'rrate'.
        # MD can do whatever it wants (rightly or wrongly to 'rate')
        # I would expect that this fix utility will now only find relative rate errors not rate/rrate errors from MD2021.1(3089)+

        # Other notes:
        # Currencies can only be relative to base (and should be set to None)
        # Securities should be set to Base (as None), or can be relative to another Currency (not Security)
        # Max relative relational depth is SEC>CURR>Base or CURR>Base

        global fixRCurrencyCheck      # global must be here as we set it

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "Diagnose currencies / securities (including relative currencies)"
        if lFix: _THIS_METHOD_NAME = "FIX currencies / securities (including relative currencies)"

        PARAM_RATE = "rate"
        PARAM_RRATE = "rrate"
        PARAM_REL_CURR_ID = "rel_curr_id"
        PARAM_RELATIVE_TO_CURRID = "relative_to_currid"

        # reset_relative_currencies.py
        myPrint("B", "Script running to %s ..............." %(_THIS_METHOD_NAME))

        if MD_REF.getCurrentAccount().getBook() is None: return

        VERBOSE = True
        lFixErrors = lFixWarnings = False
        lCurrencies = lSecurities = True


        def validateCurrencyKeys(theCurr):

            _rCurrByIDs = theCurr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
            if _rCurrByIDs: return True

            _get_rel_curr_id = theCurr.getParameter(PARAM_REL_CURR_ID,None)
            _get_relative_to_currid = theCurr.getParameter(PARAM_RELATIVE_TO_CURRID,None)

            if not _get_rel_curr_id and not _get_relative_to_currid: return True

            return False


        if lFix:
            if not fixRCurrencyCheck:
                txt = "Sorry, you must run 'DIAG: Diagnose Currencies / Securities' first! - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            elif fixRCurrencyCheck == 1:
                txt = "'DIAG: Diagnose Currencies / Securities' reported no issues - so I will not run fixes - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            elif fixRCurrencyCheck == 2:
                pass
            elif fixRCurrencyCheck != 3:
                txt = "LOGIC ERROR reviewing 'DIAG: Diagnose Currencies / Securities' - so I will not run fixes - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            user_fixOnlyErrors = JRadioButton("Fix only Errors (ignore warnings)?", False)
            user_fixErrorsAndWarnings = JRadioButton("Fix Errors AND warnings?", False)
            bg1 = ButtonGroup()
            bg1.add(user_fixOnlyErrors)
            bg1.add(user_fixErrorsAndWarnings)

            user_fixOnlyCurrencies = JRadioButton("Fix only Currencies?", False)
            user_fixOnlySecurities = JRadioButton("Fix only Securities?", False)
            user_fixBothCurrenciesAndSecurities = JRadioButton("Fix BOTH Currencies AND Securities?", False)
            bg2 = ButtonGroup()
            bg2.add(user_fixOnlyCurrencies)
            bg2.add(user_fixOnlySecurities)
            bg2.add(user_fixBothCurrenciesAndSecurities)

            user_VERBOSE = JCheckBox("Verbose Output?",True)
            userFilters = JPanel(GridLayout(0, 1))

            if fixRCurrencyCheck != 2:
                userFilters.add(user_fixOnlyErrors)
            userFilters.add(user_fixErrorsAndWarnings)
            userFilters.add(JLabel("-------------"))
            userFilters.add(user_fixOnlyCurrencies)
            userFilters.add(user_fixOnlySecurities)
            userFilters.add(user_fixBothCurrenciesAndSecurities)
            userFilters.add(JLabel("-------------"))
            userFilters.add(user_VERBOSE)

            while True:
                options = ["EXIT", "PROCEED"]
                userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                           userFilters,
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.OK_CANCEL_OPTION,
                                                           JOptionPane.QUESTION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           options, options[0]))
                if userAction != 1:
                    txt = "'%s' - No changes made....." %(_THIS_METHOD_NAME.upper())
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,_THIS_METHOD_NAME,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if not user_fixOnlyErrors.isSelected() and not user_fixErrorsAndWarnings.isSelected():
                    continue
                if not user_fixOnlyCurrencies.isSelected() and not user_fixOnlySecurities.isSelected() and not user_fixBothCurrenciesAndSecurities.isSelected():
                    continue
                break

            del userFilters, bg1, bg2

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "EXECUTE '%s'?" %(_THIS_METHOD_NAME.upper())):
                return

            VERBOSE = user_VERBOSE.isSelected()
            lFixErrors=True
            lFixWarnings=user_fixErrorsAndWarnings.isSelected()
            lCurrencies=(user_fixOnlyCurrencies.isSelected() or user_fixBothCurrenciesAndSecurities.isSelected())
            lSecurities=(user_fixOnlySecurities.isSelected() or user_fixBothCurrenciesAndSecurities.isSelected())

        else:

            txt = "Diagnosing Currencies/Securities"
            if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


        # OK - let's do it!
        fixRCurrencyCheck = None

        lNeedFixScript = False
        iWarnings = 0

        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies()
        baseCurr = currencies.getBaseType()

        output = "%s: \n" \
                 " ===================================================\n\n" %(_THIS_METHOD_NAME)

        # Catch any error during update - this would be bad! :-<
        try:
            if lFix:
                output += "FIX MODE:\n" \
                          " ========\n" \
                          "Parameters Selected:\n" \
                          "- Fix Errors: %s\n" \
                          "- Fix Errors and Warnings: %s\n" \
                          "- Fix Currencies: %s\n" \
                          "- Fix Securities: %s\n" \
                          "- VERBOSE: %s\n\n" \
                          % (lFixErrors, lFixWarnings, lCurrencies, lSecurities, VERBOSE)

                MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
                MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
                MD_REF.getUI().setSuspendRefresh(True)

            # ##########################################################################################################
            # BASE CURRENCY FIRST
            # ##########################################################################################################
            if not lFix or lCurrencies:
                output += "Analysing the Base currency setup....\n"
                output += "Base currency: %s\n" % baseCurr

                lSyncNeeded = False

                # Relative Rate - should always be 1.0
                if baseCurr.getParameter(PARAM_RRATE, None) is None or not isGoodRate(baseCurr.getDoubleParameter(PARAM_RRATE, 0.0)) or baseCurr.getDoubleParameter(PARAM_RRATE, 0.0) != 1.0:
                    txt = "@@ERROR@@ - base currency '%s' has (new) relative 'rrate' <> 1: %s (whereas legacy 'rate' is set to: %s)" \
                          %(baseCurr, baseCurr.getParameter(PARAM_RRATE, None), baseCurr.getParameter(PARAM_RATE, None))
                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    lNeedFixScript = True
                    if lFix:
                        lSyncNeeded = True
                        baseCurr.setEditingMode()
                        baseCurr.setParameter(PARAM_RATE, 1.0)
                        baseCurr.setParameter(PARAM_RRATE, 1.0)
                        baseCurr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                        txt = "@@BASE CURRENCY FIX APPLIED (set 'rrate' to 1.0) @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                # The Rate - should always be 1.0
                # if baseCurr.getParameter(PARAM_RATE, None) is None or not isGoodRate(baseCurr.getDoubleParameter(PARAM_RATE, 0.0)) or baseCurr.getDoubleParameter(PARAM_RATE, 0.0) != 1.0:
                #     txt = "@@ERROR@@ - base currency has (legacy) 'rate' <> 1: %s" %(baseCurr.getParameter(PARAM_RATE, None))
                #     myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                #     lNeedFixScript = True
                #     if lFix:
                #         lSyncNeeded = True
                #         baseCurr.setEditingMode()
                #         baseCurr.setParameter(PARAM_RATE, 1.0)
                #         baseCurr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
                #         txt = "@@BASE CURRENCY FIX APPLIED (set legacy 'rate' to 1.0) @@"
                #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                if lSyncNeeded:
                    baseCurr.syncItem(); lSyncNeeded = False                                                            # noqa

                if not lNeedFixScript:
                    output += ("Base currency has legacy 'rate' of: %s and new relative 'rrate': of %s >> 'rrate' is correct...\n"
                               % (baseCurr.getParameter(PARAM_RATE, None), baseCurr.getParameter(PARAM_RRATE, None)))

                # Check for price history - should be none on base currency (also now handled by MD launch)
                baseSnapshots = baseCurr.getSnapshots()
                if baseSnapshots.size() > 0:
                    lNeedFixScript = True
                    txt = "ERROR: base currency has %s historical prices! These need to be deleted!" %(baseSnapshots.size())
                    myPrint("J",txt); output += "----\n%s\n----\n" %(txt)
                    for baseSnapshot in baseSnapshots:
                        if lFix:
                            output += "  @@DELETING@@: %s\n" % (baseSnapshot)
                            baseSnapshot.deleteItem()
                        else:
                            if VERBOSE:
                                output += "  snapshot: %s\n" % baseSnapshot
                else:
                    output += "\nBase currency has no historical prices. This is correct\n"

                # Check Root account's currency is base
                root = MD_REF.getCurrentAccount().getBook().getRootAccount()
                if root.getCurrencyType() != baseCurr:
                    lNeedFixScript = True

                    txt = "Root account's currency: '%s', Base currency: '%s'" %(root.getCurrencyType(), baseCurr)
                    myPrint("J", txt); output += "%s\n" %(txt)

                    txt = "ERROR - The root account's currency is not set to base! This needs correcting!"
                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                    if lFix:
                        root.setCurrencyType(baseCurr); root.syncItem()
                        txt = "@@ROOT ACCOUNT CURRENCY FIX APPLIED (set to base)@@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                else:
                    output += "GOOD, the 'root' account's currency is set to the base currency! Root: '%s', Base: '%s'\n" % (root.getCurrencyType(), baseCurr)


            # Sort the table so that Currencies and Securities are together and by name
            currencies = sorted(currencies, key=lambda x: (x.getCurrencyType(), x.getName().upper()))

            last = None
            lWarning = False
            output += "\nAnalysing the Currency / Security table...\n" \
                      " ===========================================\n"

            for curr in currencies:

                if curr.getCurrencyType() != last:
                    output += "\n\n TYPE: %s\n" \
                              " ========================\n" %(curr.getCurrencyType())
                    last = curr.getCurrencyType()

                if curr.getCurrencyType() == CurrencyType.Type.SECURITY:

                    # ##################################################################################################
                    # SECURITIES
                    # ##################################################################################################
                    if lFix and not lSecurities: continue

                    lSyncNeeded = False

                    if VERBOSE:
                        output += "-----------------------------------------------------------------------------------------\n" \
                                  "Checking security: '%s' (uuid: %s)\n" %(curr, curr.getUUID())

                    get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID,None)
                    get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID,None)

                    rCurr = curr.getRelativeCurrency()
                    rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                    # This might still miss where one of the parameters is set, but the other is not, or where one is 'invalid'.... but let's see
                    if get_relative_to_currid is None and get_rel_curr_id is None:
                        pass    # This is OK, None is fine and means base
                    elif rCurrByIDs is None and rCurr is None:
                        pass    # This is OK, None is fine and means base
                    elif rCurrByIDs is not None and rCurrByIDs != baseCurr and rCurrByIDs.getCurrencyType() == CurrencyType.Type.CURRENCY:
                        pass    # This is OK, non-base currency is OK
                    elif rCurr is not None and rCurr != baseCurr and rCurr.getCurrencyType() == CurrencyType.Type.CURRENCY:
                        pass    # This is OK, non-base currency is OK
                    else:
                        if validateCurrencyKeys(curr):
                            lValidateCurrencies = True
                            txt = "@@ WARNING: '%s' relative_to_currid / rel_curr_id should only be None or NOT your base currency (currently %s : %s)!" %(curr,get_relative_to_currid,get_rel_curr_id)
                        else:
                            lValidateCurrencies = False
                            txt = "@@ WARNING: '%s' The relative currency appears to be missing? Either use Tools>Securities to fix manually, or this fix will reset it to base currency." %(curr)
                        myPrint("J", txt); output += "---\n%s\n" %(txt)
                        if lFix and lFixWarnings:
                            lSyncNeeded = True
                            curr.setEditingMode()
                            curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)  # Force the parameters in regardless!
                            if lValidateCurrencies:
                                txt = "@@SECURITY FIX APPLIED (set relative currency parameters to None) @@"
                            else:
                                txt = "@@SECURITY FIX APPLIED (reset the missing relative currency back to None - PLEASE VERIFY PRICE AND HISTORY IN TOOLS>SECURITIES!) @@"
                            myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                        else:
                            lWarning = True; iWarnings += 1

                    # reset in case I changed these above....
                    get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID,None)
                    get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID,None)
                    rCurr = curr.getRelativeCurrency()
                    rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                    get_rate = curr.getParameter(PARAM_RATE, None)
                    get_rateDbl = curr.getDoubleParameter(PARAM_RATE, 0.0)

                    get_rrate = curr.getParameter(PARAM_RRATE, None)
                    get_rrateDbl = curr.getDoubleParameter(PARAM_RRATE, 0.0)

                    # if get_rate is None or get_rateDbl == 0.0 or not isGoodRate(get_rateDbl):
                    #     txt = "@@ WARNING: '%s' has legacy rate (rate) of ZERO/Invalid" %(curr)
                    #     myPrint("J", txt); output += "----\n%s\n" %(txt)
                    #
                    #     if lFix and lFixWarnings:
                    #         lSyncNeeded = True
                    #         curr.setEditingMode()
                    #         curr.setParameter(PARAM_RATE, 1.0)
                    #         curr.setParameter(PARAM_RRATE, 1.0)
                    #         txt = "@@SECURITY FIX APPLIED (reset both legacy rate and new rrate to 1.0) @@"
                    #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #     else:
                    #         lWarning = True; iWarnings  += 1
                    #
                    if get_rrate is None or get_rrateDbl == 0.0 or not isGoodRate(get_rrateDbl):

                        if rCurr is None or rCurrByIDs is None:
                            isRelativeBase = True
                        elif rCurr == baseCurr or rCurrByIDs == baseCurr:
                            isRelativeBase = True
                        else:
                            isRelativeBase = False

                        if isRelativeBase:  # Relative to base currency
                            newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                            txt = "@@ WARNING: '%s' new relative 'rrate' is set to: %s (whereas legacy 'rate' is currently %s). New 'rrate' should be %s (inverted %s)\n"\
                                  %(curr, get_rrate, get_rate, newRate, safeInvertRate(newRate))
                            myPrint("J", txt); output += "---\n%s\n" %(txt)

                            if lFix and lFixWarnings:
                                lSyncNeeded = True
                                curr.setEditingMode()
                                # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters)...
                                if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                                curr.setParameter(PARAM_RRATE, newRate)
                                curr.setRate(newRate, baseCurr)
                                curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)
                                txt = "@@SECURITY FIX APPLIED (reset new 'rrate') @@"
                                myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                            else:
                                lWarning = True; iWarnings  += 1

                        else:  # Relative to another currency....

                            newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                            newRRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, rCurr))

                            txt = "@@ WARNING: '%s' ** Relative Curr is: '%s' ** legacy 'rate' is currently %s, whereas new relative 'rrate' is set to: %s. Should be new 'rrate': %s (inversed: %s)\n"\
                                  %(curr, rCurr, get_rate, get_rrate, newRRate, safeInvertRate(newRRate))
                            myPrint("J", txt); output += "---\n%s\n" %(txt)

                            if lFix and lFixWarnings:
                                lSyncNeeded = True
                                curr.setEditingMode()
                                # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters...
                                if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                                curr.setParameter(PARAM_RRATE, newRRate)
                                curr.setRate(newRRate, rCurr)
                                txt = "@@SECURITY FIX APPLIED (reset new 'rrate') @@"
                                myPrint("J", txt); output += "----\n%s\n----\n" %(txt)

                                # Doing this here so as not to trigger MD to set rrate to 1.0 (bug)
                                if rCurrByIDs is not None \
                                        and rCurrByIDs != baseCurr \
                                        and rCurrByIDs.getCurrencyType() == CurrencyType.Type.CURRENCY \
                                        and (get_relative_to_currid is None or get_rel_curr_id is None):

                                    curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, rCurrByIDs)
                                    txt = "@@EXTRA SECURITY FIX APPLIED (set both relative currency parameters) @@"
                                    myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                            else:
                                lWarning = True; iWarnings  += 1


                    iCountSnapErrors = 0
                    currSnapshots = curr.getSnapshots()
                    for snap in currSnapshots:
                        if not isGoodRate(snap.getRate()):
                            iCountSnapErrors += 1
                    if iCountSnapErrors > 0:
                        output += "\n  ** NOTE: You have %s history records with a zero or infinity price/rate! **\n" %(iCountSnapErrors)

                    if lFix and lSyncNeeded:
                        curr.syncItem()

                    continue

                # ######################################################################################################
                # CURRENCIES
                # ######################################################################################################
                if lFix and not lCurrencies: continue

                lSyncNeeded = False

                if VERBOSE:
                    output += "\n-----------------------------------------------------------------------------------------------" \
                              "\nChecking currency: %s\n" % curr

                get_rel_curr_id = curr.getParameter(PARAM_REL_CURR_ID, None)
                get_relative_to_currid = curr.getParameter(PARAM_RELATIVE_TO_CURRID, None)
                rCurr = curr.getRelativeCurrency()                                                                      # noqa
                rCurrByIDs = curr.getCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)

                if validateCurrencyKeys(curr):
                    lValidateCurrencies = True
                else:
                    lValidateCurrencies = False

                if rCurrByIDs is not None:
                    strEnd = ""
                elif not lValidateCurrencies:
                    strEnd = " - YOU APPEAR TO HAVE A MISSING RELATIVE CURRENCY?"
                else:
                    strEnd = " - None / NOT SET (this is OK and means the Base Rate will be used)"

                if VERBOSE:
                    output += "relative_to_currid: %s, rel_curr_id: %s %s\n" %(get_relative_to_currid, get_rel_curr_id, strEnd)

                if rCurrByIDs is not None or not lValidateCurrencies:
                    if lValidateCurrencies:
                        txt = "@@ WARNING: '%s' relative_to_currid & rel_curr_id should both be set to None (which means use base currency)!" %(curr)
                    else:
                        txt = "@@ WARNING: '%s' You have a missing Relative Currency. This fix can reset it back to base currency." %(curr)
                    myPrint("J", "%s" %(txt)); output += "----\n%s\n----\n" %(txt)

                    if lFix and lFixWarnings:
                        lSyncNeeded = True
                        curr.setEditingMode()
                        curr.setRelativeCurrency(None)  # This converts the snaps too!
                        curr.setCurrencyParameter(None, PARAM_REL_CURR_ID, PARAM_RELATIVE_TO_CURRID, None)  # Force the parameters in regardless
                        if lValidateCurrencies:
                            if rCurrByIDs == baseCurr:
                                txt = "@@CURRENCY FIX APPLIED (set both relative currency parameters to None) @@"
                            else:
                                txt = "@@CURRENCY FIX APPLIED (set relative currency parameters to None, rates, price history converted back to base) >> REVIEW CURRENT PRICE & HISTORICAL PRICES IN TOOLS>CURRENCIES! @@"
                        else:
                            txt = "@@CURRENCY FIX APPLIED (missing relative currency reset to base) >> REVIEW CURRENT PRICE & HISTORICAL PRICES IN TOOLS>CURRENCIES! @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    else:
                        lWarning = True; iWarnings += 1

                get_rate = curr.getParameter(PARAM_RATE, None)
                get_rateDbl = curr.getDoubleParameter(PARAM_RATE, 0.0)

                get_rrate = curr.getParameter(PARAM_RRATE, None)
                get_rrateDbl = curr.getDoubleParameter(PARAM_RRATE, 0.0)

                if VERBOSE:
                    output += "Legacy 'rate': %s (inverted: %s)\n" % (get_rate, safeInvertRate(get_rateDbl))

                if get_rate is not None and isGoodRate(get_rateDbl) and get_rrate is not None and isGoodRate(get_rateDbl):

                    if VERBOSE:
                        output += "New relative 'rrate': %s (inverted: %s)\n" % (get_rrate, safeInvertRate(get_rrateDbl))

                elif curr == baseCurr:
                    # Note: We fix base earlier on....
                    pass

                else:

                    # if get_rate is None or get_rateDbl == 0.0 or not isGoodRate(get_rateDbl):
                    #     txt = "@@ WARNING: '%s' has legacy 'rate' of ZERO/Invalid" %(curr)
                    #     myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #
                    #     if lFix and lFixWarnings:
                    #         lSyncNeeded = True
                    #         curr.setEditingMode()
                    #         curr.setParameter(PARAM_RATE, 1.0)
                    #         curr.setParameter(PARAM_RRATE, 1.0)
                    #         txt = "@@CURRENCY FIX APPLIED (reset both 'rate' and 'rrate' to 1.0) @@"
                    #         myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    #     else:
                    #         lWarning = True; iWarnings  += 1
                    #

                    # should always be set and always relative to base (1.0)
                    newRate = 1.0 / Util.safeRate(CurrencyUtil.getUserRate(curr, baseCurr))  # Copied from the MD code.....
                    txt = "@@ WARNING: '%s' new relative 'rrate' is set to: %s (whereas legacy 'rate' is currently %s). 'rrate' should be %s (inverted %s)" \
                          %(curr, get_rrate, get_rate, newRate, safeInvertRate(newRate))
                    myPrint("J", txt); output += "---\n%s\n---\n" %(txt)

                    if lFix and lFixWarnings:
                        lSyncNeeded = True
                        curr.setEditingMode()
                        # force the parameters in (sometimes setRate() detects a no change and doesn't apply the new parameters...
                        if not isGoodRate(get_rateDbl): curr.setParameter(PARAM_RATE, newRate)
                        curr.setParameter(PARAM_RRATE, newRate)
                        curr.setRate(newRate, baseCurr)
                        txt = "@@CURRENCY FIX APPLIED (reset new 'rrate') @@"
                        myPrint("J", txt); output += "----\n%s\n----\n" %(txt)
                    else:
                        lWarning = True; iWarnings  += 1

                if lFix and lSyncNeeded:
                    curr.syncItem()

                if not lFix and VERBOSE:
                    output += "  details:\n"
                    output += "\t" + "ID:             %s    (uuid: %s)\n" %(curr.getID(), curr.getUUID())
                    output += "\t" + "Name:           %s\n" %(curr.getName())
                    if curr.getTickerSymbol():
                        output += "\t" + "Ticker:         %s\n" %(curr.getTickerSymbol())
                    output += "\t" + "Curr_ID:        %s\n" %(curr.getIDString())
                    output += "\t" + "Decimal Places: %s\n" %(curr.getDecimalPlaces())
                    if curr.getHideInUI():
                        output += "\t" + "Hide in UI:     %s\n" %(curr.getHideInUI())
                    output += "\t" + "Effective Date: %s\n" %(convertStrippedIntDateFormattedText(curr.getEffectiveDateInt()))
                    if curr.getPrefix():
                        output += "\t" + "Prefix:         %s\n" %(curr.getPrefix())
                    if curr.getSuffix():
                        output += "\t" + "Suffix:         %s\n" %(curr.getSuffix())

                    output += "  pricing history (latest 2 prices):\n"
                    currSnapshots = curr.getSnapshots()
                    if currSnapshots.size() > 0:
                        i = 0
                        for currSnapshot in reversed(currSnapshots):
                            i += 1
                            output += "    snapshot: %s (reversed: %s)\n" % (currSnapshot, currSnapshot.getRate())
                            if i >= 2:
                                break
                    else:
                        if curr != baseCurr:
                            output += "  This currency has no historical prices? Is this correct?\n"
                        else:
                            output += "  Good - This currency has no historical prices...\n"

                    iCountSnapErrors = 0
                    for snap in currSnapshots:
                        if not isGoodRate(snap.getRate()):
                            iCountSnapErrors += 1
                    if iCountSnapErrors > 0:
                        output += "\n  ** NOTE: You have %s history records with a zero or infinity price/rate! **\n" %(iCountSnapErrors)

            output += "-----------------------------------------------------------------\n"

        except:

            txt = ("MAJOR ERROR - '%s' crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()

            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB, lAlertLevel=2, lWrapText=False, lAutoSize=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:
            if lFix:
                MD_REF.saveCurrentAccount()
                MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
                MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        if lFix:
            fixRCurrencyCheck = None
            myPrint("B", ">> Currency / Security errors / warning - FIXES APPLIED..")
            output += "\nRELEVANT FIXES APPLIED\n\n"
            output += "\nDISCLAIMER: Please verify your data before proceeding\n"

            if lWarning:
                output += "\n@@@@ You still have %s Warning(s)..\n" % iWarnings

            txt = "@@ CURRENCY / SECURITY FIXES APPLIED - Please review diagnostic report for details!"
            play_the_money_sound()
            msgType = JOptionPane.WARNING_MESSAGE
            statusColor = "R"

        else:

            if lNeedFixScript:
                fixRCurrencyCheck = 3
                txt = ">> Currency / Security errors detected - Consider running the FIX option.."
                myPrint("B", txt); output += "%s\n" %(txt)
                output += "\nERROR: You have Currency / Security errors..\n"
                output += "Consider running the 'FIX CURRENCIES & SECURITIES' option\n"
                output += "DISCLAIMER: Always backup your data before running change scripts and verify the result before continuing...\n"
                txt = "ERROR: You have Currency / Security errors.. Please review diagnostic report!"
                msgType = JOptionPane.ERROR_MESSAGE
                statusColor = "R"

            elif lWarning:
                fixRCurrencyCheck = 2
                txt = "You have %s Warning(s).." %(iWarnings)
                myPrint("B", txt); output += "%s\n" %(txt)
                output += "These are where your Currency records show a relative currency that's not None...;\n" \
                          "... or where Securities have an incorrect relative currency set..\n"\
                          "... or where a Currency/Security's new 'rrate' (relative rate) is not set, or different to the legacy 'rate'...\n"\
                          "... or where an 'invalid' / 'infinity' / ZERO / Not A Number (NaN) rate / 'rrate' was found\n" \
                          "NOTE: Often these issues are from 'legacy' MD2017 records that need updating to MD2019+ format by adding the 'rrate' field\n" \
                          "      MD2021.2 has fixes built in to address the 'rrate' issues....\n"
                output += "Consider running the 'FIX CURRENCIES & SECURITIES' option\n"
                output += "DISCLAIMER: Always backup your data before running change scripts and verify the result before continuing...\n"
                txt = "ERROR: You have %s Currency / Security warnings.. Please review diagnostic report!" %(iWarnings)
                msgType = JOptionPane.WARNING_MESSAGE
                statusColor = "R"

            else:
                fixRCurrencyCheck = 1
                txt = "All good, Currencies / Securities look clean! Congratulations!"
                myPrint("J", txt); output += "\n%s\n" %(txt)
                msgType = JOptionPane.INFORMATION_MESSAGE
                statusColor = "DG"

        output += "\n<END>"

        if lFix:
            theTitle = "%s: (FIX ERRORS)" %(_THIS_METHOD_NAME.upper())
        else:
            theTitle = "%s: (LOOK FOR ERRORS)" %(_THIS_METHOD_NAME.upper())

        alertLevel = 0
        if iWarnings: alertLevel = 1
        if lNeedFixScript: alertLevel = 2

        jif = QuickJFrame(theTitle,output,lAlertLevel=alertLevel, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lRestartMDAfterClose=lFix, lAutoSize=True).show_the_frame()

        setDisplayStatus(txt, statusColor)
        myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME.upper(), theMessageType=msgType)

        if lFix:
            myPopupInformationBox(jif,"RESTART OF MONEYDANCE REQUIRED - MD WILL RESTART AFTER VIEWING THIS OUTPUT", _THIS_METHOD_NAME.upper(), theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return output

    class BackupButtonAction(AbstractAction):
        theString = ""

        def __init__(self, theQuestion):
            self.theQuestion = theQuestion

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            if myPopupAskBackup(toolbox_frame_, self.theQuestion, lReturnTheTruth=True):
                txt = "Backup created as requested.."
                setDisplayStatus(txt, "B")
            else:
                txt = "User declined to create backup.."
                setDisplayStatus(txt, "R")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    def backup_custom_theme_file():

        # noinspection PyUnresolvedReferences
        themeFile = ThemeInfo.customThemeFile

        newFileName = os.path.splitext(themeFile.getName())[0]+get_filename_addition()+os.path.splitext(themeFile.getName())[1]+"_$SAVED$"
        newFile = File(themeFile.getParent(), newFileName)

        try:
            IOUtils.copy(themeFile, newFile)
            myPrint("B", "Custom theme file: backup / copied to %s prior to deletion...."%newFileName)
            return True
        except:
            myPrint("B", "Error: Failed to backup/copy custom theme file prior to deletion....")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def backup_local_storage_settings( lSaveFirst=True ):

        if lSaveFirst:
            MD_REF.getCurrentAccount().getBook().getLocalStorage().save()  # Flush settings to disk before changes

        # I would rather have called LocalStorage() to get the filepath, but it doesn't give the path
        # NOTE  - This backup copy will be encrypted, so you can just put it back to ./safe/settings.
        localStorage_file = File(os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"safe","settings"))
        copy_localStorage_filename = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"settings")

        try:
            newFileName = copy_localStorage_filename+get_filename_addition()+"_$SAVED$"
            newFile = File(newFileName)

            IOUtils.copy(localStorage_file, newFile)
            myPrint("B", "LocalStorage() ./safe/settings copied to %s prior to any changes...."%newFileName)
            return True

        except:
            myPrint("B","@@ ERROR - failed to copy LocalStorage() ./safe/settings prior to any changes!?")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def backup_config_dict(lSaveFirst=True):

        if lSaveFirst:
            MD_REF.savePreferences()  # Flush settings to disk before copy

        try:
            configFile = Common.getPreferencesFile()
            newFileName = os.path.splitext(configFile.getName())[0]+get_filename_addition()+os.path.splitext(configFile.getName())[1]+"_$SAVED$"
            newFile = File(configFile.getParent(), newFileName)

            IOUtils.copy(configFile, newFile)
            myPrint("B", "config.dict backup/copy made to %s prior to changes...."%newFileName)
            return True
        except:
            myPrint("B","@@ ERROR - failed to backup/copy config.dict prior to changes!?")
            dump_sys_error_to_md_console_and_errorlog()

        return False

    def get_sync_folder():

        try:
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

            # New feature and Mac only
            if Platform.isOSX() and int(MD_REF.getBuild()) >= MD_ICLOUD_ENABLED and isinstance(syncMethod, ICloudSyncConfigurer):

                syncF = syncMethod.getSyncFolder()

                p_icloudObject = getFieldByReflection(syncF, "icloud")
                if isinstance(p_icloudObject, ICloudContainer): pass

                # p_getPathToDocFile = syncF.getClass().getDeclaredMethod("getPathToDocFile",[String])
                # p_getPathToDocFile.setAccessible(True)
                # syncBaseFolder = p_getPathToDocFile.invoke(syncF,[""])
                # p_getPathToDocFile.setAccessible(False)

                syncBaseFolder = invokeMethodByReflection(p_icloudObject, "nativeGetICloudPath", None)

                saveSyncFolder = syncBaseFolder

                if os.path.exists(saveSyncFolder):
                    myPrint("DB","icloud folder found:", saveSyncFolder)
                    return saveSyncFolder

            elif isinstance(syncMethod, DropboxSyncConfigurer): return None

            elif syncMethod is not None and syncMethod.getSyncFolder() is not None:
                syncBaseFolder = syncMethod.getSyncFolder().getSyncBaseFolder()                                         # noqa
                saveSyncFolder = syncBaseFolder.getCanonicalPath()
                if os.path.exists(saveSyncFolder):
                    myPrint("DB","sync folder found:", syncBaseFolder)
                    return saveSyncFolder
        except:
            myPrint("B","ERROR: in .get_sync_folder()")
            dump_sys_error_to_md_console_and_errorlog()

        return None

    def check_for_dropbox_folder():

        try:
            # NOTE: If there is a problem with Dropbox, then .getSyncFolder() will crash
            # MD2021.2 Build 3088 adds iCloud Sync which crashes if launched from command line....
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)

            dropboxOption = SyncFolderUtil.configurerForIDFromList("dropbox_folder", syncMethods)

            if (not dropboxOption) or syncMethod.getSyncFolder():
                return True
        except:
            # If there is a problem with Dropbox, .getSyncFolder() will crash....
            return True

        userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
        baseFolder = File(userHomeProperty, "Dropbox")
        dropbox = File(baseFolder, ".moneydancesync")

        # If Dropbox folder does not exist then do nothing
        if not (baseFolder.exists() and baseFolder.isDirectory()):
            return True

        if dropbox.exists() and dropbox.isDirectory():
            return True

        return False

    def tell_me_if_dropbox_folder_exists():

        userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
        baseFolder = File(userHomeProperty, "Dropbox")
        dropbox = File(baseFolder, ".moneydancesync")

        # If Dropbox folder does not exist then do nothing
        if baseFolder.exists() and baseFolder.isDirectory() and dropbox.exists() and dropbox.isDirectory():
            return dropbox.getCanonicalPath()

        return False

    def terminate_script():
        myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()")

        try:
            # NOTE - .dispose() - The windowClosed event should set .isActiveInMoneydance False and .removeAppEventListener()
            if not SwingUtilities.isEventDispatchThread():
                SwingUtilities.invokeLater(GenericDisposeRunnable(toolbox_frame_))
            else:
                toolbox_frame_.dispose()
        except:
            myPrint("B","Error. Final dispose failed....?")
            dump_sys_error_to_md_console_and_errorlog()


    def getUserSelectedServiceProfile(_theFrame, _theTitle, _theQuestion, lIncludePlaidWhenUnlocked=False):

        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        newServiceList = []
        for sv in serviceList:
            if sv.getTIKServiceID() == "md:plaid":
                if not lIncludePlaidWhenUnlocked:   continue
                if not isToolboxUnlocked():         continue
            newServiceList.append(StoreService(sv))

        service = JOptionPane.showInputDialog(_theFrame,
                                              _theQuestion,
                                              _theTitle,
                                              JOptionPane.INFORMATION_MESSAGE,
                                              getMDIcon(lAlwaysGetIcon=True),
                                              newServiceList,
                                              None)             # type: StoreService

        if not service:
            txt = "%s: - No Service was selected - no changes made.." %(_theTitle)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return None
        return service.getService()

    class StoreUserID():
        def __init__(self, _userID, _password="NOT SET"):
            self.userID = _userID.strip()
            self.password = _password
            self.clientUID = None
            self.accounts = []

        @staticmethod
        def findUserID(findUserID, listOfUserIDs):
            # type: (str, [StoreUserID]) -> StoreUserID
            """
            Static Method to search a [list] of StoreUserID()
            """
            for userIDFromList in listOfUserIDs:
                if findUserID.lower().strip() == userIDFromList.getUserID().lower().strip(): return userIDFromList
            return None

        def setPassword(self, _password):       self.password = _password
        def setClientUID(self, _clientUID):     self.clientUID = _clientUID
        def setAccounts(self, _accounts):       self.accounts = _accounts

        def getUserID(self):    return self.userID
        def getPassword(self):  return self.password
        def getClientUID(self): return self.clientUID
        def getAccounts(self):  return self.accounts

        def __str__(self): return "UserID: %s Password: <%s>" %(self.getUserID(), ("*"*len(self.getPassword())))
        def __repr__(self): return self.__str__()


    def clearOneServiceAuthCache():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "CLEAR AUTHENTICATION FROM ONE SERVICE"

        output = "VIEW ALL CACHED AUTHENTICATION KEYS\n" \
                 " ==================================\n\n"

        lCachePasswords = isCachingPasswords()
        _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
        if len(_auth) > 0:
            keys = sorted(_auth.keys())                                                                                 # noqa
            for theKey in keys:
                value = _auth.get(theKey)                                                                               # noqa
                output += pad("Key:%s" %(theKey),40)+" Value: %s\n" %(value.strip())
        else:
            if not lCachePasswords: output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
            output += "<NONE>\n"

        output+="\n<END>"
        jif = QuickJFrame("VIEW ALL CACHED AUTHENTICATION KEYS",output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        service = getUserSelectedServiceProfile(jif, _THIS_METHOD_NAME, "Select a service clear the Authentication Cache", lIncludePlaidWhenUnlocked=False)  # type: OnlineService
        if not service:
            jif.dispose()
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()       # already within the EDT
            return

        if confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Clear Authentication Password(s) for service:%s?" %(service)):
            # noinspection PyUnresolvedReferences
            service.clearAuthenticationCache()
            MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
            play_the_money_sound()
            txt = "%s: Password(s) for %s have been cleared" %(_THIS_METHOD_NAME, service)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            play_the_money_sound()
            myPopupInformationBox(jif,"Password(s) for %s have been cleared" %(service), _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        jif.dispose()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def clearAllServicesAuthCache():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "CLEAR ALL SERVICE(S)' AUTHENTICATION"

        output = "VIEW ALL CACHED AUTHENTICATION KEYS\n" \
                 " ==================================\n\n"

        lCachePasswords = isCachingPasswords()
        _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
        if len(_auth) > 0:
            keys = sorted(_auth.keys())                                                                                 # noqa
            for theKey in keys:
                value = _auth.get(theKey)                                                                               # noqa
                output += pad("Key:%s" %(theKey),40)+" Value: %s\n" %(value.strip())
        else:
            if not lCachePasswords: output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
            output += "<NONE>\n"

        output+="\n<END>"
        jif = QuickJFrame("VIEW ALL EXISTING AUTHENTICATION KEYS",output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()       # already within the EDT
            return

        if confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Clear Authentication All Password(s) for **ALL** service(s)?"):
            MD_REF.getUI().getOnlineManager().clearAuthenticationCache()
            MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
            play_the_money_sound()
            txt = "%s: **ALL** Password(s) for ALL Services have been cleared" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        jif.dispose()       # already within the EDT

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class MyOFXAuthInfo(OFXAuthInfo):
        def __init__(self, _user, _pass, _extra, _cookie, _type):
            self.originalCookie = _cookie
            self.newPassword = None
            super(OFXAuthInfo, self).__init__(_user, _pass, _extra, _cookie, _type)                                     # noqa

        def getCookie(self): return self.originalCookie

        def setNewPassword(self, _newPassword):
            self.newPassword = _newPassword

        def getNewPassword(self): return self.newPassword

        def getNewEncodedAuthObj(self):
            return MyOFXAuthInfo(self.getUserId(), self.getNewPassword(), self.getExtraAuth(), self.getCookie(), self.getAuthType())

        @staticmethod
        def fromCacheString(_fromRecord):
            if _fromRecord is None: return None
            params = {}
            StringUtils.parseURLParameters(_fromRecord, params)
            authTypeStr = params.get("type")
            authType = 0
            try: authType = int(authTypeStr)
            except: pass

            return (MyOFXAuthInfo(params.get("userid"),
                                  params.get("pass"),
                                  params.get("extra"),
                                  params.get("cookie"),
                                  authType))


    def editStoredOFXPasswords():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "EDIT OFX STORED PASSWORDS"

        service = getUserSelectedServiceProfile(toolbox_frame_, _THIS_METHOD_NAME, "Select a service to manage a stored Password", lIncludePlaidWhenUnlocked=False)  # type: OnlineService
        if not service: return

        output = "VIEW STORED AUTHENTICATION KEYS FOR SERVICE\n" \
                 " ==========================================\n\n"

        class StoreAuthKeyData:
            def __init__(self, _theKey, _theData):
                self.theKey = _theKey
                self.theData = _theData
                self.authObj = MyOFXAuthInfo.fromCacheString(_theData)
                self.thePassword = self.authObj.getPasswd()
                self.theUserID = self.authObj.getUserId()

            def __str__(self): return "%s User: %s Pswd: %s" %(self.theKey, self.theUserID, self.thePassword)
            def __repr__(self): return self.__str__()

        saveAuthKeys = []
        authKeys = getUpdatedAuthenticationKeys()
        for theAuthKey in sorted(authKeys.keys()):                                                                      # noqa
            if (service.getFIOrg() + "--" + service.getFIId() + "--") in theAuthKey:
                saveAuthKeys.append(StoreAuthKeyData(theAuthKey,authKeys.get(theAuthKey)))                                              # noqa
                tempAuthObj = MyOFXAuthInfo.fromCacheString(authKeys.get(theAuthKey))                                   # noqa
                output += "Key:%s" %(theAuthKey) + " Value: %s (decoded password: %s)\n" %(authKeys.get(theAuthKey), tempAuthObj.getPasswd())                     # noqa
        del authKeys

        if len(saveAuthKeys) < 1:
            txt = "%s: WARNING No stored Authentication records found for this service - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        output+="\n<END>"
        jif = QuickJFrame("VIEW EXISTING AUTHENTICATION KEYS FOR SERVICE",output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        selectedAuthKeyRecord = JOptionPane.showInputDialog(jif,
                                                     "Select an Authentication Key to edit",
                                                     _THIS_METHOD_NAME,
                                                     JOptionPane.INFORMATION_MESSAGE,
                                                     getMDIcon(lAlwaysGetIcon=True),
                                                     saveAuthKeys,
                                                     None)      # type: StoreAuthKeyData
        if not selectedAuthKeyRecord:
            txt = "%s: No Authentication Key selected - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if isinstance(selectedAuthKeyRecord, StoreAuthKeyData): pass
        authObj = selectedAuthKeyRecord.authObj

        if authObj is None or authObj.toString() != selectedAuthKeyRecord.theData:
            txt = "%s: ERROR - Failed to decode Authentication key (refer console) - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        newPassword = myPopupAskForInput(jif,
                                         _THIS_METHOD_NAME,
                                         "New password:",
                                         "Enter new password for user %s" %(authObj.getUserId()),
                                         defaultValue=authObj.getPasswd())
        if newPassword is None or newPassword == "" or newPassword == authObj.getPasswd():
            txt = "%s: User did not enter a new password - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Edit password for user %s within this service?" %(authObj.getUserId())):
            txt = "%s: User did not agree to proceed with changes - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif.dispose()
            return

        authObj.setNewPassword(newPassword)

        MD_REF.getCurrentAccount().getBook().getLocalStorage().cacheAuthentication(selectedAuthKeyRecord.theKey, authObj.getNewEncodedAuthObj().toCacheString())
        # service.cacheAuthentication(selectedAuthKeyRecord.theKey, authObj.getNewEncodedAuthObj().toCacheString())

        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
        play_the_money_sound()
        txt = "%s: UserID: %s Password set to: %s" %(_THIS_METHOD_NAME, authObj.getUserId(), authObj.getNewPassword())
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
        jif.dispose()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def my_createNewClientUID():
        # com.moneydance.apps.md.view.gui.DefaultOnlineUIProxy.createNewClientUID()
        _uid = UUID.randomUUID().toString()
        _uid = StringUtils.replaceAll(_uid, "-", "").strip()
        if len(_uid) > 32: _uid = String(_uid).substring(0, 32)
        return _uid

    def manuallyPrimeUSAARootUserIDClientIDs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "USAA: Manually 'prime' Root UserIDs/ClientUIDs".upper()

        if isMDPlusEnabledBuild() and float(MD_REF.getBuild()) < 4059:
            txt = ("WARNING: You need to upgrade to at least version MD2022.1(4059) for USAA Connections to work properly! - No changes made!")
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt, _THIS_METHOD_NAME,JOptionPane.ERROR_MESSAGE)
            return

        USAA_FI_ID = "67811"
        USAA_FI_ORG = "USAA Federal Savings Bank"
        OLD_TIK_FI_ID = "md:1295"
        USAA_PROFILE_NAME = "USAA Custom Profile (ofx_create_new_usaa_bank_profile_custom.py)"

        NEW_TIK_FI_ID = "md:custom-1295"    # as of 23rd Oct, the 'official' custom profile ID

        authKeyPrefix="ofx.client_uid"
        specificAuthKeyPrefix = authKeyPrefix+"::" + NEW_TIK_FI_ID + "::"
        defaultUserPrefix = authKeyPrefix+"_default_user"+"::" + NEW_TIK_FI_ID

        root = MD_REF.getCurrentAccount().getBook().getRootAccount()
        rootKeys = list(sorted(root.getParameterKeys()))

        pdfURL = "https://github.com/yogi1967/MoneydancePythonScripts/raw/master/source/useful_scripts/ofx_create_new_usaa_bank_custom_profile.pdf"
        try: Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(pdfURL), None)
        except: pass

        output = "INSTRUCTIONS:\n" \
                 "Read the latest walk through guide: ofx_create_new_usaa_bank_custom_profile.pdf\n" \
                 "Latest: %s\n" \
                 "(url has been copied to the clipboard)\n\n\n" %(pdfURL)

        output += "LIST OF OFX USAA USERIDs/ClientUIDs STORED ON THE ROOT ACCOUNT\n" \
                  " =============================================================\n\n"

        harvestedDefaultUserID = None
        harvestedUserIDList = []
        for i in range(0,len(rootKeys)):
            rk = rootKeys[i]
            rk_value = root.getParameter(rk)
            if rk.startswith(specificAuthKeyPrefix):
                harvestedUID = StoreUserID(rk[len(specificAuthKeyPrefix):])
                output+="Harvested existing authKey %s: ClientUID: %s\n" %(rk,rk_value)
                if harvestedUID.getUserID() != "null":
                    harvestedUID.setClientUID(rk_value)
                    harvestedUserIDList.append(harvestedUID)
            elif rk.startswith(defaultUserPrefix):
                output+="Harvested existing Default UserID: %s\n" %(rk_value)
                harvestedDefaultUserID = rk_value

        if len(harvestedUserIDList)<1: output+="\n<NONE PRE-EXISTING>\n"

        output += "\n<END>"

        jif = QuickJFrame("REVIEW EXISTING USAA USERIDs/ClientUIDs (stored on ROOT) BEFORE CHANGES",output,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        defaultEntry = ""
        while True:
            userID = myPopupAskForInput(jif, "PRIME USERID/CLIENTUID SUPPLIED BY USAA", "UserID", "Type/Paste the UserID to prime very carefully (this will overwrite existing)", defaultEntry)
            myPrint("DB", "userID entered: %s" %userID)
            if userID is None:
                txt = "ERROR - No userID supplied to prime! Aborting"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
                jif.dispose()
                return
            defaultEntry = userID
            if userID is None or userID == "" or userID == "UserID" or len(userID)<4:
                myPrint("DB", "\n ** ERROR - No valid UserID supplied to prime - try again ** \n")
                continue
            break
        del defaultEntry

        findStoredUser = StoreUserID(userID)
        if len(harvestedUserIDList) > 0:
            foundHarvestedStoredUser = StoreUserID.findUserID(findStoredUser.getUserID(),harvestedUserIDList)    # type: StoreUserID
            if foundHarvestedStoredUser is not None:
                if foundHarvestedStoredUser.getClientUID() is not None:
                    findStoredUser.setClientUID(foundHarvestedStoredUser.getClientUID())
                else:
                    raise Exception("LOGIC ERROR: Found harvested UserID (%s) with no ClientUID?! Aborting" %(findStoredUser))
            del foundHarvestedStoredUser
            myPrint("DB", "UserID entered: %s (Harvested ClientUID: %s)" %(userID, findStoredUser.getClientUID()))
        else:
            myPrint("DB","Skipping matching ClientUID into UserID as did not harvest any UserIDs from USAA root record(s)...")

        myPrint("B","")

        if findStoredUser.getClientUID() is not None:
            defaultEntry = findStoredUser.getClientUID()
        else:
            # defaultEntry = "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn"
            defaultEntry = ""
        del findStoredUser

        while True:
            uuid = myPopupAskForInput(jif, "PRIME CLIENT UUID FOR USERID: %s (SUPPLIED BY USAA)" %(userID),
                                      "PRIME UUID",
                                      "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn\n"
                                      " (Paste your USAA UUID 36 digits 8-4-4-4-12 carefully)", defaultEntry)
            myPrint("DB", "UUID entered: %s" %uuid)
            if uuid is None:
                txt = "ERROR - No uuid entered! Aborting"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)
                jif.dispose()
                return
            defaultEntry = uuid
            if (uuid is None or uuid == "" or len(uuid) != 36 or uuid == "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn" or
                    (str(uuid)[8]+str(uuid)[13]+str(uuid)[18]+str(uuid)[23]) != "----"):
                myPrint("DB", "\n ** ERROR - no valid uuid supplied - try again ** \n")
                continue
            break
        del defaultEntry

        lSetDefaultUserID = False
        if myPopupAskQuestion(jif,_THIS_METHOD_NAME, "Do you want to make UserID: %s the DEFAULT (current default: %s)" %(userID, harvestedDefaultUserID)):
            myPrint("DB","UserID: %s will be primed as the default in root (replacing: %s as default)" %(userID, harvestedDefaultUserID))
            lSetDefaultUserID = True

        if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME,"Prime UserID: %s with ClientUID: %s?" %(userID, uuid)):
            txt = "%s: User did not agree to proceed with changes - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            jif.dispose()
            return

        ####################################################################################################################
        serviceList = MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices()  # type: [OnlineService]

        deleteServices = []
        for svc in serviceList:
            if svc.getTIKServiceID() == NEW_TIK_FI_ID: continue     # Skip deleting the new custom profile as that will refresh anyway
            if (svc.getTIKServiceID() == OLD_TIK_FI_ID
                    or svc.getServiceId() == ":%s:%s" %(USAA_FI_ORG, USAA_FI_ID)
                    or "USAA" in svc.getFIOrg()
                    or "USAA" in svc.getFIName()):
                myPrint("DB", "Found old USAA service - to potentially delete: %s" %(svc))
                deleteServices.append(svc)

        if len(deleteServices):
            if myPopupAskQuestion(jif, "DELETE EXISTING OLD USAA SERVICE PROFILES", "DELETE %s EXISTING (old) USAA SERVICE PROFILES TOO [optional]?" % (len(deleteServices)), theMessageType=JOptionPane.WARNING_MESSAGE):
                for service in deleteServices:
                    service.clearAuthenticationCache()
                    service.deleteItem()
                    myPrint("B","Deleted existing (old) USAA service profile: %s" %(service))
                MD_REF.getCurrentAccount().getBook().getLocalStorage().save()
                cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        del serviceList, deleteServices
        ####################################################################################################################

        root.setEditingMode()
        root.setParameter(specificAuthKeyPrefix+userID, uuid)

        if lSetDefaultUserID:
            root.setParameter(defaultUserPrefix, userID)
            root.setParameter(specificAuthKeyPrefix+"null", uuid)

        lOverrideRootUUID = False
        theDefaultUUID = root.getParameter(authKeyPrefix, "")
        if lOverrideRootUUID or theDefaultUUID == "":
            theDefaultUUID = my_createNewClientUID()
            myPrint("B","Overriding Root's default UUID. Was: '%s' >> changing to >> '%s'" %(root.getParameter(authKeyPrefix, ""),theDefaultUUID))
            root.setParameter(authKeyPrefix, theDefaultUUID)
        del theDefaultUUID, lOverrideRootUUID

        root.syncItem()

        play_the_money_sound()
        txt = "SUCCESS! UserID: %s >> ClientUID primed to: %s (Default: %s)" %(userID, uuid, lSetDefaultUserID)
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        MyPopUpDialogBox(jif,
                         txt,
                         "Please now return to Moneydance and use Menu: Online>Set up Online Banking\n"
                         "at the select financial institution selection window, please select:\n"
                         "%s" %(USAA_PROFILE_NAME),
                         theTitle=_THIS_METHOD_NAME,
                         OKButtonText="SUCCESS").go()

        jif.dispose()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def check_OFX_USERID_Key_valid(test_str):
        pattern = r'[^a-zA-Z0-9-_.:]'
        if re.search(pattern, test_str):
            myPrint("DB","OFX UserID Key Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","OFX UserID Key Valid: %r" %(test_str))
            return True

    def check_OFX_USERID_Data_valid(test_str):
        pattern = r'[^a-zA-Z0-9-_.]'
        if re.search(pattern, test_str):
            myPrint("DB","OFX UserID Data Invalid: %r" %(test_str))
            return False
        else:
            myPrint("DB","OFX UserID Data Valid: %r" %(test_str))
            return True

    def manualEditOfRootUserIDs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        userIDKeyPrefix="ofx.client_uid"
        root = MD_REF.getCurrentAccount().getBook().getRootAccount()

        _DELETEONE  = 0
        _DELETEALL  = 1
        _EDITONE    = 2
        _ADDONE     = 3

        what = [
            "Delete One OFX UserID/ClientUID record (from root)",
            "Delete All OFX UserID/ClientUID record(s) (from root)",
            "Edit One OFX UserID/ClientUID record (key and data) (from root)",
            "Add One OFX UserID/ClientUID record (key and data) (from root)"]

        while True:

            lDoIHaveAnyKeys=True

            output = "LIST OF OFX BANK USERIDs/ClientUIDs STORED ON THE ROOT ACCOUNT\n" \
                     " =============================================================\n\n"
            userIDKeys=[]
            rootKeys=sorted(root.getParameterKeys())
            for userKey in rootKeys:
                if userKey.startswith(userIDKeyPrefix):
                    userIDKeys.append(userKey)
                    output+="Key: %s Data: %s\n" %(pad(userKey,40),root.getParameter(userKey, None))

            output+="\n<END>"

            if len(userIDKeys)<1:
                txt = "You have no Bank OFX UserIDs/ClientUIDs stored on the Root Account"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,"OFX BANK UserIDs/ClientUIDs",JOptionPane.WARNING_MESSAGE)
                lDoIHaveAnyKeys=False

            jif=QuickJFrame("REVIEW OFX BANK USERIDs/ClientUIDs (stored on ROOT) BEFORE CHANGES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if lDoIHaveAnyKeys:
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "What you want to do?",
                                                           "OFX USERID/ClientUID MANAGEMENT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           what,
                                                           None)
            else:
                selectedWhat = JOptionPane.showInputDialog(jif,
                                                           "What you want to do?",
                                                           "OFX USERID/ClientUIDs MANAGEMENT",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           [what[_ADDONE]],
                                                           None)

            if not selectedWhat:
                txt = "OFX USERID MANAGEMENT - No option was selected.."
                setDisplayStatus(txt, "R")
                jif.dispose()       # already within the EDT
                return

            lEditOne = lDeleteOne = lDeleteAll = lAddOne = False

            if selectedWhat == what[_EDITONE]:      lEditOne=True
            elif selectedWhat == what[_DELETEONE]:  lDeleteOne=True
            elif selectedWhat == what[_DELETEALL]:  lDeleteAll=True
            elif selectedWhat == what[_ADDONE]:     lAddOne=True
            else:
                jif.dispose()       # already within the EDT
                continue

            do_what=""
            if lDeleteOne:  do_what="DELETE"
            if lEditOne:    do_what="EDIT"
            if lDeleteAll:  do_what="DELETE ALL"
            if lAddOne:     do_what="ADD ONE"

            selectedUserIDKey=None
            UserIDKeyValue=None

            if lDeleteOne or lEditOne:

                selectedUserIDKey = JOptionPane.showInputDialog(jif,
                                                             "Select a UserID/ClientUIDs to %s" %(do_what),
                                                             "OFX USERID/ClientUIDs MANAGEMENT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             userIDKeys,
                                                             None)
                if not selectedUserIDKey:
                    jif.dispose()       # already within the EDT
                    continue

                UserIDKeyValue = root.getParameter(selectedUserIDKey, None)

            chgKey=None
            chgValue=None
            if lEditOne:
                chgKey = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="EDIT USERID/ClientUID PARAMETER KEY [optional]:",
                                              theFieldDescription="Carefully edit/change the key. (JUST ENTER TO KEEP THE SAME))",
                                              defaultValue=selectedUserIDKey,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)   # type: str

                if not chgKey or len(chgKey.strip()) <1:
                    myPopupInformationBox(jif,"ERROR - The edited key was not specified or blank!","OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue
                chgKey = chgKey.strip()
                if not chgKey.startswith(userIDKeyPrefix) or not check_OFX_USERID_Key_valid(chgKey) \
                        or (chgKey != selectedUserIDKey and root.getParameter(chgKey,None) is not None):
                    myPopupInformationBox(jif,"ERROR - The new key %s was invalid or must start with '%s'" %(chgKey,userIDKeyPrefix),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                chgValue = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="EDIT USERID/ClientUID PARAMETER VALUE:",
                                              theFieldDescription="Carefully edit/change the data. NOTE: There will be little validation...",
                                              defaultValue=UserIDKeyValue,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)    # type: str
                if not chgValue or len(chgValue.strip()) <1:
                    jif.dispose()       # already within the EDT
                    continue
                chgValue = chgValue.strip()
                if not check_OFX_USERID_Key_valid(chgValue):
                    myPopupInformationBox(jif,"ERROR - The changed key data %s was invalid" %(chgValue),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

            if lAddOne:
                chgKey = myPopupAskForInput(jif,
                                            theTitle="OFX USERID/ClientUID MANAGEMENT",
                                            theFieldLabel="ADD NEW USERID/ClientUID PARAMETER KEY:",
                                            theFieldDescription="Carefully complete the new key (must start with '%s')" %(userIDKeyPrefix),
                                            defaultValue=userIDKeyPrefix,
                                            isPassword=False,
                                            theMessageType=JOptionPane.WARNING_MESSAGE)    # type: str

                if not chgKey or len(chgKey.strip()) <1:
                    myPopupInformationBox(jif,"ERROR - The new key was not specified or blank!","OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue
                chgKey = chgKey.strip()
                if not chgKey.startswith(userIDKeyPrefix) or not check_OFX_USERID_Key_valid(chgKey) or root.getParameter(chgKey,None) is not None:
                    myPopupInformationBox(jif,"ERROR - The new key %s was invalid or must start with '%s'" %(chgKey,userIDKeyPrefix),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                chgValue = myPopupAskForInput(jif,
                                              theTitle="OFX USERID/ClientUID MANAGEMENT",
                                              theFieldLabel="ADD NEW USERID/ClientUID PARAMETER VALUE:",
                                              theFieldDescription="Carefully enter the new data. NOTE: There will be little validation...",
                                              defaultValue=UserIDKeyValue,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)   # type: str
                if not chgValue or len(chgValue.strip()) <1:
                    jif.dispose()       # already within the EDT
                    continue
                chgValue = chgValue.strip()
                if not check_OFX_USERID_Key_valid(chgValue):
                    myPopupInformationBox(jif,"ERROR - The new key data %s was invalid" %(chgValue),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.ERROR_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

            if not confirm_backup_confirm_disclaimer(jif,"OFX USERID/ClientUID MANAGEMENT","OFX USERIDs/ClientUIDs %s?" %(do_what)):
                jif.dispose()       # already within the EDT
                return

            if lEditOne:
                if chgKey != selectedUserIDKey:
                    myPrint("B","setting new key %s to %s" %(chgKey,chgValue))
                    myPrint("DB", "NEW pre %s %s" %(chgKey,root.getParameter(chgKey)))

                    root.setEditingMode()

                    root.setParameter(chgKey, chgValue)
                    myPrint("DB", "NEW post %s %s" %(chgKey,root.getParameter(chgKey)))

                    myPrint("B","setting old key %s to None" %(selectedUserIDKey))
                    myPrint("DB", "OLD pre %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                    root.setParameter(selectedUserIDKey,None)

                    root.syncItem()
                    myPrint("DB", "OLD post %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                else:
                    myPrint("DB", "KEYSAME pre %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                    myPrint("B","setting %s to %s" %(selectedUserIDKey,chgValue))
                    root.setParameter(selectedUserIDKey, chgValue)
                    root.syncItem()
                    myPrint("DB", "KEYSAME post %s %s" %(selectedUserIDKey,root.getParameter(selectedUserIDKey)))
                txt = "OFX UserID/ClientUID Record key %s now %s changed from %s to %s" %(selectedUserIDKey,chgKey,UserIDKeyValue,chgValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lAddOne:
                root.setParameter(chgKey,chgValue)
                root.syncItem()
                txt = "OFX new UserID/ClientUID parameter %s CREATED with data: %s" %(chgKey,chgValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteOne:
                root.setParameter(selectedUserIDKey, None)
                root.syncItem()
                txt = "OFX UserID/ClientUID parameter %s DELETED (was: %s)" %(selectedUserIDKey,UserIDKeyValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteAll:
                for keyToDelete in userIDKeys:
                    root.setParameter(keyToDelete, None)
                    root.syncItem()
                    myPrint("B", "DELETED OFX UserID/ClientUID Parameter %s from ROOT!" %(keyToDelete))
                txt = "ALL OFX UserID/ClientUID records DELETED from ROOT"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            del userIDKeys
            play_the_money_sound()
            myPopupInformationBox(jif,"Your %s changes have been made and saved!" %(do_what),"OFX USERID/ClientUID MANAGEMENT",JOptionPane.WARNING_MESSAGE)
            jif.dispose()       # already within the EDT
            continue

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def scriptRunner(_runThisScript, _method):

        if MD_EXTENSION_LOADER is None:
            txt = "%s: Sorry - You must be running Toolbox as an extension to run this extra script...." %(_method)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        if GlobalVars.SCRIPT_RUNNING_LOCK.locked():
            txt = "%s: Sorry - a script is already running with an active Lock" %(_method)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        with GlobalVars.SCRIPT_RUNNING_LOCK:
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            py = MD_REF.getPythonInterpreter()
            py.set("toolbox_script_runner", _runThisScript)
            py.getSystemState().setClassLoader(MD_EXTENSION_LOADER)
            py.set("moneydance_extension_loader", MD_EXTENSION_LOADER)

            class ScriptRunnable(Runnable):

                def __init__(self, _context, _python, _scriptStream, _scriptToRun):
                    self.context = _context
                    self.python = _python
                    self.scriptStream = _scriptStream
                    self.scriptToRun = _scriptToRun

                def run(self):  # NOTE: This will not start in the EDT (the same as Moneybot Console)
                    myPrint("B","..About to execfile(%s)" %(self.scriptToRun))
                    self.python.execfile(self.scriptStream,"Toolbox:Executing_Script_%s" %(self.scriptToRun))
                    myPrint("DB", "....I am back from script, within the special Thread().....")
                    self.scriptStream.close()
                    self.context.resetPythonInterpreter(self.python)

            scriptStream = MD_EXTENSION_LOADER.getResourceAsStream("/%s" %(_runThisScript))

            Thread(ScriptRunnable(MD_REF, py, scriptStream, _runThisScript), "toolbox_scriptRunner").start()

            myPrint("DB", ".... post calling Thread().....")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")
            myPrint("B","**********************************************************")

        return True

    def editSetupMultipleUserIDs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Edit/Setup (multiple) UserIDs / Passwords".upper()

        scriptToRun = "ofx_populate_multiple_userids.py"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute the script: %s?" %(scriptToRun)):
            return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    def createUSAAProfile():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Create USAA OFX Profile".upper()

        scriptToRun = "ofx_create_new_usaa_bank_custom_profile.py"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute the script: %s?" %(scriptToRun)):
            return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    class StoreAccountList():
        def __init__(self, obj):
            if isinstance(obj,Account):
                self.obj = obj                          # type: Account
            else:
                self.obj = None

        def __str__(self):
            if self.obj is None:
                return "Invalid Acct Obj or None"
            return "%s : %s" %(self.obj.getAccountType(),self.obj.getFullAccountName())

        def __repr__(self):
            if self.obj is None:
                return "Invalid Acct Obj or None"
            return "%s : %s" %(self.obj.getAccountType(),self.obj.getFullAccountName())

    class StoreTheOnlineTxnList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlineTxnList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.txnCount = obj.getTxnCount()
            else:
                self.txnCount = 0

        def __str__(self):
            return "OnlineTxnList Obj on Acct %s (holding %s Txns)" %(self.acct,self.txnCount)

        def __repr__(self):
            return "OnlineTxnList Obj on Acct %s (holding %s Txns)" %(self.acct,self.txnCount)

    # noinspection PyUnresolvedReferences
    def get_security_holdings(security):
        if security.getCurrencyType() != CurrencyType.Type.SECURITY:
            return 0

        acctHoldings = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(22))
        balance = 0
        for acct in acctHoldings:
            if acct.getCurrencyType() == security:
                balance += acct.getBalance()

        return balance

    class StoreCurrencySecurity():
        def __init__(self, obj):
            if isinstance(obj,CurrencyType):
                self.obj = obj                          # type: CurrencyType
            else:
                self.obj = None
            self.qtyHeld = 0
            # noinspection PyUnresolvedReferences
            if self.obj and self.obj.getCurrencyType() == CurrencyType.Type.SECURITY:
                self.qtyHeld = get_security_holdings(self.obj)
            self.decimal = MD_REF.getPreferences().getDecimalChar()

        def __str__(self):
            if self.obj is None:
                return "Invalid CurrencyType Obj or None"
            if self.qtyHeld == 0:
                return "%s: %s" %(self.obj.getCurrencyType(), self.obj.getName())
            return "%s: %s (%s)" %(self.obj.getCurrencyType(), self.obj.getName(),self.obj.formatSemiFancy(self.qtyHeld,self.decimal))

        def __repr__(self): return self.__str__()

    class StoreAccountSecurity():
        def __init__(self, obj):
            self.obj = obj                                                                                              # type: Account

        def __str__(self):
            # noinspection PyUnresolvedReferences
            if self.obj is None or not isinstance(self.obj, Account) or self.obj.getAccountType() != Account.AccountType.SECURITY:
                return "Invalid Account/Security Obj or None"
            return "%s" %(self.obj.getAccountName())

        def getAccount(self):       return self.obj
        def getAccountName(self):   return self.getAccount().getAccountName()

        def __repr__(self):         return self.__str__()
        def toString(self):         return self.__str__()

    class StoreTheOnlinePayeeList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlinePayeeList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.payeeCount = obj.getPayeeCount()
            else:
                self.payeeCount = 0

        def __str__(self):
            return "OnlinePayeeList Obj on Acct %s (holding %s Payees)" %(self.acct,self.payeeCount)

        def __repr__(self):
            return "OnlinePayeeList Obj on Acct %s (holding %s Payees)" %(self.acct,self.payeeCount)

    class StoreTheOnlinePaymentList():
        def __init__(self, obj, acct):
            self.obj = obj                          # type: OnlinePaymentList
            self.acct = acct                        # type: Account
            if self.obj is not None:
                self.paymentCount = obj.getPaymentCount()
            else:
                self.paymentCount = 0

        def __str__(self):
            return "OnlinePaymentList Obj on Acct %s (holding %s Payments)" %(self.acct,self.paymentCount)

        def __repr__(self):
            return "OnlinePaymentList Obj on Acct %s (holding %s Payments)" %(self.acct,self.paymentCount)

    def OFX_update_OFXLastTxnUpdate():
        """Allows you to update the 'OFX' last update date (not the MD+ dates)"""
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "OFX: update OFXLastTxnUpdate date".upper()

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (GlobalVars.UPDATE_MODE): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to alter the OFXLastTxnUpdate date field:",
                                                   "OFX OFXLastTxnUpdate - Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "%s: No Account was selected.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "%s: No OnlineTxnList record found... Exiting.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        # com.infinitekind.moneydance.model.OnlineTxnList
        # setOFXLastTxnUpdate(long date, String connectionID)
        # resetLastUpdateDate(String connectionID)
        # resetLastUpdateDates()

        if isMulti_OFXLastTxnUpdate_build():
            theCurrentDate = theOnlineTxnRecord.obj.getOFXLastTxnUpdate("ofx")
        else:
            theCurrentDate = theOnlineTxnRecord.obj.getOFXLastTxnUpdate()

        if theCurrentDate > 0:
            theCurrentDatePretty = get_time_stamp_as_nice_text(theCurrentDate)
        else:
            if isMDPlusEnabledBuild():
                theCurrentDatePretty = "NOT SET (MD will prompt you for start date)"
            else:
                theCurrentDatePretty = "NOT SET"

        myPopupInformationBox(toolbox_frame_,"OFXLastTxnUpdate is currently: %s (which means: %s)" %(theCurrentDate, theCurrentDatePretty))

        if not isMDPlusEnabledBuild():

            labelUpdateDate = JLabel("Select the new OFXLastTxnUpdate download Date:")
            user_selectDateStart = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
            user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())

            datePanel = JPanel(GridLayout(0, 1))
            datePanel.add(labelUpdateDate)
            datePanel.add(user_selectDateStart)

            options = ["Cancel", "OK"]

            while True:
                userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                          datePanel,
                                                          "Select new Date for the OFXLastTxnUpdate field:",
                                                          JOptionPane.OK_CANCEL_OPTION,
                                                          JOptionPane.QUESTION_MESSAGE,
                                                          getMDIcon(None),
                                                          options,
                                                          options[0])

                if userAction != 1:
                    txt = "OFX: User cancelled entering a new OFXLastTxnUpdate date - exiting"
                    setDisplayStatus(txt, "R")
                    return

                if user_selectDateStart.getDateInt() < 20150101 or user_selectDateStart.getDateInt() > DateUtil.getStrippedDateInt():
                    txt = "OFX: User cancelled entering an invalid OFXLastTxnUpdate date..."
                    setDisplayStatus(txt, "R")
                    user_selectDateStart.setDateInt(DateUtil.getStrippedDateInt())
                    user_selectDateStart.setForeground(getColorRed())                                                           # noqa
                    continue

                break   # Valid date

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Update the OFXLastTxnUpdate field to %s?" %(convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt()))):
                return

            newDate = DateUtil.convertIntDateToLong(user_selectDateStart.getDateInt()).getTime()
            newDateTxt = convertStrippedIntDateFormattedText(user_selectDateStart.getDateInt())

        else:

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Reset date so that MD Prompts you for start date?"):
                return

            newDate = 0L
            newDateTxt = "RESET SO MD PROMPTS FOR START DATE"

        if isMulti_OFXLastTxnUpdate_build():
            theOnlineTxnRecord.obj.resetLastUpdateDate("")
            theOnlineTxnRecord.obj.setOFXLastTxnUpdate(newDate, "ofx")
        else:
            theOnlineTxnRecord.obj.setOFXLastTxnUpdate(newDate)

        theOnlineTxnRecord.obj.syncItem()

        play_the_money_sound()
        txt = "OFX alter OFXLastTxnUpdate date for acct: %s successfully set to: %s (%s)" %(selectedAcct,newDate,newDateTxt)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def OFX_reset_OFXLastTxnUpdate_dates():
        """Allows you to reset all 'OFX' last update dates (including the MD+ dates) on the record"""
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "OFX: reset all OFXLastTxnUpdate dates".upper()

        if MD_REF.getCurrentAccount().getBook() is None:    return
        if not (GlobalVars.UPDATE_MODE):                    return
        if not isMulti_OFXLastTxnUpdate_build():            return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to RESET all the OFXLastTxnUpdate dates (OFX & MD+):",
                                                   "OFX OFXLastTxnUpdate - Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "%s: No Account was selected.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "%s: No OnlineTxnList record found... Exiting.." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Reset ALL OFXLastTxnUpdate dates?"):
            return

        theOnlineTxnRecord.obj.resetLastUpdateDates()
        theOnlineTxnRecord.obj.syncItem()

        play_the_money_sound()
        txt = "%s: All OFXLastTxnUpdate dates RESET" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def OFX_delete_ALL_saved_online_txns():
        # delete_intermediate_downloaded_transaction_caches.py
        # delete_orphaned_downloaded_txn_lists.py

        # CREATE TEST DATA
        # allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), AcctFilter.NON_CATEGORY_FILTER)
        # for acct in allAccounts:
        #     if "TEST"  != acct.getFullAccountName().upper() and "TEST2"  != acct.getFullAccountName().upper(): continue
        #     print "found: %s" %(acct)
        #     olTxns = acct.getDownloadedTxns()  # Note - this actually creates a new OnlineTxnList object if it didn't exist
        #     for i in range(0,10):
        #         olTxn = olTxns.newTxn()
        #         olTxn.setFIID("qif")
        #         olTxn.setName("Desc1" +str(i))
        #         olTxn.setDatePostedInt(	20200115+i )
        #         olTxn.setAmount( 9999+i )
        #         olTxn.setAllowDuplicateIDs(True)
        #         olTxns.addNewTxn(olTxn)
        #     olTxns.syncItem()
        #     print olTxns.getSyncInfo()
        # END CREATE TEST DATA

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (GlobalVars.UPDATE_MODE): return

        # quick check first...
        olTxnLists = MD_REF.getCurrentAccount().getBook().getItemsWithType("oltxns")
        lAny=False
        for txnList in olTxnLists:
            if txnList.getTxnCount() > 0:
                lAny=True
                break

        if not lAny and not myPopupAskQuestion(toolbox_frame_,"OFX PURGE OnlineTxnList OBJECTS","You don't seem to have any cached Online Txns. Proceed anyway (with general cleanup)?",theMessageType=JOptionPane.WARNING_MESSAGE):
            txt = "OFX PURGE OnlineTxnList OBJECTS. You have no cached Txns - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX PURGE OnlineTxnList OBJECTS","Purge/Clean all Cached OnlineTxnList Txns (very safe to run)?"):
            return

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes....

        myPrint("B","Purging / cleaning all OnlineTxnList Cached txns.....")

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), AcctFilter.NON_CATEGORY_FILTER)

        output = "PURGE/CLEAN ALL CACHED OnlineTxnList TXN RECORDS\n" \
                 " ===============================================\n\n"

        output += (" Found %s accounts and %s OnlineTxnList objects\n" % (len(allAccounts), len(olTxnLists)))
        shouldSaveTrunk = False

        # delete all online transactions from all downloaded-transaction-list objects,
        # which includes lists that are no longer associated with accounts
        for txnList in olTxnLists:
            output+=("OnlineTxnList %s    with    %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            if txnList.getTxnCount() > 0:
                myPrint("J", "OnlineTxnList %s - DELETING %s cached txns" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
                shouldSaveTrunk = True
                output+=("   >> DELETING Cached Txns....\n")
                txnList.setEditingMode()
                while txnList.getTxnCount() > 0:
                    txnList.removeTxn(txnList.getTxnCount() - 1)
                txnList.syncItem()
                output+=("   OnlineTxnList %s now has %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))

        output += "\n--------\n\n"

        for acct in allAccounts:
            olTxns = acct.getDownloadedTxns()  # Note - this actually creates a new OnlineTxnList object if it didn't exist
            olTxnsIdx = olTxnLists.indexOf(olTxns)
            if olTxnsIdx >= 0:
                if olTxns.getTxnCount() > 0:    # Note - I think this never finds any, as it will have been caught in the loop above....
                    shouldSaveTrunk = True
                    output+=("Found OnlineTxnList %s at index %s for account %s - DELETING %s cached txns\n"
                          % (pad(olTxns.getUUID(),50), rpad(olTxnsIdx,10), pad(acct.getAccountName(),30), olTxns.getTxnCount()))
                    myPrint("J", "Found OnlineTxnList %s at index %s for account %s - DELETING %s cached txns"
                            % (pad(olTxns.getUUID(),50), rpad(olTxnsIdx,10), pad(acct.getAccountName(),30), olTxns.getTxnCount()))
                    olTxns.setEditingMode()
                    while olTxns.getTxnCount() > 0:
                        olTxns.removeTxn(olTxns.getTxnCount() - 1)
                    olTxns.syncItem()
                    output+=("   OnlineTxnList %s                        >now has %s cached txns\n" % (pad(olTxns.getUUID(),50), rpad(olTxns.getTxnCount(),12)))
                olTxnLists.remove(olTxns)  # This check is OK though.....
            # else:
            #     output+=("@@ OnlineTxnList record NOT FOUND (orphaned), containing %s cached txns\n" % (rpad(olTxns.getTxnCount(),12)))

        output += "\n--------\n\n"

        output+=("Remaining/orphan OnlineTxnList objects to delete:\n")

        for txnList in olTxnLists:
            output+=(">> DELETING ORPHAN >> OnlineTxnList %s with %s cached txns\n" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            myPrint("J", ">> DELETING ORPHAN >> OnlineTxnList %s with %s cached txns" % (pad(txnList.getUUID(),50), rpad(txnList.getTxnCount(),12)))
            txnList.deleteItem()
            shouldSaveTrunk = True

        output += "\n--------\n\n"

        MD_REF.getCurrentAccount().getBook().logRemovedItems(olTxnLists)
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes....

        if shouldSaveTrunk:
            myPrint("J","Purge/Clean ALL OnlineTxnList objects - Saving Trunk file now....")
            output+=("SAVING TRUNK FILE...\n")
            MD_REF.getCurrentAccount().getBook().saveTrunkFile()
        else:
            myPrint("J","Purge/Clean ALL OnlineTxnList objects - NO CHANGES MADE....")
            output+=("Purge/Clean ALL OnlineTxnList objects - NO CHANGES MADE....\n")

        output+="\n<END>"

        myPrint("P",output)

        jif = QuickJFrame("OFX PURGE ALL OnlineTxnList OBJECTS",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        play_the_money_sound()
        txt = "OFX: Purge / Clean ALL OnlineTxnList Objects cached Txns completed..."
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        myPopupInformationBox(jif,txt,"OFX PURGE ALL OnlineTxnList",JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def OFX_delete_saved_online_txns():

        # delete_intermediate_downloaded_transaction_caches.py
        # delete_orphaned_downloaded_txn_lists.py

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if not (GlobalVars.UPDATE_MODE): return

        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(18))
        accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the Acct to alter the Online Txn List record:",
                                                   "Select ACCOUNT",
                                                   JOptionPane.INFORMATION_MESSAGE,
                                                   getMDIcon(lAlwaysGetIcon=True),
                                                   accountsListForOlTxns,
                                                   None)
        if not selectedAcct:
            txt = "Delete saved OnlineTxnList txns: No Account was selected.."
            setDisplayStatus(txt, "R")
            return

        theOnlineTxnRecord = StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)       # Use my version to prevent creation of default record(s)
        if theOnlineTxnRecord is None or theOnlineTxnRecord.obj is None:
            txt = "Delete saved OnlineTxnList txns: No OnlineTxnList record found... Exiting.."
            setDisplayStatus(txt, "R")
            return

        saveTxnCount = theOnlineTxnRecord.txnCount

        while True:
            _options=["CHANGE: DELETE All %s Txns stored on this record" %(saveTxnCount),
                      "CHANGE: DELETE the whole OnlineTxnList record"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "What type of change to OnlineTxnList record do you want to make?",
                                                         "OFX CHANGE OnlineTxns",
                                                         JOptionPane.WARNING_MESSAGE,
                                                         getMDIcon(None),
                                                         _options,
                                                         None)

            if not selectedOption:
                txt ="No change for OnlineTxnList record selected - exiting.."
                setDisplayStatus(txt, "R")
                return

            lDeleteAllTxns  = (_options.index(selectedOption) == 0)
            lDeleteRecord   = (_options.index(selectedOption) == 1)

            if lDeleteAllTxns and saveTxnCount<1: continue

            break

        do_what=""
        if lDeleteAllTxns: do_what="Delete all %s stored Txns within the record" %(saveTxnCount)
        if lDeleteRecord:  do_what="Delete the whole OnlineTxnList record"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX DELETE CHANGE OnlineTxnList","%s?" %(do_what)):
            return

        if lDeleteRecord:
            theOnlineTxnRecord.obj.deleteItem()
            play_the_money_sound()
            txt = "OFX CHANGE OnlineTxnList whole record for acct: %s successfully deleted: " %(selectedAcct)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,"OFX DELETE CHANGE OnlineTxnList",JOptionPane.ERROR_MESSAGE)

        elif lDeleteAllTxns:

            theOnlineTxnRecord.obj.setEditingMode()
            while theOnlineTxnRecord.obj.getTxnCount() > 0:
                theOnlineTxnRecord.obj.removeTxn(theOnlineTxnRecord.obj.getTxnCount() - 1)
            theOnlineTxnRecord.obj.syncItem()

            # for i in reversed(range(0,saveTxnCount)):
            #     theOnlineTxnRecord.obj.removeTxn(i)
            # theOnlineTxnRecord.obj.syncItem()
            #
            play_the_money_sound()
            txt = "OFX CHANGE OnlineTxnList Record for acct: %s: %s Txns deleted" %(selectedAcct, saveTxnCount)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,"OFX DELETE OnlineTxnList Txns",JOptionPane.ERROR_MESSAGE)

        del theOnlineTxnRecord

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def quick_check_cached_online_txns():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        countCachedAccounts = 0
        countCachedTxns = 0

        myPrint("DB","Quick check looking for Cached OFX Downloaded txns (that shouldn't be there)")
        accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(18))
        for acct in accountsListForOlTxns:
            cached = MyGetDownloadedTxns(acct)
            if cached.getTxnCount() > 0:
                myPrint("DB", "Account: %s contains %s cached txns" %(acct,cached.getTxnCount()))
                countCachedAccounts += 1
                countCachedTxns += cached.getTxnCount()

        myPrint("DB","... found: %s accounts containing %s cached txns" %(countCachedAccounts, countCachedTxns))
        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return countCachedAccounts, countCachedTxns

    def OFX_authentication_management():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if not isCachingPasswords():
            myPopupInformationBox(toolbox_frame_,"WARNING: Your system is not setup to cache/store Authentication details!","Manage OFX Authentication",JOptionPane.ERROR_MESSAGE)

        user_clearOneServiceAuthCache = JRadioButton("Clear the Authentication Cache (Passwords) for One Service / Bank Profile", False)
        user_clearOneServiceAuthCache.setToolTipText("Clears all remembered passwords for the OFX Service profile you select - THIS WILL CHANGE DATA!")

        user_clearAllServicesAuthCache = JRadioButton("Clear ALL Authentication Cache (Passwords)", False)
        user_clearAllServicesAuthCache.setToolTipText("Clears all remembered passwords for all OFX Service profiles - THIS WILL CHANGE DATA!")

        user_editSetupMultipleUserIDs = JRadioButton("Edit/Setup (multiple) UserIDs / Passwords (executes a special script)", False)
        user_editSetupMultipleUserIDs.setToolTipText("Allows setup of multiple UserIDs/Passwords on an OFX service profile - executes: ofx_populate_multiple_userids.py")

        user_editStoredOFXPasswords = JRadioButton("Edit stored authentication passwords linked to a working OFX Profile", False)
        user_editStoredOFXPasswords.setToolTipText("Manual edit of remembered OFX passwords linked to an OFX profile...")

        user_manualEditOfRootUserIDs = JRadioButton("Manual Edit of stored Root UserIDs/ClientUIDs", False)
        user_manualEditOfRootUserIDs.setToolTipText("Manual edit of any stored UserID/ClientUID raw record (from root account)")

        userFilters = JPanel(GridLayout(0, 1))

        bg = ButtonGroup()
        bg.add(user_clearOneServiceAuthCache)
        bg.add(user_clearAllServicesAuthCache)
        bg.add(user_editSetupMultipleUserIDs)
        bg.add(user_editStoredOFXPasswords)
        bg.add(user_manualEditOfRootUserIDs)
        bg.clearSelection()

        userFilters.add(user_clearOneServiceAuthCache)
        userFilters.add(user_clearAllServicesAuthCache)
        userFilters.add(user_editSetupMultipleUserIDs)
        userFilters.add(user_editStoredOFXPasswords)
        userFilters.add(user_manualEditOfRootUserIDs)

        while True:
            options = ["EXIT", "PROCEED"]
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       userFilters,
                                                       "Online Banking (OFX) AUTHENTICATION MANAGEMENT",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))

            if userAction != 1:
                txt = "Online Banking (OFX) AUTHENTICATION MANAGEMENT - No changes made....."
                setDisplayStatus(txt, "B")
                return False

            if user_clearOneServiceAuthCache.isSelected():
                clearOneServiceAuthCache()

            if user_clearAllServicesAuthCache.isSelected():
                clearAllServicesAuthCache()

            if user_editSetupMultipleUserIDs.isSelected():
                if editSetupMultipleUserIDs():
                    return True

            if user_editStoredOFXPasswords.isSelected():
                editStoredOFXPasswords()

            if user_manualEditOfRootUserIDs.isSelected():
                manualEditOfRootUserIDs()

            continue

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def OFX_cookie_management():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not GlobalVars.ADVANCED_MODE: return

        cookieKey="ofxcookies"

        LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

        _EDITONE = 0
        _DELETEONE = 1
        _DELETEALL = 2

        what = [
            "Edit One OFX Cookie's data",
            "Delete One OFX Cookie",
            "Delete All OFX Cookies"]

        while True:

            allCookieStrings = LS.getStringList(cookieKey)

            # LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
            # LS.put("ofxcookies.0","CBDIdleTimer=1585100844282|false|13|15; path=%2F; domain=google.com")
            # LS.put("ofxcookies.1","HNWPRD=A11; path=%2F; domain=google.com")
            # LS.put("ofxcookies.2","ADRUM_BTs=R:0|s:p; Sun, 10-Jan-2021 20:34:19 MST; path=%2F; domain=vesnc.billy.com")
            # LS.put("ofxcookies.3","ADRUM_BT1=R:0|i:52128|e:20; Tue, 12-Jan-2021 16:24:22 MST; path=%2F; domain=vesnc.apple.com")

            _i = 0
            msgStr=""
            for _i in range(0, len(allCookieStrings)):
                msgStr+="%s\n" %(allCookieStrings.get(_i))
                # print MDCookie.loadFromStorage(allCookieStrings.get(_i))
                _i+=1

            MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Your current cookies are:",
                             theMessage=msgStr,
                             theTitle="OFX COOKIE MANAGEMENT",
                             OKButtonText="CONTINUE").go()

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "What you want to do?",
                                                       "OFX COOKIE MANAGEMENT",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       what,
                                                       None)
            if not selectedWhat:
                txt = "No Cookie action/option was selected!"
                setDisplayStatus(txt, "R")
                return

            lEditOne = lDeleteOne = lDeleteAll = False

            if selectedWhat == what[_EDITONE]: lEditOne=True
            elif selectedWhat == what[_DELETEONE]: lDeleteOne=True
            elif selectedWhat == what[_DELETEALL]: lDeleteAll=True
            else: continue

            do_what=""
            if lDeleteOne: do_what="DELETE"
            if lEditOne: do_what="EDIT"
            if lDeleteAll: do_what="DELETE ALL"

            selectedCookie=None
            selectedCookieIndex=None

            if lDeleteOne or lEditOne:

                selectedCookie = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select a Cookie to %s" %(do_what),
                                                             "OFX COOKIE MANAGEMENT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             allCookieStrings,
                                                             None)
                if not selectedCookie: continue
                selectedCookieIndex=allCookieStrings.indexOf(selectedCookie)

            chgValue=None
            if lEditOne:
                chgValue = myPopupAskForInput(toolbox_frame_,
                                              theTitle="OFX COOKIE MANAGEMENT",
                                              theFieldLabel="EDIT COOKIE VALUE:",
                                              theFieldDescription="Carefully edit/change the data. NOTE: There will be no validation...",
                                              defaultValue=selectedCookie,
                                              isPassword=False,
                                              theMessageType=JOptionPane.WARNING_MESSAGE)
                if not chgValue or len(chgValue.strip()) <1 or chgValue == selectedCookie: continue
                chgValue = chgValue.strip()

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,"OFX BANK MANAGEMENT","OFX COOKIES %s?" %(do_what)):
                continue

            if not backup_local_storage_settings():
                txt = "'OFX COOKIE MANAGEMENT': ERROR making backup of LocalStorage() ./safe/settings - no changes made!"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                return

            if lEditOne:
                allCookieStrings[selectedCookieIndex] = chgValue
                txt = "OFX Cookie %s changed from %s to %s" %(selectedCookieIndex+1,selectedCookie,chgValue)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteOne:
                allCookieStrings.remove(selectedCookieIndex)
                txt = "OFX Cookie %s DELETED (was: %s)" %(selectedCookieIndex+1,selectedCookie)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            if lDeleteAll:
                allCookieStrings.clear()
                txt = "ALL OFX Cookies DELETED"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)

            myPrint("B","OFX Bank Management: Writing all Cookies back to Local Storage (after: %s)...." %(do_what))
            LS.put(cookieKey, allCookieStrings)
            LS.save()
            myPopupInformationBox(toolbox_frame_,"Your %s changes have been made and saved!" %(do_what),"OFX BANK MANAGEMENT",JOptionPane.WARNING_MESSAGE)
            continue

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def OFXDEBUGToggle():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        key = "ofx.debug.console"
        props_ofx_debug = System.getProperty(key, None)

        toggleText = "ON"
        if (props_ofx_debug is not None and props_ofx_debug!="false"):
            toggleText = "OFF"

        ask = MyPopUpDialogBox(toolbox_frame_,
                               "OFX DEBUG CONSOLE STATUS:",
                               'System.getProperty("%s") currently set to: %s\n'%(key,props_ofx_debug),
                               theTitle="TOGGLE MONEYDANCE INTERNAL OFX DEBUG",
                               lCancelButton=True,OKButtonText="SET to %s" %toggleText)
        if not ask.go():
            txt = "ADVANCED MODE: NO CHANGES MADE TO OFX DEBUG CONSOLE!"
            setDisplayStatus(txt, "B")
            return

        myPrint("B","ADVANCED MODE: User requested to toggle System Property '%s' to %s - setting this now...!" %(key,toggleText))
        if toggleText == "OFF":
            System.clearProperty(key)
        else:
            System.setProperty(key, "true")

        txt = "Internal debug ofx debug console setting turned %s" %(toggleText)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"TOGGLE MONEYDANCE INTERNAL OFX DEBUG",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def CUSIPFix():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        currID = "curr_id."

        # Credit to: Finite Mobius, LLC / Jason R. Miller" for original code (https://github.com/finitemobius/moneydance-py)
        # change-security-cusip.py
        # Variant of remove_ofx_security_bindings.py

        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
        if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD and not check_all_currency_raw_rates_ok(CurrencyType.Type.SECURITY):
            myPrint("B","@@ Error: failed check_all_currency_raw_rates_ok(SECURITY) check... Exiting CUSIPFix() without any changes...")
            txt = "ERROR: You have old format Security record(s). Consider running 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' option first"
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            setDisplayStatus(txt, "R")
            return

        # Find Securities with CUSIP(s) set...
        dropdownSecs = ArrayList()
        allSecs = ArrayList()
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() != CurrencyType.Type.SECURITY: continue
            allSecs.append(curr)
            for key in curr.getParameterKeys():
                if key.startswith(currID):
                    dropdownSecs.add(curr)
                    break

        theSchemes = None
        selectedSecurity = None
        selectedSecurityMoveTo = None
        lReset = lEdit = lMove = lAdd = False

        if len(dropdownSecs)<1:
            x="You have no existing CUSIP(s); Would you like to add a CUSIP?"
        else:
            x="You have %s securities with CUSIP(s) set; Would you like to manually add a CUSIP? (No brings up more options)" %(len(dropdownSecs))

        if not myPopupAskQuestion(toolbox_frame_,"FIX CUSIP",x,theMessageType=JOptionPane.WARNING_MESSAGE):
            if len(dropdownSecs)<1:
                txt = "FIX CUSIP - You have no existing CUSIP(s) set on Securities - No changes made..."
                setDisplayStatus(txt, "B")
                return
        else:
            allSecs=sorted(allSecs, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the security to add CUSIP data",
                                                           "FIX CUSIP",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           allSecs,
                                                           None)

            if not selectedSecurity:
                txt = "FIX CUSIP - No Security was selected - no changes made.."
                setDisplayStatus(txt, "B")
                return

            lAdd = True

        if not lAdd:
            dropdownSecs=sorted(dropdownSecs, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the security with CUSIP data to view/change",
                                                           "FIX CUSIP",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           dropdownSecs,
                                                           None)

            if not selectedSecurity:
                txt = "FIX CUSIP - No Security was selected - no changes made.."
                setDisplayStatus(txt, "B")
                return

            del dropdownSecs

            schemeText=""
            theSchemes=[]
            for key in selectedSecurity.getParameterKeys():
                if key.startswith(currID):
                    findScheme = key[len(currID):]
                    theSchemes.append([selectedSecurity,findScheme,selectedSecurity.getIDForScheme(findScheme)])
                    schemeText+="Scheme: %s ID: %s\n" %(findScheme,selectedSecurity.getIDForScheme(findScheme))

            if len(theSchemes)<1:
                txt = "FIX CUSIP - error iterating keys on %s for CUSIP(s) - NO CHANGES MADE!" %(selectedSecurity)
                setDisplayStatus(txt, "R")
                myPrint("B",txt)
                return

            ask=MyPopUpDialogBox(toolbox_frame_,"Showing CUSIP data for Security: %s" %(selectedSecurity),schemeText,theTitle="FIX CUSIP",OKButtonText="NEXT STEP",lCancelButton=True)
            if not ask.go():
                txt = "FIX CUSIP - no changes made.."
                setDisplayStatus(txt, "B")
                return

            options = ["EXIT", "RESET CUSIP(s)", "EDIT ONE CUSIP", "MOVE ALL TO DIFFERENT SECURITY", "ADD NEW CUSIP KEY"]
            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "Select CUSIP Option you want to action",
                                                         "FIX CUSIP",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(lAlwaysGetIcon=True),
                                                         options,
                                                         None)

            if not selectedOption or options.index(selectedOption) == 0:
                txt = "FIX CUSIP - No CUSIP option selected - no changes made.."
                setDisplayStatus(txt, "R")
                return

            if options.index(selectedOption) == 1: lReset = True
            elif options.index(selectedOption) == 2: lEdit = True
            elif options.index(selectedOption) == 3: lMove = True
            elif options.index(selectedOption) == 4: lAdd = True
            else:
                txt = "FIX CUSIP - Unknown option selected - no changes made"
                setDisplayStatus(txt, "R")
                return

            dropdownSecsMoveTo = selectedSecurityMoveTo = None                                                      # noqa

        if lMove:
            dropdownSecsMoveTo = ArrayList()
            currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            for curr in currencies:
                if curr.getCurrencyType() != CurrencyType.Type.SECURITY: continue                               # noqa
                if curr == selectedSecurity: continue
                dropdownSecsMoveTo.add(curr)

            if len(dropdownSecsMoveTo)<1:
                txt = "FIX CUSIP - You have no other Securities to move to - No changes made..."
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,"FIX CUSIP",JOptionPane.ERROR_MESSAGE)
                return

            dropdownSecsMoveTo=sorted(dropdownSecsMoveTo, key=lambda sort_x: (sort_x.getName().upper()))
            selectedSecurityMoveTo = JOptionPane.showInputDialog(toolbox_frame_,
                                                                 "Select the security to move the CUSIP data to:",
                                                                 "FIX CUSIP",
                                                                 JOptionPane.INFORMATION_MESSAGE,
                                                                 getMDIcon(lAlwaysGetIcon=True),
                                                                 dropdownSecsMoveTo,
                                                                 None)

            if not selectedSecurityMoveTo:
                txt = "FIX CUSIP - No Move to Security was selected - no changes made.."
                setDisplayStatus(txt, "R")
                return

            lAlreadyHasData = False
            for key in selectedSecurityMoveTo.getParameterKeys():
                if key.startswith(currID):
                    lAlreadyHasData=True
                    break
            if lAlreadyHasData:
                if not myPopupAskQuestion(toolbox_frame_,
                                          "FIX CUSIP",
                                          "Security: %s already has CUSIP data. OK will overwrite matching CUSIP key(s) (Cancel to exit)" %(selectedSecurityMoveTo),
                                          theMessageType=JOptionPane.WARNING_MESSAGE):
                    txt = "FIX CUSIP - Security: %s already has CUSIP data. User asked to Exit..." %(selectedSecurityMoveTo)
                    setDisplayStatus(txt, "R")
                    return
                myPrint("B", "FIX CUSIP - User selected to overwrite existing CUSIP data in Security: %s" %selectedSecurityMoveTo)

        if confirm_backup_confirm_disclaimer(toolbox_frame_,"FIX CUSIP","Are you sure you want to change CUSIP data on security: %s?" %(selectedSecurity)):
            if lReset:
                selectedSecurity.setEditingMode()
                for key in list(selectedSecurity.getParameterKeys()):
                    if key.startswith(currID):
                        findScheme = key[len(currID):]
                        # noinspection PyUnresolvedReferences
                        oldData = selectedSecurity.getIDForScheme(findScheme)
                        # noinspection PyUnresolvedReferences
                        selectedSecurity.setIDForScheme(findScheme, None)
                        myPrint("B","FIX CUSIP: Deleted CUSIP on Security: %s (Was: Scheme: %s ID: %s)" %(selectedSecurity,findScheme,oldData) )
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s Reset/Deleted!" %(selectedSecurity),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lMove:
                selectedSecurity.setEditingMode()
                selectedSecurityMoveTo.setEditingMode()
                for key in list(selectedSecurity.getParameterKeys()):
                    if key.startswith(currID):
                        findScheme = key[len(currID):]
                        moveData = selectedSecurity.getIDForScheme(findScheme)

                        moveToOldData = selectedSecurityMoveTo.getIDForScheme(findScheme)
                        if moveToOldData:
                            myPrint("B", "FIX CUSIP: Overwriting old data on destination security: %s (Was: Scheme: %s ID: %s)" %(selectedSecurityMoveTo,findScheme,moveToOldData))

                        myPrint("B","FIX CUSIP: Moving CUSIP data from %s to %s Scheme: %s ID: %s" %(selectedSecurity, selectedSecurityMoveTo,findScheme,moveData))
                        selectedSecurityMoveTo.setIDForScheme(findScheme, moveData)
                        selectedSecurity.setIDForScheme(findScheme, None)

                selectedSecurity.syncItem()
                selectedSecurityMoveTo.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s Moved to Security: %s!" %(selectedSecurity,selectedSecurityMoveTo),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lEdit:

                listData=[]
                for x in theSchemes:
                    listData.append(x[1])

                selectedSchemeToChange = JOptionPane.showInputDialog(toolbox_frame_,
                                                                     "Select the CUSIP to edit:",
                                                                     "FIX CUSIP",
                                                                     JOptionPane.INFORMATION_MESSAGE,
                                                                     getMDIcon(lAlwaysGetIcon=True),
                                                                     listData,
                                                                     None)

                if not selectedSchemeToChange:
                    txt = "FIX CUSIP - No CUSIP selected to edit - no changes made.."
                    setDisplayStatus(txt, "R")
                    return

                newID = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","ENTER NEW ID DATA:","Enter the new CUSIP data for Security: %s CUSIP: %s"
                                           %(selectedSecurity,selectedSchemeToChange),selectedSecurity.getIDForScheme(selectedSchemeToChange))

                if not newID or newID == selectedSecurity.getIDForScheme(selectedSchemeToChange):
                    txt = "FIX CUSIP - EDIT - new data not entered - no changes made"
                    setDisplayStatus(txt, "R")
                    return

                myPrint("B","FIX CUSIP - EDIT. Changing Security: %s CUSPID: %s from %s to %s"
                        %(selectedSecurity,selectedSchemeToChange,selectedSecurity.getIDForScheme(selectedSchemeToChange),newID))

                selectedSecurity.setIDForScheme(selectedSchemeToChange,newID)
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP data on Security: %s CUSIP: %s changed to: %s"
                                      %(selectedSecurity, selectedSchemeToChange,newID),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            elif lAdd:

                newScheme = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","NEW CUSIP Scheme/Key:","Enter Scheme Type to add (normally 'CUSIP'): %s"
                                               %(selectedSecurity), defaultValue="CUSIP")

                if not newScheme or newScheme == "":
                    txt = "FIX CUSIP - EDIT - new CUSIP Scheme Type not entered - no changes made"
                    setDisplayStatus(txt, "R")
                    return

                newID = myPopupAskForInput(toolbox_frame_,"FIX CUSIP","NEW CUSIP ID:","Enter the new CUSIP ID for Scheme Type: %s to add to Security: %s"
                                           %(newScheme,selectedSecurity))

                if not newID or newID == "":
                    txt = "FIX CUSIP - EDIT - new CUSIP ID not entered for new Scheme: %s to add to Security: %s - no changes made" %(newScheme,selectedSecurity)
                    setDisplayStatus(txt, "R")
                    return

                myPrint("B","FIX CUSIP - ADD. Adding CUSIP: %s ID %s to Security: %s"
                        %(newScheme, newID, selectedSecurity))

                selectedSecurity.setIDForScheme(newScheme,newID)
                selectedSecurity.syncItem()
                myPopupInformationBox(toolbox_frame_,"CUSIP Scheme/Key: %s ID: %s added to Security: %s"
                                      %(newScheme, newID, selectedSecurity),"FIX CUSIP",JOptionPane.WARNING_MESSAGE)

            else:
                txt = "FIX CUSIP - Unknown option selected - no changes made"
                setDisplayStatus(txt, "R")
                return

            play_the_money_sound()
            txt = "FIX CUSIP - Changes successfully applied to Security: %s" %(selectedSecurity)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class StoreService():
        def __init__(self, obj):
            if isinstance(obj,OnlineService):
                self.obj = obj                          # type: OnlineService
            else:
                self.obj = None

        def getService(self):
            # type: () -> OnlineService
            return (self.obj)

        def __str__(self):
            if self.obj is None:
                return "Invalid OnlineService Obj or None"
            return "Connection profile: %s (%s)" %(self.obj.getFIName(), self.obj.getTIKServiceID())

        def __repr__(self): return self.__str__()


    def deleteOFXService():
        # remove_one_service.py

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "DELETE ONLINE BANKING SERVICE / PROFILE"

        service = getUserSelectedServiceProfile(toolbox_frame_, _THIS_METHOD_NAME, "Select an Online Banking Service / Profile to delete", lIncludePlaidWhenUnlocked=True)  # type: OnlineService
        if not service: return

        if service.getTIKServiceID() == "md:plaid":
            if not myPopupAskQuestion(toolbox_frame_,
                                  _THIS_METHOD_NAME.upper(),
                                  "Are you SURE you want to delete the Moneydance+ profile? - You should NOT normally touch this! (But it should recreate itself)",
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "%s: User declined to delete the Moneydance+ profile (phew) - no changes made.." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                return

            myPrint("B","%s: User confirmed to delete the Moneydance+ Online Banking Profile...." %(_THIS_METHOD_NAME))

        if confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Delete Bank Service/Logon profile %s?" %(service)):
            # noinspection PyUnresolvedReferences
            service.clearAuthenticationCache()
            # noinspection PyUnresolvedReferences
            service.deleteItem()
            LS = MD_REF.getCurrentAccount().getBook().getLocalStorage()
            LS.save()

            cleanupMissingOnlineBankingLinks(lAutoPurge=True)

            play_the_money_sound()
            txt = "Online Banking Service / Logon Profile successfully deleted: %s" %(service)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def cleanupMissingOnlineBankingLinks(lAutoPurge=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "OFX Cleanup Missing Banking Links"

        PLAID_MAP_KEY = "map.md:plaid:::"

        mappingObject = None
        if isMDPlusEnabledBuild():
            p_osl = OnlineServiceLink.getDeclaredConstructor([String, String, Account])                                 # noqa
            p_osl.setAccessible(True)
            mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")

        ####################################################################################################################
        invalid_olblink_links = []      # New for MD2022 onwards
        invalid_mapping_links = []      # New for MD2022 onwards
        invalidBankingLinks = []
        invalidBillPayLinks = []

        myPrint("B","Searching for Account Online Banking / Bill Pay links with no profile (general cleanup routine)....")
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(26))

        for a in accounts:

            for pk in a.getParameterKeys():
                p_value = a.getParameter(pk, "")
                if pk == "olbfi" and a.getBankingFI() is None and p_value != "":
                    invalidBankingLinks.append(a)
                    myPrint("B","... Found account '%s' with a OFX banking link (to %s), but no service profile exists (thus dead)..." %(a,p_value))

                if pk == "bpfi" and a.getBillPayFI() is None and p_value != "":
                    invalidBillPayLinks.append(a)
                    myPrint("B","... Found account '%s' with a BillPay link (to %s), but no service profile exists (thus dead)..." %(a,p_value))

                if isMDPlusEnabledBuild():
                    if pk.startswith("olblink.") and p_value != "":
                        # link = OnlineServiceLink(pk[len("olblink."):], p_value, a)                                    # noqa
                        link = p_osl.newInstance(pk[len("olblink."):], p_value, a)                                      # noqa
                        if link.getService() is None:
                            invalid_olblink_links.append([a,link.onlineServiceID])
                            myPrint("B","... Found account '%s' with new 'olblink.' link ('%s' : '%s'), but no service profile exists (thus dead)..." %(a,pk, p_value))

        if isMDPlusEnabledBuild(): p_osl.setAccessible(False)

        if mappingObject is not None:
            myPrint("B","Searching for Orphaned mapping links (MD2022 onwards) (general cleanup routine)....")

            acctXRefDict = getAvailAccountsXRefDict()

            for objectKey in mappingObject.getParameterKeys():
                _value = mappingObject.getParameter(objectKey)

                if objectKey.startswith("map.none") or _value == "_none_": continue

                if objectKey.startswith("map."):
                    if objectKey.startswith(PLAID_MAP_KEY):
                        plaid_acct = objectKey[len(PLAID_MAP_KEY):].strip()
                        acctLookup = acctXRefDict.get(plaid_acct)           # type: StoreMDPlusLinkages
                        if acctLookup is None:
                            myPrint("B","...Found dead/orphaned MD+/Plaid mapping link ('%s' : '%s')" %(objectKey, _value))
                            invalid_mapping_links.append(objectKey)

                    mappedAccount = MD_REF.getCurrentAccountBook().getAccountByUUID(_value)
                    if mappedAccount is None:
                        myPrint("B","...Found orphaned mapping link ('%s' : '%s')" %(objectKey, _value))
                        invalid_mapping_links.append(objectKey)

        totalDead = len(invalidBankingLinks) + len(invalidBillPayLinks) + len(invalid_olblink_links) + len(invalid_mapping_links)
        myPrint("B", "%s: WARNING - %s dead banking links (and/or orphaned mapping links) found!" %(_THIS_METHOD_NAME.upper(), totalDead))

        if totalDead < 1:
            txt = "%s: CONGRATULATIONS - I found no Invalid Online Banking Links / Orphaned Mapping links......." %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            if not lAutoPurge:
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt)
            return

        if not lAutoPurge and not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Cleanup (remove) %s missing/dead online banking links?" %(totalDead)):
            return

        for a in invalidBankingLinks:
            a.setBankingFI(None)
            a.syncItem()
            myPrint("B","...removed the dead link Banking link on account %s" %(a))

        for a in invalidBillPayLinks:
            a.setBillPayFI(None)
            a.syncItem()
            myPrint("B","...removed the dead link BillPay link on account %s" %(a))

        for alink in invalid_olblink_links:
            alink[0].setOnlineIDForServiceID(alink[1], None)
            alink[0].syncItem()
            myPrint("B","...removed the dead link 'olblink.' link on account %s" %(alink[0]))

        if mappingObject is not None and len(invalid_mapping_links) > 0:
            mappingObject.setEditingMode()
            for maplink in invalid_mapping_links:
                myPrint("B","...removed the orphaned mapping link: %s : %s" %(maplink, mappingObject.getParameter(maplink)))
                mappingObject.setParameter(maplink, None)
            mappingObject.syncItem()

        del invalidBankingLinks, invalidBillPayLinks, invalid_olblink_links, accounts, invalid_mapping_links, mappingObject
        ####################################################################################################################

        txt = "%s dead/missing Online Banking links successfully removed (review console for details)" %(totalDead)
        myPrint("B", txt)

        if not lAutoPurge:
            play_the_money_sound()
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class StoreMDPlusLinkages():

        def __init__(self, _svc, _acct_ref, _map_key, _plaidID, _desc):
            self._svc = _svc
            self._acct_ref = _acct_ref
            self._map_key = _map_key
            self._plaidID = _plaidID
            self._desc = _desc

        def getPlaidID(self): return self._plaidID

        def getDesc(self): return self._desc

    def getPlaidService():
        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        for service in serviceList:
            if service.getTIKServiceID() == "md:plaid": return service
        return None

    def getAvailAccountsXRefDict():
        """Searches all Online Banking profiles and builds a x-ref list of Accounts to Plaid Connection refs"""

        mdplus_linkages = {}
        if isMDPlusEnabledBuild():
            service = getPlaidService()     # type: OnlineService
            if service is not None:
                for availAccount in service.getAvailableAccounts():
                    mdplus_linkages[availAccount.getAccountNumber()] = StoreMDPlusLinkages(service,
                                                                       availAccount.getAccountNumber(),
                                                                       availAccount.getMappingKey(),
                                                                       availAccount.getPlaidItemID(),
                                                                       availAccount.getDescription())
        return mdplus_linkages

    def special_toMultilineHumanReadableString(_object, lSkipSecrets=True, sFilterServiceID=None, lRedact=False):
        _output = ""
        if not _object: return _output

        if not sFilterServiceID:
            _output = "Object Parameter Keys:\n" \
                      "----------------------\n"

        PLAID_MAP_KEY = "map.md:plaid:::"

        acctXRefDict = getAvailAccountsXRefDict() if (_object.getParameter("id", None) == "online_acct_mapping") else {}

        hide_keys = ["mdplus.priv", "mdplus.pub"]
        for objectKey in sorted(_object.getParameterKeys()):
            _value = _object.getParameter(objectKey)

            acctText = ""
            acctXRef = ""

            if sFilterServiceID and not objectKey.startswith("map.%s" %(sFilterServiceID)): continue

            if objectKey.startswith("map."):
                if isMDPlusEnabledBuild() and objectKey.startswith(PLAID_MAP_KEY):
                    plaid_acct = objectKey[len(PLAID_MAP_KEY):].strip()
                    acctLookup = acctXRefDict.get(plaid_acct)           # type: StoreMDPlusLinkages
                    if acctLookup is not None:
                        acctXRef = "(Plaid ref: %s, Desc: %s) " %(acctLookup.getPlaidID(), acctLookup.getDesc())
                    else:
                        acctXRef = "(Orphan) "

                mappedAccount = MD_REF.getCurrentAccountBook().getAccountByUUID(_value)
                acctText = "(%s)" %("Missing Account" if (mappedAccount is None) else mappedAccount.getFullAccountName())

            if lSkipSecrets:
                if objectKey in hide_keys: _value = "****** hidden ****** (length: %s)" %(len(_value))

            if lRedact and not objectKey.startswith(PLAID_MAP_KEY) and ":::" in objectKey:
                redactedKey = objectKey[:objectKey.find(":::")+2] + redactor(objectKey[objectKey.find(":::")+3:])
                objectKey = redactedKey

            _output += "Key: %s %sValue: %s %s\n" %(objectKey, acctXRef, _value, acctText)

        if not sFilterServiceID: _output += "----------------------\n"
        return _output

    def getUserIDFromEmail(_emailAddress):
        if (_emailAddress is None): return ""
        digest = MessageDigest.getInstance("MD5")
        digest.update(String(String(String(_emailAddress).toLowerCase(Locale.ROOT)).trim()).getBytes(StandardCharsets.UTF_8))
        return StringUtils.encodeHex(digest.digest(), False)

    def getKeyID(_pubKeyHex):
        pubKeyBytes = StringUtils.decodeHex(_pubKeyHex)
        digest = MessageDigest.getInstance("MD5")
        digest.update(pubKeyBytes)
        keyID = StringUtils.encodeHex(digest.digest(), False)
        return keyID

    def getByteArray(syncObj, key):
        result = String(syncObj.get(key))
        return None if result is None else StringUtils.decodeHex(result)

    def decodePrivKey(pubKeyHex, privKeyHex):
        pubKeyBytes = StringUtils.decodeHex(pubKeyHex)
        privKeyBytes = StringUtils.decodeHex(privKeyHex)
        digest = MessageDigest.getInstance("MD5")
        digest.update(pubKeyBytes)
        kf = KeyFactory.getInstance("RSA")
        privkey = kf.generatePrivate(PKCS8EncodedKeySpec(privKeyBytes))
        pubkey = kf.generatePublic(X509EncodedKeySpec(pubKeyBytes))
        if privkey is None or pubkey is None: return None, None
        return pubkey, privkey

    def decrypt(cipherText, pubkey, privkey):                                                                           # noqa
        # noinspection PyUnresolvedReferences
        ENCRYPTION_PARAM_SPEC = OAEPParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec("SHA-256"), PSource.PSpecified.DEFAULT)
        if (FileUtils.byteArraysMatch(String("eparcel").getBytes(StandardCharsets.UTF_8), cipherText, 7)):
            parcel = SyncRecord()
            parcel.readSet(ByteArrayInputStream(cipherText))
            if (not parcel.containsKey("key") or  not parcel.containsKey("payload")):                                   # noqa
                return None  # Invalid encrypted parcel
            cipher1 = Cipher.getInstance("RSA/ECB/OAEPPadding")
            cipher1.init(2, privkey, ENCRYPTION_PARAM_SPEC)
            decryptedKey = cipher1.doFinal(getByteArray(parcel, "key"))
            originalKey = SecretKeySpec(decryptedKey, 0, len(decryptedKey), "AES")
            aesCipher = Cipher.getInstance("AES")
            aesCipher.init(2, originalKey)
            return aesCipher.doFinal(getByteArray(parcel, "payload"))

        cipher = Cipher.getInstance("RSA/ECB/OAEPPadding")
        cipher.init(2, privkey, ENCRYPTION_PARAM_SPEC)
        return cipher.doFinal(cipherText)

    def getLicenseForBook(_book, initIfDoesntExist):

        if not isMDPlusEnabledBuild(): return None

        # com.moneydance.apps.md.controller.MDPlus.getLicenseForBook(AccountBook, boolean) : MDPlus.MDPlusLicense
        # ... Will fail with 'java.lang.Error: java.lang.Error: Attempted security violation' on .getMDPlusLicense()
        # ... as "plusLicense" will not have yet been obtained, and the latter code calls .getLicenseForBook() which prevents Python
        # ... so we either need to get MD to do something which tricks it into setting "plusLicense" in advance.... ;->
        # ... or execute in a new Thread where MD will not detect "Python" at the top of the call stack....

        class GetLicenseForBook(Runnable):
            def __init__(self, theBook, _initIfDoesntExist):
                myPrint("DB", "INITIALISING::getLicenseForBook().GetLicenseForBook()")
                self.book = theBook
                self.initIfDoesntExist = _initIfDoesntExist
                self.plusLicense = None

            def run(self):
                myPrint("DB", "EXECUTING::getLicenseForBook().GetLicenseForBook.run() - will call MDPlus.singleton().getLicenseForBook()")
                self.plusLicense = MDPlus.singleton().getLicenseForBook(self.book, self.initIfDoesntExist)
                myPrint("DB", ">>> Finished executing GetLicenseForBook.run() - result:", self.plusLicense)

            def getResult(self):
                myPrint("DB", "getLicenseForBook().GetLicenseForBook.getResult() is returning:", self.plusLicense)
                return self.plusLicense

        clientGrabber = GetLicenseForBook(_book, initIfDoesntExist)
        t = Thread(clientGrabber, "toolbox_getLicenseForBook")
        t.start()
        t.join()
        return clientGrabber.getResult()

    def getPlaidClient(_plaidConnection):

        if not isMDPlusGetPlaidClientEnabledBuild(): return None

        # if com.moneydance.apps.md.controller.olb.plaid.PlaidConnection.getPlaidClient() is run too 'early',
        # ... then it will fail with 'java.lang.Error: java.lang.Error: Attempted security violation' on .getMDPlusLicense()
        # ... as "plusLicense" will not have yet been obtained, and the latter code calls .getLicenseForBook() which prevents Python
        # ... so we either need to get MD to do something which tricks it into setting "plusLicense" in advance.... ;->
        # ... or execute in a new Thread where MD will not detect "Python" at the top of the call stack....
        # Ref: com.moneydance.apps.md.controller.olb.plaid.PlaidConnection.plusLicense : MDPlus.MDPlusLicense

        class GetPlaidClient(Runnable):
            def __init__(self, thePlaidConnection):
                myPrint("DB", "INITIALISING::getPlaidClient().GetPlaidClient() - Plaid Connection passed:", thePlaidConnection)
                self.plaidConnection = thePlaidConnection
                self.plaidClient = None

            def run(self):
                myPrint("DB", "EXECUTING::getPlaidClient().GetPlaidClient.run()")
                try:
                    self.plaidClient = invokeMethodByReflection(self.plaidConnection, "getPlaidClient", None)
                except NoClassDefFoundError as e:
                    myPrint("B", "Caught error '%s' (expect it's 'HttpLoggingInterceptor') - will retry once more....:" %(e.getMessage()))
                    # Running twice seems to get past the 'NoClassDefFoundError: java.lang.NoClassDefFoundError: okhttp3/logging/HttpLoggingInterceptor' error
                    self.plaidClient = invokeMethodByReflection(self.plaidConnection, "getPlaidClient", None)
                myPrint("DB", ">>> Finished executing GetPlaidClient.run() - result:", self.plaidClient)

            def getResult(self):
                myPrint("DB", "getPlaidClient().GetPlaidClient.getResult() is returning:", self.plaidClient)
                return self.plaidClient

        clientGrabber = GetPlaidClient(_plaidConnection)
        t = Thread(clientGrabber, "toolbox_getPlaidClient")
        t.start()
        t.join()
        return clientGrabber.getResult()

    def UNLOCKMDPlusDiagnostic():

        if not isToolboxUnlocked() or not isMDPlusEnabledBuild(): return

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "UNLOCKED Moneydance+ Diagnostics"

        output = "%s:\n %s\n\n" %(_THIS_METHOD_NAME, "-"*len(_THIS_METHOD_NAME))

        licenseObject = getMDPlusLicenseInfoForBook()               # Note: Builds prior to 2006 will return None anyway...
        if licenseObject is None:
            output += "No Moneydance+ License Object found\n".upper()
        else:
            output += "Moneydance+ License Object found... Details:\n"

            mdplus_email = licenseObject.getParameter("mdplus.account_email", None)                                     # noqa
            mdplus_pend_email = licenseObject.getParameter("mdplus.pending_email", None)                                # noqa
            mdplus_signup_status = licenseObject.getParameter("signup_status", None)                                    # noqa
            mdplus_keyRegenDate = licenseObject.getLongParameter("mdplus.date", 0L)                                     # noqa
            mdplus_refreshDate = licenseObject.getLongParameter("mdplus.refresh_date", 0L)                              # noqa
            mdplus_keypairCreated = licenseObject.getLongParameter("mdplus.keypair_created", 0L)                        # noqa
            mdplus_privKeyHex = licenseObject.getParameter("mdplus.priv", None)                                         # noqa
            mdplus_pubKeyHex = licenseObject.getParameter("mdplus.pub", None)                                           # noqa

            output += "Dataset's UUID:          %s\n" %(MD_REF.getCurrentAccountBook().getFileUUID())
            output += "Email:                   %s\n" %(mdplus_email)
            output += "Email's MD5 encoded hex: %s\n" %(getUserIDFromEmail(mdplus_email))
            output += "Pending Email:           %s\n" %(mdplus_pend_email)
            if mdplus_signup_status:    output += "Signup status:           %s\n" %(mdplus_signup_status)
            if mdplus_keyRegenDate:     output += "MD+ date:                %s\n" %(get_time_stamp_as_nice_text(mdplus_keyRegenDate))
            if mdplus_refreshDate:      output += "MD+ refresh date:        %s\n" %(get_time_stamp_as_nice_text(mdplus_refreshDate))
            if mdplus_keypairCreated:   output += "MD+ keypair date:        %s\n" %(get_time_stamp_as_nice_text(mdplus_keypairCreated))
            if mdplus_privKeyHex:       output += "MD+ Private Key (raw):   %s\n" %(mdplus_privKeyHex)
            if mdplus_pubKeyHex:
                output += "MD+ Public Key (raw):    %s\n\n" %(mdplus_pubKeyHex)
                output += "Dataset/license 'KeyID': %s\n" %(getKeyID(mdplus_pubKeyHex))

            statusURL = None
            if mdplus_pubKeyHex and mdplus_email:
                statusURL = ("https://mdplus.infinitekind.com/tik/get_status/%s/%s"
                             %(getUserIDFromEmail(mdplus_email), getKeyID(mdplus_pubKeyHex)))
                output += "\nMD Check Key Status URL:\n%s\n\n" %(statusURL)

            if statusURL:
                output += "\nDATA DOWNLOADED FROM URL:\n"
                pubkey = privkey = None                                                                                 # noqa
                try:
                    grabGson = Gson()
                    url = URL(statusURL)
                    inx = BufferedReader(InputStreamReader(url.openStream(), "UTF8"))
                    status_outerJson = grabGson.fromJson(inx, Map); inx.close()                                         # type: HashMap

                    for o in status_outerJson:
                        output += "Key: %s: Value: %s\n" %(o, status_outerJson.get(o))                                  # noqa

                    status = status_outerJson.getOrDefault("status", "none")                                            # noqa
                    responseMsg = String.valueOf(status_outerJson.getOrDefault("message", ""))                          # noqa

                    pubkey, privkey = decodePrivKey(mdplus_pubKeyHex, mdplus_privKeyHex)

                    userInfo = SyncRecord()
                    userDataObject = status_outerJson.get("user_data")                                                  # noqa
                    userPayloadsJSON = HashMap() if userDataObject is None else userDataObject
                    for payloadKey in userPayloadsJSON.keySet():
                        cipherValue = StringUtils.decodeHex(String.valueOf(userPayloadsJSON.get(payloadKey)))
                        try:
                            accessTokenInfo = SyncRecord()
                            accessTokenInfo.readSet(ByteArrayInputStream(decrypt(cipherValue, pubkey, privkey)))
                            output += "'user_data' User Payload key: %s Decrypted value: %s\n" %(String.valueOf(payloadKey), accessTokenInfo)
                        except:
                            output += "'user_data' unable to decrypt user payload:       %s\n" % (payloadKey)

                    keyDataObject = status_outerJson.get("key_data")                                                    # noqa
                    keyPayloadsJSON = HashMap() if keyDataObject is None else keyDataObject
                    for payloadKey in keyPayloadsJSON.keySet():
                        cipherValue = StringUtils.decodeHex(String.valueOf(keyPayloadsJSON.get(payloadKey)))
                        try:
                            accessTokenInfo = SyncRecord()
                            accessTokenInfo.readSet(ByteArrayInputStream(decrypt(cipherValue, pubkey, privkey)))
                            output += "'key_data' Key Payload key: %s Decrypted value:   %s\n" %(String.valueOf(payloadKey), accessTokenInfo)
                        except:
                            output += "'key_data' unable to decrypt key payload:         %s\n" % (payloadKey)

                    if status_outerJson.containsKey("encrypted"):                                                       # noqa
                        ciphertext = StringUtils.decodeHex(String.valueOf(status_outerJson.get("encrypted")))           # noqa
                        clearbytes = decrypt(ciphertext, pubkey, privkey)
                        userInfo.readSet(ByteArrayInputStream(clearbytes))
                        for ui in userInfo:
                            output += "'encrypted'... Key: %s Value %s\n" %(ui, userInfo.get(ui))                       # noqa

                    output += "<END OF URL DATA>\n\n"
                except:
                    output += "Error downloading, decrypting status data from IK URL...!?\n"
                    output += dump_sys_error_to_md_console_and_errorlog(True)
                    output += "<END OF URL DATA>\n\n"

                finally:
                    del pubkey, privkey

            tokens = MD_REF.getCurrentAccountBook().getLocalStorage().getSublist("access_tokens")
            output += "\n>>Moneydance+ Access Tokens (local storage 'access_tokens')...:\n"
            if len(tokens) > 0:
                for token in tokens:
                    for token_key in token:
                        output += "Key: %s Value: %s\n" %(token_key, token.get(token_key))
            else:
                output += "<NONE>\n"

            mdp_cache = MD_REF.getCurrentAccountBook().getLocalStorage().getSubset("mdp_items")
            output += "\n>>Moneydance+ Plaid Cache (local storage 'mdp_items')...:\n"
            if len(mdp_cache) > 0:
                for cacheItem in mdp_cache:
                    output += "Key: %s Value: %s\n" %(cacheItem, mdp_cache.get(cacheItem))
            else:
                output += "<NONE>\n"
            del mdp_cache

            output += "\n>>Account Mappings Object's PARAMETER KEYS (MD2022 onwards)\n"
            mappingObject = MD_REF.getCurrentAccount().getBook().getItemForID("online_acct_mapping")
            if mappingObject is None:
                output += "<NO ACCOUNT MAPPING OBJECT FOUND>\n"
            else:
                output += special_toMultilineHumanReadableString(mappingObject, lSkipSecrets=False)

        output += "\n<END>"
        QuickJFrame(_THIS_METHOD_NAME.upper(),output,lAlertLevel=1,copyToClipboard=False,lWrapText=False).show_the_frame()

        txt = "%s: CONFIDENTIAL Moneydance+ settings displayed... DO NOT SHARE THESE WITH ANYONE" %(_THIS_METHOD_NAME.upper())
        setDisplayStatus(txt, "R"); myPrint("B", txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def export_MDPlus_LicenseObject():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Export Moneydance+ (Plaid) license (keys) to file"
        _TEST_KEY = "Confidential data: KEYTEST123$"

        licenseObject = getMDPlusLicenseInfoForBook()

        if licenseObject is None:
            myPopupInformationBox(toolbox_frame_,"No Moneydance+ license object found - NO EXPORT PERFORMED!",_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        mdplus_email = licenseObject.getParameter("mdplus.account_email", None)                                         # noqa
        mdplus_pend_email = licenseObject.getParameter("mdplus.pending_email", None)                                    # noqa
        mdplus_signup_status = licenseObject.getParameter("signup_status", None)                                        # noqa
        mdplus_keyRegenDate = licenseObject.getLongParameter("mdplus.date", 0L)                                         # noqa
        mdplus_refreshDate = licenseObject.getLongParameter("mdplus.refresh_date", 0L)                                  # noqa
        mdplus_keypairCreated = licenseObject.getLongParameter("mdplus.keypair_created", 0L)                            # noqa
        mdplus_privKeyHex = licenseObject.getParameter("mdplus.priv", None)                                             # noqa
        mdplus_pubKeyHex = licenseObject.getParameter("mdplus.pub", None)                                               # noqa

        if not mdplus_email or not mdplus_pubKeyHex or not mdplus_privKeyHex or not mdplus_signup_status:
            txt = "No Valid Moneydance+ license object found - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME.upper(),"ALERT: This Exports your confidential MD+(Plaid) private/public keys to an encrypted file. Continue?"):
            return

        theTitle = "Select location to Export your encrypted Moneydance+ license object ... (CANCEL=ABORT)"
        exportFile = getFileFromFileChooser(toolbox_frame_,                                     # Parent frame or None
                                            get_home_dir(),                                     # Starting path
                                            "MoneydancePlus_license_object_CONFIDENTIAL.mdp",   # Default Filename
                                            theTitle,                                           # Title
                                            False,                                              # Multi-file selection mode
                                            False,                                              # True for Open/Load, False for Save
                                            True,                                               # True = Files, else Dirs
                                            "EXPORT",                                           # Load/Save button text, None for defaults
                                            "mdp",                                              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if exportFile is None or exportFile == "": return

        encryptionKey = myPopupAskForInput(toolbox_frame_,
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           theFieldLabel="Encryption password:",
                                           theFieldDescription="Enter any password you like to encrypt the exported data (YOU MUST REMEMBER THIS!)",
                                           isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if encryptionKey is None or encryptionKey == "":
            txt = "Encryption password not entered - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        verifyEncryptionKey = myPopupAskForInput(toolbox_frame_,
                                                theTitle=_THIS_METHOD_NAME.upper(),
                                                theFieldLabel="RE-ENTER the same Encryption password:",
                                                theFieldDescription="REENTER the password to verify it's the same....",
                                                isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if verifyEncryptionKey is None or verifyEncryptionKey == "" or verifyEncryptionKey != encryptionKey:
            txt = "Encryption password not re-entered successfully - NO EXPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return
        del verifyEncryptionKey

        p_cipher = MDSyncCipher.getDeclaredConstructor([String])                                                        # noqa
        p_cipher.setAccessible(True)
        cipher = p_cipher.newInstance(encryptionKey)
        del encryptionKey

        fout = FileOutputStream(File(exportFile))
        export_encryptedStream = invokeMethodByReflection(cipher, "getEncryptStream", [OutputStream], [fout])

        # Pause the MD+ poller...
        if isMDPlusEnabledBuild():
            myPrint("B", "Pausing MD+")
            plusPoller = MD_REF.getUI().getPlusController()
            invokeMethodByReflection(plusPoller, "pausePolling", None)

        exportMDPlusData = StreamTable()
        exportMDPlusData.put("_TOOLBOX_",_TEST_KEY)
        for object_key in licenseObject.getParameterKeys():
            # encryptedData = String(MDSyncCipher.encryptString(licenseObject.getParameter(object_key), encryptionKey), StandardCharsets.UTF_8)
            theData = licenseObject.getParameter(object_key)
            exportMDPlusData.put(object_key, theData)
            del theData

        MD_REF.saveCurrentAccount()

        try:
            exportMDPlusData.writeTo(export_encryptedStream)
            export_encryptedStream.flush(); export_encryptedStream.close()
            fout.close()
            del cipher, exportMDPlusData, licenseObject

            play_the_money_sound()
            txt = "Moneydance+ settings encrypted & exported to: %s" %(exportFile)
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

            txt = "Exported (encrypted) file contains confidential MD+(Plaid) license key data. Use then DELETE file ASAP!"
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR exporting & decrypting Moneydance+ license object to: %s (review console)" %(exportFile)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)

        if isMDPlusEnabledBuild():
            myPrint("B", "Un-pausing MD+")
            plusPoller = MD_REF.getUI().getPlusController()
            invokeMethodByReflection(plusPoller, "resumePolling", None)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def import_MDPlus_LicenseObject():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not isMDPlusEnabledBuild(): return

        _THIS_METHOD_NAME = "Import Moneydance+ (Plaid) license object from file"
        _TEST_KEY = "Confidential data: KEYTEST123$"

        if not myPopupAskQuestion(toolbox_frame_,_THIS_METHOD_NAME.upper(), "WARNING: This will overwrite/replace/transplant your MD+(Plaid) license object with data from a file. Continue?"):
            return False

        book = MD_REF.getCurrentAccountBook()

        theTitle = "Select file to Import ('transplant') your Moneydance+ license object from... (CANCEL=ABORT)"
        importFile = getFileFromFileChooser(toolbox_frame_,                                     # Parent frame or None
                                            get_home_dir(),                                     # Starting path
                                            "MoneydancePlus_license_object_CONFIDENTIAL.mdp",   # Default Filename
                                            theTitle,                                           # Title
                                            False,                                              # Multi-file selection mode
                                            True,                                               # True for Open/Load, False for Save
                                            True,                                               # True = Files, else Dirs
                                            "IMPORT",                                           # Load/Save button text, None for defaults
                                            "mdp",                                              # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if importFile is None or importFile == "": return False

        encryptionKey = myPopupAskForInput(toolbox_frame_,
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           theFieldLabel="Decryption password:",
                                           theFieldDescription="Enter the encryption password you used when Exporting the data...",
                                           isPassword=True,theMessageType=JOptionPane.WARNING_MESSAGE)

        if encryptionKey is None or encryptionKey == "":
            txt = "Decryption password not entered - NO IMPORT PERFORMED!"
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return

        p_cipher = MDSyncCipher.getDeclaredConstructor([String])                                                        # noqa
        p_cipher.setAccessible(True)
        cipher = p_cipher.newInstance(encryptionKey)
        del encryptionKey

        fin = FileInputStream(File(importFile))
        import_decryptedStream = invokeMethodByReflection(cipher, "getDecryptStream", [InputStream], [fin])

        try:
            importMDPlusData = StreamTable()
            importMDPlusData.readFrom(import_decryptedStream)
            import_decryptedStream.close(); fin.close()
            del cipher
            myPrint("DB","Import... StreamTable read & decrypted from file: %s" %(importFile))
        except:
            txt = "ERROR decrypting IMPORT file >> Wrong password entered? (review console) - NO CHANGES MADE!"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
            return False

        mdplus_keys = [ "mdplus.account_email",
                        "mdplus.pending_email",
                        "signup_status",
                        "mdplus.date",
                        "mdplus.refresh_date",
                        "mdplus.keypair_created",
                        "mdplus.priv",
                        "mdplus.pub"]

        mdplus_validateKeys = [ "_TOOLBOX_",
                                "mdplus.account_email",
                                "signup_status",
                                "mdplus.priv",
                                "mdplus.pub"]

        mdplus_skipKeys = ["_TOOLBOX_",
                           "id",
                           "obj_type",
                           "ts",
                           "_txnfile"]

        # noinspection PyUnresolvedReferences
        for checkKey in mdplus_validateKeys:

            if not importMDPlusData.get(checkKey):
                myPrint("B","Import validation: Failed checking for key '%s' (missing)" %(checkKey))
                txt = "Import file for Moneydance+ license object INVALID - NO IMPORT PERFORMED!"
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
                return False

            if checkKey == "_TOOLBOX_":
                if importMDPlusData.get(checkKey) != _TEST_KEY:
                    txt = "Decryption test failed.. Did you enter the correct password? >> NO IMPORT PERFORMED!"
                    setDisplayStatus(txt, "R"); myPrint("B", txt)
                    myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
                    return
                myPrint("B","Verified that the _TOOLBOX_ Key Test properly decrypted... Proceeding....")

        if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(), "Import ('transplant') Moneydance+ license object from file & OVERWRITE EXISTING SETTINGS?"):
            return False

        myPrint("B", "... shutting down the md+ controller...")
        shutdownMDPlusPoller()

        preZapMDPlusSettingsFirst = myPopupAskQuestion(toolbox_frame_, _THIS_METHOD_NAME, "Wipe all pre-existing MD+ settings before importing MD+ licence?")

        if preZapMDPlusSettingsFirst:
            zap_MDPlus_Profile(lAutoZap=True)
        else:
            forceMDPlusNameCacheAccessTokensRebuild(lAutoWipe=True)   # Clear the LocalStorage cache.... It will rebuild itself...

        licenseObject = getMDPlusLicenseInfoForBook()

        if licenseObject is not None:
            myPrint("B","Moneydance+ IMPORT.. Existing license object will be overwritten.. Settings were..:\n", special_toMultilineHumanReadableString(licenseObject))
            licenseObject.setEditingMode()
            for key_to_delete in mdplus_keys: licenseObject.setParameter(key_to_delete, None)
        else:
            myPrint("B","Creating new Moneydance+(Plaid) license object....")
            licenseObject = MoneydanceSyncableItem(book)
            licenseObject.setEditingMode()
            licenseObject.setParameter("id", "tik.mdplus-license")
            licenseObject.setParameter("obj_type", "misc")

        for object_key in importMDPlusData:
            if object_key in mdplus_keys:
                licenseObject.setParameter(object_key, importMDPlusData.get(object_key))
                myPrint("B","IMPORT... Setting key %s into MD+ license object..." %(object_key))
            elif object_key in mdplus_skipKeys: pass
            else: myPrint("B","IMPORT.. Ignoring/skipping the setting: '%s', Value: '%s'" %(object_key,importMDPlusData.get(object_key)))

        licenseObject.syncItem()

        myPrint("B", "... Auto-running cleanup of banking links...")
        cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().getLocalStorage().save()

        del importMDPlusData, licenseObject

        myPrint("B", "Deleting Moneydance+ Import file...: %s" %(importFile))
        try: os.remove(importFile)
        except: pass

        play_the_money_sound()
        txt = "Moneydance+ license object IMPORTED (import file deleted) >> MONEYDANCE WILL NOW RELOAD DATASET/RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def zap_MDPlus_Profile(lAutoZap=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Zap Dataset's Moneydance+ (Plaid) settings"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        licenseObject = getMDPlusLicenseInfoForBook()

        # if licenseObject is None:
        #     myPopupInformationBox(toolbox_frame_,"NO Moneydance+ settings/profile found - NO CHANGES MADE!",_THIS_METHOD_NAME.upper(),JOptionPane.ERROR_MESSAGE)
        #     return False

        if not lAutoZap:
            if isMDPlusLicenseActivated():
                ask = MyPopUpDialogBox(toolbox_frame_,
                                     theStatus="WARNING: Attempting to ZAP MD+ settings when Dataset status is ACTIVATED!?",
                                     theTitle=_THIS_METHOD_NAME.upper(),
                                     theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                                "This dataset has an Activated MD+ License. (You may lose access to your subscription)\n"
                                                "If you ZAP, then your Account linkages will still be stored on the IK/Plaid servers ('Zombies')\n"
                                                "You should use the Online/Setup Moneydance+ menu to Disconnect this dataset's account links (first)\n"
                                                "However, if you have 'transplanted' your MD+ license to other datasets, then it's OK to Zap...\n"
                                                "         (as your account links will be accessible from the other dataset with the same MD+ license)\n"
                                                "NOTE: Running ZAP will not cause any harm, but you will have to setup MD+ / PLaid links again (in this dataset)\n"
                                                "\n",
                                     lCancelButton=True,
                                     OKButtonText="I AGREE - PROCEED",
                                     lAlertLevel=2)

                if not ask.go():
                    txt = "User did not say yes to ZAP an Activated MD+ license - NO CHANGES MADE"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return False
                del ask

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"ZAP this Dataset's Moneydance+ settings/profile & banking links etc (USE WITH CARE)?"):
                return False

            myPrint("B", "User requested to delete all Moneydance+ settings - proceeding....:")

            myPrint("B", "... shutting down the md+ controller...")
            shutdownMDPlusPoller()

        if licenseObject is None:
            myPrint("B", "... No md+ license object found to delete... skipping...")
        else:
            myPrint("B", "... md+ license object's settings before deletion were..:\n", special_toMultilineHumanReadableString(licenseObject))
            licenseObject.deleteItem()

        plaidSettings = getMDPlusPlaidSettings()
        if plaidSettings is None:
            myPrint("B", "... No PlaidSettings object found to delete... skipping...")
        else:
            myPrint("B", "... PlaidSettings object's settings before deletion were..:\n", special_toMultilineHumanReadableString(plaidSettings))
            plaidSettings.deleteItem()

        # Clear the cache.... It will rebuild itself...
        forceMDPlusNameCacheAccessTokensRebuild(lAutoWipe=True)

        myPrint("B", "... Zapping md+ service / logon profile(s) (if exists)...")
        deleteServiceList = []
        serviceList = MD_REF.getCurrentAccountBook().getOnlineInfo().getAllServices()
        for sv in serviceList:
            if sv.getTIKServiceID() == "md:plaid": deleteServiceList.append(sv)
        if len(deleteServiceList) > 0: MD_REF.getCurrentAccount().getBook().logRemovedItems(deleteServiceList)

        PLAID_MAP_KEY = "map.md:plaid:::"
        mappingObject = MD_REF.getCurrentAccountBook().getItemForID("online_acct_mapping")

        myPrint("B", "... Zapping md+ mapping links (if they exist)...")
        if mappingObject is not None:
            invalid_mapping_links = []
            for objectKey in mappingObject.getParameterKeys():
                if objectKey.startswith(PLAID_MAP_KEY):
                    invalid_mapping_links.append(objectKey)

            if len(invalid_mapping_links) > 0:
                mappingObject.setEditingMode()
                for maplink in invalid_mapping_links: mappingObject.setParameter(maplink, None)
                mappingObject.syncItem()

        if lAutoZap:
            myPrint("B", "... >> All pre-existing moneydance+ settings have been deleted.. (returning to calling function)...")
            return

        myPrint("B", "... Auto-running cleanup of banking links...")
        cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        myPrint("B", "... Saving local storage...")
        storage.save()

        myPrint("B", "... Flushing changes to sync...")
        MD_REF.saveCurrentAccount()

        play_the_money_sound()

        txt = "All Moneydance+ settings DELETED >> MONEYDANCE WILL NOW RELOAD DATASET/RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def forceMDPlusNameCacheAccessTokensRebuild(lAutoWipe=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "Force MD+ name cache & access tokens rebuild"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        if not lAutoWipe:

            if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Wipe MD+ name cache and access tokens (to force a rebuild)?"):
                return False

            myPrint("B", "User requested to wipe MD+ name cache and access tokens (mdp_items and access_tokens) - proceeding....:")

            myPrint("B", "... shutting down the md+ controller...")
            shutdownMDPlusPoller()

        myPrint("B", "... Zapping md+ 'access_tokens' from local storage (if they exist)...")
        storage.removeSubset("access_tokens")

        myPrint("B", "... Zapping md+ plaid cache 'mdp_items' from local storage (if they exist)...")
        storage.removeSubset("mdp_items")

        if lAutoWipe: return

        myPrint("B", "... Auto-running cleanup of banking links...")
        cleanupMissingOnlineBankingLinks(lAutoPurge=True)

        myPrint("B", "... Saving local storage...")
        storage.save()

        myPrint("B", "... Flushing changes to sync...")
        MD_REF.saveCurrentAccount()

        play_the_money_sound()

        txt = "MD+ name cache & access tokens have been wiped..! MONEYDANCE WILL NOW RELOAD DATASET/RESTART"
        setDisplayStatus(txt, "R"); myPrint("B", txt)
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def forceDisconnectMDPlusConnection(lReturnConnectionInfoOnly=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not isMDPlusEnabledBuild() or not isMDPlusGetPlaidClientEnabledBuild(): return ""

        _THIS_METHOD_NAME = "Force disconnect an MD+ connection".upper()

        output = "%s:\n" \
                 " ========================================\n\n" %(_THIS_METHOD_NAME)

        connectionTxt = "\n\n** WARNING: There was a script problem reproducing the md+ connection list **\n\n"

        try:
            book = MD_REF.getCurrentAccountBook()

            service = PlaidConnection.getPlaidService(book)
            if service is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: could not get Plaid Service - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # plaidConnection = PlaidConnection(book, DefaultOnlineUIProxy(MD_REF.getUI(), book, None))
            plusController = MD_REF.getUI().getPlusController()
            if plusController is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: could not get PlusController - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            plaidConnection = plusController.getPlaidConnection()
            if plaidConnection is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: could not get plaidConnection - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            mapping = OnlineAccountMapping(book, service)
            licenseInfo = getMDPlusLicenseInfoForBook()
    
            # noinspection PyUnresolvedReferences
            p_mdpl = MDPlus.MDPlusLicense.getDeclaredConstructor(MoneydanceSyncableItem)
            p_mdpl.setAccessible(True)
            plusLicense = p_mdpl.newInstance(licenseInfo)
    
            status = None                                                                                               # noqa
            try:
                status = plusLicense.getSignupStatusWithRefreshing()
            except:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: Could not retrieve md+ signup status (perhaps you are offline) - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # noinspection PyUnresolvedReferences
            if status != MDPlus.SignupStatus.ACTIVATED:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: MD+ signup status(%s) is not activated - NO CHANGES MADE" %(status)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            # if getFieldByReflection(plaidConnection, "plusLicense") is None: raise Exception("PLEASE WAIT AND TRY AGAIN")

            plaidClient = getPlaidClient(plaidConnection)
            if plaidClient is None:
                if lReturnConnectionInfoOnly: return connectionTxt
                txt = "WARNING: getPlaidClient returned None - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            output += "MD+ signup status returned: %s\n\n" %(status)

            # noinspection PyUnresolvedReferences
            allAccessTokens = [PlaidConnection.ItemAccessInfo(tokenInfo) for tokenInfo in book.getLocalStorage().getSublist("access_tokens")]
            allItems = plaidConnection.getAccessTokensByItemID()    # Duplicates are ignored....

            output += "allAccessTokens:\n"
            for token in allAccessTokens:
                accessToken = invokeMethodByReflection(token, "getAccessToken", [])
                output += "%s %s\n" %(token, accessToken)
            output += "\n"
    
            accounts = service.getAvailableAccounts()
            output += "getAvailableAccounts: accounts\n"
            for acct in accounts: output += "%s (%s)\n" %(acct.getDescription(), acct.getAccountNumber().strip())
            output += "\n"
    
            itemsToBanks = {}
            for itemID in allItems.keySet():
                fiID = plaidConnection.getItemInfo(itemID).getStr("inst", "")
                itemsToBanks[itemID] = plaidConnection.getInstitutionInfo(fiID)

            output += "itemsToBanks:\n"
            for item in itemsToBanks: output += "%s <> '%s' (%s)\n" %(item, itemsToBanks[item].getName(), itemsToBanks[item].getID())
            output += "\n"
    
            sortedItemIDs = sorted(allItems.keySet(), key=lambda sort_x: (itemsToBanks[sort_x].getName()))

            class AccountMappingRow:
                def __init__(self, _itemInfo, _accountInfo, _allAccessTokens=None):
                    self.itemInfo = _itemInfo
                    self.accountInfo = _accountInfo
                    self.allAccessTokens = _allAccessTokens
                def isItemRow(self): return (self.accountInfo is None and self.itemInfo is not None)
    
            connectionRows = []

            for itemID in sortedItemIDs:
                itemInfo = allItems.get(itemID)
                connectionRows.append(AccountMappingRow(itemInfo, None, [token for token in allAccessTokens if token.getItemID() == itemID]))
                itemAccounts = sorted([olAccount for olAccount in accounts if olAccount.getPlaidItemID() == itemID], key=lambda sort_x: (sort_x.getDisplayName()))
                for acctInfo in itemAccounts:
                    connectionRows.append(AccountMappingRow(itemInfo, acctInfo))

            connectionTxt = "\n" \
                            "CONNECTIONS (should duplicate Menu>Online>Setup Moneydance+):\n" \
                            "-------------------------------------------------------------\n"

            class StoreConnectionRow:
                def __init__(self, _connectionRow, _institutionName):
                    self.connectionRow = _connectionRow
                    self.institutionName = _institutionName
                def __str__(self):  return self.institutionName
                def __repr__(self): return self.__str__()
                def toString(self): return self.__str__()

            connectionRowSelector = []
            for connectionRow in connectionRows:
                if connectionRow.isItemRow():
                    itemInfo = plaidConnection.getItemInfo(connectionRow.itemInfo.getItemID())
                    institutionInfo = plaidConnection.getInstitutionInfo(itemInfo.getStr("inst", ""))
                    institutionName = institutionInfo.getName("no name") + " (%s)" %(connectionRow.itemInfo.getItemID())
                    connectionTxt += "\nConnection: %s\n" %(institutionName)
                    if len(connectionRow.allAccessTokens) > 1:
                        connectionTxt += "... Found multiple payloads for this connection:\n"
                        for token in connectionRow.allAccessTokens:
                            connectionTxt += "...... payloadid=%s token=%s\n" %(token.getPayloadID(), invokeMethodByReflection(token, "getAccessToken", []))
                    connectionRowSelector.append(StoreConnectionRow(connectionRow, institutionName))
                else:
                    acctInfo = connectionRow.accountInfo
                    accountNum = acctInfo.getAccountNumber()
                    localAccount = mapping.getAccountForOnlineID(acctInfo.getAccountNumber(), None, False)
                    connectionTxt += "... ACCOUNT MAPPING: '%s' <> '%s'(%s)\n" %(acctInfo.getDisplayName(), localAccount, accountNum)
    
            connectionTxt += "\n<END OF REPRODUCED MD+ CONNECTIONS LIST>\n"

            if lReturnConnectionInfoOnly: return connectionTxt

            output += connectionTxt

            if len(connectionRowSelector) < 1:
                txt = "You have no connections available that can be disconnected - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()

            ask = MyPopUpDialogBox(jif,
                                 theStatus="WARNING: User requests to force disconnect an MD+ connection",
                                 theTitle=_THIS_METHOD_NAME.upper(),
                                 theMessage="Only attempt this when standard MD menus are not working....!\n"
                                            "Try the MD Menu > Online > Setup Moneydance + > REFRESH and DISCONNECT options first\n",
                                 lCancelButton=True,
                                 OKButtonText="I AGREE - PROCEED",
                                 lAlertLevel=1)
    
            if not ask.go():
                txt = "User did not say yes force disconnect the selected MD+ connection - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return
    
            selectedConnectionRow = JOptionPane.showInputDialog(jif,
                                                       "Select the Connection to force disconnect:",
                                                       "Select CONNECTION",
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       connectionRowSelector,
                                                       None)
    
            if not selectedConnectionRow:
                txt = "User did not select a connection to force disconnect - NO CHANGES MADE"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return
            if isinstance(selectedConnectionRow, StoreConnectionRow): pass

            if not confirm_backup_confirm_disclaimer(jif,_THIS_METHOD_NAME.upper(),"Proceed with force disconnect '%s' md+ connection (USE WITH CARE)?" %(selectedConnectionRow.institutionName)):
                return

            jif.dispose()

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing 'force disconnecting md+ connection' right now..",
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            output += "\n"
            txt = "User requested to force disconnect the '%s' Moneydance+ connection - proceeding....:" %(selectedConnectionRow.institutionName)
            output += "%s\n" %(txt); myPrint("B", txt)

            for token in selectedConnectionRow.connectionRow.allAccessTokens:
                # itemAccessInfo = token.
                accessToken = invokeMethodByReflection(token, "getAccessToken", [])
                response = plaidClient.service().itemRemove(ItemRemoveRequest(accessToken)).execute()
                success = response.isSuccessful()
                if success:
                    txt = "Plaid ItemRemoveRequest(%s) reported SUCCESS (token: %s)!" %(accessToken, token)
                    output += "%s\n" %(txt); myPrint("B", txt)
                else:
                    errorResponse = plaidClient.parseError(response)
                    txt = "Plaid ItemRemoveRequest(%s) FAILED (token: %s) - will continue... (error: %s %s)" %(accessToken, token, errorResponse, errorResponse.getErrorCode())
                    output += "%s\n" %(txt); myPrint("B", txt)

                payloadID = token.getPayloadID()
                if not StringUtils.isBlank(payloadID):
                    plusLicense.deleteKeyPayload(payloadID)
                    txt = "Deleted payloadID: '%s' from plusLicense at server..." %(payloadID)
                    output += "%s\n" %(txt); myPrint("B", txt)
                else:
                    txt = "payloadID: '%s' empty - no delete from server.... will continue...." %(payloadID)
                    output += "%s\n" %(txt); myPrint("B", txt)

                # noinspection PyUnresolvedReferences
                invokeMethodByReflection(plaidConnection, "removeAccessToken", [PlaidConnection.ItemAccessInfo], token)
                txt = "Removed access token from access_tokens cache: %s" %(token)
                output += "%s\n" %(txt); myPrint("B", txt)

            try:
                plaidConnection.updateAccountList()
                txt = "Plaid - called update account list..."
                output += "%s\n" %(txt); myPrint("B", txt)
            except Exception as e:
                txt = "Unable to refresh accounts list after removing token(s). Error was: %s" %(e)
                output += "%s\n" %(txt); myPrint("B", txt)
                dump_sys_error_to_md_console_and_errorlog()

            txt = "... Auto-running cleanup of banking links..."
            output += "%s\n" %(txt); myPrint("B", txt)
            cleanupMissingOnlineBankingLinks(lAutoPurge=True)

            MD_REF.getCurrentAccountBook().getLocalStorage().save()
            MD_REF.saveCurrentAccount()
    
            pleaseWait.kill()

            play_the_money_sound()

            txt = "Process to force disconnect '%s' MD+ connection completed.." %(selectedConnectionRow.institutionName)
            output += "%s\n" %(txt); myPrint("B", txt)
            setDisplayStatus(txt, "R")

            output += "\n<END>\n"

            jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
            myPopupInformationBox(jif,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        except:
            if lReturnConnectionInfoOnly: return connectionTxt
            output += "\n\nERROR script has crashed - please review console\n".upper()
            txt = dump_sys_error_to_md_console_and_errorlog(True)
            output += txt
            QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True, lAlertLevel=2).show_the_frame()

    def forgetOFXImportLink():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(10))
        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select an account (only these have remembered links)",
                                                      "FORGET OFX banking link",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      accounts.toArray(),
                                                      None)
        if not selectedAccount:
            txt = "'RESET BANKING LINK' No Account was selected - no changes made.."
            setDisplayStatus(txt, "R")
            return

        if confirm_backup_confirm_disclaimer(toolbox_frame_,"RESET BANKING LINK", "Forget OFX banking Import link for Acct: %s?" %(selectedAccount) ):

            selectedAccount.setEditingMode()                                                                # noqa
            selectedAccount.removeParameter("ofx_import_acct_num")                                          # noqa
            selectedAccount.removeParameter("ofx_import_remember_acct_num")                                 # noqa
            selectedAccount.syncItem()                                                                      # noqa

            txt = "Banking Import link on account: %s forgotten!" %(selectedAccount)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            play_the_money_sound()
            myPopupInformationBox(toolbox_frame_, txt, "RESET BANKING LINK",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def download_md_fiscal_setup_for_one_bank(bankID):

        if globalSaveFI_data is None or len(globalSaveFI_data)<1:
            return

        FI = MD_OFX_BANK_SETTINGS_DIR + bankID.strip() + ".dct"
        output = ""
        inx = None

        myPrint("B","######################################################################################################################################################################")
        myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind Servers to download the banking connection profiles for the bank you selected - IT IS NOT SENDING ANY DATA ###")
        myPrint("B","######################################################################################################################################################################")

        try:
            url = URL(FI)
            urlConn = url.openConnection()
            if urlConn is not None:
                rc = urlConn.getResponseCode()                                                                          # noqa
                if rc == 200:
                    inx = BufferedReader(InputStreamReader(urlConn.getInputStream(), "UTF8"))
                    while True:
                        lineofdata = inx.readLine()
                        if lineofdata is None: break
                        output+=(lineofdata+"\n")                                                                      # noqa
        except:
            myPrint("B", "ERROR downloading from Moneydance Fiscal Setup profiles link: %s " %(FI))
            output+="\n@@ERROR downloading from Moneydance Fiscal Setup profiles link: %s\n" %(FI)
            output+=dump_sys_error_to_md_console_and_errorlog(True)
        finally:
            if inx:
                try:
                    inx.close()
                except:
                    myPrint("B", "Error closing URL stream %s" %(FI))
                    output+="\n@@Error closing URL stream %s\n" %(FI)
                    output+=dump_sys_error_to_md_console_and_errorlog(True)

        return output

    class FIInfo():
        def __init__(self, info):
            self.info = info
            self.id = info.getStr("id", "")
            self.name = info.getStr("fi_name", "")
            self.lowerName = self.name.lower()

        def __str__(self):
            return "%s (%s)" %(self.name,self.id)

        def __repr__(self):
            return "%s (%s)" %(self.name,self.id)

    # noinspection PyUnresolvedReferences
    def download_md_fiscal_setup():

        global globalSaveFI_data, globalSave_DEBUG_FI_data      # global must be here as we set them

        downloadInfo = StreamTable()

        inx = None
        tagText=""
        wait = None

        if globalSaveFI_data is None or len(globalSaveFI_data)<1:

            wait = MyPopUpDialogBox(toolbox_frame_,"PLEASE WAIT - RETRIEVING FISCAL SETUP DATA...",lModal=False)
            wait.go()

            myPrint("B","###################################################################################################################################################")
            myPrint("B","### INFORMATION: Toolbox is connecting to Infinite Kind Servers to download the latest banking connection profiles - IT IS NOT SENDING ANY DATA ###")
            myPrint("B","###################################################################################################################################################")

            for theFile in [MD_OFX_DEBUG_SETTINGS_FILE,MD_OFX_DEFAULT_SETTINGS_FILE]:
                myPrint("DB", "Attempting to download: %s" %(theFile))
                try:
                    url = URL(theFile)
                    urlConn = url.openConnection()
                    if urlConn is not None:
                        rc = urlConn.getResponseCode()                                                                     # noqa
                        if rc == 200:
                            inx = BufferedReader(InputStreamReader(urlConn.getInputStream(), "UTF8"))
                            downloadInfo.readFrom(inx)
                            myPrint("DB", "Success downloading: %s" %(theFile))
                except:
                    myPrint("B", "ERROR downloading from Moneydance Fiscal Setup profiles link: %s " %(theFile))
                    dump_sys_error_to_md_console_and_errorlog(False)
                finally:
                    if inx:
                        try:
                            inx.close()
                        except:
                            myPrint("B", "Error closing URL stream %s" %(theFile))
                            dump_sys_error_to_md_console_and_errorlog()

                matches=None
                overrideMessage = downloadInfo.getStr("override_msg", None)
                ifNoneAvailableMessage = downloadInfo.getStr("no_fis_msg", None)
                infoMessage = downloadInfo.getStr("extra_msg", None)
                if overrideMessage is not None:
                    tagText=overrideMessage
                else:
                    matchesObj = downloadInfo.get("matches")
                    matches = ArrayList()
                    if isinstance(matchesObj,(StreamVector)):
                        matchesVector = matchesObj
                        for matchObj in matchesVector:
                            if isinstance(matchObj, StreamTable):
                                matches.add(FIInfo(matchObj))
                    matchCount = 0
                    for i in range(0, matches.size()):
                        if matches is None: break
                        match = matches.get(i)
                        minVersion = match.info.getInt("min_version", 0)                                                    # noqa
                        maxVersion = match.info.getInt("max_version", 99999999)                                             # noqa

                        # Mirrors code (ish) from: com.moneydance.apps.md.view.gui.ofxsetup.OFXNewFIPanel.run() Line 294 ("min_version", "max_version)
                        if ((float(MD_REF.getBuild())) < minVersion or (float(MD_REF.getBuild())) > maxVersion):
                            matches.remove(i)
                            # i-=1
                        else:
                            matchCount+=1
                            i+=1
                    if matchCount == 0 and ifNoneAvailableMessage is not None:
                        tagText= ifNoneAvailableMessage
                    elif infoMessage is not None:
                        tagText=infoMessage

                if theFile == MD_OFX_DEFAULT_SETTINGS_FILE:
                    globalSaveFI_data=matches
                    globalSaveFI_data = sorted(globalSaveFI_data, key=lambda sort_x: (sort_x.lowerName, sort_x.id))
                else:
                    globalSave_DEBUG_FI_data=matches
                    globalSave_DEBUG_FI_data = sorted(globalSave_DEBUG_FI_data, key=lambda sort_x: (sort_x.lowerName, sort_x.id))

        output="Moneydance's Fiscal Institution Initial Dynamic Setup profiles..\n" \
               " ==============================================================\n\n"

        if len(tagText)>0:
            output+="\n%s\n\n" %(tagText)

        miniList=[]
        for bankSetup in globalSaveFI_data:
            output += "\nName: %s (%s)\n" %(bankSetup.name,bankSetup.id)
            miniList.append(bankSetup.lowerName)
            for element in bankSetup.info:
                if element == "id" or element == "fi_name": continue
                output+=" %s %s\n" %(pad(element+":",30), bankSetup.info.get(element))

        miniListDEBUG=[]
        for bankSetup in globalSave_DEBUG_FI_data:
            miniListDEBUG.append(bankSetup.lowerName)

        if len(globalSaveFI_data) < 1: output+="\nNO SETUP FOUND... DID SOMETHING GO WRONG? REVIEW CONSOLE ERROR LOG..!\n\n"

        output+="\n<END>"

        if wait is not None: wait.kill()

        jif = QuickJFrame("VIEW Moneydance's Dynamic / live Fiscal Institution setup profiles", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if len(miniList) > 0:
            selectedID = JOptionPane.showInputDialog(jif,
                                                     "Select Bank Profile to view specific setup data",
                                                      "VIEW SPECIFIC SETUP DATA",
                                                      JOptionPane.INFORMATION_MESSAGE,
                                                      getMDIcon(lAlwaysGetIcon=True),
                                                      globalSaveFI_data,
                                                      None)
            if selectedID:
                specificText = download_md_fiscal_setup_for_one_bank(selectedID.id)

                output="Moneydance's Fiscal Institution Initial Dynamic Setup profiles..\n" \
                       " ==============================================================\n\n" \
                       "Initial/Default Setup:\n" \
                       "----------------------\n"

                output += "\nName: %s (%s)\n" %(selectedID.name,selectedID.id)
                for element in selectedID.info:
                    if element == "id" or element == "fi_name": continue

                    extraText=""
                    if element == "dt_prof_updated": extraText="(%s)" %(get_time_stamp_as_nice_text(int(selectedID.info.get(element))))
                    output+=" %s %s %s\n" %(pad(element+":",30), selectedID.info.get(element),extraText)

                try:
                    output += "\n\nDEBUG Setup:\n" \
                              "--------------------------\n"
                    for findID in globalSave_DEBUG_FI_data:
                        if findID.id == selectedID.id:
                            for element in findID.info:
                                if element == "id" or element == "fi_name": continue
                                extraText=""
                                if element == "dt_prof_updated": extraText="(%s)" %(get_time_stamp_as_nice_text(int(findID.info.get(element))))
                                output+=" %s %s %s\n" %(pad(element+":",30), findID.info.get(element),extraText)
                            break
                except:
                    pass

                output += "\n\nSPECIFIC OVERRIDING Setup:\n" \
                       "--------------------------\n"
                output+=specificText
                output+="\n<END>"

                QuickJFrame("VIEW Moneydance's Specific (dynamic) Fiscal Institution setup profiles", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        txt = "OFX: Moneydance's Dynamic Fiscal Institution Setup profiles have been retrieved and displayed...."
        setDisplayStatus(txt, "B")

    def get_the_objects_for_curious_view_and_advanced_edit(objWhat, selectedObjType, titleStr, lForceOneTxn):

        # Yes, I know, repeated from calling function.... EDIT IN BOTH PLACES!
        # You need to edit the below in the sub def function too!!! (sorry ;-> )
        _OBJROOT        =  0
        _OBJACCT        =  1
        _OBJCAT         =  2
        _OBJACCTSEC     =  3
        _OBJCURR        =  4
        _OBJSEC         =  5
        _OBJREMINDERS   =  6
        _REPORT_MEM     =  7
        _GRAPH_MEM      =  8
        _REPORT_DEF     =  9
        _GRAPH_DEF      =  10
        _OBJADDRESSES   =  11
        _OBJOFXONLINE   =  12
        _OBJBYUUID      =  13
        _OBJTRANSACTION =  14
        _OBJSECSUBTYPES =  15
        _OBJMDPLUSLIC   =  16
        _OBJOFXMAPPINGS =  17
        _OBJOFXOLPAYEES =  18
        _OBJOFXOLPAYMNT =  19
        _OBJOFXTXNS     =  20

        lReportDefaultsSelected = False

        def getCurrTable(cType):

            cTable=ArrayList()
            myTable = MD_REF.getCurrentAccountBook().getCurrencies()
            myTable = sorted(myTable, key=lambda sort_x: (sort_x.getCurrencyType(), sort_x.getName().upper()))
            for curr in myTable:
                if curr.getCurrencyType() == cType:
                    cTable.add(curr)
            return cTable

        def getReportsTable(memorized_default_or_all, report_or_graph_or_all):

            theReports = None

            repTable=ArrayList()
            if report_or_graph_or_all == "ALL":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllItems()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllMemorizedItems()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllItems()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            elif report_or_graph_or_all == "REPORT":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllReports()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedReports()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllReports()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            elif report_or_graph_or_all == "GRAPH":
                if memorized_default_or_all == "ALL":
                    return MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllGraphs()
                elif memorized_default_or_all == "MEMORIZED":
                    return  MD_REF.getCurrentAccount().getBook().getMemorizedItems().getMemorizedGraphs()
                elif memorized_default_or_all == "DEFAULT":
                    theReports = MD_REF.getCurrentAccount().getBook().getMemorizedItems().getAllGraphs()
                else:
                    assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))
            else:
                assert("ERROR - Report  type not defined: %s %s" %(memorized_default_or_all,report_or_graph_or_all))

            # For Default return non memorized Items
            for rep in theReports:
                if not rep.isMemorized():
                    repTable.add(rep)

            return repTable

        objects = None
        try:
            if objWhat.index(selectedObjType) == _OBJROOT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(12))
                # The palaver below is to get the list sorted.....
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJACCT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(7))
                # The palaver below is to get the list sorted.....
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJCAT:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(8)).toArray()
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJACCTSEC:
                obj_x = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(9)).toArray()
                obj_x = sorted(obj_x, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
                objects = ArrayList()
                for o in obj_x: objects.add(o)
                objects = objects.toArray()
            elif objWhat.index(selectedObjType) == _OBJCURR:
                # noinspection PyUnresolvedReferences
                objects = getCurrTable(CurrencyType.Type.CURRENCY)
            elif objWhat.index(selectedObjType) == _OBJSEC:
                # noinspection PyUnresolvedReferences
                objects = getCurrTable(CurrencyType.Type.SECURITY)
            elif objWhat.index(selectedObjType) == _REPORT_MEM:
                objects = getReportsTable("MEMORIZED", "REPORT")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _GRAPH_MEM:
                objects = getReportsTable("MEMORIZED", "GRAPH")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _REPORT_DEF:
                lReportDefaultsSelected = True
                objects = getReportsTable("DEFAULT", "REPORT")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _GRAPH_DEF:
                lReportDefaultsSelected = True
                objects = getReportsTable("DEFAULT", "GRAPH")
                objects = sorted(objects, key=lambda x: (x.isMemorized(), x.getName().upper()))
            elif objWhat.index(selectedObjType) == _OBJREMINDERS:
                root = MD_REF.getCurrentAccountBook()
                objects = root.getReminders().getAllReminders()
                objects = sorted(objects, key=lambda x: (x.getDescription().upper()))
            elif objWhat.index(selectedObjType) == _OBJADDRESSES:
                root = MD_REF.getCurrentAccountBook()
                objects = root.getAddresses().getAllEntries()
                objects = sorted(objects, key=lambda x: (x.getName().upper()))
            elif objWhat.index(selectedObjType) == _OBJOFXONLINE:
                objects = MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices()
                objects = sorted(objects, key=lambda x: (x.getFIName().upper()))
            elif objWhat.index(selectedObjType) == _OBJBYUUID:
                pass
            elif objWhat.index(selectedObjType) == _OBJTRANSACTION:
                pass
            elif objWhat.index(selectedObjType) == _OBJSECSUBTYPES:
                item = MD_REF.getCurrentAccount().getBook().getItemForID("security_subtypes")             # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have a 'security_subtypes' to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif objWhat.index(selectedObjType) == _OBJMDPLUSLIC:
                item = getMDPlusLicenseInfoForBook()                        # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have a Moneydance+ license object to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif objWhat.index(selectedObjType) == _OBJOFXMAPPINGS:
                item = MD_REF.getCurrentAccount().getBook().getItemForID("online_acct_mapping")           # type: MoneydanceSyncableItem
                if item is None:
                    txt = "%s: Sorry - You don't have an OFX Account Mappings object to view..!" %(titleStr)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                    return None, lReportDefaultsSelected
                else:
                    objects = [item]
            elif (objWhat.index(selectedObjType) == _OBJOFXOLPAYEES
                  or objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT
                  or objWhat.index(selectedObjType) == _OBJOFXTXNS):

                accountsListForOlTxns = None
                if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(15))
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(16))
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                    accountsListForOlTxns = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(17))

                accountsListForOlTxns = sorted(accountsListForOlTxns, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

                selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the Acct to find Online Data about:",
                                                             "Select ACCOUNT",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             accountsListForOlTxns,
                                                             None)
                if not selectedAcct:
                    txt = "No Account was selected.."
                    setDisplayStatus(txt, "R")
                    return None, lReportDefaultsSelected

                if objWhat.index(selectedObjType) == _OBJOFXTXNS:
                    objects = [StoreTheOnlineTxnList(MyGetDownloadedTxns(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYEES:
                    objects = [StoreTheOnlinePayeeList(MyGetOnlinePayees(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)
                elif objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT:
                    objects = [StoreTheOnlinePaymentList(MyGetOnlinePayments(selectedAcct),selectedAcct)]       # Use my version to prevent creation of default record(s)

            else:
                return None, lReportDefaultsSelected
        except:
            dump_sys_error_to_md_console_and_errorlog( True )
            return None, lReportDefaultsSelected

        if objWhat.index(selectedObjType) == _OBJTRANSACTION:

            dateStart = 20251231
            dateEnd = 20251231

            dateTxt=""
            if lForceOneTxn:
                labelDateStart = JLabel("Select the Date:")
            else:
                dateTxt="Range "
                labelDateStart = JLabel("Date range start:")
            user_selectDateStart = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
            user_selectDateStart.setDateInt(dateStart)

            labelDateEnd = JLabel("Date range end:")
            user_selectDateEnd = JDateField(MD_REF.getUI())   # Use MD API function (not std Python)
            user_selectDateEnd.setDateInt(dateEnd)

            datePanel = JPanel(GridLayout(0, 2))
            datePanel.add(labelDateStart)
            datePanel.add(user_selectDateStart)

            if not lForceOneTxn:
                datePanel.add(labelDateEnd)
                datePanel.add(user_selectDateEnd)

            options = ["Cancel", "OK"]

            while True:
                userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                          datePanel,
                                                          "%s: Select Date %sfor TXNs (less is better)" %(titleStr,dateTxt),
                                                          JOptionPane.OK_CANCEL_OPTION,
                                                          JOptionPane.QUESTION_MESSAGE,
                                                          getMDIcon(None),
                                                          options,
                                                          options[1])

                if userAction != 1:
                    txt = "%s: User cancelled Date Selection for TXN Search" %(titleStr)
                    setDisplayStatus(txt, "R")
                    return None, lReportDefaultsSelected

                if lForceOneTxn:
                    user_selectDateEnd.setDateInt( user_selectDateStart.getDateInt() )

                if user_selectDateStart.getDateInt() <= user_selectDateEnd.getDateInt() \
                        and user_selectDateEnd.getDateInt() >= user_selectDateStart.getDateInt():
                    break   # Valid date range

                user_selectDateStart.setForeground(getColorRed())                                                       # noqa
                user_selectDateEnd.setForeground(getColorRed())                                                         # noqa
                continue   # Loop

            if objWhat.index(selectedObjType) == _OBJTRANSACTION:
                txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactions(
                                            MyTxnSearchFilter(user_selectDateStart.getDateInt(),user_selectDateEnd.getDateInt()))
            else:
                txns = []

            if not txns or txns.getSize() <1:
                txt = "%s: No Transactions Found.."  %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            if not lForceOneTxn:
                if txns.getSize() > 50:
                    txt = "%s:TXN SEARCH FOUND %s TXNs. TOO MANY, WILL ABORT...."%(titleStr,txns.getSize())
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt)
                    return None, lReportDefaultsSelected

            if lForceOneTxn:
                objects=ArrayList()
                for txn in txns:
                    objects.add(txn)
            else:
                objects = txns

        if objWhat.index(selectedObjType) == _OBJBYUUID:
            theUUID = myPopupAskForInput(toolbox_frame_, "GET SINGLE OBJECT BY UUID", "UUID:", "%s: Enter the UUID of the Object to get" %(titleStr), "", False)

            if not theUUID or theUUID == "":
                txt = "%s: No Object UUID was entered.." %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            selectedObject = MD_REF.getCurrentAccount().getBook().getItemForID(theUUID.strip())
            if selectedObject is None:
                txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
                selectedObject = txnSet.getTxnByID(theUUID.strip())
                if selectedObject is None:
                    selectedObject = TxnUtil.getTxnByID(txnSet, theUUID.strip())

            objects  = [selectedObject]
            if not selectedObject:
                txt = "%s: No Object was found for UUID: %s" %(titleStr,theUUID)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected


        if (objWhat.index(selectedObjType) == _OBJTRANSACTION and not lForceOneTxn):
            pass
        else:
            if len(objects) > 0 and isinstance(objects[0],(ParentTxn,SplitTxn)):

                class StoreTheTxn:
                    def __init__(self, obj):
                        if isinstance(obj,(ParentTxn,SplitTxn)):
                            self.obj = obj
                        else:
                            self.obj = None

                    def __str__(self):
                        MD_decimal = MD_REF.getPreferences().getDecimalChar()
                        if self.obj is None: return "Invalid Txn Obj or None"
                        _txt = "PARENT TXN: "
                        if isinstance(self.obj, SplitTxn): _txt = "SPLIT TXN:  "
                        curr = self.obj.getAccount().getCurrencyType()
                        _txt += "Date: %s " %(convertStrippedIntDateFormattedText(self.obj.getDateInt()))
                        _txt += "%s " %(pad(self.obj.getDescription(),40))
                        _txt += "Value: %s" %(rpad(curr.formatFancy(self.obj.getValue(),MD_decimal),15))
                        return _txt

                    def __repr__(self): return self.__str__()

                storeTheTxns = []
                for storeTxn in objects:
                    storeTheTxns.append( StoreTheTxn(storeTxn))

                selectedObject = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the specific Txn to %s" %(titleStr),
                                                             "Select Specific Txn",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             storeTheTxns,
                                                             None)

                objects  = [selectedObject.obj]                                                                         # noqa

            else:

                selectedObject = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "Select the specific Object to %s" %(titleStr),
                                                             "Select Specific Object",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             objects,
                                                             None)
                objects  = [selectedObject]

            if not selectedObject:
                txt = "%s: No Object was selected.." %(titleStr)
                setDisplayStatus(txt, "R")
                return None, lReportDefaultsSelected

            if (objWhat.index(selectedObjType) == _OBJOFXTXNS
                    or objWhat.index(selectedObjType) == _OBJOFXOLPAYEES
                    or objWhat.index(selectedObjType) == _OBJOFXOLPAYMNT):
                # noinspection PyUnresolvedReferences
                objects = [selectedObject.obj]       # Use my version to prevent creation of default record(s)

        return objects, lReportDefaultsSelected

    def advancedRemoveInternalFilesSettings():
        thisDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

        filesToRemove = []
        for wrapper in AccountBookUtil.getInternalAccountBooks():
            internal_filepath = wrapper.getBook().getRootFolder().getCanonicalPath()
            if internal_filepath == thisDataset:
                continue
            filesToRemove.append(internal_filepath)

        if len(filesToRemove)<1:
            txt = "ADVANCED: DELETE internal / Default Dataset(s) from DISK - You have no files to DELETE - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        iFilesOnDiskRemoved = 0

        while True:

            selectedFile = None
            if len(filesToRemove) > 0:
                saveOK = UIManager.get("OptionPane.okButtonText")
                saveCancel = UIManager.get("OptionPane.cancelButtonText")
                UIManager.put("OptionPane.okButtonText", "DELETE DATASET FROM DISK")
                UIManager.put("OptionPane.cancelButtonText", "EXIT")

                selectedFile = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the default/internal location Dataset to DELETE from disk",
                                                           "ADVANCED - DELETE FROM DISK",
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           filesToRemove,
                                                           None)

                UIManager.put("OptionPane.okButtonText", saveOK)
                UIManager.put("OptionPane.cancelButtonText", saveCancel)

            if not selectedFile:
                if iFilesOnDiskRemoved<1:
                    txt = "Thank you for using ADVANCED MODE!.. No changes made"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                else:
                    txt = "Thank you for using ADVANCED MODE!.. %s Datasets DELETED" %(iFilesOnDiskRemoved)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
                return

            if os.path.exists(selectedFile):
                if not myPopupAskQuestion(toolbox_frame_,
                                      "ADVANCED - DISCLAIMER - ARE YOU SURE?",
                                      "Are you SURE you REALLY want me to DELETE the %s dataset from disk?" %(selectedFile),
                                      theMessageType=JOptionPane.ERROR_MESSAGE):
                    continue

                filesToRemove.remove(selectedFile)

                try:
                    shutil.rmtree(selectedFile)
                    iFilesOnDiskRemoved+=1
                    play_the_money_sound()
                    txt = "@@ ADVANCEDMODE: Dataset %s removed from disk" %(selectedFile)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_,
                                          txt,
                                          "ADVANCED - DELETE FILE FROM DISK",
                                          JOptionPane.ERROR_MESSAGE)
                except:
                    dump_sys_error_to_md_console_and_errorlog()
                    txt = "@ERROR@ ADVANCED - Dataset %s FAILED TO remove from disk" %(selectedFile)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_,
                                          "@ERROR@ ADVANCED - Dataset %s FAILED TO remove from disk" %(selectedFile),
                                          "ADVANCED - ERROR",
                                          JOptionPane.ERROR_MESSAGE)

            continue

        del filesToRemove

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def cleanup_external_files_setting(lAutoPurge=False):
        # type: (bool) -> bool

        myPrint("DB", "In cleanup_external_files_setting()")

        _THIS_METHOD_NAME = "Cleanup External Files Setting".upper()

        if not backup_config_dict(): return False

        prefs = MD_REF.getUI().getPreferences()
        extFiles = prefs.getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, None)
        if extFiles is None or len(extFiles) < 1:
            myPrint("DB", "config.dict holds no '%s' - skipping cleanup routine...." %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES))
            return True

        newExtFiles = StreamVector()
        if isinstance(newExtFiles, Vector): pass

        for externalFilename in extFiles:
            try:
                if externalFilename.endswith(".moneydance"):
                    testWrapper = AccountBookWrapper.wrapperForFolder(File(externalFilename))
                    if testWrapper is not None and testWrapper.getBook().isValid():
                        if AccountBookUtil.isWithinInternalStorage(testWrapper.getBook()):
                            myPrint("DB", "config.dict: '%s': Confirmed exists: '%s' - BUT IS AN INTERNAL FILE - So will remove....." %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilename))
                        else:
                            myPrint("DB", "config.dict: '%s': Confirmed exists: '%s'" %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilename))
                            newExtFiles.add(externalFilename)
                            continue
            except:
                myPrint("B", "Error checking external file ('%s') - aborting checks" %(externalFilename))
                dump_sys_error_to_md_console_and_errorlog()
                return False

            myPrint("DB", "Checking external file >> NOT VALID (will remove): %s" %(externalFilename))

        invalidExtFiles = (extFiles.size() - newExtFiles.size())

        if invalidExtFiles < 1:
            txt = "No invalid/missing 'external' files found in config.dict - no changes made"
            myPrint("DB", txt)
            if not lAutoPurge:
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.INFORMATION_MESSAGE)
            return True

        if not lAutoPurge and not doesUserAcceptDisclaimer(toolbox_frame_,_THIS_METHOD_NAME.upper(),"Cleanup (remove) %s missing/invalid external files from config.dict?" %(invalidExtFiles)):
            return False

        myPrint("DB", "Saving new list of %s valid files (%s removed)" %(newExtFiles.size(), (extFiles.size() - newExtFiles.size())))
        prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, newExtFiles)

        txt = "%s invalid/missing 'external' files removed from config.dict (review console for details)" %(invalidExtFiles)
        myPrint("B", txt)

        if not lAutoPurge:
            play_the_money_sound()
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME.upper(),JOptionPane.WARNING_MESSAGE)

        return True

    def advancedRemoveExternalFilesSettings():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if not backup_config_dict():
            txt = "ADVANCED: Remove files from 'External' (non-default) file list in File/Open - Error backing up config.dict preferences file - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # Just clean up orphans anyway first.....
        cleanup_external_files_setting(lAutoPurge=True)

        prefs = MD_REF.getUI().getPreferences()
        thisDataset = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

        externalFilesVector = prefs.getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, StreamVector())

        filesToRemove = []
        for externalFileObj in externalFilesVector:
            if externalFileObj != thisDataset:
                filesToRemove.append(externalFileObj)

        if externalFilesVector is None or len(filesToRemove)<1:
            txt = "ADVANCED: Remove files from 'External' (non-default) file list in File/Open - You have no %s files in config.dict to edit - no changes made...." %(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,"You have no 'External' file references in config.dict to remove - NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        iReferencesRemoved = 0
        iFilesOnDiskRemoved = 0

        while True:

            selectedFile = None
            if len(filesToRemove) > 0:
                saveOK = UIManager.get("OptionPane.okButtonText")
                saveCancel = UIManager.get("OptionPane.cancelButtonText")
                UIManager.put("OptionPane.okButtonText", "REMOVE FILE REFERENCE FROM File/Open")
                UIManager.put("OptionPane.cancelButtonText", "EXIT")

                selectedFile = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the 'External' (non-default) file reference to remove",
                                                           "ADVANCED",
                                                           JOptionPane.WARNING_MESSAGE,
                                                           getMDIcon(None),
                                                           filesToRemove,
                                                           None)

                UIManager.put("OptionPane.okButtonText", saveOK)
                UIManager.put("OptionPane.cancelButtonText", saveCancel)

            if not selectedFile:
                if (iReferencesRemoved+iFilesOnDiskRemoved)<1:
                    txt = "ADVANCED MODE!.. No changes made"
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                else:
                    txt = "ADVANCED MODE!.. %s references removed and %s Datasets DELETED" %(iReferencesRemoved, iFilesOnDiskRemoved)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            iReferencesRemoved+=1
            filesToRemove.remove(selectedFile)

            externalFilesVector.remove(selectedFile)
            prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilesVector)
            MD_REF.savePreferences()
            txt = "I have removed the reference to file %s from config.dict (and file/open menu if present)" %(selectedFile)
            myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_,txt,"ADVANCED",JOptionPane.WARNING_MESSAGE)

            if not os.path.exists(selectedFile): continue

            if not myPopupAskQuestion(toolbox_frame_,
                                  "ADVANCED",
                                  "Would you like me to DELETE the %s dataset from disk too?" %(selectedFile),
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
                continue

            try:

                shutil.rmtree(selectedFile)
                iFilesOnDiskRemoved+=1

                myPrint("B","ADVANCED - Dataset %s removed from disk" %(selectedFile))
                play_the_money_sound()
                txt = "ADVANCED - Dataset %s removed from disk" %(selectedFile)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_, txt, "ADVANCED", theMessageType=JOptionPane.ERROR_MESSAGE)
            except:
                dump_sys_error_to_md_console_and_errorlog()
                txt = "@ERROR@ ADVANCED - Dataset %s FAILED TO remove from disk" %(selectedFile)
                myPrint("B",txt)
                myPopupInformationBox(toolbox_frame_, txt, "ADVANCED", theMessageType=JOptionPane.WARNING_MESSAGE)

            continue

        del filesToRemove

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    class MyMoneydanceEventListener(AppEventListener):

        def __init__(self, theFrame):
            self.alreadyClosed = False
            self.theFrame = theFrame
            self.myModuleID = myModuleID

        def getMyself(self):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
            fm = MD_REF.getModuleForID(self.myModuleID)
            if fm is None: return None, None
            try:
                pyObject = getFieldByReflection(fm, "extensionObject")
            except:
                myPrint("DB","Error retrieving my own Python extension object..?")
                dump_sys_error_to_md_console_and_errorlog()
                return None, None

            return fm, pyObject

        def handleEvent(self, appEvent):
            myPrint("DB", "In ", inspect.currentframe().f_code.co_name, "()")
            myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))
            myPrint("DB", "I am .handleEvent() within %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
            myPrint("DB","Extension .handleEvent() received command: %s" %(appEvent))

            if self.alreadyClosed:
                myPrint("DB","....I'm actually still here (MD EVENT %s CALLED).. - Ignoring and returning back to MD...." %(appEvent))
                return

            # MD doesn't call .unload() or .cleanup(), so if uninstalled I need to close myself
            fm, pyObject = self.getMyself()
            myPrint("DB", "Checking myself: %s : %s" %(fm, pyObject))
            # if (fm is None or pyObject is None) and appEvent != "md:app:exiting":
            if (fm is None or (self.theFrame.isRunTimeExtension and pyObject is None)) and appEvent != "md:app:exiting":
                myPrint("B", "@@ ALERT - I've detected that I'm no longer installed as an extension - I will deactivate.. (switching event code to :close)")
                appEvent = "%s:customevent:close" %self.myModuleID

            # I am only closing Toolbox when a new Dataset is opened.. I was calling it on MD Close/Exit, but it seemed to cause an Exception...
            if (appEvent == "md:file:closing"
                    or appEvent == "md:file:closed"
                    or appEvent == "md:file:opening"
                    or appEvent == "md:app:exiting"):
                myPrint("DB","@@ Ignoring MD handleEvent: %s" %(appEvent))

            elif (appEvent == "md:file:opened"
                  or (appEvent == "md:licenseupdated" and MD_REF.isRegistered())
                  or appEvent == "%s:customevent:close" %(self.myModuleID)):
                if debug:
                    myPrint("DB","MD event %s triggered.... Will call GenericWindowClosingRunnable (via the Swing EDT) to push a WINDOW_CLOSING Event to %s to close itself (while I exit back to MD quickly) ...." %(appEvent, self.myModuleID))
                else:
                    myPrint("B","Moneydance triggered event %s triggered - So I am closing %s now...." %(appEvent, self.myModuleID))
                self.alreadyClosed = True
                try:
                    SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.theFrame))
                    myPrint("DB","Back from calling GenericWindowClosingRunnable to push a WINDOW_CLOSING Event (via the Swing EDT) to %s.... ;-> ** I'm getting out quick! **" %(self.myModuleID))
                except:
                    dump_sys_error_to_md_console_and_errorlog()
                    myPrint("B","@@ ERROR calling GenericWindowClosingRunnable to push  a WINDOW_CLOSING Event (via the Swing EDT) to %s.... :-< ** I'm getting out quick! **" %(self.myModuleID))
                if not debug: myPrint("DB","Returning back to Moneydance after calling for %s to close...." %self.myModuleID)

            # md:file:closing	The Moneydance file is being closed
            # md:file:closed	The Moneydance file has closed
            # md:file:opening	The Moneydance file is being opened
            # md:file:opened	The Moneydance file has opened
            # md:file:presave	The Moneydance file is about to be saved
            # md:file:postsave	The Moneydance file has been saved
            # md:app:exiting	Moneydance is shutting down
            # md:account:select	An account has been selected by the user
            # md:account:root	The root account has been selected
            # md:graphreport	An embedded graph or report has been selected
            # md:viewbudget	One of the budgets has been selected
            # md:viewreminders	One of the reminders has been selected
            # md:licenseupdated	The user has updated the license

    def getUpdatedAuthenticationKeys():

        _storage = SyncRecord()
        _authenticationCache = SyncRecord()

        try:
            LS = MD_REF.getCurrentAccount().getBook().getLocalStorage()
            LS.save()

            localFile = File(os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"safe","settings"))
            if localFile.exists() and localFile.canRead():
                inx = LS.openFileForReading("settings")
                _storage.readSet(inx)
                _authenticationCache = _storage.getSubset("_authentication")
                inx.close()
        except:
            myPrint("B","@@@ ERROR Reading authentication cache from settings @@@")
            dump_sys_error_to_md_console_and_errorlog()

        del _storage
        return _authenticationCache

    def find_nth(haystack, needle, n):
        start = haystack.find(needle)
        while start >= 0 and n > 1:
            start = haystack.find(needle, start+len(needle))
            n -= 1
        return start

    class CuriousViewInternalSettingsButtonAction(AbstractAction):

        def __init__(self, lOFX=False, EDIT_MODE=False):
            self.lOFX = lOFX
            self.EDIT_MODE = EDIT_MODE

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            if MD_REF.getCurrentAccount().getBook() is None: return

            output = ""

            _SEARCH   = 0
            _ROOTKEYS = 1
            _BOOKKEYS = 2
            _PREFKEYS = 3
            _ACCTKEYS = 4
            _OBJKEYS  = 5
            _SYNCKEYS = 6
            _BANKKEYS = 7
            _SIZEKEYS = 8
            _OSPROPS  = 9
            _OSENV    = 10

            what = [
                "Search for a key/data (in most places  - but not txns)",
                "Show ROOT Account's Parameter Keys and data",
                "Show Dataset's Local Storage Keys and data (from ./safe/settings)",
                "Show All User Preferences loaded into Memory (from config.dict)",
                "Show Accounts' Parameter's Keys and Data",
                "Show an Obj's settings/data (Acct, Cat, Curr, Security, Reports, Reminders, Addrs, OFX, by UUID, TXNs)",
                "Show All Sync Settings",
                "Show All Online Banking (Searches for OFX) Settings",
                "Show all Settings relating to Window Locations/Sizes/Widths/Sort Order/Filters/Initial Reg View etc..",
                "Show all Java JVM System Properties",
                "Show all Operating System Environment Variables"]

            # You need to edit the below in the sub function and edit function too!!! (sorry ;-> )
            _OBJROOT        =  0
            _OBJACCT        =  1
            _OBJCAT         =  2
            _OBJACCTSEC     =  3
            _OBJCURR        =  4
            _OBJSEC         =  5
            _OBJREMINDERS   =  6
            _REPORT_MEM     =  7
            _GRAPH_MEM      =  8
            _REPORT_DEF     =  9
            _GRAPH_DEF      =  10
            _OBJADDRESSES   =  11
            _OBJOFXONLINE   =  12
            _OBJBYUUID      =  13
            _OBJTRANSACTION =  14
            _OBJSECSUBTYPES =  15
            _OBJMDPLUSLIC   =  16
            _OBJOFXMAPPINGS =  17
            _OBJOFXOLPAYEES =  18
            _OBJOFXOLPAYMNT =  19
            _OBJOFXTXNS     =  20

            objWhat = [                 # Note - I haven't included csnaps/csplit - they don't actually return the map / keys.....
                "ROOT (the master/parent/top-level Account)",
                "Account",
                "Category",
                "Security sub-account",
                "Currency",
                "Security (from Currency Table)",
                "Reminders",
                "Report (Memorized)",
                "Graph (Memorized)",
                "Report (Default)",
                "Graph (Default)",
                "Address Book Entry",
                "Online OFX Services (Bank Logon Profiles)",
                "Object by UUID",
                "Object Transactions (by date)",                    # TransactionSet(ParentTxn) "txn"
                "Security Sub Types",                               # moneydanceSyncableItem    ID:"secsubtypes"
                "Moneydance+ Settings/Profile (MD2022 onwards)",    # moneydanceSyncableItem    ID:"tik.mdplus-license"
                "OFX Account Mappings (MD2022 onwards)"             # moneydanceSyncableItem    ID:"online_acct_mapping"
            ]

            if not self.lOFX:                                   # ... and not self.EDIT_MODE:
                objWhat += [
                    "OFX Online Payees",                         # onlinePayeeList           "olpayees"
                    "OFX Online Payments",                       # onlinePaymentList         "olpmts"
                    "OFX Online Transactions"                    # onlineTxnList             "oltxns"
                ]

            if self.lOFX:
                selectedWhat = what[_BANKKEYS]
            elif self.EDIT_MODE:
                selectedWhat = what[_OBJKEYS]
            else:
                selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the type of Key data you want to view",
                                                           "CURIOUS? VIEW: INTERNAL SETTINGS",
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(lAlwaysGetIcon=True),
                                                           what,
                                                           None)
                if not selectedWhat:
                    txt = "CURIOUS? VIEW: INTERNAL SETTINGS: No data type was selected to view.."
                    setDisplayStatus(txt, "B")
                    return

            myPrint("J", "CURIOUS? VIEW: INTERNAL SETTINGS. User has requested to view: %s"%selectedWhat)

            lObject = False
            selectedObject = None                                                                                       # noqa
            lReportDefaultsSelected = False

            root = MD_REF.getCurrentAccountBook().getRootAccount()

            searchWhat = ""
            lSearch = lKeys = lKeyData = False
            if selectedWhat == what[_SEARCH]:
                lSearch = True

                selectedSearch = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "SEARCH: Keys or Key Data?",
                                                             "CURIOUS? VIEW: INTERNAL SETTINGS",
                                                             JOptionPane.INFORMATION_MESSAGE,
                                                             getMDIcon(lAlwaysGetIcon=True),
                                                             ["Keys","Key Data"],
                                                             None)
                if not selectedSearch:
                    txt = "CURIOUS? VIEW: INTERNAL SETTINGS: No Search type selected"
                    setDisplayStatus(txt, "B")
                    return

                if selectedSearch == "Keys": lKeys = True
                elif selectedSearch == "Key Data": lKeyData = True
                else:
                    raise(Exception("CURIOUS? VIEW: INTERNAL SETTINGS: ERROR: Unknown Search Key type selected!?"))

                searchWhat = myPopupAskForInput(toolbox_frame_, "CURIOUS? VIEW: INTERNAL SETTINGS: SEARCH", "%s:" % selectedSearch, "Enter the (partial) string to search for within %s..." % selectedSearch, "", False)
                if not searchWhat or searchWhat == "":
                    txt = "CURIOUS? VIEW: INTERNAL SETTINGS: No Search data selected"
                    setDisplayStatus(txt, "B")
                    return
                searchWhat=searchWhat.strip()

            if selectedWhat == what[_OBJKEYS]:
                lObject = True

                titleText="CURIOUS? VIEW: INTERNAL SETTINGS"
                moreText="VIEW"
                lFindInAdvancedMode=False
                if self.EDIT_MODE:
                    titleText="ADVANCED"
                    lFindInAdvancedMode=True
                    moreText="CHANGE"

                selectedObjType = JOptionPane.showInputDialog(toolbox_frame_,
                                                              "Select the type of Object you want to %s" %(moreText),
                                                              "%s" %(titleText),
                                                              JOptionPane.INFORMATION_MESSAGE,
                                                              getMDIcon(lAlwaysGetIcon=True),
                                                              objWhat,
                                                              None)
                if not selectedObjType:
                    txt = "%s: No Object type was selected.."%(titleText)
                    setDisplayStatus(txt, "B")
                    return

                baseCurr = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

                objects, lReportDefaultsSelected = get_the_objects_for_curious_view_and_advanced_edit(objWhat, selectedObjType, "%s" % (titleText), lFindInAdvancedMode)
                if self.EDIT_MODE:
                    return objects
                else:
                    if objects is None:
                        return

            lSync = lOFX = lSizes = False
            if selectedWhat == what[_SYNCKEYS]: lSync = True
            if selectedWhat == what[_BANKKEYS]: lOFX = True
            if selectedWhat == what[_SIZEKEYS]: lSizes = True

            GlobalVars.redact = False
            if not self.EDIT_MODE and (lSync or lOFX or lSearch
                                       or selectedWhat == what[_ROOTKEYS]
                                       or selectedWhat == what[_BOOKKEYS]
                                       or selectedWhat == what[_ACCTKEYS]):
                GlobalVars.redact = myPopupAskQuestion(toolbox_frame_, "Display data", "Redact confidential information?")

                if GlobalVars.redact:
                    output += "** Confidential data will be redacted **\n"
                else:
                    output += "** WARNING: Confidential data will be visible **\n"

            try:
                if lObject:  # selected object

                    output += "\n ====== SELECTED OBJECT's RAW PARAMETER KEYS ======\n"

                    for selectedObject in objects:                                                                      # noqa
                        # noinspection PyUnresolvedReferences
                        keys=sorted(selectedObject.getParameterKeys())
                        output += "\nObject Type: %s\n" %type(selectedObject)

                        if isinstance(selectedObject, Account):
                            # noinspection PyUnresolvedReferences
                            if selectedObject.getAccountType() == Account.AccountType.ROOT:
                                output += "\n@@OBJECT IS ACCOUNT AND IT IS ROOT\n"
                            else:
                                output += "\nAccount  Type: %s\n" %selectedObject.getAccountType()

                        if isinstance(selectedObject, (ParentTxn,SplitTxn)):
                            output += "Account: %s\n" %selectedObject.getAccount()

                        for theKey in keys:
                            # noinspection PyUnresolvedReferences
                            value = selectedObject.getParameter(theKey)
                            output += pad("Key:%s" %theKey,50)+" Value: '%s'\n" %(value.strip())

                        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                            if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

                        if isinstance(selectedObject, OnlineTxnList):
                            output += "\nMD User Representation of Data Held by this Account/OnlineTxnList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getTxnCount():",50),                        selectedObject.getTxnCount()  )
                            output += "%s %s\n" % (pad("hasOnlineAvailBalance():",50),              selectedObject.hasOnlineAvailBalance()  )
                            output += "%s %s\n" % (pad("getOnlineAvailBalance():",50),              selectedObject.getOnlineAvailBalance()  )
                            output += "%s %s (%s)\n" % (pad("getOnlineAvailBalanceDate():",50),     selectedObject.getOnlineAvailBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineAvailBalanceDate()))  )
                            output += "%s %s\n" % (pad("hasOnlineLedgerBalance():",50),             selectedObject.hasOnlineLedgerBalance()  )
                            output += "%s %s\n" % (pad("getOnlineLedgerBalance():",50),             selectedObject.getOnlineLedgerBalance()  )
                            output += "%s %s (%s)\n" % (pad("getOnlineLedgerBalanceDate():",50),    selectedObject.getOnlineLedgerBalanceDate(), convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOnlineLedgerBalanceDate()))  )

                            if isMulti_OFXLastTxnUpdate_build():
                                output += "%s %s (%s)\n" % (pad("getMostRecentTxnUpdate():",50),
                                                            selectedObject.getMostRecentTxnUpdate(),
                                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getMostRecentTxnUpdate())))
                                for k in selectedObject.getParameterKeys():
                                    if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                                        value = selectedObject.getLongParameter(k, 0)
                                        output += "... Key: %s %s (%s)\n" %(pad(k,75), value, convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(value)))
                            else:
                                output += "%s %s (%s)\n" % (pad("getOFXLastTxnUpdate():",50),
                                                            selectedObject.getOFXLastTxnUpdate(),
                                                            convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(selectedObject.getOFXLastTxnUpdate())))

                        if isinstance(selectedObject, OnlinePayeeList):
                            output += "\nMD User Representation of Data Held by this Account/OnlinePayeeList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getPayeeCount():",50),             selectedObject.getPayeeCount()  )

                        if isinstance(selectedObject, OnlinePaymentList):
                            output += "\nMD User Representation of Data Held by this Account/OnlinePaymentList record:\n"
                            output += " ==========================================================================  \n"
                            output += "%s %s\n" % (pad("getPaymentCount():",50),           selectedObject.getPaymentCount()  )

                        if isinstance(selectedObject, Account):
                            try:
                                theCurr = selectedObject.getCurrencyType()
                                output += "\nMD User Representation of Data Held by this Account/Category\n"
                                output += " =============================================================\n"
                                output += "%s %s\n" % (pad("Object's Sync Type:",50),                selectedObject.getSyncItemType()  )
                                output += "%s %s\n" % (pad("Account Name:",50),                      selectedObject.getAccountName()   )
                                if selectedObject.getParentAccount() is not None:
                                    output += "%s %s\n" % (pad("Parent Account Name:",50),           selectedObject.getParentAccount().getAccountName() )
                                output += "%s %s\n" % (pad("Full Account Name:",50),                 selectedObject.getFullAccountName()                )
                                output += "%s %s\n" % (pad("Account Type:",50),                      selectedObject.getAccountType()                    )
                                output += "%s %s\n" % (pad("Account Description:",50),               selectedObject.getAccountDescription()             )
                                output += "%s %s\n" % (pad("Account Start Date:",50),                convertStrippedIntDateFormattedText(selectedObject.getCreationDateInt()))
                                output += "%s %s\n" % (pad("Comment:",50),                           selectedObject.getComment()                        )
                                output += "%s %s\n" % (pad("Account Number (Legacy):",50),           selectedObject.getAccountNum()                     )
                                output += "%s %s\n" % (pad("Account Is Inactive:",50),               selectedObject.getAccountIsInactive()              )
                                output += "%s %s\n" % (pad("Account Or Parent Is Inactive:",50),     selectedObject.getAccountOrParentIsInactive()      )
                                output += "%s %s\n" % (pad("Hidden from Home Screen:",50),           selectedObject.getHideOnHomePage()                 )
                                output += "%s %s\n" % (pad("This Accounts Depth (from top):",50),    selectedObject.getDepth()                          )
                                output += "%s %s\n" % (pad("Parent Accounts back to Root:",50),      selectedObject.getAllAccountNames()                )
                                output += "%s %s\n" % (pad("This Acct's sub accounts:",50),          selectedObject.getSubAccounts()                    )
                                output += "%s %s\n" % (pad("Account Currency:",50),                  selectedObject.getCurrencyType()                   )
                                output += "%s %s\n" % (pad("Count of Sub Accounts:",50),             selectedObject.getSubAccountCount()                )
                                output += "%s %s\n" % (pad("Account Number:",50),                    selectedObject.getBankAccountNumber()              )
                                output += "%s %s\n" % (pad("Bank Name:",50),                         selectedObject.getBankName()                       )
                                output += "%s %s\n" % (pad("Default Category:",50),                  selectedObject.getDefaultCategory()                )
                                if selectedObject.getDefaultTransferAccount():
                                    output += "%s %s\n" % (pad("Default Transfer Acct:",50),         selectedObject.getDefaultTransferAccount()         )
                                output += "%s %s\n" % (pad("Tax related:",50),                       selectedObject.isTaxRelated()                      )
                                if selectedObject.isDeductible():
                                    output += "%s %s\n" % (pad("is Deductible:",50),                 selectedObject.isDeductible()                      )
                                if selectedObject.getTaxCategory():
                                    output += "%s %s\n" % (pad("Tax Category:",50),                 selectedObject.getTaxCategory()                     )

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD:
                                    output += "%s %s\n" % (pad("Card Number:",50),                  selectedObject.getCardNumber()                 )
                                    output += "%s %s\n" % (pad("Card Expiration Month:",50),        selectedObject.getCardExpirationMonth()        )
                                    output += "%s %s\n" % (pad("Card Expiation Year:",50),          selectedObject.getCardExpirationYear()         )
                                    output += "%s %s\n" % (pad("Credit Limit:",50),                 selectedObject.getCreditLimit()                )
                                    output += "%s %s\n" % (pad("APR %:",50),                        selectedObject.getAPRPercent()                 )

                                output += "%s %s\n" % (pad("Transactions within this Account:",50),  selectedObject.getTxnCount()                  )
                                output += "%s %s\n" % (pad("Unconfirmed Transactions:",50),          selectedObject.getUnconfirmedTxnCount()       )

                                if selectedObject.getReminder():
                                    output += "%s %s\n" % (pad("Reminder:",50),                      selectedObject.getReminder()                  )

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.BANK \
                                        or selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD \
                                        or selectedObject.getAccountType() == Account.AccountType.INVESTMENT:
                                    if selectedObject.isOnlineEnabled():
                                        output += "%s %s\n" % (pad("Online Enabled:",50),                selectedObject.isOnlineEnabled()                 )
                                    if selectedObject.isOnlineBankingCandidate():
                                        output += "%s %s\n" % (pad("Online Banking Candidate:",50),      selectedObject.isOnlineBankingCandidate()        )
                                    if selectedObject.isOnlineBillpayCandidate():
                                        output += "%s %s\n" % (pad("Online Bill Pay Candidate:",50),     selectedObject.isOnlineBillpayCandidate()        )
                                    if selectedObject.getBankingFI():
                                        output += "%s %s\n" % (pad("OFX Banking Service:",50),           selectedObject.getBankingFI()                    )
                                    if selectedObject.getBillPayFI():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Service:",50),          selectedObject.getBillPayFI()                    )
                                    if selectedObject.getOFXAccountType():
                                        output += "%s %s\n" % (pad("OFX Account Type:",50),              selectedObject.getOFXAccountType()               )
                                    if selectedObject.getOFXAccountNumber():
                                        output += "%s %s\n" % (pad("OFX Account Number:",50),            selectedObject.getOFXAccountNumber()             )
                                    if selectedObject.getOFXBankID():
                                        output += "%s %s\n" % (pad("OFX Bank ID:",50),                   selectedObject.getOFXBankID()                    )
                                    if selectedObject.getOFXBranchID():
                                        output += "%s %s\n" % (pad("OFX Branch ID:",50),                 selectedObject.getOFXBranchID()                  )
                                    if selectedObject.getOFXBrokerID():
                                        output += "%s %s\n" % (pad("OFX Broker ID:",50),                 selectedObject.getOFXBrokerID()                  )
                                    if selectedObject.getOFXAccountKey():
                                        output += "%s %s\n" % (pad("OFX Account Key:",50),               selectedObject.getOFXAccountKey()                )
                                    if selectedObject.getOFXAccountMsgType():
                                        output += "%s %s\n" % (pad("OFX Acct Message Type:",50),         selectedObject.getOFXAccountMsgType()            )
                                    if selectedObject.getOFXBillPayAccountNumber():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Acct Number:",50),      selectedObject.getOFXBillPayAccountNumber()      )
                                    if selectedObject.getOFXBillPayAccountType():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Acct Type:",50),        selectedObject.getOFXBillPayAccountType()        )
                                    if selectedObject.getOFXBillPayBankID():
                                        output += "%s %s\n" % (pad("OFX Bill Pay Bank ID:",50),          selectedObject.getOFXBillPayBankID()             )

                                output += "%s %s\n" % ( pad("Start Balance:",50),                        theCurr.getDoubleValue(selectedObject.getStartBalance()))
                                output += "%s %s\n" % ( pad("Balance:",50),                              theCurr.getDoubleValue(selectedObject.getBalance()))
                                output += "%s %s\n" % ( pad("Cleared Balance:",50),                      theCurr.getDoubleValue(selectedObject.getClearedBalance()))
                                output += "%s %s\n" % ( pad("Current Balance:",50),                      theCurr.getDoubleValue(selectedObject.getCurrentBalance()))
                                output += "%s %s\n" % ( pad("Confirmed Balance:",50),                    theCurr.getDoubleValue(selectedObject.getConfirmedBalance()))
                                output += "%s %s\n" % ( pad("Reconciling Balance:",50),                  theCurr.getDoubleValue(selectedObject.getReconcilingBalance()))

                                output += "%s %s\n" % ( pad("User Start Balance:",50),                   theCurr.getDoubleValue(selectedObject.getUserStartBalance()))
                                output += "%s %s\n" % ( pad("User Balance:",50),                         theCurr.getDoubleValue(selectedObject.getUserBalance()))
                                output += "%s %s\n" % ( pad("User Cleared Balance:",50),                 theCurr.getDoubleValue(selectedObject.getUserClearedBalance()))
                                output += "%s %s\n" % ( pad("User Confirmed Balance:",50),               theCurr.getDoubleValue(selectedObject.getUserConfirmedBalance()))
                                output += "%s %s\n" % ( pad("User Current Balance:",50),                 theCurr.getDoubleValue(selectedObject.getUserCurrentBalance()))
                                output += "%s %s\n" % ( pad("User Reconciling Balance:",50),             theCurr.getDoubleValue(selectedObject.getUserReconcilingBalance()))

                                output += "%s %s\n" % ( pad("Recursive Start Balance:",50),              theCurr.getDoubleValue(selectedObject.getRecursiveStartBalance()))
                                output += "%s %s\n" % ( pad("Recursive Balance:",50),                    theCurr.getDoubleValue(selectedObject.getRecursiveBalance()))
                                output += "%s %s\n" % ( pad("Recursive Cleared Balance:",50),            theCurr.getDoubleValue(selectedObject.getRecursiveClearedBalance()))
                                output += "%s %s\n" % ( pad("Recursive Current Balance:",50),            theCurr.getDoubleValue(selectedObject.getRecursiveCurrentBalance()))
                                output += "%s %s\n" % ( pad("Recursive Reconciling Balance:",50),        theCurr.getDoubleValue(selectedObject.getRecursiveReconcilingBalance()))

                                output += "%s %s\n" % ( pad("User Recursive Start Balance:",50),         theCurr.getDoubleValue(selectedObject.getRecursiveUserStartBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Balance:",50),               theCurr.getDoubleValue(selectedObject.getRecursiveUserBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Cleared Balance:",50),       theCurr.getDoubleValue(selectedObject.getRecursiveUserClearedBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Current Balance:",50),       theCurr.getDoubleValue(selectedObject.getRecursiveUserCurrentBalance()))
                                output += "%s %s\n" % ( pad("User Recursive Reconciling Balance:",50),   theCurr.getDoubleValue(selectedObject.getRecursiveUserReconcilingBalance()))

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.CREDIT_CARD \
                                        or selectedObject.getAccountType() == Account.AccountType.LOAN:

                                    if selectedObject.getInstitutionName():
                                        output += "%s %s\n" % (pad("Institution Name:",50),               selectedObject.getInstitutionName())
                                    if selectedObject.getInitialPrincipal():
                                        output += "%s %s\n" % (pad("Initial Principle:",50),             selectedObject.getInitialPrincipal())
                                    if selectedObject.getPermanentAPR():
                                        output += "%s %s\n" % (pad("Permanent APR:",50),                  selectedObject.getPermanentAPR())
                                    if selectedObject.getPoints():
                                        output += "%s %s\n" % (pad("%loan added as fee to Principle.:",50),selectedObject.getPoints())
                                    if selectedObject.getPaymentsPerYear():
                                        output += "%s %s\n" % (pad("Payments per year:",50),              selectedObject.getPaymentsPerYear())
                                    if selectedObject.getInterestAccount():
                                        output += "%s %s\n" % (pad("Interest Account:",50),               selectedObject.getInterestAccount())
                                    if selectedObject.getEscrowAccount():
                                        output += "%s %s\n" % (pad("Escrow Account:",50),                selectedObject.getEscrowAccount())
                                    if selectedObject.getEscrowPayment():
                                        output += "%s %s\n" % (pad("Escrow Payment:",50),                selectedObject.getEscrowPayment())
                                    if selectedObject.getInterestRate():
                                        output += "%s %s\n" % (pad("Interest Rate:",50),                 selectedObject.getInterestRate())
                                    if selectedObject.getFixedMonthlyPaymentAmount():
                                        output += "%s %s\n" % (pad("Fixed Payment Amt:",50),             selectedObject.getFixedMonthlyPaymentAmount())
                                    if selectedObject.getRateChangeDate():
                                        output += "%s %s\n" % (pad("Date Rate  Changed:",50),            selectedObject.getRateChangeDate())
                                    if selectedObject.getDebtPaymentAmount():
                                        output += "%s %s\n" % (pad("Val Pmts made to this CC:",50),      selectedObject.getDebtPaymentAmount())
                                    if selectedObject.getDebtPaymentProportion():
                                        output += "%s %s\n" % (pad("%value Pmts made to this cc:",50),   selectedObject.getDebtPaymentProportion())
                                    if selectedObject.getDebtPaymentSpec():
                                        output += "%s %s\n" % (pad("Pmt  Plan Used:",50),                selectedObject.getDebtPaymentSpec())

                                    if selectedObject.getPaymentSchedule():
                                        output += "%s %s\n" % (pad("Payment Schedule:",50),               selectedObject.getPaymentSchedule())
                                    if selectedObject.hasExpiringRate():
                                        output += "%s %s\n" % (pad("Has Expiring Rate:",50),              selectedObject.hasExpiringRate())
                                    if selectedObject.getCalcPmt():
                                        output += "%s %s\n" % (pad("Calc Payment:",50),                   selectedObject.getCalcPmt())

                                if selectedObject.getInvestAccountNumber():
                                    output += "%s %s\n" % (pad("Investment Account Number:",50),          selectedObject.getInvestAccountNumber())

                                # noinspection PyUnresolvedReferences
                                if selectedObject.getAccountType() == Account.AccountType.SECURITY:
                                    if selectedObject.getBroker():
                                        output += "%s %s\n" % (pad("Broker:",50),                           selectedObject.getBroker())
                                    if selectedObject.getBrokerPhone():
                                        output += "%s %s\n" % (pad("Broker Phone:",50),                     selectedObject.getBrokerPhone())
                                    if selectedObject.getInvstCommissionAcct():
                                        output += "%s %s\n" % (pad("Investment Commission Account",50),     selectedObject.getInvstCommissionAcct())
                                    if selectedObject.getAnnualFee():
                                        output += "%s %s\n" % (pad("Annual Fee:",50),                       selectedObject.getAnnualFee())
                                    if selectedObject.getDividend():
                                        output += "%s %s\n" % (pad("Dividend:",50),                         selectedObject.getDividend())
                                    if selectedObject.getUsesAverageCost():
                                        output += "%s %s\n" % (pad("Uses Average Cost:",50),                selectedObject.getUsesAverageCost())
                                    if selectedObject.getSecurityType():
                                        output += "%s %s\n" % (pad("Security Type:",50),                    selectedObject.getSecurityType())
                                    if selectedObject.getSecuritySubType():
                                        output += "%s %s\n" % (pad("`Security Sub Type`:",50),              selectedObject.getSecuritySubType())
                                    if selectedObject.getBondType():
                                        output += "%s %s\n" % (pad("Bond Type:",50),                        selectedObject.getBondType())
                                    if selectedObject.getMaturity():
                                        output += "%s %s\n" % (pad("Maturity:",50),                         selectedObject.getMaturity())
                                    if selectedObject.getNumYears():
                                        output += "%s %s\n" % (pad("Maturity Year (6=six Mnths):",50),      selectedObject.getNumYears())
                                    if selectedObject.getCompounding():
                                        output += "%s %s\n" % (pad("CD Compounding:",50),                   selectedObject.getCompounding())
                                    if selectedObject.getOptionPrice():
                                        output += "%s %s\n" % (pad("Option Price:",50),                     selectedObject.getOptionPrice())
                                    if selectedObject.getMonth():
                                        output += "%s %s\n" % (pad("Option Exercise Month (0-11 3rd Fri):",50),selectedObject.getMonth())
                                    if selectedObject.getStrikePrice():
                                        output += "%s %s\n" % (pad("Option Strike Price:",50),               selectedObject.getStrikePrice())
                                    if selectedObject.getPut():
                                        output += "%s %s\n" % (pad("Option Put(T), Call(F):",50),           selectedObject.getPut())
                                    if selectedObject.getEscrow():
                                        output += "%s %s\n" % (pad("Escrow?:",50),                          selectedObject.getEscrow())
                                    if selectedObject.getExchange():
                                        output += "%s %s\n" % (pad("Trading Platform:",50),                 selectedObject.getExchange())
                                    if selectedObject.getFaceValue():
                                        output += "%s %s\n" % (pad("Bond face value:",50),                  selectedObject.getFaceValue())

                            except:
                                output += dump_sys_error_to_md_console_and_errorlog( True )

                        elif isinstance(selectedObject, CurrencyType):
                            try:
                                output += "\nMD User Representation of Data Held by this Currency/Security\n"
                                output += " =============================================================-\n"
                                if selectedObject == baseCurr:                                                              # noqa
                                    output += "THIS IS THE BASE RATE!\n"
                                output += "%s %s\n" % (pad("Sync Item Type:",50),       selectedObject.getSyncItemType()  )
                                output += "%s %s\n" % (pad("Currency Type:",50),        selectedObject.getCurrencyType()  )
                                output += "%s %s\n" % (pad("Name:",50),                 selectedObject.getName()  )
                                output += "%s %s\n" % (pad("Hide in UI?:",50),          selectedObject.getHideInUI()  )
                                output += "%s %s\n" % (pad("ID:",50),                   selectedObject.getID()  )
                                output += "%s %s\n" % (pad("ID String:",50),            selectedObject.getIDString()  )
                                output += "%s %s\n" % (pad("Ticker Symbol:",50),        selectedObject.getTickerSymbol()  )
                                output += "%s %s\n" % (pad("Prefix:",50),               selectedObject.getPrefix()  )
                                output += "%s %s\n" % (pad("Suffix:",50),               selectedObject.getSuffix()  )
                                output += "%s %s\n" % (pad("Decimal Places:",50),       selectedObject.getDecimalPlaces()  )
                                output += "%s %s\n" % (pad("Curr Start Date:",50),      convertStrippedIntDateFormattedText(selectedObject.getEffectiveDateInt())  )

                                for convertTimeStamp in ["price_date"]:
                                    if selectedObject.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(selectedObject.getLongParameter(convertTimeStamp, 0))  )

                                snaps = selectedObject.getSnapshots()

                                output += "%s %s\n" % (pad("RATE (to base):",50),           selectedObject.getRate(None)  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getRate(None))  )
                                output += "%s %s\n" % (pad("RATE in terms of Base:",50),    selectedObject.getBaseRate()  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getBaseRate())  )
                                output += "%s %s\n" % (pad("Relative Currency:",50),        selectedObject.getRelativeCurrency()  )
                                output += "%s %s\n" % (pad("Relative Rate:",50),            selectedObject.getRelativeRate()  )
                                output += "%s %s\n" % (pad("     (Inverted):",50),          safeInvertRate(selectedObject.getRelativeRate())  )
                                output += "%s %s\n" % (pad("Count Price History:",50),      snaps.size() )
                                output += "%s %s\n" % (pad("Count Stock Splits:",50),       len(selectedObject.getSplits()  ))
                                output += "%s %s\n" % (pad("Daily Change:",50),             selectedObject.getDailyChange()  )
                                output += "%s %s\n" % (pad("Daily Volume:",50),             selectedObject.getDailyVolume()  )

                                output += "\n" \
                                          "Oldest and Newest (max) 5 Price History Records (RAW records) (use 1.0/rate to convert values):\n" \
                                          " ----------------------------------------------------------------------------------------------\n"

                                if snaps.size():
                                    # Put all maps back for snapshots listed.....
                                    dummySyncR = SyncRecord()

                                    iCountSnapsPrinted = iSnap = 0
                                    maxToPrint = min(10, snaps.size())

                                    output += "<-- Oldest (max) 5 records -->>\n"
                                    while iCountSnapsPrinted <= maxToPrint:
                                        snaps[iSnap].itemWillSync(dummySyncR)
                                        output += dummySyncR.toMultilineHumanReadableString()+"---\n"
                                        dummySyncR.clear()                                                                  # noqa
                                        iSnap += 1
                                        iCountSnapsPrinted += 1
                                        if iCountSnapsPrinted >= snaps.size() or iSnap >= snaps.size(): break
                                        if iCountSnapsPrinted < 5: continue
                                        if iCountSnapsPrinted == 5:
                                            output += "<-- Newest (max) 5 records -->>\n"
                                            iSnap = max(5, snaps.size() - (maxToPrint-iCountSnapsPrinted))
                                        if iCountSnapsPrinted > 10: break
                                    del dummySyncR
                                del snaps
                                output += "<END>\n"
                            except:
                                output += dump_sys_error_to_md_console_and_errorlog( True )

                        elif isinstance(selectedObject, ReportSpec):

                            if lReportDefaultsSelected:
                                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                                keys=sorted(LS.keys())

                                found_any = False
                                for theKey in keys:
                                    value = LS.get(theKey)
                                    if not theKey.lower().startswith("report_params."+selectedObject.getReportGenerator().getShortID()): continue
                                    if not found_any:
                                        output += "\nDEFAULT REPORT PARAMETERS (SET BY USER):\n"
                                        found_any = True
                                    output += "Key:%s Value: %s\n" % (pad(theKey,70), value.strip())
                        elif isinstance(selectedObject, Reminder):
                            pass
                        elif isinstance(selectedObject, AddressBookEntry):
                            pass
                        elif isinstance(selectedObject, OnlineService):
                            pass

                if selectedWhat == what[_PREFKEYS] or lSync or lOFX or lSizes or lSearch:  # User  Preferences

                    output += "\n ====== USER PREFERENCES LOADED INTO MEMORY (May or may not be quite the same as config.dict) ======\n"

                    # This bit below is really, really cool!!!! But I am not using it as it only gets pre-defined settings from config.dict.
                    # prefs=[]
                    # what_x = MD_REF.getUI().getPreferences()
                    # members = [attr for attr in dir(what_x) if not callable(getattr(what_x, attr)) and not attr.startswith("__")]
                    # for mem in members:
                    #     if not mem.upper() == mem: continue
                    #     try:
                    #         convertKey = getattr(UserPreferences, mem)
                    #     except:
                    #         continue
                    #     if not convertKey or convertKey=="" : continue
                    #     value = MD_REF.getUI().getPreferences().getSetting(getattr(UserPreferences, mem))
                    #     if value: prefs.append([convertKey, mem, value])
                    # prefs =sorted(prefs) # Sort the result (as the input is only a reference to a reference)

                    # As all settings in memory actually come from config.dict (or go back to config.dict) then we look there instead to get the keys
                    st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
                    prefs=sorted(tk)

                    for theKey in prefs:
                        value = st.get(theKey)
                        if lSync and not ("sync" in theKey.lower()): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()): continue
                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            myTestValue = value
                            if not isinstance(myTestValue,(str,unicode)): myTestValue  = repr(myTestValue)  # Force the StreamTable / StreamVector into a string for search comparison
                            # noinspection PyUnresolvedReferences
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in myTestValue.lower()): continue
                        # noinspection PyUnresolvedReferences
                        output += (pad("Key:%s" % (theKey),35)+ " Value: %s\n" %((value)))


                if selectedWhat == what[_ROOTKEYS] or lSync or lOFX or lSizes or lSearch:  # ROOT
                    keys = sorted(root.getParameterKeys())
                    output += '\n ====== ROOT PARAMETER KEYS (Preferences will mostly be in Local Storage) ======\n'
                    authKeyPrefix = "ofx.client_uid"
                    for theKey in keys:
                        value = root.getParameter(theKey)
                        if lSync and ("sync" not in theKey.lower()): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()): continue
                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                        if GlobalVars.redact:
                            if theKey.lower() == "netsync.synckey" or theKey.lower().startswith("netsync.db."): value = "<%s> (hidden)" %(redactor(value))

                        rk_redact = theKey
                        val_redact = value

                        if GlobalVars.redact:
                            if theKey.startswith(authKeyPrefix):
                                findUser = find_nth(theKey, "::", 2)
                                if theKey.startswith("ofx.client_uid_default_user::"):
                                    val_redact = redactor(val_redact)
                                elif findUser > len(authKeyPrefix)+4:
                                    rk_redact = theKey[:findUser+2] + redactor(theKey[findUser+2:])

                        output += pad("Key:%s" %(rk_redact),100)+" Value: %s\n" %(val_redact.strip())

                    if selectedWhat == what[_ROOTKEYS]:
                        output+="\n"
                        for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                            if root.getLongParameter(convertTimeStamp, 0) > 0:
                                output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),100), get_time_stamp_as_nice_text(root.getLongParameter(convertTimeStamp, 0))  )


                if selectedWhat == what[_BOOKKEYS] or lOFX or lSearch:  # Local Storage - authentication cache

                    output += '\n ====== BOOK>LOCAL STORAGE KEYS - CACHED AUTHENTICATION ======\n'

                    lCachePasswords = isCachingPasswords()

                    _auth = getUpdatedAuthenticationKeys()      # type: SyncRecord
                    if len(_auth) > 0:
                        if not lCachePasswords: output += "** NOTE THESE WILL NOT BE SAVED/REMEMBERED WHEN YOU RESTART MD **\n"
                        keys = sorted(_auth.keys())                                                                     # noqa
                        for theKey in keys:
                            value = _auth.get(theKey)                                                                   # noqa
                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue
                            output += pad("Key:%s" %theKey,90)+" Value: %s\n" %(redactAuth(value.strip()))
                    else:
                        if not lCachePasswords:
                            output += "** Your system is not setup to cache passwords... Cannot display this session's cache **\n"
                            output += "** Use Menu Online Banking (OFX) Tools > View installed Bank / Service Profiles to view specific cached items **\n"
                        output += "<NONE>\n"


                if selectedWhat == what[_BOOKKEYS] or lSync or lOFX or lSizes or lSearch:  # Local Storage

                    output += '\n ====== BOOK>LOCAL STORAGE KEYS ======\n'

                    LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                    keys=sorted(LS.keys())

                    last = None
                    for theKey in keys:
                        value = LS.get(theKey)    # NOTE: .get loses the underlying type and thus becomes a string

                        if theKey.startswith("_authentication"): continue

                        if lSync and "sync" not in theKey.lower(): continue
                        if lSync and "netsync.del_item" in theKey.lower(): continue
                        if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()
                                         or "access_tokens" in theKey.lower() or "mdp_items" in theKey.lower()): continue

                        if lSizes and not check_for_window_display_data(theKey,value): continue
                        if lSearch:
                            if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                            elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                        if GlobalVars.redact:
                            if theKey.lower() == "netsync.synckey" or theKey.lower().startswith("netsync.db."): value = "<%s> (hidden)" %(redactor(value))

                        if GlobalVars.redact:
                            if ("._payloadid" in theKey.lower() or ".token" in theKey.lower()): value = "<%s> (hidden)" %(redactor(value))

                        splitKey = theKey.split('.')
                        if splitKey[0] != last:
                            last = splitKey[0]
                            lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])
                            if lookupAcct:
                                output += ("\n>> Account: %s\n" %(lookupAcct.getFullAccountName()))
                            else:
                                output += "\n"

                        output += pad("Key:%s" %theKey,90)+" Value: %s\n" %(value.strip())

                if selectedWhat == what[_ACCTKEYS] or lSync or lOFX or lSizes or lSearch:  # Accounts (excluding Root)

                    output += "\n ====== ACCOUNTS' PARAMETER KEYS  (Preferences will mostly be in Local Storage) ======\n"
                    accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(5))
                    lastAcct = None
                    for acct in accounts:

                        lPrintedAccountHeading = False

                        if lOFX:
                            if acct != lastAcct:
                                lPrintedAccountHeading = True
                                output += "\n>> Account: %s\n" %acct.getFullAccountName()
                                lastAcct = acct

                            output += "\nSpecific OFX Data:\n"
                            if (acct.canDownloadTxns() and not acct.getAccountIsInactive()):
                                output += pad(">> Can Download Txns:",50)+safeStr(acct.canDownloadTxns() and not acct.getAccountIsInactive())+"\n"

                            if acct.getOFXAccountNumber() is not None and acct.getOFXAccountNumber() != "":
                                output += pad(">> OFX Account Number:",50)+redactor(safeStr(acct.getOFXAccountNumber()))+"\n"

                            if isMDPlusEnabledBuild():
                                gbs = acct.getBankingServices()
                                if gbs.size() > 0:
                                    if isMDPlusUniqueBankingServicesEnabledBuild():
                                        for bs in gbs:
                                            output += pad(">> Banking Service found (out of %s):" %(gbs.size()),50)+safeStr(bs.getService())+"\n"
                                    else:
                                        # Sean advised that always take the first item (there are duplicates in the list, but it is sorted)
                                        output += pad(">> Banking Services first candidate:",50)+safeStr(gbs[0].getService())+"\n"

                            if acct.getBankingFI() is not None:
                                output += pad(">> Bank Service/Logon profile (getBankingFI()):",50)+safeStr(acct.getBankingFI())+"\n"
                                if my_get_account_key(acct):
                                    output += pad(">> (Account Key):",50)+safeStr(my_get_account_key(acct))+"\n"

                            if acct.getBillPayFI() is not None:
                                output += pad(">> BillPay Service/Logon profile:",50)+safeStr(acct.getBillPayFI())+"\n"
                                if my_get_account_key(acct):
                                    output += pad(">> (Account Key):",50)+safeStr(my_get_account_key(acct))+"\n"

                            getOnlineData = MyGetDownloadedTxns(acct)

                            if getOnlineData is not None:
                                lFoundExtra_ofx_last_txn_update = False
                                ofx_last_txn_update_keys = []
                                for k in getOnlineData.getParameterKeys():
                                    if k.startswith(GlobalVars.Strings.OFX_LAST_TXN_UPDATE):
                                        ofx_last_txn_update_keys.append(k)
                                        lFoundExtra_ofx_last_txn_update = True

                                if (lFoundExtra_ofx_last_txn_update
                                        or getOnlineData.getParameter(GlobalVars.Strings.OFX_LAST_TXN_UPDATE, None) is not None
                                        or getOnlineData.getParameter("ol.availbal", None) is not None
                                        or getOnlineData.getParameter("ol.ledgerbal", None) is not None):
                                    output += (">> OnlineTxnList data:\n")
                                    for _k in sorted(getOnlineData.getParameterKeys()):
                                        _v = getOnlineData.getParameter(_k)
                                        for checkKey in ["ol.availbal", "ol.ledgerbal"]:
                                            if checkKey == _k:
                                                _v = redactor(_v.strip())
                                                break
                                        output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())

                                    for convertTimeStamp in ["ts", "ol.ledgerbalasof"]: ofx_last_txn_update_keys.append(convertTimeStamp)

                                    for convertTimeStamp in ofx_last_txn_update_keys:
                                        if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                            output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),90), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0)))

                            getOnlineData = MyGetOnlinePayees(acct)
                            if getOnlineData is not None:
                                output += (">> OnlinePayees data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", GlobalVars.Strings.OFX_LAST_TXN_UPDATE, "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            getOnlineData = MyGetOnlinePayments(acct)
                            if getOnlineData is not None:
                                output += (">> OnlinePayments data:\n")
                                for _k in sorted(getOnlineData.getParameterKeys()):
                                    _v = getOnlineData.getParameter(_k)
                                    output += pad("  >> Key:%s" %(_k),50)+" Value: %s\n" %(_v.strip())
                                for convertTimeStamp in ["ts", GlobalVars.Strings.OFX_LAST_TXN_UPDATE, "ol.ledgerbalasof"]:
                                    if getOnlineData.getLongParameter(convertTimeStamp, 0) > 0:
                                        output += "%s %s\n" % (pad("   >> TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(getOnlineData.getLongParameter(convertTimeStamp, 0))  )

                            output += "\n"

                        keys = sorted(acct.getParameterKeys())
                        for theKey in keys:

                            value = acct.getParameter(theKey)
                            if lSync and not ("sync" in theKey.lower()): continue
                            if lOFX and not ("ofx" in theKey.lower() or "ol." in theKey.lower() or "olb." in theKey.lower()
                                             or "olblink." in theKey.lower()
                                             or "olbfi" in theKey.lower()
                                             or "bpfi" in theKey.lower()): continue
                            if lSizes and not check_for_window_display_data(theKey,value): continue
                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                            if GlobalVars.redact:
                                if theKey.lower() == "netsync.synckey" or theKey.lower().startswith("netsync.db."): value = "<%s> (hidden)" %(redactor(value))

                            if GlobalVars.redact:
                                for checkKey in ["bank_account_number", "ofx_account_number", "ofx_bank_id", "ofx_import_acct_num", "olblink."]:
                                    if checkKey in theKey.lower():
                                        value = "<%s> (hidden >> disable redaction to view)" %(redactor(value))
                                        break

                            if lOFX and value.strip() == "": continue

                            if not lPrintedAccountHeading:
                                if acct != lastAcct:
                                    lPrintedAccountHeading = True
                                    output += "\n>> Account: %s\n" %acct.getFullAccountName()
                                    lastAcct = acct

                            output += pad("Key:%s" %(theKey),50)+" Value: %s\n" %(value.strip())

                        if selectedWhat == what[_ACCTKEYS]:
                            output+="\n"
                            for convertTimeStamp in ["ts", "rec_dt", "dtentered", "creation_date"]:
                                if acct.getLongParameter(convertTimeStamp, 0) > 0:
                                    output += "%s %s\n" % (pad("TIMESTAMP('%s'):" %(convertTimeStamp),50), get_time_stamp_as_nice_text(acct.getLongParameter(convertTimeStamp, 0))  )

                if lOFX or lSearch:
                    output += "\n ========= OFX Online Banking Service's PARAMETER KEYS =========\n"
                    output += "\n (NOTE: More information will be in view bank service / login profiles)\n"

                    lastService = None
                    services = MD_REF.getCurrentAccount().getBook().getOnlineInfo().getAllServices()
                    for service in services:
                        keys = sorted(service.getParameterKeys())
                        for theKey in keys:

                            value = service.getParameter(theKey)

                            if lSearch:
                                if lKeys and not (searchWhat.lower() in theKey.lower()): continue
                                elif lKeyData and not (searchWhat.lower() in value.lower()): continue

                            if service != lastService:
                                output += "\nOFX SERVICE: %s\n" %service
                                output += "--------------------------------------------\n"
                                lastService = service

                            if GlobalVars.redact:
                                for checkKey in ["balance", "account_num", "branch_id", "routing_num", "so_user_id"]:
                                    if checkKey in theKey:
                                        value = redactor(value, ("balance" in theKey))
                                        break

                            output += pad("Key:%s" %(theKey), 50)+ " Value: %s\n" %(value)

                if lOFX:
                    output += "\n ========= Moneydance+ license object's PARAMETER KEYS (MD2022 onwards) =========\n"
                    licenseObject = getMDPlusLicenseInfoForBook()
                    if licenseObject is None:
                        output += "<NO LICENSE OBJECT FOUND>\n"
                    else:
                        output += special_toMultilineHumanReadableString(licenseObject, lSkipSecrets=GlobalVars.redact, lRedact=GlobalVars.redact)
                        del licenseObject

                    output += "\n ========= OFX Account Mappings Object's PARAMETER KEYS (MD2022 onwards) =========\n"
                    mappingObject = MD_REF.getCurrentAccount().getBook().getItemForID("online_acct_mapping")
                    if mappingObject is None:
                        output += "<NO ACCOUNT MAPPING OBJECT FOUND>\n"
                    else:
                        output += special_toMultilineHumanReadableString(mappingObject, lSkipSecrets=GlobalVars.redact, lRedact=GlobalVars.redact)
                        del mappingObject

                if selectedWhat == what[_OSPROPS]:  # System.Properties

                    output += "\n ====== (Java JVM) System.Properties.....======\n"

                    props = sorted(System.getProperties())
                    for prop in props:
                        output += pad("Property:%s" %prop,50)+ " Value: %s\n"%(System.getProperty(prop))

                if selectedWhat == what[_OSENV]:    # Environment variables

                    output += "\n ====== Operating System Environment Variables.....======\n"

                    for k, v in os.environ.items():
                        output += pad("Variable: %s" %k,50)+ " Value: %s\n" %(v)

            except:
                output += dump_sys_error_to_md_console_and_errorlog( True )

            output += "<END>\n"

            jif = QuickJFrame("Curious? View Internal Settings...: %s" % selectedWhat, output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

            if self.lOFX:
                txt = "OFX: Your OFX Bank related settings have been searched and displayed...."
                setDisplayStatus(txt, "B")
                return jif
            else:
                txt = "I hope you enjoyed Curiously Viewing Internal Settings...: %s" %(selectedWhat)
                setDisplayStatus(txt, "DG")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    def prune_internal_backups(lStartup=False):
        myPrint("D","In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("J","Auto-prune is enabled.... auto-pruning internal backups of config.dict and settings now.....")

        try:

            backup_extn = "_$SAVED$"

            backup_localStorage_path = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath())
            backup_config_path = os.path.dirname(Common.getPreferencesFile().getCanonicalPath())
            # backup_custom_theme_path = os.path.dirname(ThemeInfo.customThemeFile.getCanonicalPath())

            settingsFile = "settings"
            # backup_localStorage_filename = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getAbsolutePath(),"settings")
            # configFile = Common.getPreferencesFile().getName()
            # themeFile = ThemeInfo.customThemeFile.getName()

            themeFiles = []
            configFiles = []
            settingsFiles = []

            iCountConfig = iCountSettings = iCountTheme = 0

            for _path in [backup_localStorage_path, backup_config_path]:
                for _file in os.listdir(_path):
                    filepath = os.path.join(_path, _file)
                    if _file.startswith(settingsFile) and _file.endswith(backup_extn):
                        settingsFiles.append(filepath)
                        iCountSettings+=1
                    elif _file.startswith("config-") and _file.endswith(".dict"+backup_extn):
                        configFiles.append(filepath)
                        iCountConfig+=1
                    elif _file.startswith("custom_theme-") and _file.endswith(".properties"+backup_extn):
                        themeFiles.append(filepath)
                        iCountTheme+=1
                    else:
                        pass

            myPrint("DB", "Found %s settings backup files" %(iCountSettings))
            myPrint("DB", "Found %s config.dict backup files" %(iCountConfig))
            myPrint("DB", "Found %s custom themes backup files" %(iCountTheme))

            settingsFiles = sorted(settingsFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)
            configFiles = sorted(configFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)
            themeFiles = sorted(themeFiles, key=lambda _x: (os.path.getmtime(_x)), reverse=True)

            files_to_keep = 5
            days_to_look_back = 5

            lookBack = datetime.datetime.today() - datetime.timedelta(days=(days_to_look_back+1))

            myPrint("DB", "Look-back cutoff date for auto-prune internal backup files set to: %s " %(get_time_stamp_as_nice_text(lookBack)))

            iDeletedConfig = iDeletedThemes = iDeletedSettings = 0

            iErrors=0
            for filelist in [settingsFiles, configFiles, themeFiles]:
                iRecords=0
                for _fp in filelist:
                    iRecords += 1
                    if iRecords <= files_to_keep:
                        myPrint("D", "skipping-keeping %s files: %s %s" %(files_to_keep,datetime.datetime.fromtimestamp(os.path.getmtime(_fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),_fp))
                        continue
                    file_ts = datetime.datetime.fromtimestamp(os.path.getmtime(_fp))
                    if file_ts >= lookBack:
                        myPrint("D","skipping < %s days: %s %s" %(days_to_look_back, file_ts.strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),_fp))
                        continue
                    myPrint("DB", "DELETING: %s %s" %(file_ts.strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),_fp))
                    if "settings" in _fp:
                        iDeletedSettings+=1
                    elif "config-" in _fp:
                        iDeletedConfig+=1
                    elif "custom_theme-" in _fp:
                        iDeletedThemes+=1
                    try:
                        os.remove(_fp)
                    except:
                        iErrors+=1
                        myPrint("B","@ERROR deleting file: %s - skipping and moving on....." %(_fp))
                        dump_sys_error_to_md_console_and_errorlog()
        except:
            txt = "@@ ERROR auto-pruning internal backup files... continuing....."
            setDisplayStatus(txt, "R")
            myPrint("B",txt)
            dump_sys_error_to_md_console_and_errorlog()
            return

        del themeFiles
        del configFiles
        del settingsFiles

        myPrint("J","Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..."
                %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors))

        if not lStartup:
            txt = "Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..." %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors)
            setDisplayStatus(txt, "R")

        if iErrors:
            myPopupInformationBox(toolbox_frame_, "Auto-prune of internal backups completed - deleted %s config.dict, %s settings and %s custom_theme files (with %s errors)..."
                                  %(iDeletedConfig,iDeletedSettings,iDeletedThemes,iErrors),
                                  "AUTO-PRUNE INTERNAL BACKUPS",
                                  JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    class ViewFileButtonAction(AbstractAction):

        class CloseAction(AbstractAction):

            def __init__(self, the_frame):
                self.theFrame = the_frame

            # noinspection PyUnusedLocal
            def actionPerformed(self, event):
                myPrint("DB", "Inner View File Frame shutting down....")
                self.theFrame.dispose()     # Listener will already be on the EDT
                return

        def __init__(self, theFile, displayText):
            self.theFile = theFile
            self.displayText = displayText

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            x = safeStr(self.theFile)

            myPrint("DB", "User requested to view " + self.displayText + " file...")
            if not os.path.exists(x):
                txt = "Sorry - " + self.displayText + " file does not exist or is not available to view!?: " + x
                setDisplayStatus(txt, "R")
                return

            try:
                with open(x, "r") as myFile:
                    displayFile = myFile.readlines()

                # If VMOptions, stick a "'" at the beginning for clipboard to Excel to work OK
                if lCopyAllToClipBoard_TB and x.lower().endswith(".vmoptions"):
                    newDisplayFile=[]
                    for line in displayFile:
                        line ="'"+line
                        newDisplayFile.append(line)
                    displayFile = newDisplayFile
                else:
                    displayFile.append("\n<END>")

                displayFile = ''.join(displayFile)
            except:
                displayFile = "Sorry - error opening file...."
                dump_sys_error_to_md_console_and_errorlog()

            if x.lower().endswith(".vmoptions"):
                vmoptionsPath = get_vmoptions_path()
                displayFile += """
-------------------------------------------------------------------------------------------------------------------------------------------
<INSTRUCTIONS - MEMORY>
======================
You can allow for more memory by editing the '%s' file and set it to increase the amount of memory that
Moneydance is allowed to use. To achieve this you can try the following:

Navigate to the '%s' file, located in the folder where Moneydance is installed:

If you open that file with Notepad or any other text editor, you'll see some instructions for how to change it.
Close Moneydance first!

The basic recommendation is to changing the -Xmx1024m setting to -Xmx2048m which doubles the amount of memory that Moneydance is allowed to use.
You can give it more if you wish, E.g.: you make it -Xmx3072m, for optimal results.

NOTE: The limit is set deliberately low to enable it to work with computers having very small amounts of RAM.

""" %(vmoptionsPath, vmoptionsPath)                                                                                     # noqa

                windowsExtra = """
-----
Windows location: '%s'

In Windows - due to permissions, you will need to do this:
In the 'Type here to Search' box on the Windows 10 Toolbar, type CMD (do not press enter)
When Command Prompt appears, click Run as Administrator
Click yes/agree to allow this app to make changes to this device / grant administrator permissions
notepad "%s" (and press enter)
edit the file and change the -Xmx1024 setting
ctrl-s to save and then exit Notepad
exit
restart Moneydance
-------------------------------------------------------------------------------------------------------------------------------------------
""" %(vmoptionsPath, vmoptionsPath)                                                                                     # noqa

                linuxExtra = """
<INSTRUCTIONS - Linux and High Resolution Screens>
=================================================
When running Linux on a computer with a high resolution display, some distributions will let you adjust the "scaling" of 
the interface to provide clearer graphics at a larger size. If you use scaling on your Linux desktop but the contents of
the Moneydance window appears very small then you may need to adjust Moneydance's scaling.

To change the scaling, open '%s' with a text editor (as per instructions below) add the following two
lines to the bottom of the file:

-Dsun.java2d.uiScale=2
-Dsun.java2d.uiScale.enabled=true

>>PLEASE NOTE: that as of this writing, non-integer scales (for example, 1.2) are not supported.
refer: https://infinitekind.tenderapp.com/kb/linux/linux-and-hidpi-high-resolution-screens

-----
Linux file location: '%s'

In Linux - due to permissions, you will need to do this:
a) Either edit in Terminal using sudo before the command (e.g. sudo vi '%s') , or;

b) You ideally need to be able to open files as root via a right click.
- This assumes you are on a Debian based system
1. Open the Terminal
2. Type sudo su and press enter. Provide your password and press enter
3. Then type apt-get install -y nautilus-admin and press enter
4. Now type nautilus -q and press enter
5. Finally type exit and press enter, and close the terminal window
6. All set. Now when you want to open a file as root, simply right click the FOLDER and select Open as Root (or Administrator).

So, now find the /Opt folder, right click on the Moneydance FOLDER, Open as Root. Enter your password. Now you can edit the '%s' file....
>> Note: You may need to logoff and then login to see the changes!

now after saving the file, restart Moneydance
-------------------------------------------------------------------------------------------------------------------------------------------
""" %(vmoptionsPath, vmoptionsPath, vmoptionsPath, vmoptionsPath)                                                       # noqa

                if Platform.isWindows():
                    displayFile += windowsExtra
                elif Platform.isUnix():
                    displayFile += linuxExtra
                try:
                    helper = MD_REF.getPlatformHelper()
                    helper.openDirectory(self.theFile)
                except:
                    pass
                time.sleep(0.5)

            jif = QuickJFrame("View " + self.displayText + " file: " + x, displayFile, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            jif.toFront()

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def view_shouldBeIncludedInNetWorth_settings():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "View Accounts' shouldBeIncludedInNetWorth() settings"

        PARAM_APPLIES_TO_NW = "applies_to_net_worth"

        output = "\n" \
                 "%s:\n" \
                 " ======================================================\n\n" %(_THIS_METHOD_NAME.upper())

        output += "Moneydance predefines rules to include/exclude Accounts in the Home Summary Page NetWorthView widget, & also the Titlebar NW instant graph\n" \
                  "- If the Account or Parent is Inactive, then it's excluded\n" \
                  "- ROOT and Income/Expense Categories are excluded\n" \
                  "- Then it checks for a hidden Account setting >> You can set this in Toolbox Update Mode\n" \
                  "- You cannot force include an account into these, you can only force exclude accounts....\n" \
                  "\n" \
                  "Other NetWorth rules for information:\n" \
                  "- NW Reports / Graphs are based on transactions up to the date you specify; uses Price history data for balance valuations\n" \
                  "- The Top title bar NW Graph's cutoff date can be changed: 'All Dates' includes future Balances; uses Price history data for balance valuations\n" \
                  "- The Home Screen View NW widget total ALWAYS uses Current Balance(s) - so future balances are excluded; uses Current Price\n" \
                  "\n\n"

        output += "%s %s %s %s\n" %(pad("Account Name",50),
                                    pad("Account Type",20),
                                    pad("shouldBeIncludedInNetWorth()",30),
                                    pad("Override Setting",20))

        output += "%s %s %s %s\n" %("-"*50,
                                    "-"*20,
                                    "-"*30,
                                    "-"*20)

        output += "\n"

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(25))
        allAccounts = sorted(allAccounts, key=lambda x: (x.getAccountType(), x.getFullAccountName().upper()))

        for acct in allAccounts:
            output += "%s %s %s %s\n" %(pad(acct.getFullAccountName(),50),
                                        pad(str(acct.getAccountType()),20),
                                        pad(str(acct.shouldBeIncludedInNetWorth()),30),
                                        ("NOT SET" if (not acct.getParameter(PARAM_APPLIES_TO_NW, None)) else (str(acct.getBooleanParameter(PARAM_APPLIES_TO_NW, True)))))
        output += "\n<END>"

        txt = "%s: - Displaying NetWorth Settings" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "B")
        QuickJFrame(_THIS_METHOD_NAME.upper(), output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
        del allAccounts

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return


    def edit_shouldBeIncludedInNetWorth_settings():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "EDIT an Account's shouldBeIncludedInNetWorth() setting"

        PARAM_APPLIES_TO_NW = "applies_to_net_worth"

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(25))
        allAccounts = sorted(allAccounts, key=lambda x: (x.getAccountType(), x.getFullAccountName().upper()))

        newAccounts = []
        for acct in allAccounts: newAccounts.append(StoreAccountList(acct))
        del allAccounts

        lPresentedBackupDisclaimer = False
        iCountChanges = 0

        while True:

            selectedAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Acct edit the shouldBeIncludedInNetWorth() setting",
                                                       _THIS_METHOD_NAME.upper(),
                                                       JOptionPane.INFORMATION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       newAccounts,
                                                       None)
            if not selectedAcct: break

            selectedAcct = selectedAcct.obj       # type: Account                                                       # noqa

            currentNWsettingBool = selectedAcct.getBooleanParameter(PARAM_APPLIES_TO_NW, True)

            options = ["YES - Include", "NO - Exclude"]
            if currentNWsettingBool:
                current = options[0]
            else:
                current = options[1]

            selectedIncludeInNW = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select whether to include/exclude this account in the default NW Home Screen Widget & Titlebar Graph",
                                                       _THIS_METHOD_NAME.upper()+" for: %s" %(selectedAcct.getAccountName()),
                                                       JOptionPane.WARNING_MESSAGE,
                                                       getMDIcon(None),
                                                       options,
                                                       current)
            if not selectedIncludeInNW: continue

            if not lPresentedBackupDisclaimer:
                if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "Change 'include in NW' to '%s'?" %(selectedIncludeInNW)):
                    return
                lPresentedBackupDisclaimer = True

            if options.index(selectedIncludeInNW) == 0:
                # Include selected
                selectedAcct.setParameter(PARAM_APPLIES_TO_NW, None)
            else:
                # Exclude selected
                selectedAcct.setParameter(PARAM_APPLIES_TO_NW, False)

            selectedAcct.syncItem()
            iCountChanges += 1

            txt = "%s: Account: '%s' Parameter: '%s' set to %s" %(_THIS_METHOD_NAME, selectedAcct, PARAM_APPLIES_TO_NW, selectedIncludeInNW)
            setDisplayStatus(txt, "B")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt)

            continue

        del newAccounts

        if iCountChanges:
            txt = "%s: Updated the NW setting in %s Account(s)!" %(_THIS_METHOD_NAME, iCountChanges)
        else:
            txt = "%s: No Accounts changed" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return


    def zero_bal_categories(lFix):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if lFix:
            myPrint("DB","User requested to Inactivate Zero Balance Categories!")
        else:
            myPrint("D", "User requested to View Zero Balance Categories!")

        if lFix:
            myPrint("B", "Script running to Analyse your Active Categories for Zero Balance...............")
            myPrint("P", "---------------------------------------------------------")
        else:
            myPrint("B", "Script running to de-activate your Categories with Zero Balance...............")
            myPrint("P", "---------------------------------------------------------")

        if MD_REF.getCurrentAccount().getBook() is None: return

        output = ""
        output += "Analysing your categories for Zero Balances....\n\n"

        baseCurr = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()


        # ==========================================
        # Search reminders first
        root = MD_REF.getCurrentAccountBook()
        rems = root.getReminders().getAllReminders()

        listOfRems={}

        for rem in rems:
            remType = rem.getReminderType()  # NOTE or TRANSACTION

            if str(remType) != 'TRANSACTION': continue

            lastDate = rem.getLastDateInt()
            if not lastDate:
                pass    # No end date set, so proceed
            else:
                remDate = rem.getNextOccurance(lastDate)    # Stop at enddate
                if not remDate: continue    # Expired so skip

                if not remDate >= DateUtil.getStrippedDateInt(): continue
                # Right, got one!

            desc = rem.getDescription()

            txnParent = rem.getTransaction()

            for index2 in range(0, int(txnParent.getOtherTxnCount())):
                splitDesc = txnParent.getOtherTxn(index2).getDescription()
                acct = txnParent.getAccount()
                cat = txnParent.getOtherTxn(index2).getAccount()
                catValue = baseCurr.getDoubleValue(txnParent.getOtherTxn(index2).getValue()) * -1

                if catValue:
                    theReminder = [acct, cat, catValue, desc, splitDesc]
                    listOfRems[cat]=theReminder

        # ==========================================


        # Now the Categories
        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(4))    # This returns active and inactive accounts
        accounts = sorted(accounts, key=lambda x: (x.getAccountType(), safeStr(x.getFullAccountName()).upper()))

        categoriesToInactivate = {}

        output += "LISTING ACTIVE CATEGORIES WITH ZERO BALANCES:\n\n"

        # Run 1 - get the initial list
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0
                    # and cat.getRecursiveReconcilingBalance() == 0
            ):
                if listOfRems.get(cat):     # Found a reminder!
                    pass
                else:
                    categoriesToInactivate[cat]=True

        # Run 2 - filter out parents.... if we are retaining any sub cats
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if not categoriesToInactivate.get(cat):     # Select categories that we are not deactivating

                # Look for its parents in the list of Cats to deactivate
                parentCats = cat.getPath()
                for theParent in parentCats:
                    if categoriesToInactivate.get(theParent):   # Found a parent - so don't deactivate it!
                        categoriesToInactivate[theParent]=False

        last = None
        iCountForInactivation = 0
        sortedCategoriesToInactivate=sorted(list(categoriesToInactivate), key=lambda x: (x.getAccountType(),x.getFullAccountName()) )

        # for cat in categoriesToInactivate.keys():
        for cat in sortedCategoriesToInactivate:
            if categoriesToInactivate.get(cat):
                iCountForInactivation+=1

                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "Category: %s has Zero Balances\n" % pad(cat.getFullAccountName(),100)
            else:
                output += "Category: %s ** But cannot be deactivated as it's the Parent of an active Category **\n" % pad(cat.getFullAccountName(),100)


        output += "--------------------------------------------------------------------------------------------------\n"
        output += ("You have %s categories with Zero Balances - these can be made Inactive using Update Mode......\n" % iCountForInactivation).upper()
        output += "---------------------------------------------------------------------------------------------------\n\n"

        output += "LISTING ACTIVE CATEGORIES WITH ZERO BALANCES - BUT WITH FUTURE REMINDERS PRESENT:\n\n"

        output += pad("Category Name", 78)
        output += " " + pad("Account", 20)
        output += " " + pad("Reminder Description", 35)
        output += " " + rpad("Rem Amount", 12)
        output += " " + pad("Split Desc", 35)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        last = None
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0
                    # and cat.getRecursiveReconcilingBalance() == 0
            ):
                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                foundRem = listOfRems.get(cat)
                if foundRem:    # Found a reminder!
                    output += "Category: %s Reminder Details: " % pad(cat.getFullAccountName(),50)
                    output += pad(foundRem[0].getAccountName(),20)+" "
                    output += pad(foundRem[3],35)+" "
                    output += rpad(foundRem[2],12)+" "
                    output += pad(foundRem[4],35)+"\n"

        output += "-----------------------------------------------------------------------------------------------------------\n"


        output += "\n\nLISTING INACTIVE CATEGORIES WITH ZERO BALANCES:\n\n"

        ii=0
        last = None
        for cat in accounts:
            if not cat.getAccountOrParentIsInactive(): continue
            if (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0 ):  # and cat.getRecursiveReconcilingBalance() == 0


                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "Inactive Category: %s has Zero Balances\n" % pad(cat.getFullAccountName(),100)
                ii+=1

        if not ii:
            output += "<NONE FOUND>\n\n"

        output += "--------------------------------------------------------------------------------------------------\n"

        output += "LISTING ACTIVE CATEGORIES WITH BALANCES:\n\n"

        output += pad("Category Name", 85)
        output += " " + rpad("Balance", 12)
        # output += " " + rpad("ClrdBal", 12)
        # output += " " + rpad("ConfBal", 12)
        output += " " + rpad("CurrBal", 12)
        # output += " " + rpad("RecBal", 12)
        output += " " + rpad("RcrsBal", 12)
        # output += " " + rpad("RcrsClrdBal", 12)
        output += " " + rpad("RcrsCurrBal", 12)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        ii = 0
        last = None
        for cat in accounts:
            if cat.getAccountOrParentIsInactive(): continue
            if not (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0):     # and cat.getRecursiveReconcilingBalance() == 0
                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "%s" % pad(cat.getFullAccountName(), 85)

                mult = 1
                # noinspection PyUnresolvedReferences
                if cat.getAccountType() == Account.AccountType.EXPENSE: mult = -1

                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserClearedBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserConfirmedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserReconcilingBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserClearedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserReconcilingBalance()*-1), 12)
                output += "\n"
                ii+=1
        if not ii:
            output += "<NONE FOUND>\n\n"

        output += "----------------------------------------------------------------------------\n\n"

        output += "LISTING INACTIVE CATEGORIES WITH BALANCES:\n\n"

        output += pad("Category Name", 85)
        output += " " + rpad("Balance", 12)
        # output += " " + rpad("ClrdBal", 12)
        # output += " " + rpad("ConfBal", 12)
        output += " " + rpad("CurrBal", 12)
        # output += " " + rpad("RecBal", 12)
        output += " " + rpad("RcrsBal", 12)
        # output += " " + rpad("RcrsClrdBal", 12)
        output += " " + rpad("RcrsCurrBal", 12)
        # output += " " + rpad("RcrsRecBal", 12)
        output += "\n"

        ii=0
        last = None
        for cat in accounts:
            if not cat.getAccountOrParentIsInactive(): continue
            if not (cat.getBalance() == 0
                    # and cat.getClearedBalance() == 0
                    and cat.getConfirmedBalance() == 0
                    and cat.getCurrentBalance() == 0
                    # and cat.getReconcilingBalance() == 0
                    and cat.getRecursiveBalance() == 0
                    # and cat.getRecursiveClearedBalance() == 0
                    and cat.getRecursiveCurrentBalance() == 0):       # and cat.getRecursiveReconcilingBalance() == 0

                if not last or last != cat.getAccountType():
                    output += "\nCATEGORY TYPE: %s\n" % cat.getAccountType()
                    last = cat.getAccountType()

                output += "%s" % pad(cat.getFullAccountName(), 85)

                mult = 1
                # noinspection PyUnresolvedReferences
                if cat.getAccountType() == Account.AccountType.EXPENSE: mult = -1

                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserClearedBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserConfirmedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getUserReconcilingBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserClearedBalance()*mult), 12)
                output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserCurrentBalance()*mult), 12)
                # output += " " + rpad("%s" % baseCurr.getDoubleValue(cat.getRecursiveUserReconcilingBalance()*mult), 12)
                output += "\n"
                ii+=1

        if not ii:
            output += "<NONE FOUND>\n\n"

        output += "----------------------------------------------------------------------------\n\n"

        output += "\nLEGEND:\n"
        output += "** NOTE: The Balances shown on a Parent Category in any section may not be the sum of its Child Categories shown in the same section.\n"
        output += "         The calculation matches the Moneydance Tools>Categories method and will include the balances(s) from all its Child Categories whether active, inactive or otherwise....\n\n"
        output += "Balance = Account Balance\n"
        # output += "ClrdBal = Cleared Balance (Normally Zero on a Category). Balance excluding uncleared or reconciling txns\n"
        # output += "ConfBal = Confirmed Balance (The Balance less any unconfirmed Online / Downloaded Bank txns\n"
        output += "CurrBal = Current Balance\n"
        # output += "RecBal = Reconciling Balance (Normally Zero on a Category)\n"
        output += "RcrsBal = Recursive (through all sub categories) Account Balance (Note: may contain balances from inactive sub-categories as per Moneydance)\n"
        # output += "RcrsClrdBal = Recursive (through all sub categories) Cleared Balance (Normally Zero on a Category)\n"
        output += "RcrsCurrBal = Recursive (through all sub categories) Current Balance (Note: may contain balances from inactive sub-categories as per Moneydance)\n"
        # output += "RcrsRecBal = Recursive (through all sub categories) Reconciling Balance (Normally Zero on a Category)\n"
        output += "----------------------------------------------------------------------------\n\n"
        output += "<END>"

        if lFix:
            output += "\nDISCLAIMER: I take no responsibility if you decide to execute the Inactivate Zero Balance Category fix script!\n"

        if not lFix:
            jif = QuickJFrame("View your Active Categories with Zero Balances....", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        else:
            jif = QuickJFrame("View your Active Categories with Zero Balances.... CLICK OK WHEN READY TO PROCEED", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        myPrint("J", "There are %s Active Categories with Zero Balances that could be Inactivated!" % iCountForInactivation)

        if not lFix:
            txt = "VIEW ZERO BALANCE CATEGORIES: YOU HAVE %s Zero Balance Categories..." %(iCountForInactivation)
            setDisplayStatus(txt, "DG")
            myPopupInformationBox(jif, txt, "ZERO BALANCE CATEGORIES", JOptionPane.INFORMATION_MESSAGE)
            return

        if iCountForInactivation < 1:
            txt = "FIX ZERO BALANCE CATEGORIES: You have no Zero Balance Categories to fix - no fixes applied..."
            setDisplayStatus(txt, "DG")
            myPopupInformationBox(jif, txt, "ZERO BALANCE CATEGORIES", JOptionPane.INFORMATION_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(jif, "FIX - INACTIVATE ZERO BALANCE CATEGORIES", "Inactivate these %s Zero Balance Categories?" %(iCountForInactivation)):
            return

        # OK - so we are fixing...!
        myPrint("B", ">> User selected to Inactivate %s Zero Balance Categories!?" % iCountForInactivation)

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for cat in categoriesToInactivate.keys():
            if categoriesToInactivate.get(cat):
                myPrint("B", "Cat: " + cat.getFullAccountName() + " with Zero Balances, Set to INACTIVE!")
                cat.setAccountIsInactive(True)
                cat.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        myPrint("B", "Finished Inactivating %s Categories with Zero Balances..." % iCountForInactivation)

        txt = "FIX - I have set %s Categories with Zero Balances to Inactive as requested!" %(iCountForInactivation)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(jif,txt,"INACTIVATE ZERO BALANCE CATEGORIES",JOptionPane.WARNING_MESSAGE)
        play_the_money_sound()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_account_parent():

        # fix_account_parent.py (and old check_root_structure.py)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("B", "Diagnosing INVALID Parent Accounts....")
        myPrint("P", "--------------------------------------")

        book = MD_REF.getCurrentAccountBook()
        root = book.getRootAccount()
        allAccounts = book.getItemsWithType(Account.SYNCABLE_TYPE_VALUE)


        def validate_path(check_acct):
            _acct = check_acct
            iterations = 0
            while True:
                # noinspection PyUnresolvedReferences
                if _acct.getAccountType() == Account.AccountType.ROOT:      return True
                if _acct is None:                                           return False
                if iterations > 100:                                        return False
                iterations+=1
                _acct = _acct.getParentAccount()
                continue


        output = "FIX ACCOUNT(s)' INVALID PARENT ACCOUNTS:\n" \
                 " ========================================\n\n"

        def check_fix_accounts(lFix=False):

            iErrors=0
            textFixed=""

            for acct in allAccounts:

                # skip root
                # noinspection PyUnresolvedReferences
                if acct == root or acct.getAccountType() == Account.AccountType.ROOT: continue

                parent = acct.getParentAccount()
                if ((parent is None or parent == acct)
                        or (parent is not None and parent != root and not validate_path(acct))):
                    iErrors+=1
                    if lFix:
                        myPrint("B","Resetting parent account for %s to root" %(acct.getAccountName()))
                        textFixed+=("Resetting parent account for %s to root\n" %(acct.getAccountName()))
                        acct.setParentAccount(root)
                        acct.syncItem()
                    else:
                        myPrint("B", "@@ ERROR - NEEDS RESET - Account: %s\n" % acct.getAccountName())
                        textFixed+="NEEDS RESET - Account: %s\n" % acct.getAccountName()

            return iErrors, textFixed

        iCountErrors, x =  check_fix_accounts(lFix=False)
        output += x

        if iCountErrors<1:
            txt = "'FIX: Account(s)'s Invalid Parent - CONGRATULATIONS - I found no Invalid parents......."
            setDisplayStatus(txt, "B")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        myPrint("B","FIX - Account(s)' Invalid Parent Accounts - found %s errors..." %(iCountErrors))

        jif=QuickJFrame("VIEW ACCOUNT(s) WITH INVALID PARENT ACCOUNTS", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if not confirm_backup_confirm_disclaimer(jif, "FIX ACCOUNT(S)' INVALID PARENTS","FIX %s Acct(s)'s Invalid Parent Accts?" %(iCountErrors)):
            return

        jif.dispose()       # already within the EDT
        myPrint("B", "User accepted disclaimer to FIX Account(s)' Invalid Parent Accounts. Proceeding.....")

        output += "\n\nRUNNING FIX ON PARENT ACCOUNTS\n" \
                  "--------------------------------\n\n"

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes...
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        iCountErrors, x = check_fix_accounts(lFix=True)
        output += x
        output += "\n<END>"

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)
        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        play_the_money_sound()
        txt = "FIXED %s invalid Parent Accounts" %(iCountErrors)
        setDisplayStatus(txt, "DG")
        myPrint("B", txt)
        jif = QuickJFrame("VIEW ACCOUNT(s) WITH INVALID PARENT ACCOUNTS", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        myPopupInformationBox(jif,txt, "FIX INVALID PARENT ACCOUNTS", JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_root_account_name():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        bookName = MD_REF.getCurrentAccountBook().getName().strip()
        root = MD_REF.getCurrentAccountBook().getRootAccount()
        rootName = root.getAccountName().strip()

        if rootName == bookName:
            myPopupInformationBox(toolbox_frame_,
                                  "The name of your Root Account is already the same as your Dataset(or 'Book'): %s" % (bookName),
                                  "RENAME ROOT ACCOUNT",
                                  JOptionPane.INFORMATION_MESSAGE)
            txt = "No changed applied as your Root Account name is already the same as your Dataset ('Book') name: %s" %(bookName)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B", "User requested to fix Root Account Name")
        myPrint("B", "Dataset's ('Book') Name: ", bookName)
        myPrint("B", "Root's Account Name: ", rootName)

        MyPopUpDialogBox(toolbox_frame_,
                         "RENAME ROOT ACCOUNT",
                         "Your Dataset ('book') name is: %s (this is the name that will be used)\nYour Root Account name is: %s" %(bookName,rootName),
                         theTitle="RENAME ROOT ACCOUNT").go()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "RENAME ROOT ACCOUNT", "rename your Root Account to: %s?" %(bookName)):
            return

        myPrint("B", "User accepted disclaimer to reset Root Account Name. Proceeding.....")
        # Flush all in memory settings to config.dict file on disk
        MD_REF.savePreferences()

        root.setAccountName(bookName)
        root.syncItem()

        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        myPrint("B", "Root account renamed to: %s" % (bookName))
        play_the_money_sound()

        txt = "Root Account Name changed to : %s" %(bookName)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,"RENAME ROOT",JOptionPane.WARNING_MESSAGE)

    # noinspection PyUnresolvedReferences
    def force_change_account_type():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # set_account_type.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change an Account's Type?",
                             theTitle="FORCE CHANGE TYPE",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have have created an Account with the wrong Type\n"
                                        "This fix will NOT attempt to check that the Acct has Txns that are valid in the new Account Type.\n"
                                        "It simply changes the Type set on the account to the new Type.\n"
                                        "You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change an Account's type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to FORCE change its Type",
                                                      "FORCE CHANGE ACCOUNT's TYPE",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList
        if not selectedAccount:
            txt = "User did not Select an Account to FORCE change its Type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        if selectedAccount.getAccountType() == Account.AccountType.ROOT:
            if not myPopupAskQuestion(toolbox_frame_,"FORCE CHANGE ACCOUNT TYPE","THIS ACCOUNT IS ROOT (SPECIAL). DO YOU REALLY WANT TO CHANGE IT'S TYPE (Normally a bad idea!) ?", theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "User Aborted change of Root's Account Type (phew!) - no changes made"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

        possTypes = Account.AccountType.values()
        possTypes.remove(Account.AccountType.ROOT)
        possTypes.remove(Account.AccountType.SECURITY)
        if selectedAccount.getAccountType() in possTypes:
            possTypes.remove(selectedAccount.getAccountType())

        selectedType = JOptionPane.showInputDialog(toolbox_frame_,
                                                   "Select the new Account Type",
                                                   "FORCE CHANGE ACCOUNT's TYPE",
                                                   JOptionPane.WARNING_MESSAGE,
                                                   getMDIcon(None),
                                                   possTypes,
                                                   None)  # type: Account.AccountType
        if not selectedType:
            txt = "User did not Select a new Account Type - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if selectedType == Account.AccountType.ROOT:
            if not myPopupAskQuestion(toolbox_frame_,"FORCE CHANGE ACCOUNT TYPE","DO YOU REALLY WANT TO CHANGE TO ROOT (Normally a bad idea!)?", theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "User Aborted change Account to type Root (phew!) - no changes made"
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change this Account's Type?",
                             theTitle="FORCE CHANGE TYPE",
                             theMessage="Account: %s\n"
                                        "Old Type: %s\n"
                                        "New Type: %s\n"
                                        %(selectedAccount.getFullAccountName(), selectedAccount.getAccountType(),selectedType),  # noqa
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User aborted the FORCE change to an Account's type - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE TYPE", "FORCE CHANGE ACCOUNT %s TYPE to %s" %(selectedAccount.getFullAccountName(),selectedType)):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Type of Account: %s from: %s to %s - APPLYING UPDATE NOW...."
                %(selectedAccount.getFullAccountName(),selectedAccount.getAccountType(),selectedType))          # noqa

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        selectedAccount.setAccountType(selectedType)                                                            # noqa
        selectedAccount.syncItem()                                                                              # noqa

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = "The Account: %s has been changed to Type: %s - PLEASE REVIEW & THEN MANUALLY RESTART MD" %(selectedAccount.getAccountName(),selectedAccount.getAccountType())  # noqa
        setDisplayStatus(txt, "R")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def force_change_account_cat_currency():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # force_change_account_currency.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change an Account's / Category's Currency?",
                             theTitle="FORCE CHANGE CURRENCY",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have duplicated Currencies and you want to move\n"
                                        "transactions from one account to another, but the system prevents you unless they are the same currency\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "set on the account / category to the new currency. You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change an Account's / Category's currency - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        currencies=[]
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                       # noqa
                currencies.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))
        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account / Category to FORCE change currency",
                                                      "FORCE CHANGE ACCOUNT's / CATEGORY's CURRENCY",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList
        if not selectedAccount:
            txt = "User did not Select an Account / Category to FORCE change currency - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account
        if isinstance(selectedAccount, Account): pass

        # noinspection PyUnresolvedReferences
        currencies.remove(selectedAccount.getCurrencyType())

        selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Old Currency: %s >> Select the new currency for the account/Category" %(selectedAccount.getCurrencyType()),                    # noqa
                                                       "FORCE CHANGE ACCOUNT's / CATEGORY's CURRENCY",
                                                       JOptionPane.ERROR_MESSAGE,
                                                       getMDIcon(None),
                                                       currencies,
                                                       None)  # type: CurrencyType
        if not selectedCurrency:
            txt = "User did not Select an new currency for Account / Category FORCE change - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change this Account's / Category's Currency?",
                             theTitle="FORCE CHANGE CURRENCY",
                             theMessage="Account: %s\n"
                                        "Old Currency: %s\n"
                                        "New Currency: %s\n"
                                        %(selectedAccount.getFullAccountName(), selectedAccount.getCurrencyType(),selectedCurrency),
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User aborted the FORCE change to an Account's / Category's currency - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE CURRENCY", "FORCE CHANGE ACCOUNT / CATEGORY %s CURRENCY" %(selectedAccount.getFullAccountName())):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Currency of Account/Category: %s from: %s to %s - APPLYING UPDATE NOW...."
                %(selectedAccount.getFullAccountName(),selectedAccount.getCurrencyType(),selectedCurrency))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        selectedAccount.setCurrencyType(selectedCurrency)
        selectedAccount.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = "Account/Category: %s has been changed to Curr: %s - PLEASE REVIEW & THEN MANUALLY RESTART MD WHEN FINISHED"\
              %(selectedAccount.getAccountName(),selectedAccount.getCurrencyType())
        setDisplayStatus(txt, "R")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def force_change_all_accounts_categories_currencies():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # force_change_all_currencies.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change ALL Accounts' / Categories' Currencies?",
                             theTitle="FORCE CHANGE ALL ACCOUNTS' / CATEGORYS' CURRENCIES",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you have a missing currency, or need to change them all\n"
                                        "This fix will not touch the ROOT account nor Security sub-accounts (which are stocks/shares)\n"
                                        "... it will include categories, along with all other account types...\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "set on all accounts to the new currency. You should carefully review your data afterwards and revert\n"
                                        "to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to FORCE change ALL Accounts' / Categories' currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(19))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        currencies=[]
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                       # noqa
                currencies.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))

        if len(currencies) < 1:
            myPrint("B", "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES - Creating new currency record!")
            selectedCurrency = CurrencyType(book.getCurrencies())       # Creates a new CT object
            selectedCurrency.setEditingMode()
            selectedCurrency.setName("NEW CURRENCY - PLEASE EDIT ME LATER")
            selectedCurrency.setIDString("AAA")
            selectedCurrency.setDecimalPlaces(2)
            selectedCurrency.syncItem()
            myPrint("B", "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES - Creating new currency: %s" %(selectedCurrency))
            myPopupInformationBox(toolbox_frame_,"FYI - I have created a new Currency %s for you (Edit it later)" %(selectedCurrency),
                                  "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES")
        else:
            selectedCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select a currency to assign to *ALL* accounts/categories",
                                                           "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES",
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedCurrency:
            txt = "User did not Select a new currency for FORCE change ALL Accounts' / Categories' Currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES", "FORCE CHANGE ALL %s ACCTS' / CATS' CURRENCIES TO %s?" %(len(accounts),selectedCurrency)):    # noqa
            return

        myPrint("B","@@ User requested to Force Change the Currency of ALL %s Accounts / Categories to %s - APPLYING UPDATE NOW...."
                %(len(accounts),selectedCurrency))     # noqa

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        accountsChanged = 0
        for account in accounts:
            if account.getAccountType() == Account.AccountType.ROOT:                                                    # noqa
                continue
            if account.getAccountType() == Account.AccountType.SECURITY:                                                # noqa
                continue
            if account.getCurrencyType() == selectedCurrency:
                continue

            myPrint("B","Setting account / category %s to currency %s" %(account, selectedCurrency))
            account.setCurrencyType(selectedCurrency)
            account.syncItem()
            accountsChanged += 1

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = "FORCE CHANGE ALL ACCOUNTS' / CATEGORIES' CURRENCIES: %s Accts / Cats changed to curr: %s - MONEYDANCE WILL NOW RESTART - PLEASE REVIEW RESULTS" %(accountsChanged,selectedCurrency)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def force_change_accounts_cats_from_to_currency():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "FORCE CHANGE ACCTs / CATs FROM / TO CURRENCY"

        # force_change_all_currencies.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to FORCE change Accounts / Categories FROM / TO Currency?",
                             theTitle=_THIS_METHOD_NAME,
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenarios is where you have a duplicate currency and want to change to the right one\n"
                                        "PLEASE ENSURE THE FROM's and TO's Currency rates are essentially the same before you start!\n"
                                        "This fix will not touch the ROOT account nor Security sub-accounts (which are stocks/shares)\n"
                                        "... it will include categories, along with all other account types...\n"
                                        "You will be asked if you also want to include Security records on the from/to switch to...\n"
                                        "... (you can switch security records manually if you prefer)...\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the currency\n"
                                        "...set on all accounts to the new currency. You should carefully review your data afterwards and revert\n"
                                        "...to a backup if you are not happy with the results....\n"
                                        "\n",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to %s - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        includeSecurities = myPopupAskQuestion(toolbox_frame_, _THIS_METHOD_NAME.upper(),  "Include Security records in the FROM/TO currency switch too?")

        allAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(19))
        allAccounts = sorted(allAccounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        currencies = []
        securities = []
        book = MD_REF.getCurrentAccountBook()
        allCurrencies = book.getCurrencies().getAllCurrencies()
        for c in allCurrencies:
            if c.getCurrencyType() == CurrencyType.Type.CURRENCY:                                                       # noqa
                currencies.append(c)
            if c.getCurrencyType() == CurrencyType.Type.SECURITY:                                                       # noqa
                securities.append(c)
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getName().upper()))
        securities = sorted(securities, key=lambda sort_x: (sort_x.getName().upper()))

        if len(currencies) < 2:
            txt = "%s: Not enough currencies exist - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedFromCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the FROM currency (that you want to remove from accts/cats)",
                                                           _THIS_METHOD_NAME,
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedFromCurrency:
            txt = "User did not Select the old FROM currency for '%s' - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if isinstance(selectedFromCurrency, CurrencyType): pass

        currencies.remove(selectedFromCurrency)

        selectedToCurrency = JOptionPane.showInputDialog(toolbox_frame_,
                                                           "Select the TO currency (that you store on your accts/cats)",
                                                           _THIS_METHOD_NAME,
                                                           JOptionPane.ERROR_MESSAGE,
                                                           getMDIcon(None),
                                                           currencies,
                                                           None)  # type: CurrencyType

        if not selectedToCurrency:
            txt = "User did not Select the new TO currency for '%s' - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if isinstance(selectedToCurrency, CurrencyType): pass

        replaceAccts = []
        for acct in allAccounts:
            if acct.getCurrencyType() == selectedFromCurrency:
                replaceAccts.append(acct)

        replaceSecurities = []
        if includeSecurities:
            for sec in securities:
                if sec.getRelativeCurrency() == selectedFromCurrency:
                    replaceSecurities.append(sec)

        if (len(replaceAccts) + len(replaceSecurities)) < 1:
            txt = "%s: No accounts / Securities found with the old currency: %s - no changes made" %(_THIS_METHOD_NAME, selectedFromCurrency)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "SWITCH FROM CURRENCY %s TO %s ON %s ACCTS / CATS & %s SECURITIES?"
                                                                                    %(selectedFromCurrency, selectedToCurrency, len(replaceAccts), len(replaceSecurities))):
            return

        myPrint("B","%s: @@ User requested to replace currency %s with %s on %s Accounts/Categories & %s Securities - APPLYING UPDATE NOW...."
                %(_THIS_METHOD_NAME, selectedFromCurrency, selectedToCurrency, len(replaceAccts), len(replaceSecurities)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for acct in replaceAccts:
            myPrint("B","Setting account / category '%s' currency to: %s" %(acct, selectedToCurrency))
            acct.setCurrencyType(selectedToCurrency)
            acct.syncItem()

        for sec in replaceSecurities:
            if sec.getRelativeCurrency() == selectedFromCurrency:
                myPrint("B","Setting security '%s' relative currency to: %s" %(sec, selectedToCurrency))
                sec.setRelativeCurrency(selectedToCurrency)
                sec.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)

        root = MD_REF.getRootAccount()
        MD_REF.getCurrentAccount().getBook().notifyAccountModified(root)

        txt = ("%s: %s Accts / Cats, and %s Securities, changed from curr: %s to %s - MD WILL RESTART - PLEASE REVIEW RESULTS"
               %(_THIS_METHOD_NAME, len(replaceAccts), len(replaceSecurities), selectedFromCurrency, selectedToCurrency))

        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.ERROR_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def fix_invalid_relative_currency_rates():

        myPrint(u"D", u"In ", inspect.currentframe().f_code.co_name, u"()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        txt = "fix_invalid_relative_currency_rates"
        if not perform_qer_quote_loader_check(toolbox_frame_, txt): return

        book = MD_REF.getCurrentAccountBook()
        currencies = book.getCurrencies().getAllCurrencies()
        currencies = sorted(currencies, key=lambda sort_x: (sort_x.getCurrencyType(),sort_x.getName().upper()))

        output=u"FIX INVALID RELATIVE CURRENCIES\n" \
               u" ==============================\n\n"

        upperLimit = 9999999999

        output += u"** Wild rates set to %s <= (rate) >= %s\n" %((1.0 / upperLimit), upperLimit)

        iErrors = 0
        for curr in currencies:
            if not isGoodRate(curr.getRelativeRate()) or curr.getRelativeRate() <= (1.0 / upperLimit) or curr.getRelativeRate() >= upperLimit:
                iErrors += 1
                output += u"Invalid - Type: %s Name: %s Relative Rate: %s\n" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20))

        if iErrors < 1:
            txt = u"FIX INVALID REL CURR RATES: You have no relative rates <= %s or >= %s to fix - NO CHANGES MADE" %((1.0 / upperLimit),upperLimit)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, u"FIX INVALID REL CURR RATES")
            return

        jif=QuickJFrame(u"FIX INVALID RELATIVE CURRENCIES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        # force_change_account_currency.py
        ask=MyPopUpDialogBox(jif,
                             theStatus=u"Are you sure you want to FIX these %s INVALID RELATIVE CURRENCIES?" %iErrors,
                             theTitle=u"FIX INVALID RELATIVE CURRENCIES",
                             theMessage=u"Do not proceed unless you know you want to do this....!\n"
                                        u"This fix will NOT attempt to correct any transactions or fx rates etc... It simply changes the relative rate(s)\n"
                                        u"You should carefully review your data afterwards and revert to a backup if you are not happy with the results....\n",
                             lCancelButton=True,
                             OKButtonText=u"I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = u"User did not say yes to fix invalid relative currencies - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(jif, u"FIX INVALID RELATIVE CURR RATES", u"FIX %s INVALID RELATIVE CURRENCY RATES" %(iErrors)):
            return

        jif.dispose()       # already within the EDT

        myPrint(u"B",u"@@ User requested to fix %s invalid relative currency rates - APPLYING UPDATE NOW...." %(iErrors) )

        output += u"\n\n APPLYING FIXES\n" \
                  u" ==============\n\n"

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for curr in currencies:
            if not isGoodRate(curr.getRelativeRate()) or curr.getRelativeRate() <= (1.0 / upperLimit) or curr.getRelativeRate() >= upperLimit:
                output += u"FIXING >> Invalid - Type: %s Name: %s Relative Rate: %s - RESET TO 1.0\n" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20))

                myPrint(u"B", u"FIXING >> Invalid - Type: %s Name: %s Relative Rate: %s - RESET TO 1.0" %(curr.getCurrencyType(),pad(curr.getName(),25),rpad(curr.getRelativeRate(),20)))

                curr.setRelativeRate(1.0)
                curr.syncItem()

        myPrint(u"P", output)

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        output += "\n<END"

        jif = QuickJFrame(u"FIX INVALID RELATIVE CURRENCIES",output,copyToClipboard=lCopyAllToClipBoard_TB,lRestartMDAfterClose=True).show_the_frame()

        txt = u"%s Invalid Currency relative rates reset to 1.0 - MD WILL RESTART AFTER VIEWING THIS OUTPUT" %(iErrors)
        setDisplayStatus(txt, "R")
        play_the_money_sound()
        myPopupInformationBox(jif,txt, u"FIX INVALID RELATIVE CURRENCIES", theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint(u"D", u"Exiting ", inspect.currentframe().f_code.co_name, u"()")
        return

    def fix_invalid_price_history():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, u"()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        txt = "Fix Invalid Price History Records"
        if not perform_qer_quote_loader_check(toolbox_frame_, txt): return

        output="FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES\n" \
               " ===================================================\n\n"

        upperLimit = 9999999999

        output += "** Wild rates set to %s <= (rate) >= %s\n" %((1.0 / upperLimit), upperLimit)

        allSnaps = MD_REF.getCurrentAccount().getBook().getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE)
        output += "\nFound price history records (snaps): %s" %(len(allSnaps))

        iGood = 0
        badSnaps = []
        output += "\n.. scanning snaps for 'wild' rates....\n"

        for snap in allSnaps:
            snapRate = snap.getRate()
            if not isGoodRate(snapRate) or snapRate <= (1.0 / upperLimit) or snapRate >= upperLimit:
                badSnaps.append(snap)
            else:
                iGood += 1

        if len(badSnaps) < 1:
            txt = "CONGRATULATIONS >> No snaps with 'wild' rates (out of %s good found) found! No changes made!" %(iGood)
            myPrint("DB", txt)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt)
            return

        badSnaps = sorted(badSnaps, key=lambda sort_x: (sort_x.getParameter("curr", None),sort_x.getDateInt()))
        for badSnap in badSnaps:
            output += "Invalid rate found: %s\n" %(badSnap)

        output += "\n\n--------------------------------------\n"
        output += "Good snaps: %s\n" %(iGood)

        txt = "Bad snaps with 'wild' rates found: %s" %(len(badSnaps))
        myPrint("B", txt); output += "%s\n" %(txt)

        jif = QuickJFrame("FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        ask=MyPopUpDialogBox(jif,
                             theStatus="Are you sure you want to DELETE these %s INVALID PRICE HISTORY RECORDS?" %(len(badSnaps)),
                             theTitle="FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",
                             theMessage="Do not proceed unless you know you want to do this....!\n"
                                        "This fix will NOT attempt to correct any transactions or fx rates etc... It simply deletes the invalid rate(s)",
                             lCancelButton=True,
                             OKButtonText="I AGREE - DELETE",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to delete %s invalid price history records - no changes made" %(len(badSnaps))
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        if not confirm_backup_confirm_disclaimer(jif,
                                                 "DELETE INVALID PRICE HISTORY RECORDS WITH 'WILD' RATES",
                                                 "DELETE %s INVALID PRICE HISTORY RECORDS" %(len(badSnaps))):
            return
        jif.dispose()       # already within the EDT


        txt = "@@ User requested to delete %s invalid price history with 'wild' rates - DELETING NOW...." %(len(badSnaps))
        myPrint("B", txt); output += "%s\n\n" %(txt)

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        output += "Logging snaps with 'wild' rates for deletion....\n"
        MD_REF.getCurrentAccount().getBook().logRemovedItems(badSnaps)

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        output += "Flushing dataset changes in memory back to disk....\n"
        MD_REF.getCurrentAccount().getBook().saveTrunkFile()

        txt = "%s snaps with 'wild' rates DELETED." %(len(badSnaps))
        myPrint("B", txt); output += "%s\n\n" %(txt)

        output += "\n<END>"

        setDisplayStatus(txt, "R")
        play_the_money_sound()
        jif = QuickJFrame("FIX - DELETE INVALID PRICE HISTORY WITH 'WILD' RATES",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, u"()")
        return

    def reverse_txn_amounts():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # reverse_txn_amounts.py
        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to REVERSE Transaction amounts on an Account's Transactions (between two dates)?",
                             theTitle="REVERSE TRANSACTIONAL AMOUNTS",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you perhaps imported transactions with the wrong +/- sign\n"
                                        "..or perhaps you  have changed an account's type\n"
                                        "This fix will not touch the ROOT account nor Investment/Security sub-accounts (which are stocks/shares)\n"
                                        "You should carefully review your data afterwards and revert to a backup if you are not happy with the results....",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to REVERSE TXN AMOUNTS - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(20))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to REVERSE Transactional Amounts",
                                                      "REVERSE ACCOUNT's TXN AMOUNTS",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList

        if not selectedAccount:
            txt = "User did not Select an Account to REVERSE Transactional Amounts - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        dateField = JDateField(MD_REF.getUI())
        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select Starting Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select start date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        startDate = dateField.getDateInt()

        dateField.gotoToday()

        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select Ending Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select end date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        endDate = dateField.getDateInt()

        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        txns = txnSet.iterableTxns()

        iTxnsFound = 0
        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue
            acct = txn.getAccount()
            if not acct == selectedAccount: continue
            iTxnsFound += 1

        if iTxnsFound < 1:
            txt = "REVERSE TXN AMOUNTS - Sorry - no transactions found - NO CHANGES MADE"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "REVERSE ACCT TXN AMOUNTS", "ACCOUNT %s - REVERSE %s Txns' amounts between %s - %s?"
                                                                                             %(selectedAccount,iTxnsFound,convertStrippedIntDateFormattedText(startDate),convertStrippedIntDateFormattedText(endDate))):
            return

        myPrint("B","@@ User requested to REVERSE the (%s) Txn Amounts on Account %s between %s to %s - APPLYING UPDATE NOW...." %(iTxnsFound, selectedAccount, convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue
            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            myPrint("B","Reversing the amount on %s" %(txn))
            ptxn = txn.getParentTxn()

            ptxn.setEditingMode()

            if ptxn == txn:             # this is the parent part of the txn
                myPrint("B", "  - is a parent, changing each split")
                for splitIdx in range(0, txn.getSplitCount()):
                    txn.getSplit(splitIdx).negateAmount()
            else:
                myPrint("B", "  - is a split")
                txn.negateAmount()

            ptxn.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "REVERSE %s Txns Amounts on Account %s between %s - %s COMPLETED - PLEASE REVIEW" %(iTxnsFound,selectedAccount,convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate))
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def reverse_txn_exchange_rates_by_account_and_date():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        # reverse_txn_exchange_rates_by_account_and_date.py

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Are you sure you want to REVERSE Exchange Rates on an Account's Transactions (between two dates)?",
                             theTitle="REVERSE TRANSACTIONAL EXCHANGE RATES",
                             theMessage="This is normally a BAD idea, unless you know you want to do it....!\n"
                                        "The typical scenario is where you perhaps imported transactions with the fx rates inversed \n"
                                        "This fix will not touch the Currency price history...!\n"
                                        "This fix will not touch the ROOT account nor Investment/Security sub-accounts (which are stocks/shares)\n"
                                        "You should carefully review your data afterwards and revert to a backup if you are not happy with the results....",
                             lCancelButton=True,
                             OKButtonText="I AGREE - PROCEED",
                             lAlertLevel=2)

        if not ask.go():
            txt = "User did not say yes to REVERSE TXN EXCHANGE RATES - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        del ask

        accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(20))
        accounts = sorted(accounts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))

        newAccounts = []
        for acct in accounts:
            newAccounts.append(StoreAccountList(acct))

        selectedAccount = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Account to REVERSE Transactional Exchange Rates",
                                                      "REVERSE ACCOUNT's TXN EXCHANGE RATES",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      newAccounts,
                                                      None)  # type: StoreAccountList

        if not selectedAccount:
            txt = "User did not select an Account to REVERSE Transactional Exchange Rates - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        selectedAccount = selectedAccount.obj       # type: Account

        dateField = JDateField(MD_REF.getUI())
        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select STARTING Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select start date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        startDate = dateField.getDateInt()

        dateField.gotoToday()

        if not JOptionPane.showConfirmDialog(toolbox_frame_, dateField, "Select ENDING Date for reverse", JOptionPane.OK_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE, getMDIcon(None))==JOptionPane.OK_OPTION:
            txt = "User did not select end date - no changes made"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return
        endDate = dateField.getDateInt()

        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        txns = txnSet.iterableTxns()

        iTxnsFound = 0

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue

            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            if txn.getParentTxn() == txn:   # Parent
                for splitNum in range(0, txn.getSplitCount()):
                    split = txn.getSplit(splitNum)
                    if split.getAmount() != split.getValue():
                        iTxnsFound += 1
                        break
            else:   # Split
                if txn.getAmount() != txn.getValue():
                    iTxnsFound += 1

        if iTxnsFound < 1:
            txt = "REVERSE TXN EXCHANGE RATES - Sorry - no transactions found (with fx) - NO CHANGES MADE"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "REVERSE ACCT TXN EXCHANGE RATES", "ACCOUNT %s - REVERSE %s Txns' exchange rates between %s - %s?"
                                                                                                    %(selectedAccount,iTxnsFound,convertStrippedIntDateFormattedText(startDate),convertStrippedIntDateFormattedText(endDate))):
            return

        myPrint("B","@@ User requested to REVERSE the (%s) Txn Exchange Rates on Account %s between %s to %s - APPLYING UPDATE NOW...."
                %(iTxnsFound, selectedAccount, convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate)))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for txn in txns:
            if txn.getDateInt() < startDate: continue
            if txn.getDateInt() > endDate: continue

            acct = txn.getAccount()
            if not acct == selectedAccount: continue

            ptxn = txn.getParentTxn()
            needsSync = False

            if ptxn == txn:
                for splitNum in range(0, txn.getSplitCount()):
                    split = txn.getSplit(splitNum)
                    if split.getAmount() != split.getValue():
                        if not needsSync:
                            myPrint("B","Reversing exchange rate on %s" %(txn))
                            myPrint("B", "  - is a parent, changing each split")
                            ptxn.setEditingMode()
                        needsSync = True
                        parentVal = split.getParentValue()
                        rate = split.getRate()
                        split.setParentAmount(safeInvertRate(rate), parentVal)
            else:
                split = txn
                if split.getAmount() != split.getValue():
                    myPrint("B","Reversing exchange rate on %s" %(txn))
                    myPrint("B", "  - This is a split - changing...")
                    if not needsSync:
                        ptxn.setEditingMode()
                    needsSync = True
                    parentVal = split.getParentValue()
                    rate = split.getRate()
                    split.setParentAmount(safeInvertRate(rate), parentVal)

            if needsSync:
                ptxn.syncItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        txt = "REVERSE %s Txns Exchange Rates on Account %s between %s - %s COMPLETED - PLEASE REVIEW"\
              %(iTxnsFound,selectedAccount,convertStrippedIntDateFormattedText(startDate), convertStrippedIntDateFormattedText(endDate))
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def isSplitTxnAccountAssignedRoot(_txn, _fix=False, _accounts=None, _fixAcctType=None):
        if _fix and (_accounts is None or _fixAcctType is None):
            raise Exception("ERROR: isTxnAccountAssignedRoot() Fix, _accounts and _fixAcctType must NOT be None")
        acct = _txn.getAccount()
        # noinspection PyUnresolvedReferences
        assignedRoot = (acct is not None and acct.getAccountType() == Account.AccountType.ROOT)
        if assignedRoot and _fix:
            if _txn.getParameter("invest.splittype", "") == "sec":
                myPrint("B", "NOT FIXING: 'security' transaction assigned to root account:", _txn, "FIX MANUALLY")
            else:
                fixAccount = _accounts.getAccount(_fixAcctType)
                myPrint("B", "FIXING: transaction assigned to root account:", _txn, "Assigning to:", fixAccount)
                _txn.setAccount(fixAccount)
        return assignedRoot

    def isTxnAccountAssignedRoot(_txn, _fix=False, _accounts=None):
        if _fix and _accounts is None: raise Exception("ERROR: isTxnAccountAssignedRoot() Fix, _accounts must not be None")
        if not isinstance(_txn, ParentTxn) or _txn.getOtherTxnCount() < 1: return False
        # noinspection PyUnresolvedReferences
        isTxnAssignedRoot = isSplitTxnAccountAssignedRoot(_txn,
                                                          _fix,
                                                          _accounts,
                                                          (Account.AccountType.INVESTMENT if (isInvestmentTxn(_txn)) else Account.AccountType.BANK))
        for i in range(0, _txn.getOtherTxnCount()):
            # noinspection PyUnresolvedReferences
            if isSplitTxnAccountAssignedRoot(_txn.getOtherTxn(i), _fix, _accounts, Account.AccountType.EXPENSE):
                isTxnAssignedRoot = True
        return isTxnAssignedRoot

    def isInvestmentTxn(_txn):
        if not isinstance(_txn, ParentTxn) or _txn.getOtherTxnCount() < 1: return False
        # noinspection PyUnresolvedReferences
        if _txn.getAccount() is not None and _txn.getAccount().getAccountType() == Account.AccountType.INVESTMENT: return True
        if _txn.getParameter("invest.txntype", None) is not None: return True
        if _txn.getParameter("xfer_type", None) is not None: return True
        for i in range(0, _txn.getOtherTxnCount()):
            split = _txn.getOtherTxn(i)
            if split.getParameter("invest.splittype", None) is not None: return True
        return False

    def checkForTxnsAssignedRoot(lFix=False, accounts=None):
        if lFix and accounts is None: raise Exception("ERROR: checkForTxnsAssignedRoot() Fix, accounts must not be None")
        _countValid = _countAssignedRoot = _countInvestmentAssignedRoot = 0
        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        for txn in txnSet:
            if not isinstance(txn, ParentTxn): continue
            if isTxnAccountAssignedRoot(txn, lFix, accounts):
                _countAssignedRoot += 1
                if isInvestmentTxn(txn):
                    _countInvestmentAssignedRoot += 1
                if lFix: txn.syncItem()
            else:
                _countValid += 1
        return _countValid, _countAssignedRoot, _countInvestmentAssignedRoot


    def detect_fix_txns_assigned_root():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "DETECT / FIX TXNS ASSIGNED TO 'ROOT'"
        PARAMETER_KEY = "toolbox_detect_fix_txns_assigned_root"

        countValid, countAssignedRoot, countInvestmentAssignedRoot = checkForTxnsAssignedRoot()

        if countAssignedRoot < 1:
            myPopupInformationBox(toolbox_frame_, "You have no transactions assigned to 'root' account - no changes made", _THIS_METHOD_NAME)
            return

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        book = MD_REF.getCurrentAccountBook()

        # myPopupInformationBox(toolbox_frame_, "WARNING: %s txns assigned to 'root' out of %s parent txns (%s are Investments)" %(countAssignedRoot, countValid, countInvestmentAssignedRoot), _THIS_METHOD_NAME)

        txt = "WARNING: %s txns assigned to 'root' out of %s parent txns [%s are Investment(s)]" %(countAssignedRoot, countValid, countInvestmentAssignedRoot)
        diagPanel = JPanel(GridLayout(0, 1))
        diagPanel.add(JLabel(txt))
        _options = ["Cancel", "VIEW REGISTER(s)", "AUTO-FIX"]

        userResponse = JOptionPane.showOptionDialog(toolbox_frame_,
                                                  diagPanel,
                                                  _THIS_METHOD_NAME.upper(),
                                                  JOptionPane.OK_CANCEL_OPTION,
                                                  JOptionPane.QUESTION_MESSAGE,
                                                  getMDIcon(None),
                                                  _options,
                                                  _options[0])

        if userResponse < 1:
            txt = "%s: User did not select option - no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt)
            return

        if userResponse == 1:
            # View REGISTER
            # prefs = MD_REF.getPreferences(); twoLines = prefs.getBoolSetting("gui.two_line_transactions", False)

            class MyTxnAcctSearch(TxnSearch):
                def __init__(self, lAll=True, lInvestments=False):
                    self.lAll = lAll
                    self.lInvestments = lInvestments

                def matches(self, _txn):
                    assignedRoot = isTxnAccountAssignedRoot(_txn)
                    if not assignedRoot or self.lAll: return assignedRoot
                    foundInvestment = isInvestmentTxn(_txn)
                    if (not self.lInvestments and not foundInvestment) or (self.lInvestments and foundInvestment):
                        return assignedRoot
                    return False

                def matchesAll(self): return False

            offset = 75
            w, h = 1200, 500
            toolboxLocation = toolbox_frame_.getLocation()
            toolboxLocation.x += offset; toolboxLocation.y += offset

            if (countAssignedRoot - countInvestmentAssignedRoot) > 0:
                popupTxnRegister = MyPopupRegister("TRANSACTIONS INCORRECTLY ASSIGNED TO ROOT (non Investments)",
                                                   TxnRegisterType,
                                                   MyTxnAcctSearch(lAll=False, lInvestments=False),
                                                   parent=toolbox_frame_,
                                                   editableRegister=True,
                                                   modal=False)


                AwtUtil.setupWindow(popupTxnRegister, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                toolboxLocation.x += offset; toolboxLocation.y += offset
                popupTxnRegister.setVisible(True)

            if countInvestmentAssignedRoot > 0:
                popupInvestTxnRegister = MyPopupRegister("INVESTMENT TRANSACTIONS INCORRECTLY ASSIGNED TO ROOT",
                                                         InvestRegisterType,
                                                         MyTxnAcctSearch(lAll=False, lInvestments=True),
                                                         parent=toolbox_frame_,
                                                         editableRegister=debug,
                                                         modal=False)
                AwtUtil.setupWindow(popupInvestTxnRegister, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                toolboxLocation.x += offset; toolboxLocation.y += offset
                popupInvestTxnRegister.setVisible(True)

            txt = "%s: Txns Assigned to Root displayed in Register(s) so that user can view/amend" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            return

        # AUTOFIX ###############################################
        if not confirm_backup_confirm_disclaimer(toolbox_frame_,
                                                 _THIS_METHOD_NAME,
                                                 "AUTO-FIX %s txns assigned to 'root' account?" %(countAssignedRoot)):
            return

        class HoldAutoFixAccounts:
            accountName = "* TOOLBOX: %s (DELETE AFTER USE/WHEN EMPTY) **" %(_THIS_METHOD_NAME)

            def __init__(self): self.accounts = {}

            def getAccount(self, accountType):
                if accountType not in self.accounts:
                    newAccount = Account.makeAccount(book, accountType, book.getRootAccount())
                    newAccount.setAccountName(HoldAutoFixAccounts.accountName + " (%s)" %(accountType))
                    newAccount.setAccountDescription("DUMMY ACCOUNT..... PLEASE REVIEW AND FIX THESE TXNS (DELETE WHEN EMPTY)")
                    # noinspection PyUnresolvedReferences
                    if accountType == Account.AccountType.INVESTMENT:
                        newAccount.setPreference("sel_inv_view", "sec_register_view")
                        newAccount.setParameter("gen.asked_to_add_security", True)
                    newAccount.setParameter(PARAMETER_KEY, True)
                    newAccount.syncItem()
                    myPrint("B", "%s: Made account:" %(_THIS_METHOD_NAME), newAccount)
                    self.accounts[accountType] = newAccount
                return self.accounts[accountType]

        holdAutoFixAccounts = HoldAutoFixAccounts()
        checkForTxnsAssignedRoot(lFix=True, accounts=holdAutoFixAccounts)

        fix_non_hier_sec_acct_txns(autofix=True)

        extraSecurityText = ""
        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            extraSecurityText = "\nERROR - Cross-linked (or Orphaned) security txns detected..\n" \
                                ".....I've already run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)'\n" \
                                ".....>> NEEDS MANUAL INVESTIGATION'\n"

        txt = "%s: AUTO-FIX applied to %s Parent txns [%s investment txn(s)]" %(_THIS_METHOD_NAME, countAssignedRoot, countInvestmentAssignedRoot)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        MyPopUpDialogBox(toolbox_frame_,
                         theStatus=txt,
                         theMessage="Please review console and also the contents of NEW temporary accounts/categories\n"
                                    "Go to Menu Tools>Accounts / Tools>Categories and look for: '%s'\n"
                                    "You will need to reassign these Accounts/Categories as needed\n"
                                    "... There may be up to 1 Bank Account, 1 Investment Account, 1 Expense Category\n"
                                    "%s"
                                    %(HoldAutoFixAccounts.accountName, extraSecurityText),
                         theTitle=_THIS_METHOD_NAME).go()

        try:
            # OK, let's show the new accounts/registers to the user.....
            offset = 75
            w, h = 1150, 650
            toolboxLocation = toolbox_frame_.getLocation()
            toolboxLocation.x += offset; toolboxLocation.y += offset

            for acctT in holdAutoFixAccounts.accounts:
                selectAccount = holdAutoFixAccounts.accounts[acctT]

                # mf = MainFrame(MD_REF.getUI(), MD_REF.getCurrentAccountBook())
                # mf.selectAccount(selectAccount)
                # if isinstance(mf, JFrame): pass
                # mf.setExtendedState(JFrame.NORMAL)
                # AwtUtil.setupWindow(mf, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                # toolboxLocation.x += offset; toolboxLocation.y += offset
                # mf.setVisible(True)

                class MyTxnAcctSearch(TxnSearch):
                    def __init__(self, account):
                        self.account = account

                    def matches(self, _txn):
                        if _txn.getAccount() == self.account: return True
                        return False

                    def matchesAll(self): return False

                # noinspection PyUnresolvedReferences
                popupTxnRegister = MyPopupRegister("TRANSACTIONS REASSIGNED TO NEW ACCOUNT: %s" %(selectAccount),
                                                   InvestRegisterType if (selectAccount.getAccountType() == Account.AccountType.INVESTMENT) else TxnRegisterType,
                                                   MyTxnAcctSearch(selectAccount),
                                                   parent=toolbox_frame_,
                                                   editableRegister=True,
                                                   modal=False)

                AwtUtil.setupWindow(popupTxnRegister, w, h, toolboxLocation.x, toolboxLocation.y, toolbox_frame_)
                toolboxLocation.x += offset; toolboxLocation.y += offset
                popupTxnRegister.setVisible(True)

        except: pass

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def thin_price_history():
        # based on: price_history_thinner.py
        # (also includes elements from 2017_remove_orphaned_currency_history_entries.py)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return
        if MD_REF.getCurrentAccount().getBook().getSyncer() is None: return
        if MD_REF.getCurrentAccount().getBook().getSyncer().getSyncedDocument() is None: return

        if GlobalVars.lMustRestartAfterSnapChanges:
            x="Sorry - you have to RESTART MD after running 'FIX - Thin/Purge Price History' to update the csnap cache....."
            myPrint("B",x)
            setDisplayStatus(x, "R")
            myPopupInformationBox(toolbox_frame_,x,"FIX - THIN/PURGE PRICE HISTORY",JOptionPane.ERROR_MESSAGE)
            return

        txt = "Purge/Thin Price History"
        if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


        # prune historical exchange rates and price history from the given currency
        # this thins price history older than a year by keeping no more than one price per week
        # prices within the last year (or the age_limit_days parameter) are not removed

        totalChangesMade = 0

        diagDisplay = "DIAGNOSE CURRENCY PRICE HISTORY (csnaps)\n"
        diagDisplay += " =======================================\n\n"

        def objects_by_type():
            text = "Objects by type summary:\n"
            objectTypes = [ CurrencyType.SYNCABLE_TYPE_VALUE, CurrencySnapshot.SYNCABLE_TYPE_VALUE, CurrencySplit.SYNCABLE_TYPE_VALUE]
            for objectType in objectTypes:
                xx=""
                if objectType == CurrencyType.SYNCABLE_TYPE_VALUE: xx=" (Currency/Security records)"                     # noqa
                if objectType == CurrencySnapshot.SYNCABLE_TYPE_VALUE: xx=" (Currency/Security price history records)"   # noqa
                if objectType == CurrencySplit.SYNCABLE_TYPE_VALUE: xx=" (Security Stock Split records)"                 # noqa
                objects = MD_REF.getCurrentAccount().getBook().getItemsWithType(objectType)
                text+="  %s: %s %s\n"%(pad(objectType,9), rpad(len(objects),12), xx)
            text+="\n"
            return text

        diagDisplay += objects_by_type()

        def hunt_down_orphans():
            # Hunt down the poor little orphans...!
            orphanSnaps = totalSnaps = 0                                                                        # noqa
            text = ""
            saveRawSnaps={}
            for mdItem in MD_REF.getRootAccount().getBook().getSyncer().getSyncedDocument().allItems():
                if not (isinstance(mdItem, MoneydanceSyncableItem)): continue
                if mdItem.getParameter("obj_type", None) != CurrencySnapshot.SYNCABLE_TYPE_VALUE: continue
                saveRawSnaps[mdItem.getParameter("id")] = mdItem
            _currencies = MD_REF.getCurrentAccount().getBook().getCurrencies()
            for _curr in _currencies:
                snapshots = _curr.getSnapshots()
                for snap in snapshots:
                    saveRawSnaps.pop(snap.getParameter("id"))

            oList=[]
            if len(saveRawSnaps)>0:
                lAllValid=True
                for _value in saveRawSnaps.values():
                    if not _value.getCurrencyParameter(None, "curr", None): lAllValid=False
                    oList.append(_value)
                if lAllValid:
                    # Sort and make pretty for Derek ;->
                    oList = sorted(oList, key=lambda sort_x: (sort_x.getCurrencyParameter(None, "curr", None).getCurrencyType(),sort_x.getParameter("curr", None),sort_x.getDateInt()))

                _last = None
                for _x in oList:
                    orphanSnaps += 1
                    chk = _x.getCurrencyParameter(None, "curr", None)
                    if chk: chk = _x.getCurrencyParameter(None, "curr", None).getCurrencyType()
                    if _last != chk:
                        text+=" \n%s:\n" %(chk)
                        _last = chk
                    if debug:
                        text+=" >> Orp/Dup: %s %s\n" %(_x.getUUID(),_x)
                    else:
                        text+=" >> Orp/Dup: %s\n" %(_x)

            for snap in MD_REF.getCurrentAccount().getBook().getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE):
                totalSnaps += 1
                if snap.getParameter("curr", None) is None or MD_REF.getCurrentAccount().getBook().getItemForID(snap.getParameter("curr", None)) is None:
                    if not saveRawSnaps.get(snap.getParameter("id",None)):
                        orphanSnaps += 1
                        saveRawSnaps[snap.getParameter("id")] = snap
                        if debug:
                            text+=" >> Orp (no Curr): %s %s\n" %(snap.getUUID(), snap)
                        else:
                            text+=" >> Orp (no Curr): %s\n" %(snap)
                        oList.append(snap)

            if orphanSnaps:
                text+="\nWARNING: %s of %s currency or security snapshots were orphans/duplicates/stranded (or had no Currency link)\n" %(orphanSnaps, totalSnaps)
                text+="(NOTE: The system 'hides' duplicate price history records for the same currency/date.....)   \n"
            else:
                text+="No price history snapshot orphans/duplicates detected!\n"

            del saveRawSnaps

            oList = sorted(oList, key=lambda sort_x: (sort_x.getParameter("curr", None),sort_x.getDateInt()))

            return text, orphanSnaps, oList

        txt, orphanSnaps, orphans_to_delete = hunt_down_orphans()
        diagDisplay += txt

        def snaps_by_currency():
            text = ""
            _currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            _currencies = sorted(_currencies, key=lambda sort_x: (sort_x.getName().upper()))
            lastC = None
            # noinspection PyUnresolvedReferences
            iAll=iCurrs=iSecs=0
            for theCType in [CurrencyType.Type.CURRENCY, CurrencyType.Type.SECURITY]:                           # noqa
                for _currency in _currencies:
                    if _currency.getCurrencyType() != theCType: continue
                    iAll+=1
                    if _currency.getCurrencyType() == CurrencyType.Type.CURRENCY: iCurrs+=1                     # noqa
                    if _currency.getCurrencyType() == CurrencyType.Type.SECURITY: iSecs+=1                      # noqa
                    if lastC != _currency.getCurrencyType():
                        text+="\n%s:\n" % _currency.getCurrencyType()
                        lastC = _currency.getCurrencyType()
                    _snapshots = _currency.getSnapshots()
                    text+="  %s (snapshots: %s, splits: %s)\n" %(pad(_currency.getName(), 45), rpad(_snapshots.size(),10), rpad(_currency.getSplits().size(),10))

            text+="\n-----\nTotal Curr/Sec listed: %s Currencies: %s Securities: %s\n" %(iAll,iCurrs,iSecs)

            return text

        diagDisplay += snaps_by_currency()

        def does_base_has_snaps(lDelete=False,lVerbose=True):

            baseCurr = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()
            baseSnapshots = baseCurr.getSnapshots()

            iCountBaseSnapsDeleted = 0
            text = ""
            if baseSnapshots.size() > 0:
                text += "ERROR: base currency %s has %s historical prices! These should be deleted!" % (baseCurr, baseSnapshots.size())
                if lDelete and not lVerbose: myPrint("J","@@ Deleting all snapshots from base Currency @@")
                for baseSnapshot in baseSnapshots:
                    if lDelete:
                        if lVerbose:
                            text += "  @@DELETING@@: %s\n" %(baseSnapshot)
                            myPrint("J","Deleting Base Currency snapshot: %s" %(baseSnapshot))
                        baseSnapshot.deleteItem()
                        iCountBaseSnapsDeleted+=1
                    else:
                        if lVerbose:
                            text += "  snapshot: %s\n" %(baseSnapshot)
            else:
                text += "\n\nBase currency %s has NO historical prices! These is correct!\n\n" % (baseCurr)

            return text, iCountBaseSnapsDeleted

        x, y = does_base_has_snaps()
        diagDisplay += x

        jif = QuickJFrame("Price History Analysis", diagDisplay,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()


        if orphanSnaps>0:
            MyPopUpDialogBox(jif,
                             "YOU HAVE ORPHAN/STRANDED Price History Records - READ THIS FIRST",
                             theMessage="These are either 'Orphaned' records with no Currency linkage;\n"
                                        "or they are duplicated records (i.e. multiple records with the same date due to a MD bug)..\n"
                                        "These are 'stranded' / hidden from view. Once you delete the visible record, any Orphan on the same date will reappear\n"
                                        "BEST PRACTICE (after reviewing the Simulation Log) is as follows:\n"
                                        "1. Select 'Only Delete Orphans Mode' and ALL Currencies and ALL Securities. Then Execute\n"
                                        "2. Exit and restart Moneydance (as MD's cache needs refreshing)\n"
                                        "3. Come back here and then choose your desired Purge/Thin mode (if required - optional)\n"
                                        "If you don't follow this sequence, then as you purge, previously hidden records will start appearing\n"
                                        "..(inside or outside the purge/thin window date range you selected)\n"
                                        "(NOTE: Any 'Orphans' that start appearing are harmless, it means they've become visible)",
                             theTitle="THIN/PURGE PRICE HISTORY",
                             OKButtonText="ACKNOWLEDGE",lAlertLevel=1).go()

        saveColor = JLabel("TEST").getForeground()

        # prune historical exchange rates and price history from the given currency
        # this thins price history older than a year by keeping no more than one price per week
        # prices within the last year (or the age_limit_days parameter) are not removed

        dropdownCurrs=ArrayList()
        dropdownSecs=ArrayList()
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() == CurrencyType.Type.CURRENCY: dropdownCurrs.add(curr)                    # noqa
            if curr.getCurrencyType() == CurrencyType.Type.SECURITY: dropdownSecs.add(curr)                     # noqa
        dropdownCurrs=sorted(dropdownCurrs, key=lambda sort_x: (sort_x.getName().upper()))
        dropdownSecs=sorted(dropdownSecs, key=lambda sort_x: (sort_x.getName().upper()))
        dropdownCurrs.insert(0,"<EXCLUDE Currencies>")
        dropdownCurrs.insert(0,"<ALL Currencies>")
        dropdownSecs.insert(0,"<EXCLUDE Securities>")
        dropdownSecs.insert(0,"<ALL Securities>")
        del currencies

        label_simulate = JLabel("Simulate with no changes?")
        user_simulate = JCheckBox("(Uncheck to make changes)", True)
        user_simulate.setName("user_simulate")

        purgeStrings = ["<DO NOTHING>",
                        "Thin Mode (Thin older than cutoff)",
                        "Purge Mode (Delete all older than cutoff)",
                        "Only Delete Orphans Mode (No Purge/Thin, just Delete Orphans)"]

        if MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0:
            purgeStrings.append("Only Delete Base Records (No Purge/Thin, just Delete Base Records)")

        labelPurgeOrThinMode = JLabel("Select the mode of operation:")
        user_purgeOrThinMode = JComboBox(purgeStrings)
        user_purgeOrThinMode.setName("user_purgeOrThinMode")
        user_purgeOrThinMode.setSelectedIndex(0)

        label_age_limit_days = JLabel("Thin/Purge records older than how many days? (1 to 1825 days)")
        user_age_limit_days = JTextField(5)
        user_age_limit_days.setDocument(JTextFieldLimitYN(5, False, "CURR"))
        user_age_limit_days.setText("")
        user_age_limit_days.setName("user_age_limit_days")
        user_age_limit_days.setEnabled(False)

        label_max_days_between_thinned = JLabel("When Thinning, keep no more than one price per x days? (1 to 31 days)")
        user_max_days_between_thinned = JTextField(3)
        user_max_days_between_thinned.setDocument(JTextFieldLimitYN(3, False, "CURR"))
        user_max_days_between_thinned.setText("")
        user_max_days_between_thinned.setName("user_max_days_between_thinned")
        user_max_days_between_thinned.setEnabled(False)

        label_includeCurrencies = JLabel("Thin/purge Currencies (All/Exclude/Select)?")
        user_includeCurrencies = JComboBox(dropdownCurrs)
        user_includeCurrencies.setSelectedIndex(1)
        user_includeCurrencies.setName("user_includeCurrencies")
        user_includeCurrencies.setEnabled(False)

        label_includeSecurities = JLabel("Thin/purge Securities (All/Exclude/Select)?")
        user_includeSecurities = JComboBox(dropdownSecs)
        user_includeSecurities.setSelectedIndex(1)
        user_includeSecurities.setName("user_includeSecurities")
        user_includeSecurities.setEnabled(False)

        labelPurgeOrphans = JLabel("While Purging/Thinning, also delete any/all Orphan/duplicate Snapshots found?")
        user_purgeOrphans = JCheckBox("(will only delete Orphans matching your ^^Curr/Sec^^ filters above)", False)
        user_purgeOrphans.setEnabled( orphanSnaps>0 )
        user_purgeOrphans.setName("user_purgeOrphans")
        user_purgeOrphans.setEnabled(False)

        labelPurgeBase = JLabel("While Purging/Thinning, also delete all Snapshots found on Base Currency?")
        user_purgeBase = JCheckBox("(will delete all Base Currency snapshots)", False)
        user_purgeBase.setEnabled(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0 )
        user_purgeBase.setName("user_purgeBase")
        user_purgeBase.setEnabled(False)

        labelSaveTrunk = JLabel("Consolidate into new Trunk File after mass thin/purge process?")
        user_SaveTrunk = JCheckBox("(compacts/rewrites Dataset (trunk file) & clears *.mdtxn files)", False)
        user_SaveTrunk.setName("user_SaveTrunk")
        user_SaveTrunk.setEnabled(False)

        labelVERBOSE = JLabel("VERBOSE mode = Extra logfile output on all steps?")
        user_VERBOSE = JCheckBox("", False)
        user_VERBOSE.setName("user_VERBOSE")
        user_VERBOSE.setEnabled(False)

        labelSTATUS = JLabel("")
        labelSTATUS2 = JLabel("")

        userFilters = JPanel(GridLayout(0, 2))

        class PanelAction(AbstractAction):

            def __init__(self, thePanel, iOrphs):
                self.thePanel=thePanel
                self.iOrphs=iOrphs

            def actionPerformed(self, event):                                                                   # noqa
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event)

                the_simulate = None
                the_purgeOrThinMode = None
                the_age_limit_days = None
                the_max_days_between_thinned = None
                the_includeCurrencies = None
                the_includeSecurities = None
                the_purgeOrphans = None
                the_purgeBase = None
                the_SaveTrunk = None
                the_VERBOSE = None
                saveDropDownStateToo = None

                _components = self.thePanel.getComponents()
                for _theComponent in _components:

                    if isinstance(_theComponent, (JComboBox, JTextField, JCheckBox, JButton)):
                        if event.getSource().getName() == _theComponent.getName():
                            if _theComponent.getName() == "user_purgeOrThinMode": the_purgeOrThinMode  = _theComponent

                        if _theComponent.getName() == "user_purgeOrThinMode": saveDropDownStateToo  = _theComponent
                        if _theComponent.getName() == "user_simulate": the_simulate  = _theComponent
                        if _theComponent.getName() == "user_includeCurrencies": the_includeCurrencies  = _theComponent
                        if _theComponent.getName() == "user_includeSecurities": the_includeSecurities  = _theComponent
                        if _theComponent.getName() == "user_purgeOrphans": the_purgeOrphans  = _theComponent
                        if _theComponent.getName() == "user_purgeBase": the_purgeBase  = _theComponent
                        if _theComponent.getName() == "user_age_limit_days": the_age_limit_days  = _theComponent
                        if _theComponent.getName() == "user_max_days_between_thinned": the_max_days_between_thinned  = _theComponent
                        if _theComponent.getName() == "user_SaveTrunk": the_SaveTrunk  = _theComponent
                        if _theComponent.getName() == "user_VERBOSE": the_VERBOSE  = _theComponent

                if the_simulate:
                    if not the_simulate.isSelected():
                        if saveDropDownStateToo.getSelectedIndex() > 0:
                            the_SaveTrunk.setEnabled(True)
                        else:
                            the_SaveTrunk.setEnabled(False)
                            the_SaveTrunk.setSelected(False)
                    else:
                        the_SaveTrunk.setEnabled(False)
                        the_SaveTrunk.setSelected(False)

                # noinspection PyUnresolvedReferences
                if the_purgeOrThinMode:
                    if the_purgeOrThinMode.getSelectedItem().lower().startswith("<DO NOTHING>".lower()):        # noqa
                        the_age_limit_days.setEnabled(False)
                        the_max_days_between_thinned.setEnabled(False)
                        the_includeCurrencies.setEnabled(False)
                        the_includeSecurities.setEnabled(False)
                        the_purgeOrphans.setEnabled(False)
                        the_purgeBase.setEnabled(False)
                        the_SaveTrunk.setEnabled(False)
                        the_VERBOSE.setEnabled(False)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Thin Mode".lower()):         # noqa
                        the_age_limit_days.setEnabled(True)
                        the_age_limit_days.setText("90")
                        the_max_days_between_thinned.setEnabled(True)
                        the_max_days_between_thinned.setText("7")
                        the_includeCurrencies.setEnabled(True)
                        the_includeSecurities.setEnabled(True)
                        the_purgeOrphans.setEnabled(self.iOrphs>0)
                        the_purgeBase.setEnabled(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0)
                        the_SaveTrunk.setEnabled(True)
                        the_VERBOSE.setEnabled(True)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Purge Mode".lower()):        # noqa
                        the_age_limit_days.setEnabled(True)
                        the_age_limit_days.setText("730")
                        the_max_days_between_thinned.setText("")
                        the_max_days_between_thinned.setEnabled(False)
                        the_includeCurrencies.setEnabled(True)
                        the_includeSecurities.setEnabled(True)
                        the_purgeOrphans.setEnabled(self.iOrphs>0)
                        the_purgeBase.setEnabled(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0)
                        the_SaveTrunk.setEnabled(True)
                        the_VERBOSE.setEnabled(True)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Only Delete Orphans".lower()):  # noqa
                        if self.iOrphs>0:
                            the_age_limit_days.setEnabled(False)
                            the_age_limit_days.setText("")
                            the_max_days_between_thinned.setText("")
                            the_max_days_between_thinned.setEnabled(False)
                            the_includeCurrencies.setEnabled(True)
                            the_includeCurrencies.setSelectedIndex(1)
                            the_includeSecurities.setEnabled(True)
                            the_includeSecurities.setSelectedIndex(1)
                            the_purgeOrphans.setEnabled(False)
                            the_purgeOrphans.setSelected(False)
                            the_purgeBase.setEnabled(False)
                            the_purgeBase.setSelected(False)
                            the_VERBOSE.setEnabled(True)
                            if not(the_simulate.isSelected()):
                                the_SaveTrunk.setEnabled(True)
                        else:
                            the_purgeOrThinMode.setSelectedIndex(0)
                    elif the_purgeOrThinMode.getSelectedItem().lower().startswith("Only Delete Base Records".lower()):  # noqa
                        if MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size()>0:
                            the_age_limit_days.setEnabled(False)
                            the_age_limit_days.setText("")
                            the_max_days_between_thinned.setText("")
                            the_max_days_between_thinned.setEnabled(False)
                            the_includeCurrencies.setEnabled(False)
                            the_includeCurrencies.setSelectedIndex(1)
                            the_includeSecurities.setEnabled(False)
                            the_includeSecurities.setSelectedIndex(1)
                            the_purgeOrphans.setEnabled(False)
                            the_purgeOrphans.setSelected(False)
                            the_purgeBase.setEnabled(False)
                            the_purgeBase.setSelected(False)
                            the_VERBOSE.setEnabled(True)
                            if not(the_simulate.isSelected()):
                                the_SaveTrunk.setEnabled(True)
                        else:
                            the_purgeOrThinMode.setSelectedIndex(0)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        userFilters.add(label_simulate)
        userFilters.add(user_simulate)
        userFilters.add(labelPurgeOrThinMode)
        userFilters.add(user_purgeOrThinMode)
        userFilters.add(label_age_limit_days)
        userFilters.add(user_age_limit_days)
        userFilters.add(label_max_days_between_thinned)
        userFilters.add(user_max_days_between_thinned)
        userFilters.add(label_includeCurrencies)
        userFilters.add(user_includeCurrencies)
        userFilters.add(label_includeSecurities)
        userFilters.add(user_includeSecurities)
        userFilters.add(labelPurgeOrphans)
        userFilters.add(user_purgeOrphans)
        userFilters.add(labelPurgeBase)
        userFilters.add(user_purgeBase)
        userFilters.add(labelSaveTrunk)
        userFilters.add(user_SaveTrunk)
        userFilters.add(labelVERBOSE)
        userFilters.add(user_VERBOSE)
        userFilters.add(labelSTATUS)
        userFilters.add(labelSTATUS2)

        components = userFilters.getComponents()
        for theComponent in components:
            if isinstance(theComponent, (JComboBox,JTextField,JCheckBox)):
                theComponent.addActionListener(PanelAction( userFilters, orphanSnaps))

        while True:
            options = ["EXIT", "PROCEED"]
            userAction = (JOptionPane.showOptionDialog(jif,
                                                       userFilters,
                                                       "THIN PRICE HISTORY",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))
            if userAction != 1:
                txt = "THIN PRICE HISTORY - No changes made....."
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            lDoNOTHING = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 0
            lThinMode = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 1
            lPurgeMode = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 2
            purgeOrphansONLY = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 3
            purgeBaseONLY = purgeStrings.index(user_purgeOrThinMode.getSelectedItem())== 4

            simulate = user_simulate.isSelected()
            age_limit_days = user_age_limit_days.getText()
            max_days_between_thinned = user_max_days_between_thinned.getText()
            purgeOrphans = user_purgeOrphans.isSelected()
            purgeBase = user_purgeBase.isSelected()
            confirmedSaveTrunk = user_SaveTrunk.isSelected()
            VERBOSE = user_VERBOSE.isSelected()

            if isinstance(user_includeCurrencies.getSelectedItem(),(str,unicode)):
                if str(user_includeCurrencies.getSelectedItem()).startswith("<ALL"):
                    includeCurrencies=True
                elif str(user_includeCurrencies.getSelectedItem()).startswith("<EXCL"):
                    includeCurrencies=False
                else:
                    raise(Exception("THIN PRICE HISTORY INCLUDE CURRENCIES PARAMETER ERROR"))
            elif isinstance(user_includeCurrencies.getSelectedItem(),(CurrencyType)):
                includeCurrencies = user_includeCurrencies.getSelectedItem()
            else:
                raise(Exception("THIN PRICE HISTORY INCLUDE CURRENCIES PARAMETER ERROR2"))

            if isinstance(user_includeSecurities.getSelectedItem(),(str,unicode)):
                if str(user_includeSecurities.getSelectedItem()).startswith("<ALL"):
                    includeSecurities=True
                elif str(user_includeSecurities.getSelectedItem()).startswith("<EXCL"):
                    includeSecurities=False
                else:
                    raise(Exception("THIN PRICE HISTORY INCLUDE SECURITIES PARAMETER ERROR"))
            elif isinstance(user_includeSecurities.getSelectedItem(),(CurrencyType)):
                includeSecurities = user_includeSecurities.getSelectedItem()
            else:
                raise(Exception("THIN PRICE HISTORY INCLUDE SECURITIES PARAMETER ERROR2"))

            paramError=False
            labelSTATUS.setText("")
            labelSTATUS.setForeground(getColorRed())

            if lDoNOTHING:
                labelSTATUS.setText("ERROR: I CANNOT DO NOTHING? PLEASE CHOOSE AN OPTION!")
                continue

            if lThinMode or lPurgeMode:
                # noinspection PyChainedComparsons
                if not StringUtils.isInteger(age_limit_days) or not (int(age_limit_days) >0 and int(age_limit_days) <= (365*5)):        # noqa
                    user_age_limit_days.setForeground(getColorRed())
                    labelSTATUS.setText("ERROR: age limit days parameter must be between 0 and 1825 (5 years)")
                    paramError=True
                else:
                    age_limit_days=int(age_limit_days)
                    user_age_limit_days.setForeground(saveColor)
            else:
                age_limit_days=0

            if lThinMode:
                # noinspection PyChainedComparsons
                if not StringUtils.isInteger(max_days_between_thinned) or not (int(max_days_between_thinned) >0 and int(max_days_between_thinned) <= (31)):   # noqa
                    user_max_days_between_thinned.setForeground(getColorRed())
                    labelSTATUS.setText("ERROR: max days between dates parameter must be between 0 and 31")
                    paramError=True
                else:
                    max_days_between_thinned=int(max_days_between_thinned)
                    user_max_days_between_thinned.setForeground(saveColor)
            else:
                max_days_between_thinned = 0

            if purgeOrphans and purgeOrphansONLY:
                user_purgeOrphans.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: you cannot select both purge Orphans and purge ONLY orphans")
                paramError=True
            else:
                user_purgeOrphans.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if (purgeOrphans or purgeOrphansONLY) and orphanSnaps < 1:
                user_purgeOrphans.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: You have no Orphan records to purge - please deselect these options")
                paramError=True
            else:
                user_purgeOrphans.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if purgeBase and purgeBaseONLY:
                user_purgeBase.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: you cannot select both delete Base records and delete ONLY base records")
                paramError=True
            else:
                user_purgeBase.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if (purgeBase or purgeBaseONLY) and MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType().getSnapshots().size() < 1:
                user_purgeBase.setForeground(getColorRed())
                user_purgeOrThinMode.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: You have no Base Currency snapshot records to delete - please deselect these options")
                paramError=True
            else:
                user_purgeBase.setForeground(saveColor)
                user_purgeOrThinMode.setForeground(saveColor)

            if not includeCurrencies and not includeSecurities and (lThinMode or lPurgeMode or purgeOrphansONLY):
                user_includeSecurities.setForeground(getColorRed())
                user_includeCurrencies.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: Please select Security(s) / Currency(s) to process/filter...")
                paramError = True
            else:
                user_includeSecurities.setForeground(saveColor)
                user_includeCurrencies.setForeground(saveColor)

            if (includeCurrencies or includeSecurities) and (purgeBaseONLY):
                user_includeSecurities.setForeground(getColorRed())
                user_includeCurrencies.setForeground(getColorRed())
                labelSTATUS.setText("ERROR: Delete Base Currency records IGNORES filters. Please Deselect Security(s) / Currency(s) filter(s)...")
                paramError = True
            else:
                user_includeSecurities.setForeground(saveColor)
                user_includeCurrencies.setForeground(saveColor)

            if paramError: continue

            break

        components = userFilters.getComponents()
        for theComponent in components:
            if isinstance(theComponent, (JComboBox,JTextField, JCheckBox)):
                for al in theComponent.getActionListeners():
                    theComponent.removeActionListener(al)
        del userFilters

        if lDoNOTHING: raise Exception("ERROR: Why is lDoNOTHING set?")

        if not simulate:
            if not confirm_backup_confirm_disclaimer(jif, "THIN PRICE HISTORY", "Thin Price History?"):
                return

        jif.dispose()       # already within the EDT

        myPrint("B","THIN PRICE HISTORY - User choose parameters: "
                    "Simulate: %s "
                    "Thin Mode: %s "
                    "Purge Mode: %s "
                    "age_limit_days: %s "
                    "max_days_between_thinned: %s "
                    "includeCurrencies: %s "
                    "includeSecurities: %s "
                    "purgeOrphans: %s "
                    "purgeOrphansONLY: %s "
                    "purgeBase: %s"
                    "purgeBaseONLY: %s"
                    "SaveTrunk: %s"
                    "verbose: %s"
                %(simulate, lThinMode, lPurgeMode, age_limit_days, max_days_between_thinned, includeCurrencies, includeSecurities, purgeOrphans, purgeOrphansONLY, purgeBase, purgeBaseONLY, confirmedSaveTrunk,  VERBOSE))

        del orphanSnaps

        def prune_snapshots(_curr, THINMODE, age_limit_days, max_days_between_thinned, lDelete=False, lVerbose=False):        # noqa

            if THINMODE: ThnTxt="THIN"
            else: ThnTxt="PURGE"

            age_limit_date = DateUtil.incrementDate(DateUtil.getStrippedDateInt(), 0, 0, -(age_limit_days))
            text = "\n>%s: %s'ing snapshots older than %s\n" %(_curr, ThnTxt, convertStrippedIntDateFormattedText(age_limit_date))
            text += "  %s BEFORE %s (snapshots: %s, splits: %s)\n"%(_curr, ThnTxt, _curr.getSnapshots().size(), _curr.getSplits().size())
            _snapshots = _curr.getSnapshots()
            old_snapshots = []
            countChanges  = 0
            saveFirstSnapPreserved = None
            for snapshot in _snapshots:
                if snapshot.getDateInt() < age_limit_date:
                    if len(old_snapshots)+1 >= len(_snapshots):
                        text += "  > NOTE: Preserving the newest and last Price History record (so you always have 1): %s\n" %snapshot
                        saveFirstSnapPreserved = snapshot.getDateInt()
                    else:
                        old_snapshots.append(snapshot)
                else:
                    if saveFirstSnapPreserved is None:
                        saveFirstSnapPreserved = snapshot.getDateInt()

            if saveFirstSnapPreserved is None:
                myPrint("B","@@ LOGIC ERROR why saveFirstSnapPreserved == None?")
                saveFirstSnapPreserved = age_limit_date

            last_date = 0
            text += "  %s snapshot(s) are older than cutoff date and eligible to be %s'd'..\n" %(len(old_snapshots),ThnTxt)
            num_thinned = 0
            # This presumes the data is presented oldest, to newest, which the inbuilt comparator/sort seems to do...

            # for snapshot in old_snapshots:
            for _i in range(0, len(old_snapshots)):
                snapshot = old_snapshots[_i]
                snap_date = snapshot.getDateInt()

                if _i+1 < len(old_snapshots):                        # not at end of the records
                    safetyDate = old_snapshots[_i+1].getDateInt()    # take a peek at the next record..
                else:
                    safetyDate = saveFirstSnapPreserved

                if (not THINMODE) \
                        or (THINMODE and DateUtil.calculateDaysBetween(last_date, snap_date) < max_days_between_thinned
                            and DateUtil.calculateDaysBetween(last_date, safetyDate) < max_days_between_thinned+1):  # This ensures there's no huge leap to the next date......
                    if lVerbose:
                        text += "    *** delete snapshot dated %s\n" %(convertStrippedIntDateFormattedText(snap_date))
                    num_thinned += 1
                    if lDelete:
                        if lVerbose:
                            myPrint("B","%s PRICE HISTORY: Deleting snapshot: %s" %(ThnTxt,repr(snapshot)))
                        countChanges+=1
                        snapshot.deleteItem()
                else:
                    # don't thin this snapshot, and set the last seen date to it
                    if  lVerbose:
                        text += "    > Not deleting snapshot dated %s (preserving 1 per interval specified)\n" %(convertStrippedIntDateFormattedText(snap_date))
                    last_date = snap_date
                _i+=1

            if len(old_snapshots):
                text += "  >> %s'd %s of %s eligible (old) snapshots (%s percent) from %s\n"%(ThnTxt, num_thinned, len(old_snapshots), 100*num_thinned/len(old_snapshots), _curr.getName())
                text += "  >> %s'd %s of %s total snapshots          (%s percent) from %s\n"%(ThnTxt, num_thinned, len(_snapshots), 100*num_thinned/len(_snapshots), _curr.getName())
            else:
                text += "  >> No old snapshots %s'd from %s\n" %(ThnTxt, _curr.getName())

            return text, countChanges

        def prune_all_snapshots(THIN_MODE, age_limit_days, max_days_between_thinned, incCurrencies, incSecurities, lVerbose=False, lDelete=False):       # noqa
            countTheChanges = 0
            _currs = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            lastC = None
            text = ""

            if THIN_MODE: Thn_Txt="THIN"
            else: Thn_Txt="PURGE"

            theList = []
            if incCurrencies: theList.append(CurrencyType.Type.CURRENCY)                                        # noqa
            if incSecurities: theList.append(CurrencyType.Type.SECURITY)                                        # noqa

            for theCType in theList:

                for _curr in _currs:

                    if _curr.getCurrencyType() != theCType: continue

                    if (_curr.getCurrencyType() == CurrencyType.Type.CURRENCY                                                  # noqa
                            and incCurrencies and isinstance(incCurrencies,(CurrencyType)) and _curr != incCurrencies):
                        continue
                    if (_curr.getCurrencyType() == CurrencyType.Type.SECURITY                                                   # noqa
                            and incSecurities and isinstance(incSecurities,(CurrencyType)) and _curr != incSecurities):
                        continue

                    if lastC != _curr.getCurrencyType():
                        text+="\n%s:\n" %_curr.getCurrencyType()
                        lastC = _curr.getCurrencyType()

                    _snaps = _curr.getSnapshots()
                    if _snaps.size() >= 1:
                        _txt, _i = prune_snapshots(_curr, THIN_MODE, age_limit_days, max_days_between_thinned, lDelete, lVerbose)
                        text += _txt
                        countTheChanges += _i
                        _snaps = _curr.getSnapshots()
                        text += "  %s AFTER %s (snapshots: %s, splits: %s)\n"%(_curr, Thn_Txt, _snaps.size(), _curr.getSplits().size())
            return text, countTheChanges

        def prune_orphans(_orphans, incCurrencies, incSecurities, lVerbose=False, lDelete=False):

            iPurgeCount=0

            _orphanSnaps = len(_orphans)
            text = "\nReviewing 'orphan' (or duplicates/stranded) snaps...:\n"

            theList = []                                                                                                # noqa
            theList.append(None)
            if incCurrencies: theList.append(CurrencyType.Type.CURRENCY)                                                # noqa
            if incSecurities: theList.append(CurrencyType.Type.SECURITY)                                                # noqa

            filteredOrphanList=[]
            for theCType in theList:
                for _o in _orphans:
                    theCurr = _o.getCurrencyParameter(None, "curr", None)

                    if theCType is None:
                        if theCurr is not None: continue
                    else:
                        if theCurr.getCurrencyType() != theCType: continue

                    if theCurr:
                        if (theCurr.getCurrencyType() == CurrencyType.Type.CURRENCY                                                  # noqa
                                and incCurrencies and isinstance(incCurrencies,(CurrencyType)) and theCurr != incCurrencies):
                            continue
                        if (theCurr.getCurrencyType() == CurrencyType.Type.SECURITY                                                   # noqa
                                and incSecurities and isinstance(incSecurities,(CurrencyType)) and theCurr != incSecurities):
                            continue
                    filteredOrphanList.append(_o)

            del _orphans

            if len(filteredOrphanList)<1:
                text += "\nNo *filtered* currency or security snapshots were 'orphans' (duplicates/stranded)\n\n"
            else:
                text += "\n%s *filtered* currency or security snapshots were 'orphans' (duplicates/stranded)\n\n"%(len(filteredOrphanList))
                if lDelete:
                    myPrint("B","Logging 'orphan' snaps for deletion....")
                    text += "Logging 'orphan' snaps for deletion....\n"
                    if lVerbose:
                        for _o in filteredOrphanList:
                            text += "Logging 'Orphan' to delete: %s\n" %(repr(_o))
                            myPrint("B","Logging 'Orphan' to delete: %s" %(repr(_o)))
                    MD_REF.getCurrentAccount().getBook().logRemovedItems(filteredOrphanList)
                    iPurgeCount+=len(filteredOrphanList)
                else:
                    if lVerbose:
                        for _o in filteredOrphanList: text += "  'Orphan' found: %s\n" %(_o)
                    text += "\nSimulation so no 'orphan' snaps will be deleted....\n"
            del filteredOrphanList

            return text, iPurgeCount

        if lThinMode: ThnPurgeTxt="THIN"
        elif lPurgeMode: ThnPurgeTxt="PURGE"
        elif purgeOrphansONLY: ThnPurgeTxt="PURGE ORPHANS"
        elif purgeBaseONLY: ThnPurgeTxt="PURGE BASE CURRENCY RECORDS"
        else: ThnPurgeTxt="THIN/PURGE"

        if simulate: x="SIMULATE"
        else: x="DATABASE UPDATE"

        purgingMsg = MyPopUpDialogBox(toolbox_frame_,
                                      "Please wait: Processing your %s request (%s).." %(ThnPurgeTxt,x),
                                      theTitle="FIX - Thin/Purge",
                                      lModal=False,OKButtonText="WAIT")
        purgingMsg.go()

        diagDisplay += "\n\n *** EXECUTING %s PRICE HISTORY ***\n" %(ThnPurgeTxt)
        diagDisplay += "\nUser choose parameters:\n" \
                       " >> Simulate:                 %s\n" \
                       " >> Purge Mode:               %s\n" \
                       " >> Thin Mode:                %s\n" \
                       " >> age_limit_days:           %s (%s)\n" \
                       " >> max_days_between_thinned: %s\n" \
                       " >> includeCurrencies:        %s\n" \
                       " >> includeSecurities:        %s\n" \
                       " >> purgeOrphans:             %s\n" \
                       " >> purgeOrphansONLY:         %s\n" \
                       " >> purgeBase:                %s\n" \
                       " >> purgeBaseONLY:            %s\n" \
                       " >> confirmedSaveTrunk:       %s\n" \
                       " >> VERBOSE:                  %s\n" \
                       %(simulate,
                         lPurgeMode,
                         lThinMode,
                         age_limit_days,
                         convertStrippedIntDateFormattedText(DateUtil.incrementDate(DateUtil.getStrippedDateInt(), 0, 0, -(age_limit_days))),
                         max_days_between_thinned,
                         includeCurrencies,
                         includeSecurities,
                         purgeOrphans,
                         purgeOrphansONLY,
                         purgeBase,
                         purgeBaseONLY,
                         confirmedSaveTrunk,
                         VERBOSE)

        diagDisplay+="\n%s PRICE HISTORY\n" \
                     " =================\n" %(ThnPurgeTxt)

        if not simulate:
            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

        if simulate:
            diagDisplay += "\n ** SIMULATION MODE - NO CHANGES MADE ** \n"
        else:
            diagDisplay += "\n ** %s MODE - CHANGES BEING MADE! ** \n" %(ThnPurgeTxt)

        if purgeOrphans or purgeOrphansONLY:
            x,i = prune_orphans(orphans_to_delete, includeCurrencies, includeSecurities, lVerbose=VERBOSE, lDelete=(not simulate))
            diagDisplay += x
            totalChangesMade += i

        if purgeBase or purgeBaseONLY:
            x,i = does_base_has_snaps(lDelete=(not simulate), lVerbose=VERBOSE)
            diagDisplay += x
            totalChangesMade += i

        if lPurgeMode or lThinMode:  # Mutually exclusive!
            txt, i = prune_all_snapshots(lThinMode, age_limit_days, max_days_between_thinned, includeCurrencies, includeSecurities, lVerbose=VERBOSE, lDelete=(not simulate))
            diagDisplay += txt
            totalChangesMade += i

        if not simulate:
            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        if confirmedSaveTrunk:
            if not simulate:
                if totalChangesMade > 0:
                    myPrint("B","%s PRICE HISTORY: Calling saveTrunkFile()...." %(ThnPurgeTxt))
                    diagDisplay += "\n\n ======\nSaving Trunk File.....\n ======\n\n"
                    MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                else:
                    myPrint("B","%s PRICE HISTORY: No changes made - so NOT Calling saveTrunkFile()...." %(ThnPurgeTxt))
                    diagDisplay += "No changes made, so **NOT** Saving Trunk File.....\n"
            else:
                diagDisplay += "Simulation mode >> (Not) Saving Trunk File.....\n"

        purgingMsg.kill()

        diagDisplay+="\n\n ANALYSIS AFTER %s:\n" %(ThnPurgeTxt)
        diagDisplay+=" ==============================\n"

        diagDisplay += objects_by_type()

        diagDisplay += snaps_by_currency()

        diagDisplay+="\n"

        if simulate:
            x="SIMULATION MODE ONLY"
        else:
            x="UPDATE/%s MODE" %(ThnPurgeTxt)

        if totalChangesMade > 0:
            GlobalVars.lMustRestartAfterSnapChanges = True
            diagDisplay += ("\n\n *** %s changes were made! ***\n\n" %(totalChangesMade)).upper()
        else:
            diagDisplay += "\n\n *** no changes were made! ***\n\n".upper()

        diagDisplay+="\n%s PRICE HISTORY in %s COMPLETED!\n" %(ThnPurgeTxt,x)
        diagDisplay+="\n<END>"

        txt = "%s PRICE HISTORY - %s >> Successfully executed (%s changes made)" %(ThnPurgeTxt,x,totalChangesMade)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)

        jif = QuickJFrame("Price History Analysis", diagDisplay,copyToClipboard=lCopyAllToClipBoard_TB,
                          lRestartMDAfterClose=(not simulate and GlobalVars.lMustRestartAfterSnapChanges)).show_the_frame()
        if simulate:
            MyPopUpDialogBox(jif, "%s PRICE HISTORY - %s >> Successfully executed" %(ThnPurgeTxt,x),"",theTitle="THIN/PRUNE PRICE HISTORY").go()
        else:
            if totalChangesMade > 0:
                play_the_money_sound()
                MyPopUpDialogBox(jif,
                                 "%s PRICE HISTORY - %s >> Successfully executed %s changes - MD WILL RESTART AFTER VIEWING THIS OUTPUT" %(ThnPurgeTxt,x,totalChangesMade),
                                 theTitle="THIN/PRUNE PRICE HISTORY").go()
            else:
                MyPopUpDialogBox(jif,
                                 "%s PRICE HISTORY - %s >> Successfully executed - NO CHANGES NECESSARY / MADE" %(ThnPurgeTxt,x),
                                 theTitle="THIN/PRUNE PRICE HISTORY").go()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def extract_attachments():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "EXTRACT ATTACHMENTS"

        ask=MyPopUpDialogBox(toolbox_frame_,"EXTRACT ATTACHMENTS - For Your Information",
                             "This will extract all your attachments to a directory....\n"
                             "There is also an extension which will extract attachments alongside your Investment or Bank Account Registers\n"
                             ">> Extension: 'Extract Data' available from MD menu >> Manage Extensions\n"
                             "Please select a directory to extract attachments to...\n"
                             "I will create a sub-directory called 'EXTRACT_MD_ATTACHMENTS-x' (I will append a unique number)",
                             theTitle=_THIS_METHOD_NAME,
                             OKButtonText="PROCEED", lCancelButton=True)
        if not ask.go():
            return

        while True:
            lExit = False

            _theTitle = "Select location to Extract Attachments to... (CANCEL=ABORT)"
            theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                                get_home_dir(),         # Starting path
                                                None,                   # Default Filename
                                                _theTitle,              # Title
                                                False,                  # Multi-file selection mode
                                                True,                   # True for Open/Load, False for Save
                                                False,                  # True = Files, else Dirs
                                                "EXTRACT ATTACHMENTS",  # Load/Save button text, None for defaults
                                                None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                lAllowTraversePackages=True,
                                                lForceJFC=False,
                                                lForceFD=False,
                                                lAllowNewFolderButton=True,
                                                lAllowOptionsButton=True)

            if theDir is None or theDir == "":
                _txt = "%s: User did not select Extract Directory to put attachments... Aborting" %(_THIS_METHOD_NAME)
                myPrint("P", _txt); myPopupInformationBox(None, _txt)
                lExit = True
                break

            if not os.path.exists(theDir):
                myPopupInformationBox(None, "ERROR - the folder does not exist?", _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
                continue

            theDir = os.path.join(theDir,"EXTRACT_MD_ATTACHMENTS-%s" %(UUID.randomUUID().toString()))
            if os.path.exists(theDir):
                myPopupInformationBox(None, "SORRY - the folder %s already exists... I need to create it myself...", _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
                continue

            break

        iSkip=0
        iCountAttachments = 0
        textLog = "\n%s:\n" \
                  " ===================\n\n" %(_THIS_METHOD_NAME)

        textLog += "Base extract folder: %s%s\n\n" %(theDir,os.path.sep)
        textRecords = []

        if not lExit and theDir is not None:
            exportFolder = theDir

            txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()

            File(exportFolder).mkdirs()

            myPrint("B", "Will export all attachments to %s"%(exportFolder))

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: extracting attachments..",
                                          theTitle=_THIS_METHOD_NAME,
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            for txn in txnSet.iterableTxns():
                for attachKey in txn.getAttachmentKeys():
                    iCountAttachments+=1
                    attachTag = txn.getAttachmentTag(attachKey)
                    txnDate = txn.getDateInt()
                    attachFile = File(attachTag).getName()
                    attachFolder = os.path.join(exportFolder,"ACCT-TYPE-%s"%(txn.getAccount().getAccountType()),"ACCT-%s" %(txn.getAccount().getAccountName()))
                    File(attachFolder).mkdirs()
                    outputPath = os.path.join(attachFolder, "{:04d}-{:02d}-{:02d}-{}-{}".format(txnDate/10000, (txnDate/100)%100,  txnDate%100, str(iCountAttachments).zfill(5), attachFile))
                    if os.path.exists(outputPath):
                        iSkip+=1
                        myPrint("B", "Error - path: %s already exists... SKIPPING THIS ONE!" %outputPath)
                        textLog+=("Error - path: %s already exists... SKIPPING THIS ONE!\n" %outputPath)
                    else:
                        myPrint("P", "Exporting attachment [%s]" %(os.path.basename(outputPath)))
                        try:
                            outStream = FileOutputStream(File(outputPath))
                            inStream = MD_REF.getCurrentAccount().getBook().getLocalStorage().openFileForReading(attachTag)
                            IOUtils.copyStream(inStream, outStream)
                            outStream.close()
                            inStream.close()
                            textRecords.append([txn.getAccount().getAccountType(), txn.getAccount().getAccountName(), txn.getDateInt(),
                                                "%s %s %s %s %s .%s\n"
                                                %(pad(str(txn.getAccount().getAccountType()),15),pad(txn.getAccount().getAccountName(),30),convertStrippedIntDateFormattedText(txn.getDateInt()),rpad(txn.getValue()/100.0,10),pad(txn.getDescription(),20),outputPath[len(exportFolder):])])
                        except:
                            myPrint("B","Error extracting file - will SKIP : %s" %(outputPath))
                            textLog+=("Error extracting file - will SKIP : %s\n" %(outputPath))
                            iSkip+=1

            textRecords=sorted(textRecords, key=lambda _sort: (_sort[0],_sort[1],_sort[2]))
            for r in textRecords:
                textLog+=r[3]

            if iSkip: textLog+="\nERRORS/SKIPPED: %s (review console log for details)\n" %(iSkip)

            textLog+="\n<END>"

            try:
                log = open(os.path.join(exportFolder,"Extract_Attachments_LOG.txt"), "w")
                log.write(textLog)
                log.close()
            except: pass

            pleaseWait.kill()

            txt = "%s: FINISHED: %s attachments extracted (%s skipped)..." %(_THIS_METHOD_NAME,iCountAttachments,iSkip)
            myPrint("B", txt); setDisplayStatus(txt, "B")
            play_the_money_sound()

            if iSkip < 1:
                myPopupInformationBox(toolbox_frame_,"%s attachments extracted.." %(iCountAttachments), theTitle=_THIS_METHOD_NAME)
            else:
                myPopupInformationBox(toolbox_frame_,"%s attachments extracted.. AND YOU HAD %s Missing/Errors?" %(iCountAttachments,iSkip),theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

            try:
                helper = MD_REF.getPlatformHelper()
                helper.openDirectory(File(exportFolder))
            except: pass

        else:
            txt = "%s: NO ATTACHMENTS EXTRACTED!" %(_THIS_METHOD_NAME)
            myPrint("B", txt); setDisplayStatus(txt, "R")

        return

    def diagnose_attachments(lFix=False):

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if lFix:
            MyPopUpDialogBox(toolbox_frame_,
                             "NOTE: You already have Syncing disabled - Good!\n"
                             "There is a flaw in Moneydance Syncing as regards attachments when Syncing is ON\n"
                             "Deleted attachments will keep re-appearing as they Syncronise from Sync/Dropbox/Secondary machines\n"
                             "You have to disable Sync, manually delete your sync Folder/Data, then delete the Orphans (using this tool)\n"
                             "Then re-enable Sync, Wait for Sync to complete, then re-enable Sync on secondary devices...\n"
                             "<GOOD LUCK!>",
                             theTitle="ATTACHMENT ANALYSIS & DELETION OF ORPHANS",
                             lModal=True,OKButtonText="ACKNOWLEDGE")

        scanningMsg = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching Database and filesystem for attachments..",
                                       theTitle="ATTACHMENT(S) SEARCH",
                                       lModal=False,OKButtonText="WAIT")
        scanningMsg.go()

        myPrint("P", "Scanning database for attachment data..")
        book = MD_REF.getCurrentAccount().getBook()

        attachmentList={}
        attachmentLocations={}

        iObjectsScanned=0
        iTxnsScanned=0

        iTxnsWithAttachments = 0
        iAttachmentsFound = 0
        iAttachmentsNotInLS = 0
        iDuplicateKeys = 0
        attachmentsNotInLS=[]

        diagDisplay="ANALYSIS OF ATTACHMENTS\n\n"

        attachmentFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe", MD_REF.getCurrentAccountBook().getAttachmentsFolder())

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()

        txnSet = book.getTransactionSet()
        for _mdItem in txnSet.iterableTxns():

            iObjectsScanned+=1

            iTxnsScanned+=1

            if not (_mdItem.hasAttachments() or len(_mdItem.getAttachmentKeys())>0): continue

            iTxnsWithAttachments+=1
            x="Found Record with %s Attachment(s): %s" %(len(_mdItem.getAttachmentKeys()),_mdItem)
            myPrint("D",x)
            if debug: diagDisplay+=(x+"\n")

            if attachmentList.get(_mdItem.getUUID()):
                iDuplicateKeys += 1
                x="@@ Error %s already exists in my attachment list...!?" %_mdItem.getUUID()
                myPrint("DB", x)
                if debug: diagDisplay+=(x+"\n")

            attachmentList[_mdItem.getUUID()] = [
                _mdItem.getUUID(),
                _mdItem.getAccount().getAccountName(),
                _mdItem.getAccount().getAccountType(),
                _mdItem.getDateInt(),
                _mdItem.getValue(),
                _mdItem.getAttachmentKeys()
            ]
            x="Attachment keys: %s" %_mdItem.getAttachmentKeys()
            myPrint("D",x)
            if debug: diagDisplay+=(x+"\n")

            for _key in _mdItem.getAttachmentKeys():
                iAttachmentsFound+=1
                if attachmentLocations.get(_mdItem.getAttachmentTag(_key)):
                    iDuplicateKeys += 1
                    x="@@ Error %s already exists in my attachment location list...!?" %_mdItem.getUUID()
                    myPrint("B", )
                    if debug: diagDisplay+=(x+"\n")

                attachmentLocations[_mdItem.getAttachmentTag(_key)] = [
                    _mdItem.getAttachmentTag(_key),
                    _key,
                    _mdItem.getUUID(),
                    LS.exists(_mdItem.getAttachmentTag(_key))
                ]
                if not LS.exists(_mdItem.getAttachmentTag(_key)):
                    iAttachmentsNotInLS+=1
                    attachmentsNotInLS.append([
                        _mdItem.getUUID(),
                        _mdItem.getAccount().getAccountName(),
                        _mdItem.getAccount().getAccountType(),
                        _mdItem.getDateInt(),
                        _mdItem.getValue(),
                        _mdItem.getAttachmentKeys()
                    ])

                    x="@@ Error - Attachment for Txn DOES NOT EXIST! - Attachment tag: %s" %_mdItem.getAttachmentTag(_key)
                    myPrint("B",x)
                    diagDisplay+=(x+"\n")
                else:
                    x="Attachment tag: %s" %_mdItem.getAttachmentTag(_key)
                    myPrint("D", x)
                    if debug: diagDisplay+=(x+"\n")


        # Now scan the file system for attachments
        myPrint("P", "Now scanning attachment directory(s) and files...:")

        attachmentsRawListFound = []

        typesFound={}

        for root, dirs, files in os.walk(attachmentFullPath):

            for name in files:
                theFile = os.path.join(root,name)[len(attachmentFullPath)-len(MD_REF.getCurrentAccountBook().getAttachmentsFolder()):]
                byteSize = os.path.getsize(os.path.join(root,name))
                modified = datetime.datetime.fromtimestamp(os.path.getmtime(os.path.join(root,name))).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True))
                attachmentsRawListFound.append([theFile, byteSize, modified, os.path.join(root,name)])
                theExtension = os.path.splitext(theFile)[1].lower()

                iCountExtensions = 0
                iBytes = 0
                if typesFound.get(theExtension):
                    iCountExtensions = typesFound.get(theExtension)[1]
                    iBytes = typesFound.get(theExtension)[2]
                typesFound[theExtension] = [theExtension, iCountExtensions+1, iBytes+byteSize ]

                x="Found Attachment File: %s" %theFile
                myPrint("D", x)
                if debug: diagDisplay+=(x+"\n")

        # Now match file system to the list from the database
        iOrphans=0
        iOrphanBytes=0

        orphanList=[]

        for fileDetails in attachmentsRawListFound:
            deriveTheKey = fileDetails[0]
            deriveTheBytes = fileDetails[1]
            deriveTheModified = fileDetails[2]
            deriveRawPath = fileDetails[3]
            if attachmentLocations.get(deriveTheKey.replace(os.path.sep,"/")):
                x="Attachment file system link found in Moneydance database"
                myPrint("D", x)
                if debug: diagDisplay+=(x+"\n")
            else:
                x="Error: Attachment filesystem link missing in Moneydance database: %s" %deriveTheKey
                myPrint("DB", x)
                if debug: diagDisplay+=(x+"\n")
                iOrphans+=1
                iOrphanBytes+=deriveTheBytes
                if lFix:
                    orphanList.append([deriveTheKey, deriveTheBytes, deriveTheModified, deriveRawPath])
                else:
                    orphanList.append([deriveTheKey, deriveTheBytes, deriveTheModified])

        msgStr=""

        myPrint("P","\n"*5)

        x="----------------------------------"
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")

        x = "Objects scanned: %s" %iObjectsScanned
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")

        x="Transactions scanned: %s" %iTxnsScanned
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Transactions with attachments: %s" %iTxnsWithAttachments
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Total Attachments referenced in Moneydance database (a txn may have multi-attachments): %s" %iAttachmentsFound
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Attachments missing from Local Storage: %s" %iAttachmentsNotInLS
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")
        x="Total Attachments found in file system: %s (difference %s)" %(len(attachmentsRawListFound),len(attachmentsRawListFound)-iAttachmentsFound)
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n")

        myPrint("P","\n"*1)

        x="Attachment extensions found: %s" %len(typesFound)
        myPrint("B", x)
        diagDisplay+=("\n"+x+"\n")

        iTotalBytes = 0
        sortedExtensions = sorted(typesFound.values(), key=lambda _x: (_x[2]), reverse=True)

        for x in sortedExtensions:
            iTotalBytes+=x[2]

            x="Extension: %s Number: %s Size: %sMB" %(pad(x[0],6),rpad(x[1],12),rpad(round(x[2]/(1000.0 * 1000.0),2),12))
            myPrint("B", x)
            diagDisplay+=(x+"\n")

        x="Attachments on disk are taking: %sMB" %(round(iTotalBytes/(1000.0 * 1000.0),2))
        myPrint("B", x)
        diagDisplay+=(x+"\n")
        msgStr+=(x+"\n")
        x="----------------------------------"
        myPrint("B", x)
        msgStr+=(x+"\n")
        diagDisplay+=(x+"\n\n")

        lErrors=False
        if iAttachmentsNotInLS:
            x = "@@ ERROR: You have %s missing attachment(s) referenced on Moneydance Txns!" %(iAttachmentsNotInLS)
            msgStr+=x+"\n"
            diagDisplay+=(x+"\n\n")
            myPrint("P","")
            myPrint("B",x)
            setDisplayStatus(x.upper(),"R")
            lErrors=True
            attachmentsNotInLS=sorted(attachmentsNotInLS, key=lambda _x: (_x[3]), reverse=False)
            for theOrphanRecord in attachmentsNotInLS:
                x="Attachment is missing from this Txn: AcctType: %s Account: %s Date: %s Value: %s AttachKey: %s" %(theOrphanRecord[1],
                                                                                                                     theOrphanRecord[2],
                                                                                                                     convertStrippedIntDateFormattedText(theOrphanRecord[3]),
                                                                                                                     theOrphanRecord[4],
                                                                                                                     theOrphanRecord[5])
                myPrint("B", x)
                diagDisplay+=(x+"\n")
            diagDisplay+="\n"

        if iOrphans:
            x = "@@ ERROR: %s Orphan attachment(s) found, taking up %sMBs" %(iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2))
            msgStr+=x+"\n"
            diagDisplay+=(x+"\n\n")
            myPrint("P","")
            setDisplayStatus(x.upper(),"R")

            myPrint("B",x)
            x="Base Attachment Directory is: %s" %os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe","")
            myPrint("B",x)
            diagDisplay+=(x+"\n")
            lErrors=True
            orphanList=sorted(orphanList, key=lambda _x: (_x[2]), reverse=False)

            for theOrphanRecord in orphanList:

                try:
                    x="Orphaned Attachment >> Txn Size: %sKB Modified %s for file: %s" %(rpad(round(theOrphanRecord[1]/(1000.0),1),6),
                                                                                         pad(theOrphanRecord[2],19),
                                                                                         theOrphanRecord[0])
                    diagDisplay+=(x+"\n")
                    myPrint("B", x)

                except:
                    diagDisplay += dump_sys_error_to_md_console_and_errorlog(True)
                    diagDisplay += "REVIEW MD MENU>HELP>CONSOLE WINDOW FOR DETAILS\n\n"
                    myPrint("B", "@@ record causing issue was.....:")
                    myPrint("B", theOrphanRecord)
                    myPrint("B", "... will continue.....")

        if not lErrors:
            x = "Congratulations! - No orphan attachments detected!".upper()
            myPrint("B",x)
            diagDisplay+=(x+"\n")
            setDisplayStatus(x.upper(),"B")

        if iAttachmentsFound:
            diagDisplay+="\n\nLISTING VALID ATTACHMENTS FOR REFERENCE\n"
            diagDisplay+=" ======================================\n"
            x="\nBase Attachment Directory is: %s" %os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe","")
            diagDisplay+=(x+"\n-----------\n")

            for validLocation in attachmentLocations:
                locationRecord = attachmentLocations[validLocation]
                record = attachmentList[locationRecord[2]]
                try:
                    diagDisplay+="AT: %s ACT: %s DT: %s Val: %s FILE: %s\n" \
                                 %(pad(repr(record[2]),12),
                                   pad(safeStr(record[1]),20),       # Avoid utf-8 issue!
                                   convertStrippedIntDateFormattedText(record[3]),
                                   rpad(record[4]/100.0,10),
                                   validLocation)

                except:
                    diagDisplay += dump_sys_error_to_md_console_and_errorlog(True)
                    diagDisplay += "REVIEW MD MENU>HELP>CONSOLE WINDOW FOR DETAILS\n\n"
                    myPrint("B", "@@ record causing issue was.....:")
                    myPrint("B", locationRecord)
                    myPrint("B", record)
                    myPrint("B", "... will continue.....")

        if not lFix or not iOrphans: diagDisplay+='\n<END>'

        scanningMsg.kill()

        jif = QuickJFrame("ATTACHMENT ANALYSIS",diagDisplay,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()

        if iOrphans:
            if lFix:
                theMsg = MyPopUpDialogBox(jif,
                                       "You have %s Orphan attachment(s) found, taking up %sMBs" % (iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2)),
                                          msgStr,
                                          theTitle="ORPHANED ATTACHMENTS",
                                          lCancelButton=False,
                                          OKButtonText="OK",
                                          lAlertLevel=1)
            else:
                theMsg = MyPopUpDialogBox(jif,
                                       "You have %s Orphan attachment(s) found, taking up %sMBs" % (iOrphans,round(iOrphanBytes/(1000.0 * 1000.0),2)),
                                          msgStr +"CLICK TO VIEW ORPHANS, or CANCEL TO EXIT",
                                          theTitle="ORPHANED ATTACHMENTS",
                                          lCancelButton=True,
                                          OKButtonText="CLICK TO VIEW",
                                          lAlertLevel=1)
        elif iAttachmentsNotInLS:
            theMsg = MyPopUpDialogBox(jif,
                                   "You have %s missing attachment(s) referenced on Moneydance Txns!" % (iAttachmentsNotInLS),
                                      msgStr,
                                      theTitle="MISSING ATTACHMENTS",
                                      lCancelButton=False,
                                      OKButtonText="OK",
                                      lAlertLevel=1)

        if lErrors:
            pass
        else:
            theMsg = MyPopUpDialogBox(jif,
                                      x,
                                      msgStr,
                                      theTitle="ATTACHMENTS STATUS",
                                      lCancelButton=False,
                                      OKButtonText="OK",
                                      lAlertLevel=0)

        myPrint("P","\n"*2)

        if iOrphans and not lFix:
            if theMsg.go():                                                                                             # noqa
                while True:
                    selectedOrphan = JOptionPane.showInputDialog(jif,
                                                                 "Select an Orphan to View",
                                                                 "VIEW ORPHAN (Escape or Cancel to exit)",
                                                                 JOptionPane.WARNING_MESSAGE,
                                                                 getMDIcon(None),
                                                                 orphanList,
                                                                 None)
                    if not selectedOrphan:
                        break

                    try:
                        tmpDir = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), "tmp")
                        tmpDir.mkdirs()
                        attachFileName = (File(tmpDir, selectedOrphan[0])).getName()                                    # noqa
                        tmpFile = File.createTempFile(str(System.currentTimeMillis() % 10000L), attachFileName, tmpDir)
                        tmpFile.deleteOnExit()
                        fout = FileOutputStream(tmpFile)
                        LS.readFile(selectedOrphan[0], fout)                                                            # noqa
                        fout.close()
                        Desktop.getDesktop().open(tmpFile)

                    except:
                        myPrint("B","Sorry, could not open attachment file....: %s" %selectedOrphan[0])                 # noqa

        else:
            theMsg.go()                                                                                                 # noqa

        if lFix and not iOrphans:

            myPopupInformationBox(jif, "YOU HAVE NO ORPHANS TO DELETE - NO ACTION TAKEN!")

        elif lFix:

            if confirm_backup_confirm_disclaimer(jif, "ATTACHMENTS - DELETE ORPHANS",
                                                     "Delete %s Orphan attachments from Disk?" %(iOrphans)):

                myPrint("B", "USER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH DELETION OF %s Orphan attachments from disk." %(iOrphans))

                jif.dispose()

                diagDisplay += ("\n\n"
                                "DELETING ORPHANS FROM DISK\n"
                                " =========================\n")

                for theOrphanRecord in orphanList:

                    try:
                        os.remove(theOrphanRecord[3])
                        x="DELETED ORPHAN: %s" %(theOrphanRecord[3])
                        myPrint("B",x)
                        diagDisplay+=(x+"\n")
                    except:
                        x="@@ FAILED TO DELETE ORPHAN: %s" %(theOrphanRecord[3])
                        myPrint("B",x)
                        diagDisplay+=(x+"\n")

                diagDisplay += ("Now removing empty attachment folder structures from disk......")
                if removeEmptyDirs(attachmentFullPath):
                    diagDisplay += ("Success")
                else:
                    diagDisplay += ("Hit an error (review console log)")

                diagDisplay+=("\n\n<END>\n")
                jif = QuickJFrame("ATTACHMENT ANALYSIS & ORPHAN DELETION",diagDisplay,lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False,lJumpToEnd=True).show_the_frame()
                txt = "%s Orphan Attachments deleted from disk" %(iOrphans)
                myPrint("B", txt)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(jif, txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            else:
                jif.dispose()
                txt = "User declined disclaimer - no orphans deleted!"
                myPrint("B",txt)
                diagDisplay+=("\n"+txt+"\n"+"<END>\n")
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("ATTACHMENT ANALYSIS & ORPHAN DELETION",diagDisplay,lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False,lJumpToEnd=True).show_the_frame()
                myPopupInformationBox(jif, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)

        del orphanList
        del attachmentList
        del attachmentLocations
        del typesFound
        del attachmentsRawListFound
        del attachmentsNotInLS

        toolbox_frame_.toFront()
        jif.toFront()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def detect_fix_nonlinked_investment_security_records():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        nonLinkedSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(24))

        if len(nonLinkedSecurityAccounts) < 1:
            txt = "Congratulations - No Investment Security Accounts not properly linked to a Security Master were detected - No changes made!"
            setDisplayStatus(txt, "B")
            myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        for badLink in nonLinkedSecurityAccounts:
            myPrint("B","Improperly linked Security (Sub Account): %s" %(badLink))

        selectedSecSubAcct = JOptionPane.showInputDialog(toolbox_frame_,
                                                      "Select the Security that's not properly linked to it's master'",
                                                      "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                      JOptionPane.WARNING_MESSAGE,
                                                      getMDIcon(None),
                                                      nonLinkedSecurityAccounts,
                                                      None)

        if not selectedSecSubAcct:
            txt = "User did not select any of the %s improperly linked Security(s) to fix - no changes made" %(len(nonLinkedSecurityAccounts))
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        securities = []
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for currSec in currencies:
            if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                        # noqa
            securities.append(currSec)
        securities = sorted(securities, key=lambda sort_x: (sort_x.getName().upper()))

        if len(securities) < 1:
            txt = "ERROR - You seem to have no Security Master records to link to - Create one first (Tools>Securities) - No changes made!"
            setDisplayStatus(txt, "B")
            myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        targetSecurity = JOptionPane.showInputDialog(toolbox_frame_,
                                                    "Select the target Security to link to this record",
                                                    "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                    JOptionPane.INFORMATION_MESSAGE,
                                                    getMDIcon(None),
                                                    securities,
                                                    None)

        if not targetSecurity:
            txt = "User did not select a target Security - no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "DETECT/FIX NON-PROPERLY LINKED SECURITY SUB ACCTS",
                                                 "Reassign Security '%s' to Security Master: '%s'?" %(selectedSecSubAcct, targetSecurity)):
            return

        myPrint("B", "USER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH Reassign Security '%s' to Security Master '%s'?" %(selectedSecSubAcct, targetSecurity))

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        selectedSecSubAcct.setEditingMode()
        selectedSecSubAcct.setCurrencyType(targetSecurity)
        selectedSecSubAcct.syncItem()

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "Fix/reassign Security (Sub Account) completed. Now reports '%s'. Please Check results" %(selectedSecSubAcct)
        myPrint("B", txt)
        setDisplayStatus(txt, "DG")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_invalidLotRecords():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        PARAMETER_KEY = "toolbox_fix_invalid_lots"
        PARAMETER_KEY_COST_BASIS = "cost_basis"
        PARAMETER_KEY_OLD_COST_BASIS = ".old_cost_basis"

        _THIS_METHOD_NAME = "Detect and fix (wipe) LOT records"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        allSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(2))
        if len(allSecurityAccounts) < 1:
            txt = "No Securities exist within Investment Accounts to check - No changes made!"
            setDisplayStatus(txt, "B"); myPrint("DB",txt)
            myPopupInformationBox(toolbox_frame_,txt)
            return

        # Based on: com.infinitekind.moneydance.model.TxnUtil.parseCostBasisTag(SplitTxn)
        def parseCostBasisTag(_txn):
            """Returns the Cost Basis Lot Matching Tags without validating the UUID data first"""

            if not isinstance(_txn, SplitTxn): return None
            tags = _txn.getParameter(PARAMETER_KEY_COST_BASIS, None)
            if tags is None or len(tags) < 1: return None
            splitTags = tags.split(";")

            rtnTagList = {}
            for eachTagString in splitTags:
                if eachTagString is None or len(eachTagString) < 1: continue
                splitLine = eachTagString.split(":")
                uuid = splitLine[0]
                qty = Long.valueOf(Long.parseLong(splitLine[1]))
                rtnTagList[uuid] = qty
            return rtnTagList

        output = "%s:\n\n" %(_THIS_METHOD_NAME.upper())

        securityTxnsToFix = {}
        lLotErrors = False
        for secAcct in allSecurityAccounts:
            secTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)
            output += "Validating: %s\n" %(secAcct)
            if InvestUtil.isCostBasisValid(secAcct):
                output += "... Cost Basis reports as valid\n"
            else:
                output += "... Cost Basis reports as INVALID\n"

            for secTxn in secTxns:

                newTags = {}
                lAnyTagChanges = False

                # cbTags = TxnUtil.parseCostBasisTag(secTxn)    # This will only provide tags where the txn(s) by uuid actually still exist in the entire MD TxnSet
                cbTags = parseCostBasisTag(secTxn)              # This will provide all tags set on the record irrespective of whether they exist or not.

                if cbTags is None: continue
                for txnID in cbTags:
                    if TxnUtil.getTxnByID(secTxns, txnID) is not None:
                        newTags[txnID] = cbTags[txnID]
                    else:
                        lLotErrors = True
                        lAnyTagChanges = True   # Essentially we skipped this tag and didn't add it to the dictionary...
                        output += "... ERROR: Buy (id: %s) matched to sale (id: %s) dated: %s missing/invalid?\n" %(txnID,secTxn.getUUID(), convertStrippedIntDateFormattedText(secTxn.getDateInt()))

                if lAnyTagChanges:
                    securityTxnsToFix[secTxn] = newTags

        if not lLotErrors:
            txt = "Congratulations. No Buy/Sell matched LOT errors detected"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        output += "\n*** %s Buy/Sell matched LOT ERRORS EXIST ***\n" %(len(securityTxnsToFix))
        ask = MyPopUpDialogBox(toolbox_frame_,
                               "%s: %s Buy/Sell matched LOT errors exist..\n"
                               "This utility will wipe the invalid LOT data from these records\n"
                               "(You can then manually edit the LOT data afterwards using the LOT matching window)\n"
                               "REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE FIX" %(_THIS_METHOD_NAME, len(securityTxnsToFix)),
                               output,
                               theTitle=_THIS_METHOD_NAME.upper(),
                               lCancelButton=True,
                               OKButtonText="PROCEED")
        if not ask.go():
            txt = "%s: - User Aborted - No changes made!" %(_THIS_METHOD_NAME)
            myPrint("B",txt)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(_THIS_METHOD_NAME,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(), "Wipe invalid matched Buy/Sell LOT data?"):
            return

        output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH FIX OF INVALID LOT MATCHING DATA.....\n\n"

        output += "Fixing Lot Matching data identified above for %s txns...:" %(len(securityTxnsToFix))
        for secTxn in securityTxnsToFix:
            newTag = ""
            cbTags = securityTxnsToFix[secTxn]
            for txnID in cbTags:
                newTag += "{}:{};".format(txnID,cbTags[txnID])

            pTxn = secTxn.getParentTxn()
            pTxn.setEditingMode()

            if debug: secTxn.setParameter(PARAMETER_KEY+PARAMETER_KEY_OLD_COST_BASIS,secTxn.getParameter(PARAMETER_KEY_COST_BASIS, None))
            secTxn.setParameter(PARAMETER_KEY_COST_BASIS, newTag)
            pTxn.syncItem()

        for secAcct in allSecurityAccounts:
            output += "Validating Cost Basis on all Security Sub Accounts (after the fix): %s\n" %(secAcct)
            if InvestUtil.isCostBasisValid(secAcct):
                output += "... Cost Basis reports as valid\n"
            else:
                output += "... Cost Basis reports as INVALID\n"

        output += "\n\n%s transactions corrected (invalid LOT data has been wiped)...\n\n" %(len(securityTxnsToFix))
        jif = QuickJFrame(_THIS_METHOD_NAME,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "%s: Completed. Please Check results and manually address any Buy/Sell LOT matching that needs to be resolved" %(_THIS_METHOD_NAME)
        myPrint("B", txt)
        setDisplayStatus(txt, "DG")
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def edit_security_decimal_places():

        _THIS_METHOD_NAME = "Edit a Security's Decimal Places setting"

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_security_dpc"
        PARAMETER_KEY_DATA = ".old_data"
        PARAMETER_KEY_COST_BASIS = ".old_cost_basis"

        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output = "%s:\n" \
                 " ========================================\n\n" \
                 "The Decimal Places setting on a security relates only to the qty of shares on transactions, the stock holding qty balance, and related LOT Control records.\n" \
                 "...the (max) decimal precision is set by the user when a Security is first created. It is subsequently hidden and not editable in standard MD.\n" \
                 "...This function allows you to change it. Related records will be properly updated.\n\n" \
                 "NOTE: The decimal places setting was used to store the price/rate prior to MD2019 (as a factor compared to the base currency dpc)\n" \
                 "      So, if you are using MD2019 or later, then this is not issue for you\n" \
                 "      If you want to revert back to MD2017 or earlier, then please do not use this utility to change a security dpc setting.\n" \
                 "      (Also note, that if you revert to MD2017 you will probably have to check the rates/prices anyway, due to an unrelated MD bug.....)\n\n" \
                 "" %(_THIS_METHOD_NAME)

        myPrint("B", "%s: Analysing..." %(_THIS_METHOD_NAME))

        try:

            if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

            class StoreSecurity:
                def __init__(self, _obj):
                    self.obj = _obj

                def getSecurity(self):  return self.obj

                def __str__(self):  return "Decimal Places: %s >> %s" %(rpad(self.obj.getDecimalPlaces(),2),self.obj)

                def __repr__(self): return self.__str__()


            # Sweep One - gather the potential targets by duplicate Ticker Symbol....
            allSecurities = []
            currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
            for currSec in currencies:
                if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue
                allSecurities.append(StoreSecurity(currSec))
            del currencies
            allSecurities = sorted(allSecurities, key=lambda x: (x.getSecurity().getName().upper()))

            securityToEdit = JOptionPane.showInputDialog(toolbox_frame_,
                                                        "Select Security to edit Decimal Places",
                                                        _THIS_METHOD_NAME.upper(),
                                                        JOptionPane.WARNING_MESSAGE,
                                                        getMDIcon(None),
                                                        allSecurities,
                                                        None)                                                           # type: StoreSecurity

            if not securityToEdit:
                txt = "%s: No Security selected.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            securityToEdit = securityToEdit.getSecurity()
            output += "\n" \
                      "Security: %s was selected to edit.\n" \
                      "Current Decimal Places set to: %s\n" %(securityToEdit, securityToEdit.getDecimalPlaces())

            while True:

                newDecimal = myPopupAskForInput(toolbox_frame_,
                                                _THIS_METHOD_NAME,
                                                "New Decimal Places:",
                                                "Enter the new Decimal Places setting (currently %s)" %(securityToEdit.getDecimalPlaces()),
                                                defaultValue=securityToEdit.getDecimalPlaces())

                if newDecimal is not None and not StringUtils.isInteger(newDecimal):
                    continue

                if newDecimal is None or int(newDecimal) == securityToEdit.getDecimalPlaces():
                    txt = "%s: No new decimal places selected.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if int(newDecimal) >= 0 and int(newDecimal) <= 8:
                    newDecimal = int(newDecimal)
                    break

                continue

            # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
            allInvestmentSecurityAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(22))


            iTotalTxns = 0
            iTotalBalance = 0
            lUsingLotControl = False
            securitySubAccountsNeedChanging = []
            output += "\nSearching for related Investment Account Security holdings, transactions, balances etc...:\n"

            lAnyCostBasisErrorsFound = [False]

            for secAcct in allInvestmentSecurityAccounts:
                if secAcct.getCurrencyType() == securityToEdit:
                    securitySubAccountsNeedChanging.append(secAcct)

                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

                    lFoundCostBasisTags = False
                    for txn in txns:
                        if txn.getParameter("cost_basis", None) is not None:
                            lFoundCostBasisTags = lUsingLotControl = True
                            break

                    if lFoundCostBasisTags:
                        output += "... WARNING: LOT CONTROLLED RECORDS using Cost Basis Tags found ***\n"

                    if not InvestUtil.isCostBasisValid(secAcct):
                        lAnyCostBasisErrorsFound[0] = True
                        output += "... WARNING: INVALID COST BASIS / LOT CONTROL DETECTED! ***\n"

                    iTotalTxns += txns.getSize()
                    bal = securityToEdit.getDoubleValue(secAcct.getBalance())
                    iTotalBalance += bal
                    output += "... %s Txns: %s Balance: %s\n" %(pad(secAcct.getFullAccountName(),50),rpad(txns.getSize(),12),rpad(bal,12))
                    if secAcct.getStartBalance() != 0:
                        txt = "*** ERROR: %s has a starting balance of %s - SHOULD BE ZERO - Will abort! ***" %(secAcct, secAcct.getStartBalance())
                        myPrint("B", txt); output += "\n%s\n\n" %(txt)
                        raise Exception(txt)
                    del txns

            del allInvestmentSecurityAccounts

            output += "\n" \
                      "Investment Account Security records found: %s\n" \
                      "Related Transactions found: %s\n" \
                      "Total security balance: %s\n\n" \
                      %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance)

            if lUsingLotControl:
                output += "\n*** WARNING: LOT CONTROLLED RECORDS using Cost Basis Tags found ***\n\n"

            if lAnyCostBasisErrorsFound[0]:
                output += "\n*** WARNING: INVALID LOT CONTROL / COST BASIS RECORDS BEFORE ANY CHANGES WERE DETECTED ***\n\n"
            else:
                output += "\nNOTE: No Invalid Lot Control/Cost Basis records were detected before any changes made....\n\n"

            jif = QuickJFrame(("%s: Accounts, Txns, Balance Analysis" %(_THIS_METHOD_NAME)).upper(),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if (iTotalBalance + iTotalTxns + len(securitySubAccountsNeedChanging)) == 0:
                txt = "NOTE - No related accounts, txns, balances were found for this security!"
                output += "\n*** %s ***\n" %(txt)
                myPopupInformationBox(jif, txt, _THIS_METHOD_NAME)

            elif lAnyCostBasisErrorsFound[0]:
                myPopupInformationBox(jif,
                                      "%s Accounts, %s Txns, Balance %s found ** NOTE: INVALID LOT CONTROL / COST BASIS RECORDS DETECTED! **"
                                      %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance),
                                      _THIS_METHOD_NAME)
            else:
                myPopupInformationBox(jif,
                                      "NOTE: %s Accounts, %s Txns, Balance %s found" %(len(securitySubAccountsNeedChanging), iTotalTxns, iTotalBalance),
                                      _THIS_METHOD_NAME)


            if not myPopupAskQuestion(jif,
                                  _THIS_METHOD_NAME.upper(),
                                  "CONFIRM you want to change Decimals from %s to %s?" %(securityToEdit.getDecimalPlaces(),newDecimal)):
                txt = "%s: User aborted.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            jif.dispose()

            txt = "New Decimal Places %s for %s selected (currently: %s) " %(newDecimal, securityToEdit, securityToEdit.getDecimalPlaces())
            myPrint("B", txt); output += "\n%s\n" %(txt)

            decimalAdjustmentMethod = "expand"
            jif = QuickJFrame(("%s: Decimal Strategy" %(_THIS_METHOD_NAME)).upper(),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            if newDecimal < securityToEdit.getDecimalPlaces():

                options = ["Round lost fractional balances up/down (round)",
                           "Truncate / lose / chop lost fractional balances (floor)",
                           "Always round up lost fractional balances (ceiling)"]


                selectedDecimalStrategy = JOptionPane.showInputDialog(jif,
                                                                   "Select the Decimal REDUCTION Strategy?",
                                                                   _THIS_METHOD_NAME.upper(),
                                                                   JOptionPane.WARNING_MESSAGE,
                                                                   getMDIcon(None),
                                                                   options,
                                                                   None)

                if not selectedDecimalStrategy:
                    txt = "%s: User did not select a Decimal Reduction Strategy for the edit - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return


                if options.index(selectedDecimalStrategy) == 0:    decimalAdjustmentMethod = "round"
                elif options.index(selectedDecimalStrategy) == 1:  decimalAdjustmentMethod = "floor"
                else:                                              decimalAdjustmentMethod = "ceiling"
                del options

                output += "\n** Decimal Reduction Strategy selected: '%s' (Fractional balances might be affected) **\n\n" %(decimalAdjustmentMethod)

                if lUsingLotControl:

                    ask = MyPopUpDialogBox(jif,
                                           "%s: WARNING. Lot Controlled Records in use, and reduction of dpc requested!" %(_THIS_METHOD_NAME),
                                           "You are using LOT Controlled Records (with cost basis tags) that link sells to buys\n"
                                           "You have also requested to reduce decimal precision\n"
                                           "This will probably lose fractional share balances\n"
                                           "This utility can apply the same maths to the Lot Controlled allocations, but it may be fractionally wrong\n"
                                           "You can/may review and fix these later.... Your choice....",
                                           theTitle=_THIS_METHOD_NAME.upper(),
                                           lCancelButton=True,
                                           OKButtonText="PROCEED")
                    if not ask.go():
                        txt = "%s: User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                        myPrint("B",txt)
                        setDisplayStatus(txt, "R")
                        jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                        return

                    txt = "** User agreed to reduce decimal precision and accept that LOT Controlled records might be fractionally wrong.... **"
                    myPrint("B",txt); output += "\n\n%s\n\n" %(txt)

            else:
                output += "\nDecimal Strategy selected: %s (Increased so no loss of values)\n\n" %(decimalAdjustmentMethod)
                txt = "DECIMAL INCREASE STRATEGY: You are increasing the number of decimal places; so no values will be lost.."
                output += "\n%s\n" %(txt)
                myPopupInformationBox(jif, txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

                if lUsingLotControl:
                    output += "\n\n *** NOTE: LOT CONTROLLED RECORDS using Cost Basis Tags found - As you are increasing the decimal precision, no fractional losses should occur ***\n\n"

            jif.dispose()


            ask = MyPopUpDialogBox(toolbox_frame_,
                                   "%s: REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE DECIMAL EDIT" %(_THIS_METHOD_NAME),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s... User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                myPrint("B",txt)
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE %s DECIMAL PLACE EDIT FROM %s to %s?" %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)):
                return

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH DECIMAL PLACE EDIT of %s FROM %s to %s.....\n\n" %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)

            output += "\n"

        except:
            txt = ("MINOR ERROR - %s: crashed before any merge actions. Please review output and console" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing %s right now.." %(_THIS_METHOD_NAME),
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the merge..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            # Do this first, so that the 'internal' MD maths on the txn edits work with the new dpc settings.....
            txt = "** Updating %s Security Master to new Decimal Places (was %s >> to %s) setting..." %(securityToEdit,securityToEdit.getDecimalPlaces(),newDecimal)
            myPrint("B", txt); output += "\n%s\n\n" %(txt)

            oldDecimal = securityToEdit.getDecimalPlaces()

            def calculateNewShares(oldValue):

                if newDecimal > oldDecimal:
                    _newShares = oldValue * Math.pow(10.0, (newDecimal - oldDecimal))
                else:

                    if oldValue < 0.0:
                        neg = True
                    else:
                        neg = False

                    if decimalAdjustmentMethod == "round":
                        _newShares = Math.round(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    elif decimalAdjustmentMethod == "floor":
                        _newShares = Math.floor(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    elif decimalAdjustmentMethod == "ceiling":
                        _newShares = Math.ceil(Math.abs(oldValue) * Math.pow(10.0, (newDecimal - oldDecimal)))
                    else:
                        raise Exception("ERROR: Bad Decimal Strategy detected '%s'?!" %(decimalAdjustmentMethod))

                    if neg: _newShares *= -1.0

                _newShares = int(_newShares)
                return _newShares


            securityToEdit.setEditingMode()
            securityToEdit.setDecimalPlaces(newDecimal)
            securityToEdit.setParameter(PARAMETER_KEY,True)
            securityToEdit.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_decimal_places:%s}" %(oldDecimal))
            securityToEdit.syncItem()

            # Now for Txns..    .
            if len(securitySubAccountsNeedChanging) > 0:
                txt = "Now editing all relevant txns change decimal precision ....:"
                myPrint("B", txt); output += "\n\n%s\n\n" %(txt)

                for secAcct in securitySubAccountsNeedChanging:
                    txt = "Updating %s..." %(secAcct)
                    myPrint("B",txt); output += "%s\n" %(txt)

                    parentAccount = secAcct.getParentAccount()

                    secAcct.setParameter(PARAMETER_KEY,True)
                    secAcct.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_decimal_places:%s}" %(oldDecimal))

                    secAcct.syncItem()

                    txnsToEdit = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct)

                    if txnsToEdit.getSize() < 1:
                        txt = ".... has no transactions to update..."
                        output += "%s\n" %(txt)
                    else:
                        txt = ".... Updating %s transactions: %s" %(secAcct, txnsToEdit.getSize())
                        myPrint("B",txt); output += "%s\n" %(txt)

                        txnsToEdit = sorted(txnsToEdit, key=lambda _x: (_x.getDateInt()))

                        for txn in txnsToEdit:

                            if not isinstance(txn, SplitTxn):       # Should never happen..... ;->
                                raise Exception("Error: found a non-split: %s" %(txn))

                            pTxn = txn.getParentTxn()

                            lEditingMode = False

                            # Look for and fix any Lot Control records at the same time.... Risky business!
                            if txn.getParameter("cost_basis", None) is not None:
                                cbTags = TxnUtil.parseCostBasisTag(txn)
                                if cbTags is not None:
                                    lAnyTagChanges = False
                                    totalOldSharesBUYS = totalNewSharesBUYS =0
                                    for txnID in cbTags:
                                        oldShareValue = cbTags[txnID]
                                        if oldShareValue == 0: continue
                                        totalOldSharesBUYS += oldShareValue
                                        newShares = calculateNewShares(oldShareValue)
                                        totalNewSharesBUYS += newShares
                                        cbTags[txnID] = newShares
                                        lAnyTagChanges = True

                                    if lAnyTagChanges:
                                        newTag = ""
                                        for txnID in cbTags:
                                            newTag += "{}:{};".format(txnID,cbTags[txnID])
                                        pTxn.setEditingMode()
                                        lEditingMode = True

                                        if debug:
                                            txn.setParameter(PARAMETER_KEY+PARAMETER_KEY_COST_BASIS,txn.getParameter("cost_basis", None))

                                        txn.setParameter("cost_basis", newTag)
                                        output += ".. %s %s ** Updated Lot Control: (Old BUYS: %s New BUYS: %s)**\n" %(
                                                                                                    convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                                                                    pad(pTxn.getInvestTxnType().getIDString(),12),
                                                                                                    totalOldSharesBUYS,
                                                                                                    totalNewSharesBUYS)

                            # get the current raw data
                            splitShares = txn.getValue()
                            splitParentShareValue = txn.getAmount() * -1
                            old_samt = txn.getParameter("samt", None)
                            old_pamt = txn.getParameter("pamt", None)

                            if splitShares == 0:
                                output += ".. %s %s %s Val: %s - Skipping as ZERO shares...\n" %(
                                                               convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                               pad(pTxn.getInvestTxnType().getIDString(),12),
                                                               pad(pTxn.getDescription()+pTxn.getMemo(),40),
                                                               rpad(parentAccount.getCurrencyType().formatFancy(-splitParentShareValue,MD_decimal),12))

                                if lEditingMode:
                                    pTxn.syncItem()  # Left over from the cost basis change above....

                                continue

                            newShares = calculateNewShares(splitShares)

                            if splitParentShareValue == 0:
                                price = 0.0
                            else:
                                price = (1.0 * splitParentShareValue) / (1.0 * splitShares)     # force floating point conversion

                                # Taken from MD code.....
                                price = CurrencyTable.getRawRate(secAcct.getCurrencyType(), parentAccount.getCurrencyType(), 1.0 / price)

                            pTxn.setEditingMode()
                            txn.setParameter(PARAMETER_KEY,True)

                            if debug:
                                txn.setParameter(PARAMETER_KEY+PARAMETER_KEY_DATA,"{old_samt:%s,old_pamt:%s}" %(old_samt, old_pamt))

                            # newShares = adjusted, long. Price = recalculated, double, splitParentShareValue = unchanged, long
                            txn.setAmount(newShares, price, splitParentShareValue)
                            # txn.setParameter("samt", newShares)
                            pTxn.syncItem()

                            output += ".. %s %s %s Val: %s Old Raw Shrs: %s New Raw Shrs: %s New Shrs: %s\n" %(
                                                           convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                           pad(pTxn.getInvestTxnType().getIDString(),12),
                                                           pad(pTxn.getDescription()+pTxn.getMemo(),40),
                                                           rpad(parentAccount.getCurrencyType().formatFancy(-splitParentShareValue,MD_decimal),12),
                                                           rpad(splitShares,12),
                                                           rpad(newShares,12),
                                                           rpad(secAcct.getCurrencyType().formatFancy(txn.getValue(),MD_decimal),25))

                            # Fail safe...!
                            if txn.getParameter("pamt", "ERROR") != old_pamt:
                                raise Exception("ERROR: Txn's new pamt(%s) != old pamt(%s) - review console..." %(txn.getParameter("pamt", "ERROR"),old_pamt))

                            continue

                    output += "----\n"
                    del txnsToEdit

                output += "\n>> Txn decimal places update completed.....\n\n"

            output += "\n>> Update of decimal places completed..\n\n"

        except:

            txt = ("MAJOR ERROR - %s crashed. Please review output, console, and RESTORE YOUR DATASET!"%(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output, lAlertLevel=2, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset after %s changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es).." %(_THIS_METHOD_NAME))
            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # OK - Main update is done....

            lAnyCostBasisErrorsFound = [False]

            if len(securitySubAccountsNeedChanging) > 0:
                output += "\n\nSTATISTICS AFTER EDIT DECIMAL ACTIONS COMPLETED...\n\n"

                for secAcct in securitySubAccountsNeedChanging:
                    txns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(secAcct).getSize()
                    bal = securityToEdit.getDoubleValue(secAcct.getBalance())
                    output += "... %s Txns: %s Balance: %s\n" %(pad(secAcct.getFullAccountName(),50),rpad(txns,12),rpad(bal,12))

                    if not InvestUtil.isCostBasisValid(secAcct):
                        lAnyCostBasisErrorsFound[0] = True
                        output += "   ... WARNING: INVALID COST BASIS / LOT CONTROL DETECTED AFTER UPDATE ***\n"

            if lAnyCostBasisErrorsFound[0]:
                output += "\n\n*** WARNING: INVALID COST BASIS / LOT CONTROL RECORDS WERE DETECTED AFTER UPDATE ***\n"
            else:
                output += "\nNOTE: No Invalid Lot Control/Cost Basis records were detected after the changes were made....\n\n"

            del securitySubAccountsNeedChanging

            output += "\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and %s) back to disk....." %(_THIS_METHOD_NAME),
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                pleaseWait.kill()

            if newDecimal < oldDecimal and lUsingLotControl:
                output += "\n\n *** WARNING - PLEASE REVIEW YOUR LOT CONTROL ALLOCATIONS BUYS to SELLS as fractional losses / mismatches may have occurred! ***\n\n"
                txt = "%s Completed with WARNINGS - review log, check the results & LOT Controlled BUY/SELL Allocations, then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.WARNING_MESSAGE; optionColor = "R"
            elif lAnyCostBasisErrorsFound[0]:
                output += "\n\n *** WARNING - PLEASE REVIEW YOUR LOT CONTROL ALLOCATIONS BUYS to SELLS as LOT CONTROL/COST BASIS ERRORS WERE DETECTED! ***\n\n"
                txt = "%s Completed with WARNINGS - review log, check the results & LOT Controlled BUY/SELL Allocations (Errors Detected), then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.WARNING_MESSAGE; optionColor = "R"
            else:
                txt = "%s successfully completed - please review log, check the results, then RESTART MONEYDANCE" %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.INFORMATION_MESSAGE; optionColor = "DG"

            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES & THEN RESTART MONEYDANCE ***\n\n"
            output += "\n<END>"

        except:
            txt = ("ERROR - %s crashed after the edit actions. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
        setDisplayStatus(txt, optionColor)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionMessage)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def fix_duplicate_securities_within_same_investment_account():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "Repair duplicate Securities:".upper()

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_duplicate_security_fix"

        book = MD_REF.getCurrentAccount().getBook()
        allAccounts = AccountUtil.allMatchesForSearch(book, AcctFilter.ALL_ACCOUNTS_FILTER)

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        class CaptureIllogicalAccount:
            def __init__(self, investmentAccount):
                self.investmentAccount = investmentAccount
                self.illogicalSecurities = {}

        output = "%s\n" \
                 " --------------------------------------\n\n" %(_THIS_METHOD_NAME)

        allInvestmentAccounts = []
        for acct in allAccounts:
            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.INVESTMENT:
                allInvestmentAccounts.append(acct)

        allSecurityAccounts = []
        for acct in allAccounts:
            # noinspection PyUnresolvedReferences
            if acct.getAccountType() == Account.AccountType.SECURITY:
                allSecurityAccounts.append(acct)

        illogicalInvestmentAccounts = []

        for acct in allInvestmentAccounts:
            output += ("\nAnalysing Investment Account: %s\n" %(acct))
            captureIllogicalAccount = CaptureIllogicalAccount(acct)
            storeSecurityAcctsByCurrency = {}
            subAccts = acct.getSubAccounts()
            for subAcct in subAccts:
                # noinspection PyUnresolvedReferences
                if subAcct.getAccountType() != Account.AccountType.SECURITY:
                    raise Exception("ERROR: Found non Security sub account:", subAcct.getFullAccountName())
                secCurr = subAcct.getCurrencyType()
                storeSecurityAcctsByCurrency[secCurr] = storeSecurityAcctsByCurrency.get(secCurr, 0) + 1

            lFoundIllogical = False
            for secCurr in storeSecurityAcctsByCurrency:
                appearances = storeSecurityAcctsByCurrency[secCurr]
                flag = (" "*5) if (appearances <= 1) else ("*"*5)
                output += ("... %s Security '%s' appears: %s times...\n" %(flag, secCurr, appearances))

                if appearances > 1:
                    lFoundIllogical = True
                    captureIllogicalAccount.illogicalSecurities[secCurr] = []
                    subAccts = acct.getSubAccounts()
                    for subAcct in subAccts:
                        if subAcct.getCurrencyType() == secCurr:
                            captureIllogicalAccount.illogicalSecurities[secCurr].append(subAcct)

            if lFoundIllogical: illogicalInvestmentAccounts.append(captureIllogicalAccount)

        output += ("\n")

        if len(illogicalInvestmentAccounts) < 1:
            txt = "CONGRATULATIONS - No duplicated Securities within Investment Account(s) found"
            output += ("%s\n" %(txt))
            setDisplayStatus(txt, "B"); myPrint("B", txt)
            jif = QuickJFrame(_THIS_METHOD_NAME, output).show_the_frame()
            myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.INFORMATION_MESSAGE)
            return

        lCostBasisFlagWarning = False

        output += ("@@@ ERROR - found %s duplicated securities with investment account(s)...!\n\n" %(len(illogicalInvestmentAccounts)))
        for captureIllogicalAccount in illogicalInvestmentAccounts:
            output += ("\nInvestment Account: %s\n" %(captureIllogicalAccount.investmentAccount))
            for secCurr in captureIllogicalAccount.illogicalSecurities:
                output += ("... Security: %s\n" %(secCurr))

                lUsesAverageCost = None
                lUsesAverageCostDifferent = False
                for subAcct in captureIllogicalAccount.illogicalSecurities[secCurr]:
                    if lUsesAverageCost is None: lUsesAverageCost = subAcct.getUsesAverageCost()
                    if lUsesAverageCost != subAcct.getUsesAverageCost():
                        lUsesAverageCostDifferent = True
                        lCostBasisFlagWarning = True

                    txns = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTransactionsForAccount(subAcct)
                    output += ("...... Sub security account (%s): %s Txn count: %s %s\n" %(subAcct.getUUID(), subAcct.getAccountName(), txns.getSize(),
                                                                                           "" if not lUsesAverageCostDifferent else "(WARNING: Cost Basis Flags different (Avg Cst vs Lot Control)"))

        txt = ("@@@@ FIX REQUIRED!!! @@@@")
        output += ("\n\n%s\n\n" %(txt))

        jif = QuickJFrame(txt, output, lJumpToEnd=True, lWrapText=False).show_the_frame()
        myPopupInformationBox(jif, "WARNING: %s duplicated securities found within investment account(s)!" %(len(illogicalInvestmentAccounts)),
                              theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)

        if not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME.upper(),
                                                 "EXECUTE FIX/MERGE OF %s DUPLICATED SECURITIES WITHIN INVESTMENT ACCOUNT(s)?" %(len(illogicalInvestmentAccounts))):
            return

        jif.dispose()

        output += "\nPROCEEDING TO FIX\n\n"

        accountsToDelete = []

        for captureIllogicalAccount in illogicalInvestmentAccounts:
            output += ("\nFIXING Investment Account: %s\n" %(captureIllogicalAccount.investmentAccount))
            for secCurr in captureIllogicalAccount.illogicalSecurities:
                output += ("... Security: %s\n" %(secCurr))

                acctToKeep = captureIllogicalAccount.illogicalSecurities[secCurr][0]
                for subAcct in list(captureIllogicalAccount.illogicalSecurities[secCurr]):
                    txns = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTransactionsForAccount(subAcct)
                    if subAcct == acctToKeep:
                        output += ("...... Keeping sub security account (%s) as the primary for: %s (with: %s txns) Cost Basis: '%s'\n" %(subAcct.getUUID(), subAcct.getAccountName(), txns.getSize(),
                                                                                                                                          "Average Cost" if (subAcct.getUsesAverageCost()) else "LOT Control"))
                        continue
                    output += ("...... FIXING Sub security account (%s): %s - changing %s transactions (note: this security/subacct used Cost Basis: '%s')\n" %(subAcct.getUUID(), subAcct.getAccountName(), txns.getSize(),
                                                                                                                                                                "Average Cost" if (subAcct.getUsesAverageCost()) else "LOT Control"))
                    for txn in txns:
                        pTxn = txn.getParentTxn()
                        pTxn.setEditingMode()
                        txn.setAccount(acctToKeep)
                        txn.setParameter(PARAMETER_KEY, True)
                        pTxn.syncItem()
                    accountsToDelete.append(subAcct)

                    InvestUtil.getCostBasis(subAcct)
                    if not InvestUtil.isCostBasisValid(subAcct):
                        output += ("......... Cost Basis reports as 'invalid' please manually review\n")

        output += "\n"
        for subAcct in accountsToDelete:
            txns = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTransactionsForAccount(subAcct)
            if txns.getSize() != 0:
                txt = "ERROR: Something's gone wrong! Resulting txn count should be ZERO! Acct: %s (CONSIDER RESTORE!)" %(subAcct)
                output += "%s\n" %(txt)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                jif = QuickJFrame(_THIS_METHOD_NAME, output).show_the_frame()
                myPopupInformationBox(jif, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
                return
            output += "......... will delete old (empty) sub security account: %s\n" %(subAcct)

        if lCostBasisFlagWarning:
            output += ("\n\nWARNING - you had Cost Basis (Average Cost Basis vs LOT Control) flag differences. Please review these settings (and update your LOT matching if appropriate)\n\n")

        MD_REF.getCurrentAccount().getBook().logRemovedItems(accountsToDelete)
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..

        txt = "SUCCESS / FINISHED - Please review your investment portfolios"
        output += "\n%s\n" %(txt)
        setDisplayStatus(txt, "B"); myPrint("B", txt)
        play_the_money_sound()
        jif = QuickJFrame(_THIS_METHOD_NAME, output, lJumpToEnd=True, lWrapText=False).show_the_frame()
        myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    # noinspection PyUnresolvedReferences
    def merge_duplicate_securities():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "Merge 'Duplicate' Securities (by 'ticker')"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        PARAMETER_KEY = "toolbox_security_merge"
        PARAM_CURRID = "curr_id."

        today = Calendar.getInstance()                                                                                  # noqa
        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "%s: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output = "%s:\n" \
                 " ============================================================\n\n" %(_THIS_METHOD_NAME)

        myPrint("B", "%s: Analysing..." %(_THIS_METHOD_NAME))

        try:

            base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

            # Sweep One - gather the potential targets by duplicate Ticker Symbol....
            dup_securities = OrderedDict()
            securities = []
            currencies = sorted(MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies(),
                                key=lambda x: (x.getCurrencyType(), x.getName().upper(), x.getTickerSymbol(), x.getIDString()))

            for currSec in currencies:
                if currSec.getCurrencyType() != CurrencyType.Type.SECURITY: continue                                    # noqa
                securities.append(currSec)
                theTicker = currSec.getTickerSymbol().strip().upper()
                if theTicker is None or theTicker == "" or len(theTicker) < 1: continue
                getDup = dup_securities.get(theTicker)
                if getDup is not None:
                    getDup[0] += 1
                    getDup[1].append(currSec)
                else:
                    getDup = [1, [currSec]]
                dup_securities[theTicker] = getDup
            del currencies

            def compareSplits(splitsOne, splitsTwo):
                if len(splitsOne) < 1 and len(splitsTwo) < 1:   return True
                if len(splitsOne) != len(splitsTwo):            return False
                splitsOne = sorted(splitsOne, key=lambda sort_x: (sort_x.getDateInt()))
                splitsTwo = sorted(splitsTwo, key=lambda sort_x: (sort_x.getDateInt()))

                for i in range(0,len(splitsOne)):
                    s1 = splitsOne[i]
                    s2 = splitsTwo[i]
                    if s1.getDateInt() != s2.getDateInt():        return False
                    if s1.getSplitRatio() != s2.getSplitRatio():  return False
                    # if s1.getNewShares() != s2.getNewShares():    return False
                    # if s1.getOldShares() != s2.getOldShares():    return False

                return True

            try: myPrint("DB","%s: Initial candidates found %s %s" %(_THIS_METHOD_NAME, len(dup_securities), dup_securities))
            except: pass

            # Sweep Two - start validating the data found
            lShowOutput = False
            removeList = []

            output +=   "Performing analysis and validation of potential 'duplicate' Securities.\n\n" \
                        "The following data can be edited in MD Menu > Tools>Securities (** except 'Decimal Places' where you will need to use Toolbox to edit)\n\n" \
                        "The check / validation rules are:\n" \
                        "- Find potential 'duplicates' where Securities' 'Ticker' Symbols are the same; then Duplicate Security's...:\n" \
                        "... ID must be short and DIFFERENT (so you can identify them in this process). Examples: use '^APPL1', '^APPL2', '^APPL3'.. to merge 3 Apple Stocks\n" \
                        "....(^^Close this window and use Tools>Securities>EDIT and change the Security ID for each duplicate and then re-run this function again)\n" \
                        "...'Currency' must match\n" \
                        "...'Current Price' must match\n" \
                        "...'Prefix' & 'Suffix' must match\n" \
                        "...'Splits' data must match\n" \
                        "... hidden 'Decimal Places' setting must match **\n" \
                        "- NOTE: Security Name is not matched, but you can select the Security to become the 'master', that has right details, as part of the process\n" \
                        "\n" \
                        "--------------------------------------------------------------------------------------------------------------------------------------------------\n\n"

            def getSecurityNameAndID(theSec, theLen=None):

                theName = theSec.getName()
                if theLen: theName = theName[:theLen]+".."
                return "%s(ID: %s)" %(theName,theSec.getIDString())


            class StoreSecurity:
                def __init__(self, _obj):
                    self.obj = _obj                         # type: CurrencyType

                def getSecurity(self): return self.obj      # type: CurrencyType

                def getDisplayString(self, _security, _short=False):

                    if _short:
                        return ("%s:ID %s:rate %s:dpc %s:%s:%s:(%s price recs)"
                                % (_security.getName()[:35]+"..",
                                   _security.getIDString(),
                                   safeInvertRate(_security.getRelativeRate()),
                                   _security.getDecimalPlaces(),
                                   _security.getPrefix(),
                                   _security.getSuffix(),
                                   _security.getSnapshots().size()))

                    return ("%s:Ticker %s:ID %s:rate %s:dpc %s:%s:%s:(%s price history recs)"
                            % (_security.getName(),
                               _security.getTickerSymbol(),
                               _security.getIDString(),
                               safeInvertRate(_security.getRelativeRate()),
                               _security.getDecimalPlaces(),
                               _security.getPrefix(),
                               _security.getSuffix(),
                               _security.getSnapshots().size()))

                def shortDisplay(self):
                    return (self.getDisplayString(self.getSecurity(),True))

                def __str__(self): return (self.getDisplayString(self.getSecurity()))[:200]

                def __repr__(self): return self.__str__()

            for dup in dup_securities:
                getDup = dup_securities.get(dup)
                if getDup[0] < 2:
                    removeList.append(dup)
                    continue

                highestSnapCount = 0
                primaryCurr = getDup[1][0]
                for scanDup in getDup[1]:
                    getSnaps = scanDup.getSnapshots()
                    if getSnaps.size() > highestSnapCount:
                        highestSnapCount = getSnaps.size()
                        primaryCurr = scanDup

                getDup[1].remove(primaryCurr)
                getDup[1].insert(0, primaryCurr)

                foundIDs = [primaryCurr.getIDString().strip().lower()]

                lFailChecks = False
                primarySplits = primaryCurr.getSplits()
                output += "Verifying potential 'duplicates': %s(Ticker: %s Master ID: %s) (has %s price history records)\n"\
                          %(primaryCurr.getName(),dup,primaryCurr.getIDString(),highestSnapCount)

                for scanDup in getDup[1]:

                    if scanDup == primaryCurr: continue     # You can't check against yourself...!

                    _tempSec = StoreSecurity(scanDup)
                    _len = 95

                    getDupID = scanDup.getIDString().strip().lower()
                    txt = " --- (Validating ID: %s)\n" \
                          "... '%s' NOTE: has %s price history records" %(scanDup.getIDString(), pad(_tempSec.shortDisplay(),_len), scanDup.getSnapshots().size())
                    output += "%s\n" %(txt)

                    if getDupID in foundIDs:
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as using identical ID                   %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getIDString(),primaryCurr.getIDString())
                        myPrint("DB",txt); output += "%s\n" %(txt)
                    else:
                        foundIDs.append(getDupID)

                    if scanDup.getRelativeCurrency() != primaryCurr.getRelativeCurrency():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not using the same relative currency %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getRelativeCurrency().getName(),primaryCurr.getRelativeCurrency().getName())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getDecimalPlaces() != primaryCurr.getDecimalPlaces():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same decimal places          %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getDecimalPlaces(),primaryCurr.getDecimalPlaces())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getRelativeRate() != primaryCurr.getRelativeRate():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same 'Current Prices'        %s vs %s" %(pad(_tempSec.shortDisplay(),_len),safeInvertRate(scanDup.getRelativeRate()),safeInvertRate(primaryCurr.getRelativeRate()))
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    if scanDup.getPrefix()+scanDup.getSuffix() != primaryCurr.getPrefix()+primaryCurr.getSuffix():
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not the same prefix/suffix           %s vs %s" %(pad(_tempSec.shortDisplay(),_len),scanDup.getPrefix()+":"+scanDup.getSuffix(),primaryCurr.getPrefix()+":"+primaryCurr.getSuffix())
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    thisSplits = scanDup.getSplits()
                    if not compareSplits(primarySplits, thisSplits):
                        lShowOutput = lFailChecks = True
                        txt = "... '%s' CANNOT be MERGED as not all have the same splits..." %(pad(_tempSec.shortDisplay(),_len))
                        myPrint("DB",txt); output += "%s\n" %(txt)

                    output += "\n"
                    del _tempSec

                if lFailChecks:
                    txt = "... *** Failed checks - removing candidate....."
                    myPrint("DB",txt); output += "%s\n" %(txt)
                    removeList.append(dup)
                else:
                    txt = "... *** PASSED checks - will include as candidate for merging....."
                    myPrint("DB",txt); output += "%s\n" %(txt)

                output += "\n"

            for remove_ticker in removeList:
                del dup_securities[remove_ticker]
            del removeList

            try: myPrint("DB","%s: After validation, found %s %s" %(_THIS_METHOD_NAME, len(dup_securities), dup_securities))
            except: pass

            if len(securities) < 2 or len(dup_securities) < 1:
                output += "\n" \
                          "Use MD Menu > Tools>Securities to make changes necessary for Securities to 'qualify' for merging....\n" \
                          "Ensure you use a DIFFERENT ID for each duplicate - e.g. ^APPL1, ^APPL2, ^APPL3 for Apple (for example)...\n" \
                          "** except for decimal places differences. Use Toolbox 'MENU: Currency & Security tools > FIX: Edit a Security's (hidden) Decimal Place setting'\n" \
                          "\n"
                if lShowOutput:
                    txt = "%s: Not enough Securities / no valid duplicate Tickers found (refer report on screen for details) - NO CHANGES MADE" %(_THIS_METHOD_NAME)
                else:
                    txt = "%s: Not enough Securities / no duplicate Tickers found - NO CHANGES MADE" %(_THIS_METHOD_NAME)
                myPrint("B",txt); output += "\n%s\n" %(txt)
                setDisplayStatus(txt, "R")
                output += "\n<END>"
                if lShowOutput:
                    jif=QuickJFrame(txt, output, lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                    myPopupInformationBox(jif,txt)
                else:
                    myPopupInformationBox(toolbox_frame_,txt)
                return
            del lShowOutput


            txt = _THIS_METHOD_NAME
            if not perform_qer_quote_loader_check(toolbox_frame_, txt): return


            class StoreTickerData:
                def __init__(self, _theTicker, numberCandidates, listSecurityCandidates):
                    self.theTicker = _theTicker
                    self.numberCandidates = numberCandidates
                    self.listSecurityCandidates = listSecurityCandidates        # type: [CurrencyType]
                    self.primarySecurity = self.listSecurityCandidates[0]

                def getTicker(self):
                    return (self.theTicker)

                def getName(self):
                    return (self.primarySecurity.getName())

                def getSecurityList(self):
                    return (self.listSecurityCandidates)

                def getSecurityListWithoutPrimary(self):
                    listAccts = []
                    for acct in self.listSecurityCandidates:
                        if acct == self.getPrimarySecurity(): continue
                        listAccts.append(acct)
                    return (listAccts)

                def getPrimarySecurity(self):
                    return (self.primarySecurity)

                def setPrimarySecurity(self, theSecurity):
                    self.primarySecurity = theSecurity

                def getDisplayString(self, _security):
                    return ("%s:Ticker %s:ID %s:rate %s:dpc %s:%s:%s:(%s price history recs)"
                            % (_security.getName(),
                               self.theTicker,
                               _security.getIDString(),
                               safeInvertRate(_security.getRelativeRate()),
                               _security.getDecimalPlaces(),
                               _security.getPrefix(),
                               _security.getSuffix(),
                               _security.getSnapshots().size()))

                def __str__(self): return (self.getDisplayString(self.getPrimarySecurity()))[:200]

                def __repr__(self): return self.__str__()

            listDuplicateTickers = []
            output += "\nFinal list of 'duplicate' candidates...:\n"

            for dup in dup_securities:
                theDupDetails = dup_securities[dup]
                listDuplicateTickers.append(StoreTickerData(dup,theDupDetails[0],theDupDetails[1]))
                txt = ".. %s found for Ticker: '%s'" %(theDupDetails[0],dup)
                myPrint("DB",txt); output += "%s\n" %(txt)
                for theDups in theDupDetails[1]:
                    txt = "         - Name: %s ID: %s Rate: %s Dpc: %s Prx:Sfx: %s (Price History records: %s)"\
                          %(pad(theDups.getName(),30),
                            pad(theDups.getIDString(),20),
                            rpad(safeInvertRate(theDups.getRelativeRate()),12),
                            rpad(theDups.getDecimalPlaces(),2),
                            pad(theDups.getPrefix()+":"+theDups.getSuffix(),20),
                            rpad(theDups.getSnapshots().size(),12))
                    myPrint("DB",txt); output += "%s\n" %(txt)
                output += "\n"
            del dup_securities

            output += "\n"

            jif = QuickJFrame("%s: Candidates" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            tickerToMerge = JOptionPane.showInputDialog(jif,
                                                         "Select Ticker / Security set to merge (sorted by Name, Ticker, ID)",
                                                        _THIS_METHOD_NAME.upper(),
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(None),
                                                         listDuplicateTickers,
                                                         None)                                                              # type: StoreTickerData
            del listDuplicateTickers

            if not tickerToMerge:
                txt = "%s: User did not select a Ticker / Security set to merge - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            quickSecurityDropdownList = []
            for secDropdown in tickerToMerge.getSecurityList():
                quickSecurityDropdownList.append(StoreSecurity(secDropdown))

            selectedSecurity = JOptionPane.showInputDialog(jif,
                                                           "Select the Security that will be the final master (sorted by Name, Ticker, ID)",
                                                           _THIS_METHOD_NAME.upper(),
                                                           JOptionPane.INFORMATION_MESSAGE,
                                                           getMDIcon(None),
                                                           quickSecurityDropdownList,
                                                           None)  # type: StoreSecurity

            if not selectedSecurity:
                txt = "%s: User did not select a Security as the master for the merge - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            selectedSecurity = selectedSecurity.getSecurity()

            jif.dispose()

            if selectedSecurity != tickerToMerge.getPrimarySecurity():
                txt = "Master security switched from %s to %s (ID: %s)"\
                      %(tickerToMerge.getPrimarySecurity(), selectedSecurity, selectedSecurity.getIDString())
                myPrint("DB",txt); output += "%s\n" %(txt)
                tickerToMerge.setPrimarySecurity(selectedSecurity)

            output += "\n\n" \
                      "Selected Ticker / Security: '%s'\n" %(tickerToMerge.getTicker())

            output += "Selected Security to use as the master for the merge: %s\n\n" %(tickerToMerge.getDisplayString(selectedSecurity))
            del selectedSecurity

            # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
            allInvestmentAccounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(23))

            output += "\nAnalysis of Securities to Merge - Ticker '%s' - %s:\n\n" %(tickerToMerge.getTicker(),tickerToMerge.getName())

            lAnyCostBasisErrorsFound = [False]

            # Prepare before totals...
            _WHAT = 0
            _QTY = 1
            _COSTBASIS = 2
            _VALUE = 3
            _CBFLAG = 4

            # noinspection PyUnresolvedReferences
            def create_totals(theCount, theAccount, theTable):
                _acctRelCurr = theAccount.getCurrencyType()
                theTable.append(["Txn Count",    theCount, "", "", ""])
                theTable.append(["Account Starting Balance", "","",_acctRelCurr.formatSemiFancy(theAccount.getStartBalance(),MD_decimal), ""])
                theTable.append(["Cash Balance", "", "", _acctRelCurr.formatSemiFancy(theAccount.getBalance(),MD_decimal), ""])
                _totals = [0.0, 0.0, _acctRelCurr.getDoubleValue(theAccount.getBalance()), False]
                lDetectCBError = False
                for acct in theAccount.getSubAccounts():
                    if acct.getAccountType() == Account.AccountType.SECURITY:

                        if not InvestUtil.isCostBasisValid(acct):
                            lDetectCBError = True
                            lAnyCostBasisErrorsFound[0] = True

                        _subAcctRelCurr = acct.getCurrencyType()
                        subAcctBal = acct.getBalance()
                        subAcctCostBasis = InvestUtil.getCostBasis(acct)
                        # price = (1.0 / _subAcctRelCurr.adjustRateForSplitsInt(DateUtil.convertCalToInt(today), _subAcctRelCurr.getRelativeRate()))                        # noqa
                        price = CurrencyTable.getUserRate(_subAcctRelCurr, _acctRelCurr)                                # noqa

                        _totals[0] += _subAcctRelCurr.getDoubleValue(subAcctBal)
                        _totals[1] += _acctRelCurr.getDoubleValue(subAcctCostBasis)
                        _totals[2] +=  round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())
                        if lDetectCBError: _totals[3] = True
                        theTable.append([getSecurityNameAndID(acct.getCurrencyType()),
                                         _subAcctRelCurr.formatSemiFancy(subAcctBal,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(subAcctCostBasis,MD_decimal),
                                         _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(round(_subAcctRelCurr.getDoubleValue(subAcctBal) * price,_acctRelCurr.getDecimalPlaces())),MD_decimal),
                                         lDetectCBError])
                theTable.append(["**TOTALS:",
                                 _totals[0],
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[1]),MD_decimal),
                                 _acctRelCurr.formatSemiFancy(_acctRelCurr.getLongValue(_totals[2]),MD_decimal),
                                 _totals[3]])


            def output_stats(theText, theAccount, theTable):

                if theAccount.getCurrencyType() == base or theAccount.getCurrencyType() is None:
                    relText = ""
                else:
                    relText = " relative to %s" %(theAccount.getCurrencyType().getRelativeCurrency())

                local_output = "%s: %s (Currency: %s%s)\n" %(theText, theAccount, theAccount.getCurrencyType(), relText)
                iRow = 1
                posInc = 0
                for data in theTable:
                    if iRow == 2:
                        posInc += 14
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("Qty Shares",12), rpad("Cost Basis",15), rpad("Current Value",15))
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    if iRow == 4:
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("",12), rpad("",15), rpad("-------------",15))

                    if data[_WHAT].upper() == "**TOTALS:".upper():
                        local_output += "   %s %s %s %s\n" %(pad("",60+posInc),rpad("----------",12), rpad("----------",15), rpad("-------------",15))

                    cbMsg = ""
                    if data[_CBFLAG]: cbMsg = " * Cost Basis Error detected"
                    local_output += "   %s %s %s %s %s\n" %(pad(data[_WHAT],60+posInc),rpad(data[_QTY],12), rpad(data[_COSTBASIS],15), rpad(data[_VALUE],15),cbMsg)
                    iRow += 1
                return local_output


            def isSecurityHeldWithinInvestmentAccount(_theSecurity, _theInvestmentAccount):

                _subAccts = _theInvestmentAccount.getSubAccounts()
                for _subAcct in _subAccts:
                    # noinspection PyUnresolvedReferences
                    if _subAcct.getAccountType() != Account.AccountType.SECURITY: continue
                    _subAcctCurr = _subAcct.getCurrencyType()
                    if _subAcctCurr is None: continue
                    if _subAcctCurr == _theSecurity:
                        return _subAcct

                return None


            def isSecurityHeldWithinAnyInvestmentAccount(_theSecurity):

                # MyAcctFilter() - 22 Security Sub Accounts; 23 Investment Accounts
                _subAccts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(22))

                for _subAcct in _subAccts:
                    # noinspection PyUnresolvedReferences
                    if _subAcct.getAccountType() != Account.AccountType.SECURITY: continue
                    _subAcctCurr = _subAcct.getCurrencyType()
                    if _subAcctCurr is None: continue
                    if _subAcctCurr == _theSecurity:
                        return _subAcct

                return None


            def isAnySecurityHeldWithinInvestmentAccount(_theSecurityList, _theInvestmentAccount):

                for _theSecurity in _theSecurityList:
                    _result = isSecurityHeldWithinInvestmentAccount(_theSecurity,_theInvestmentAccount)
                    if _result is not None: return True

                return False


            for security in tickerToMerge.getSecurityList():
                output += "%s Price History Records: %s\n" %(pad(getSecurityNameAndID(security),80),rpad(security.getSnapshots().size(),10))
            output += "\n"


            # OK, now scan existing investment accounts... More validation.....
            investmentAccountsInvolvedInMerge = {}
            investmentAccountsNeedingPrimaryCreated = {}
            investmentAccountsNeedingSecondaryMerge = {}

            lFailValidation = False
            iFoundAnyInvestmentAccounts = 0
            iPrimarySecuritiesToCreate = 0
            iSecuritiesMergedDeleted = 0
            output += "Investment Accounts:\n"
            for investAccount in allInvestmentAccounts:
                if not isAnySecurityHeldWithinInvestmentAccount(tickerToMerge.getSecurityList(), investAccount): continue
                failStartingBalanceMustBeZero = False
                failUsesAverageCostValidation = False
                validateUsesAvgCost = None
                iFoundAnyInvestmentAccounts += 1
                output += "** %s\n" %(investAccount.getAccountName())
                foundPrimary = isSecurityHeldWithinInvestmentAccount(tickerToMerge.getPrimarySecurity(), investAccount)
                if not foundPrimary:
                    iPrimarySecuritiesToCreate += 1
                    output += "   <NEW MASTER SECURITY NOT FOUND IN THIS INVESTMENT ACCOUNT - WILL BE ADDED>\n"
                foundSecondary = False
                for security in tickerToMerge.getSecurityList():
                    foundSecurity = isSecurityHeldWithinInvestmentAccount(security, investAccount)
                    if foundSecurity is not None:
                        if security != tickerToMerge.getPrimarySecurity():
                            foundSecondary = True
                            iSecuritiesMergedDeleted += 1
                        txnsUsed = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(foundSecurity)
                        _relCurr = foundSecurity.getCurrencyType()
                        output += "   %s Uses Avg Cost: %s Shares Held: %s Txns: %s" \
                                  %(pad("'%s':%s" %(foundSecurity.getParentAccount().getAccountName()[:30], getSecurityNameAndID(foundSecurity.getCurrencyType(),theLen=35)),85),
                                    pad(str(foundSecurity.getUsesAverageCost()),6),
                                    rpad(_relCurr.formatSemiFancy(foundSecurity.getBalance(),MD_decimal),18),
                                    rpad(txnsUsed.getSize(),15))
                        if security == tickerToMerge.getPrimarySecurity():
                            output += "   <MASTER - KEEP>\n"
                        else:
                            output += "   ** will be merged/removed **\n"

                        if foundSecurity.getStartBalance() != 0:
                            failStartingBalanceMustBeZero = lFailValidation = True
                            output += "   *** <ERROR - StartingBalance() reports %s - SHOULD ALWAYS BE ZERO! CANNOT MERGE>\n" %(foundSecurity.getStartBalance())

                        if validateUsesAvgCost is None:
                            validateUsesAvgCost = foundSecurity.getUsesAverageCost()
                        elif validateUsesAvgCost != foundSecurity.getUsesAverageCost():
                            output += "   *** <ERROR - UsesAverageCost() differs between Investment Accounts for this same Security! CANNOT MERGE>\n"
                            failUsesAverageCostValidation = lFailValidation = True

                investmentAccountsInvolvedInMerge[investAccount] = True

                if failUsesAverageCostValidation or failStartingBalanceMustBeZero:
                    output += "   <Above Investment account FAILED VALIDATION. Function will ABORT WITHOUT CHANGES>\n"
                elif foundSecondary:
                    investmentAccountsNeedingSecondaryMerge[investAccount] = True
                    output += "   <Above Investment account will be included in Security merge>\n"
                    if not foundPrimary:
                        investmentAccountsNeedingPrimaryCreated[investAccount] = True
                else:
                    output += "   <Above Investment account will NOT be touched, no 'duplicate' securities to merge>\n"

                output += "   ----\n"
            del allInvestmentAccounts

            if not iFoundAnyInvestmentAccounts:
                output += "<NONE FOUND>\n\n"
            else:
                output += "%s Investment Accounts are involved in the merge...\n" %(iFoundAnyInvestmentAccounts)
                output += "... Will add the master security to %s investment accounts\n" %(iPrimarySecuritiesToCreate)
                output += "... Will merge/remove %s duplicate securities from investment accounts\n" %(iSecuritiesMergedDeleted)
                output += "----\n"


            if lFailValidation:
                txt = "\n\n INVESTMENT ACCOUNT: SECURITY HOLDING VALIDATION FAILED - CANNOT PROCEED! Review the report on screen for details.\n"
                myPrint("DB", txt); output += "\n\n%s\n" %(txt)
                setDisplayStatus(txt, "R")
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            output += "\n"

            ############################################################################################################
            # OK - Snapshot validation etc
            primarySnaps = 0
            allOtherSnaps = 0
            for security in tickerToMerge.getSecurityList():
                if security == tickerToMerge.getPrimarySecurity():
                    primarySnaps = security.getSnapshots().size()
                else:
                    allOtherSnaps += security.getSnapshots().size()

            lSnapshotActionRequired = False
            lSnapsDeleteAll = lSnapsMergeAll = lSnapsKeepMasterOnly = lSnapsDumpMaster = False
            if (primarySnaps+allOtherSnaps) < 1:
                output += "No Price History Exists - No action required....\n"
            elif primarySnaps > 0 and allOtherSnaps < 1:
                output += "Only the Primary Security has Price History records - No action required....\n"
            else:
                lSnapshotActionRequired = True
                output += "Master Security has %s Price History records, the others have %s - STRATEGY REQUIRED...\n" %(primarySnaps, allOtherSnaps)

            if lSnapshotActionRequired:
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()

                options = ["Keep Master's %s Price History Records Only (dump the other's %s records)"  %(primarySnaps, allOtherSnaps),
                           "Merge all other %s history records into master's (currently holds %s)"      %(allOtherSnaps, primarySnaps),
                           "Dump Master's %s Price History records, merge %s others into master"        %(primarySnaps, allOtherSnaps),
                           "DELETE ALL %s PRICE HISTORY RECORDS"                                        %(primarySnaps+allOtherSnaps)]

                selectedSnapStrategy = JOptionPane.showInputDialog(jif,
                                                               "Select the Price History Strategy?",
                                                               "%s - PRICE HISTORY" %(_THIS_METHOD_NAME.upper()),
                                                               JOptionPane.INFORMATION_MESSAGE,
                                                               getMDIcon(lAlwaysGetIcon=True),
                                                               options,
                                                               None)

                if not selectedSnapStrategy:
                    txt = "%s: User did not select a Price History Strategy for the merge - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                jif.dispose()

                if options.index(selectedSnapStrategy) == 0:    lSnapsKeepMasterOnly = True
                elif options.index(selectedSnapStrategy) == 1:  lSnapsMergeAll = True
                elif options.index(selectedSnapStrategy) == 2:  lSnapsDumpMaster = True
                else:                                           lSnapsDeleteAll = True

                output += "** Price History Strategy selected: %s\n\n" %(selectedSnapStrategy)


            ############################################################################################################
            # OK - hidden CUSIP validation etc


            def countCUSIPs(_theSec):
                iCUSIPs = 0
                for key in _theSec.getParameterKeys():
                    if key.startswith(PARAM_CURRID):
                        iCUSIPs += 1
                return iCUSIPs


            def getAllUniqueCUSIPs(_theSecList):
                _allUniqueCUSIPs = {}
                returnUniqueCUSIPs = []
                for _theSec in _theSecList:
                    for key in _theSec.getParameterKeys():
                        if key.startswith(PARAM_CURRID):
                            _theScheme = key[len(PARAM_CURRID):]
                            _theCUSIP = _theSec.getIDForScheme(_theScheme)
                            if _allUniqueCUSIPs.get(_theScheme+"."+_theCUSIP) is None:
                                _allUniqueCUSIPs[_theScheme+"."+_theCUSIP] = True
                                returnUniqueCUSIPs.append([_theScheme, _theCUSIP])
                return returnUniqueCUSIPs


            primaryCUSIPs = 0
            allOtherCUSIPs = 0
            for security in tickerToMerge.getSecurityList():
                if security == tickerToMerge.getPrimarySecurity():
                    primaryCUSIPs = countCUSIPs(security)
                else:
                    allOtherCUSIPs += countCUSIPs(security)

            allUniqueCUSIPs = getAllUniqueCUSIPs(tickerToMerge.getSecurityList())
            if len(allUniqueCUSIPs) > 0:
                output += "Hidden CUSIP data found (used for linking Investment Downloaded Securities to MD Securities)...:\n"
                for theScheme, theCUSIP in allUniqueCUSIPs:
                    output += "Scheme: %s, ID: %s\n" %(theScheme, theCUSIP)
                output += "\n"

            lCUSIPActionRequired = False
            if len(allUniqueCUSIPs) < 1:
                output += "No hidden CUSIP data exists - This is OK and No action required....\n"
            elif primaryCUSIPs > 0 and allOtherCUSIPs < 1:
                output += "Only the Master Security has hidden CUSIP data - This is OK and No action required....\n"
            else:
                lCUSIPActionRequired = True
                output += "Hidden CUSIP data - STRATEGY REQUIRED...\n"

            selectedCUSIP = None
            if lCUSIPActionRequired:
                jif = QuickJFrame("Merge duplicate securities (by Ticker): REPORT/LOG",output,copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()

                class StoreCUSIP:
                    def __init__(self, _objScheme, _objCUSIP):
                        self._objScheme = _objScheme
                        self._objCUSIP = _objCUSIP

                    def getScheme(self): return self._objScheme

                    def getCUSIP(self): return self._objCUSIP

                    def __str__(self):
                        if self.getScheme() is None: return ("<NONE> (No hidden CUSIP data)")
                        return ("Scheme: %s, ID: %s" % (self.getScheme(), self.getCUSIP()))

                    def __repr__(self): return self.__str__()


                allUniqueCUSIPsPicklist = []                                                                            # noqa
                allUniqueCUSIPsPicklist.append(StoreCUSIP(None,None))
                for theScheme, theCUSIP in allUniqueCUSIPs:
                    allUniqueCUSIPsPicklist.append(StoreCUSIP(theScheme, theCUSIP))

                selectedCUSIP = JOptionPane.showInputDialog(jif,
                                                            "Select the hidden CUSIP to keep/use in the new Master Security?",
                                                            "%s - HIDDEN CUSIP DATA" % (_THIS_METHOD_NAME.upper()),
                                                            JOptionPane.INFORMATION_MESSAGE,
                                                            getMDIcon(lAlwaysGetIcon=True),
                                                            allUniqueCUSIPsPicklist,
                                                            None)

                del allUniqueCUSIPsPicklist

                if not selectedCUSIP:
                    txt = "%s: User did not select a hidden CUSIP record for the merge - no changes made" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                jif.dispose()

                output += "** Hidden CUSIP Strategy: - CUSIP data selected: %s\n\n" %(selectedCUSIP)
            del allUniqueCUSIPs


            ############################################################################################################
            output += "\n------\n"
            output += "Investment Accounts included in merge:                  %s\n" %(len(investmentAccountsInvolvedInMerge))
            output += "Investment new Master securities to be added:           %s\n" %(len(investmentAccountsNeedingPrimaryCreated))
            output += "Investment 'duplicate' securities to be merged/removed: %s\n" %(len(investmentAccountsNeedingSecondaryMerge))
            output += "\n------\n"


            jif = QuickJFrame("%s: REPORT/LOG" %(_THIS_METHOD_NAME),output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            ask = MyPopUpDialogBox(jif,
                                   "%s: REVIEW DIAGNOSTIC BELOW - THEN CLICK PROCEED TO EXECUTE THE SECURITY MERGE" %(_THIS_METHOD_NAME.upper()),
                                   output,
                                   theTitle=_THIS_METHOD_NAME.upper(),
                                   lCancelButton=True,
                                   OKButtonText="PROCEED")
            if not ask.go():
                txt = "%s: User Aborted - No changes made!" %(_THIS_METHOD_NAME)
                myPrint("B",txt)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME.upper(),
                                                     "EXECUTE MERGE OF SECURITY %s / %s?" %(tickerToMerge.getTicker(),tickerToMerge.getPrimarySecurity())):
                return

            jif.dispose()

            output += "\nUSER ACCEPTED DISCLAIMER AND CONFIRMED TO PROCEED WITH SECURITY MERGE of %s / %s.....\n\n" %(tickerToMerge.getTicker(),getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))

            if len(investmentAccountsInvolvedInMerge) > 0:
                output += "\nSTATISTICS BEFORE START...\n\n"
                for reportAccount in investmentAccountsInvolvedInMerge:
                    getTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(reportAccount)
                    countTxns = getTxns.getSize()
                    valuesTable = []
                    create_totals(countTxns, reportAccount, valuesTable)
                    output += output_stats("Before:", reportAccount, valuesTable)
                    output += "\n----\n"
                    del getTxns, valuesTable

                if lAnyCostBasisErrorsFound[0]:
                    output += "\n\n** WARNING: Lot Control / Cost Basis errors detected before changes started - review output....\n\n"
                else:
                    output += "\nLot Control / Cost Basis reports OK before changes....\n"

            output += "\n"

        except:
            txt = ("MINOR ERROR - %s: crashed before any merge actions. Please review output and console" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        # Catch any crash during the update as this would be bad... :-(
        try:

            pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                          "Please wait: executing 'duplicate' security merge right now..",
                                          theTitle=_THIS_METHOD_NAME.upper(),
                                          lModal=False,
                                          OKButtonText="WAIT")
            pleaseWait.go()

            myPrint("DB","Flushing dataset pre-merge changes in memory to sync... and disabling balance recalculation(s) / display refresh(es)..")
            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the merge..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            ############################################################################################################
            # Start with snapshot merge...
            if not lSnapshotActionRequired:
                txt = "Skipping Price History actions...."
                myPrint("B", txt); output += "%s\n\n" %(txt)
            else:
                primary = tickerToMerge.getPrimarySecurity()
                if lSnapsDumpMaster or lSnapsDeleteAll:
                    getSnaps = primary.getSnapshots()
                    txt = "Deleting %s price history records from %s" %(getSnaps.size(), getSecurityNameAndID(primary))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    for snap in getSnaps: snap.deleteItem()

                if lSnapsMergeAll or lSnapsDumpMaster:
                    for security in tickerToMerge.getSecurityListWithoutPrimary():
                        rCurr = primary.getRelativeCurrency()
                        getSnaps = security.getSnapshots()
                        txt = "Merging %s potential price history records from %s into %s" %(getSnaps.size(), getSecurityNameAndID(security), getSecurityNameAndID(primary))
                        myPrint("B",txt); output += "%s\n" %(txt)
                        for snap in getSnaps:
                            foundSnap = primary.getSnapshotForDate(snap.getDateInt())
                            if foundSnap is not None and foundSnap.getDateInt() == snap.getDateInt():
                                # Found a match - skip
                                pass
                            else:
                                newSnap = primary.addSnapshotInt(snap.getDateInt(), snap.getRate(), rCurr)
                                newSnap.setEditingMode()
                                newSnap.setDailyVolume(snap.getDailyVolume())
                                newSnap.setUserDailyLow(snap.getDailyLow())
                                newSnap.setUserDailyHigh(snap.getDailyHigh())
                                newSnap.syncItem()

                if lSnapsKeepMasterOnly: pass

                for security in tickerToMerge.getSecurityListWithoutPrimary():
                    getSnaps = security.getSnapshots()
                    txt = "Now Deleting %s price history records from %s (post any merge actions)" %(getSnaps.size(), getSecurityNameAndID(security))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    for snap in getSnaps: snap.deleteItem()

                output += "----\n"
                output += "Master %s now contains: %s Price History records...\n" %(getSecurityNameAndID(primary), primary.getSnapshots().size())
                for security in tickerToMerge.getSecurityListWithoutPrimary():
                    output += "Duplicate %s now contains: %s Price History records...\n" %(getSecurityNameAndID(security), security.getSnapshots().size())
                output += "----\n"

            ############################################################################################################
            # Now CUSIP merge...

            def deleteCUSIPs(_theSec):
                _deleteList = []
                for key in _theSec.getParameterKeys():
                    if key.startswith(PARAM_CURRID):
                        _theScheme = key[len(PARAM_CURRID):]
                        _deleteList.append(_theScheme)
                for _delSchemeCUSIP in _deleteList:
                    _theSec.setIDForScheme(_delSchemeCUSIP, None)


            if not lCUSIPActionRequired:
                txt = "Skipping hidden CUSIP data actions...."
                myPrint("B", txt); output += "%s\n\n" %(txt)

            else:

                txt = "Removing any hidden CUSIP data from %s" %(getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))
                myPrint("B",txt); output += "%s\n" %(txt)

                tickerToMerge.getPrimarySecurity().setEditingMode()
                deleteCUSIPs(tickerToMerge.getPrimarySecurity())

                if selectedCUSIP.getScheme():
                    txt = "Adding CUSIP data - Scheme: %s ID: %s to %s" %(selectedCUSIP.getScheme(), selectedCUSIP.getCUSIP(), getSecurityNameAndID(tickerToMerge.getPrimarySecurity()))
                    myPrint("B",txt); output += "%s\n" %(txt)
                    tickerToMerge.getPrimarySecurity().setIDForScheme(selectedCUSIP.getScheme(),selectedCUSIP.getCUSIP())

                tickerToMerge.getPrimarySecurity().setParameter(PARAMETER_KEY,True)
                tickerToMerge.getPrimarySecurity().syncItem()

                output += "----\n"
                output += "Master %s now contains: hidden CUSIP record: Scheme: %s, ID: %s\n" %(getSecurityNameAndID(tickerToMerge.getPrimarySecurity()), selectedCUSIP.getScheme(),selectedCUSIP.getCUSIP())
                output += "----\n"


            ############################################################################################################
            # Now create any missing Primary security sub account(s)...

            if len(investmentAccountsNeedingPrimaryCreated) > 0:
                txt = "Adding the new master Security to %s Investment accounts:" %(len(investmentAccountsNeedingPrimaryCreated))
                myPrint("B", txt); output += "%s\n" %(txt)

                primary = tickerToMerge.getPrimarySecurity()
                for createAccount in investmentAccountsNeedingPrimaryCreated:
                    # Copy the first one we find... Yup - there could be more, but tough!
                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,createAccount)

                        if copyAcct is None: continue

                        txt = "... Adding: %s to %s" %(getSecurityNameAndID(primary), createAccount)
                        myPrint("B", txt); output += "%s\n" %(txt)

                        newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(),
                                                              Account.AccountType.SECURITY,
                                                              createAccount)
                        newSecurityAcct.setEditingMode()
                        newSecurityAcct.getUUID()
                        newSecurityAcct.setAccountName(primary.getName())
                        newSecurityAcct.setCurrencyType(primary)
                        newSecurityAcct.setStartBalance(0)

                        newSecurityAcct.setUsesAverageCost(copyAcct.getUsesAverageCost())
                        newSecurityAcct.setBroker(copyAcct.getBroker())
                        newSecurityAcct.setBrokerPhone(copyAcct.getBrokerPhone())
                        newSecurityAcct.setAPR(copyAcct.getAPR())
                        newSecurityAcct.setBondType(copyAcct.getBondType())
                        newSecurityAcct.setComment(copyAcct.getComment())
                        newSecurityAcct.setCompounding(copyAcct.getCompounding())
                        newSecurityAcct.setFaceValue(copyAcct.getFaceValue())
                        newSecurityAcct.setFaceValue(copyAcct.getFaceValue())
                        newSecurityAcct.setMaturity(copyAcct.getMaturity())
                        newSecurityAcct.setMonth(copyAcct.getMonth())
                        newSecurityAcct.setNumYears(copyAcct.getNumYears())
                        newSecurityAcct.setPut(copyAcct.getPut())
                        newSecurityAcct.setOptionPrice(copyAcct.getOptionPrice())
                        newSecurityAcct.setDividend(copyAcct.getDividend())
                        newSecurityAcct.setExchange(copyAcct.getExchange())
                        newSecurityAcct.setSecurityType(copyAcct.getSecurityType())
                        newSecurityAcct.setSecuritySubType(copyAcct.getSecuritySubType())
                        newSecurityAcct.setStrikePrice(copyAcct.getStrikePrice())

                        for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                            newSecurityAcct.setParameter(param, copyAcct.getParameter(param))

                        newSecurityAcct.setParameter(PARAMETER_KEY,True)
                        newSecurityAcct.syncItem()

                        break

            lErrorDeletingSecuritySubAccounts = False
            if len(investmentAccountsNeedingSecondaryMerge) > 0:
                txt = "Now reassigning relevant txns to the new/merged master security....:"
                myPrint("B", txt); output += "\n\n%s\n" %(txt)

                # now for the merge/reassignment of relevant transactions...
                for reassignAcct in investmentAccountsNeedingSecondaryMerge:

                    primaryAcct = isSecurityHeldWithinInvestmentAccount(tickerToMerge.getPrimarySecurity(),reassignAcct)

                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,reassignAcct)
                        if copyAcct is None: continue

                        reassignTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(copyAcct)
                        reassignTxns = sorted(reassignTxns, key=lambda _x: (_x.getDateInt()))

                        # Note sorted loses x.getSize() >> use len(x)
                        output += "... retrieved %s txns from duplicate security %s within investment account '%s' - reassigning.....\n" %(len(reassignTxns), getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount())

                        for srcTxn in reassignTxns:

                            if not isinstance(srcTxn, SplitTxn):       # Should never happen..... ;->
                                raise Exception("Error: found a non-split: %s" %(srcTxn))

                            pTxn = srcTxn.getParentTxn()
                            pTxn.setEditingMode()
                            srcTxn.setAccount(primaryAcct)
                            srcTxn.setParameter(PARAMETER_KEY,True)
                            pTxn.syncItem()
                            output += ".. %s %s %s %s\n" %(convertStrippedIntDateFormattedText(pTxn.getDateInt()),
                                                           pad(pTxn.getInvestTxnType().getIDString(),12),
                                                           pad(pTxn.getDescription()+pTxn.getMemo(),60),
                                                           rpad(copyAcct.getCurrencyType().formatFancy(srcTxn.getValue(),MD_decimal),18))
                            continue

                        output += "\n"
                        del reassignTxns

                output += "\n>> Txn reassignment completed.....\n\n"

                txt = "Now removing duplicate securities from Investment account(s)...."
                myPrint("B", txt); output += "\n%s\n" %(txt)

                ############################################################################################################
                # now delete the empty sub accounts.....
                for reassignAcct in investmentAccountsNeedingSecondaryMerge:

                    for findAcctToCopy in tickerToMerge.getSecurityListWithoutPrimary():
                        copyAcct = isSecurityHeldWithinInvestmentAccount(findAcctToCopy,reassignAcct)
                        if copyAcct is None: continue

                        remainingTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(copyAcct)
                        output += "... %s txns left in %s for duplicate security %s ..." %(remainingTxns.getSize(), copyAcct.getParentAccount(), getSecurityNameAndID(copyAcct.getCurrencyType()))

                        if remainingTxns.getSize() < 1:
                            txt = "... Removing: security %s (empty) from Account: %s" %(getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount())
                            myPrint("B", txt); output += "%s\n" %(txt)
                            copyAcct.deleteItem()
                        else:
                            lErrorDeletingSecuritySubAccounts = True
                            txt = "... *** ERROR - Cannot remove security %s from %s as it still contains %s txns! ***" %(getSecurityNameAndID(copyAcct.getCurrencyType()), copyAcct.getParentAccount(), remainingTxns.getSize())
                            myPrint("B", txt); output += "%s\n" %(txt)

                output += "\n>> Removal of duplicate Securities from Investment Account(s) completed.....\n\n"

            # Now delete the (empty) and now unused old duplicate Securities
            txt = "Now deleting the redundant duplicate security(s) (that have been merged into the new master) from Tools>Securities..:"
            myPrint("B", txt); output += "\n%s\n\n" %(txt)

            lErrorDeletingSecurities = False
            for securityToDelete in tickerToMerge.getSecurityListWithoutPrimary():
                findSecurityAcct = isSecurityHeldWithinAnyInvestmentAccount(securityToDelete)
                if findSecurityAcct is None:
                    output += ".. Verified %s is not being used...... DELETING REDUNDANT SECURITY FROM TOOLS>SECURITIES....\n" %(getSecurityNameAndID(securityToDelete))
                    securityToDelete.deleteItem()
                else:
                    lErrorDeletingSecurities = True
                    output += ".. ERROR %s is still being used in %s ...... ** NOT DELETING REDUNDANT SECURITY FROM TOOLS>SECURITIES **\n" %(getSecurityNameAndID(securityToDelete), findSecurityAcct)

            output += "\n>> Merge 'duplicate' Securities completed..\n\n"

            del tickerToMerge

        except:

            txt = ("MAJOR ERROR - %s: crashed. Please review output, console, and RESTORE YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt,output, lAlertLevel=2, copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:

            myPrint("DB","Saving dataset merge 'duplicate' security changes in memory to sync... and re-enabling balance recalculation(s) and display refresh(es)..")
            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            pleaseWait.kill()                                                                                           # noqa

        try:
            # OK - Main update is done....

            lAnyCostBasisErrorsFound[0] = False
            if len(investmentAccountsInvolvedInMerge) > 0:
                output += "\n\nSTATISTICS AFTER MERGE ACTIONS COMPLETED...\n\n"
                for reportAccount in investmentAccountsInvolvedInMerge:
                    getTxns = MD_REF.getCurrentAccountBook().getTransactionSet().getTransactionsForAccount(reportAccount)
                    countTxns = getTxns.getSize()
                    valuesTable = []
                    create_totals(countTxns, reportAccount, valuesTable)
                    output += output_stats("After:", reportAccount, valuesTable)
                    output += "\n----\n"
                    del getTxns, valuesTable

                if lAnyCostBasisErrorsFound[0]:
                    output += "\n\n** WARNING: Lot Control / Cost Basis errors detected after changes completed - review output....\n\n"
                else:
                    output += "\nLot Control / Cost Basis reports OK after changes....\n"

            del investmentAccountsInvolvedInMerge, investmentAccountsNeedingSecondaryMerge, investmentAccountsNeedingPrimaryCreated

            output += "\n"

            if True:    # We are saving Trunk as we want to flush the mass changes to disk. Stops the restart reapplying these again....
                pleaseWait = MyPopUpDialogBox(toolbox_frame_,
                                              "Please wait: Flushing dataset (and merge actions) back to disk.....",
                                              theTitle=_THIS_METHOD_NAME.upper(),
                                              lModal=False,
                                              OKButtonText="WAIT")
                pleaseWait.go()

                txt = "... Saving Trunk to flush all changes back to disk now ...."
                myPrint("B", txt); output += "\n%s\n" %(txt)
                MD_REF.getCurrentAccount().getBook().saveTrunkFile()
                pleaseWait.kill()

            if lErrorDeletingSecuritySubAccounts or lErrorDeletingSecurities:
                txt = "%s: completed ** WITH ERRORS ** Please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.ERROR_MESSAGE
                optionColor = "R"
            elif lAnyCostBasisErrorsFound[0]:
                txt = "%s: completed ** NOTE: You have Lot Control errors >> please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.ERROR_MESSAGE
                optionColor = "R"
            else:
                txt = "%s: successfully completed - please review log and check the results..." %(_THIS_METHOD_NAME)
                optionMessage = JOptionPane.INFORMATION_MESSAGE
                optionColor = "DG"
            myPrint("B", txt); output += "\n\n%s\n" %(txt)
            output += "\n\n *** PLEASE CHECK YOUR PORTFOLIO VIEW & REPORTS TO BALANCES ***\n\n"
            output += "\n<END>"

        except:
            txt = ("ERROR - %s: crashed after the merge actions. Please review output, console, and VERIFY YOUR DATASET!" %(_THIS_METHOD_NAME)).upper()
            myPrint("B",txt); output += "\n\n\n%s\n\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            setDisplayStatus(txt, "R")
            jif = QuickJFrame(txt, output, lAlertLevel=2, copyToClipboard=lCopyAllToClipBoard_TB,lJumpToEnd=True).show_the_frame()
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        jif = QuickJFrame(txt,output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
        setDisplayStatus(txt, optionColor)
        play_the_money_sound()
        myPopupInformationBox(jif,txt,theMessageType=optionMessage)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def move_merge_investment_txns():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")
        if MD_REF.getCurrentAccount().getBook() is None: return

        _THIS_METHOD_NAME = "Move/Merge Investment Accounts"

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        scriptToRun = "toolbox_move_merge_investment_txns.py"

        # if not confirm_backup_confirm_disclaimer(toolbox_frame_,_THIS_METHOD_NAME,"Execute the script: %s?" %(scriptToRun)):
        #     return False

        return scriptRunner(scriptToRun, _THIS_METHOD_NAME)

    def fix_non_hier_sec_acct_txns(autofix=False):

        _THIS_METHOD_NAME = "FIX: Non-Hierarchical Security Acct Txns".upper()

        PARAMETER_KEY = "toolbox_fix_non_hier_sec_acct_txns"

        book = MD_REF.getCurrentAccountBook()
        base = MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType()

        # fix_non-hierarchical_security_account_txns.py
        # (replaces fix_investment_txns_to_wrong_security.py)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if autofix: myPrint("B", "AUTOFIX running... There will be no prompts and all fixes will be applied silently....")

        myPrint("B", "Diagnosing Investment Transactions where Security's Account is not linked properly to the Parent Txn's Acct")
        myPrint("P", "-----------------------------------------------------------------------------------------------------------")

        output = "FIX Investment Transactions where Security's Account is not linked properly to the Parent Txn's Acct:\n" \
                 " =====================================================================================================\n\n"

        try:
            txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
            txns = list(txnSet.iterableTxns())      # copy into list() to prevent concurrent modification when modifying.....
            fields = InvestFields()

            iOrphans = 0
            txt = "Scanning for Security Orphans...:"
            output += "\n%s\n" %(txt); myPrint("B",txt)

            saveInvestmentAccountsNeedingDummy = {}
            for _txn in txns:
                if not isinstance(_txn, ParentTxn): continue   # only work with parent transactions
                _acct = _txn.getAccount()
                if _acct.getAccountType() != Account.AccountType.INVESTMENT: continue                                   # noqa
                fields.setFieldStatus(_txn)

                if fields.hasSecurity and fields.security is None:
                    iOrphans += 1
                    txt = "ERROR: Txn for 'Orphaned' Security %s found within Investment Account %s! (old QIF import or you have force removed a Security with linked TXNs?\n" \
                          "txn:\n%s\n" %(fields.security, _acct, _txn.getSyncInfo().toMultilineHumanReadableString())
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                    saveInvestmentAccountsNeedingDummy[_acct] = True

            if iOrphans:
                txt = "ERROR: %s investment txn(s) with 'Orphaned' securities detected (probably an old QIF import or User has force removed a Security from this Investment Account)" %(iOrphans)
                if not autofix:
                    MyPopUpDialogBox(toolbox_frame_,
                                     txt,
                                     "It's highly likely that you have: either a) old QIF Import data (that was improperly imported)... or\n"
                                     "b) you have clicked 'Actions' > 'Remove Security' from an Investment Account..\n"
                                     ".. and that this Security had linked Transactions... You would have been warned and asked to respond 'yes'\n"
                                     ".. this will have deleted Buy/Sell TXNs and partially removed the Security from other TXNs like buy/Sell/Xfr etc\n"
                                     "- These are 'illogical' and 'damaged' records.... The proper 'security' linkage is irrecoverable.\n"
                                     "... Toolbox can 'repair' these txns by assigning a 'dummy' security which you can edit/change later.\n"
                                     "**OR** You can restore, or manually edit and repair the TXNs with your own knowledge of what security was lost...",
                                     theTitle=_THIS_METHOD_NAME,
                                     OKButtonText="ACKNOWLEDGED",
                                     lAlertLevel=1).go()

            else:
                txt = ">> No investment txn(s) with Orphaned securities were detected!"
                output += "\n%s\n" %(txt); myPrint("B",txt)

            output += "\n\n"

            lFixedOrphans = False
            ############################################################################################################
            if iOrphans:

                if autofix:
                    txt = "AUTOFIX will proceed and fix 'Orphaned' securities..."
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                else:
                    txt = "ERROR: %s investment txn(s) with 'Orphaned' securities detected (probably an old QIF import or User has force removed a Security from this Investment Account)" %(iOrphans)
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                    jif = QuickJFrame(_THIS_METHOD_NAME,output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
                    if not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME, "FIX %s orphaned security txns (using a dummy security)?" %(iOrphans)):
                        return

                    jif.dispose()
                    txt = "User accepted disclaimer to FIX orphaned security txns. Proceeding....."
                    output += "\n%s\n" %(txt); myPrint("B",txt)

                newSecurity = CurrencyType(book.getCurrencies())  # Creates a new CT object
                newSecurity.setEditingMode()
                newSecurity.setRelativeCurrency(base)
                newSecurity.setCurrencyType(CurrencyType.Type.SECURITY)                                                 # noqa
                newSecurity.setName("TOOLBOX: %s" %(_THIS_METHOD_NAME))
                newSecurity.setIDString("^TOOLBOX")
                newSecurity.setTickerSymbol("^TOOLBOX")
                newSecurity.setDecimalPlaces(4)
                newSecurity.setRelativeRate(1.0)
                newSecurity.syncItem()
                output += "\n\nCreated dummy Security: %s (%s)\n" %(newSecurity, newSecurity.getUUID())

                dummySecurityAccounts = {}

                for _txn in txns:
                    if not isinstance(_txn, ParentTxn): continue   # only work with parent transactions
                    _acct = _txn.getAccount()
                    if _acct.getAccountType() != Account.AccountType.INVESTMENT: continue                               # noqa
                    fields.setFieldStatus(_txn)

                    if fields.hasSecurity and fields.security is None:

                        if saveInvestmentAccountsNeedingDummy.pop(_acct, False):

                            # need to create the Security sub-account in this Investment Account....
                            newSecurityAcct = Account.makeAccount(book, Account.AccountType.SECURITY, _acct)            # noqa
                            newSecurityAcct.setEditingMode()
                            newSecurityAcct.getUUID()
                            newSecurityAcct.setAccountName("TOOLBOX DUMMY")
                            newSecurityAcct.setCurrencyType(newSecurity)
                            newSecurityAcct.setStartBalance(0)
                            newSecurityAcct.setUsesAverageCost(True)
                            newSecurityAcct.setComment("Dummy created by Toolbox: %s" %(_THIS_METHOD_NAME))
                            newSecurityAcct.setParameter(PARAMETER_KEY, True)
                            newSecurityAcct.syncItem()
                            output += "\nCreated dummy Security Sub Account: %s (%s) linked to new dummy security\n" %(newSecurityAcct, newSecurityAcct.getUUID())
                            dummySecurityAccounts[_acct] = newSecurityAcct

                        fields.security = dummySecurityAccounts[_acct]
                        fields.storeFields(_txn)
                        _txn.syncItem()

                        txt = "FIXED: Txn for 'Orphaned' Security - Investment Account %s: '%s'\n" %(_acct, _txn)
                        output += "\n%s\n" %(txt)

                output += "\nFinished fixing 'orphans'....\n" \
                          " -----------------------------\n\n"
                lFixedOrphans = True

                # Create a new list of txns
                txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
                txns = list(txnSet.iterableTxns())      # copy into list() to prevent concurrent modification when modifying.....

            ############################################################################################################

            def review_security_accounts(_txns, FIX_MODE=False):

                count_the_errors = 0
                count_unfixable_yet = 0
                errors_fixed = 0
                text = ""
                for txn in _txns:
                    if txn.getParentTxn() != txn: continue   # only work with parent transactions

                    acct = txn.getAccount()
                    # noinspection PyUnresolvedReferences
                    if acct.getAccountType() != Account.AccountType.INVESTMENT: continue

                    # at this point we are only dealing with investment parent txns
                    fields.setFieldStatus(txn)

                    if fields.hasSecurity and not acct.isAncestorOf(fields.security):
                        count_the_errors += 1
                        txnTxt = txn.toMultilineString().replace(";",";\n")
                        text+=("Must fix txn %s\n"
                               "%s\n"
                               " > in %s with sec acct %s\n" %(fields.txnType, txnTxt, acct, fields.security.getFullAccountName()))
                        # This fix assumes that the split / security bit should sit within the txn's parent account. It seeks for the same
                        # security in this account and reattaches it.

                        # Alternatively you could txn.setAccount() to be the split security's parent account
                        # e.g. txn.setAccount(fields.security.getParentAccount())

                        secCurr = fields.security.getCurrencyType()
                        correctSecAcct = None
                        for subacct in AccountUtil.getAccountIterator(acct):
                            if subacct.getCurrencyType() == secCurr:
                                correctSecAcct = subacct
                                break

                        if not correctSecAcct:
                            if FIX_MODE:
                                _txt = ".. Security sub-acct '%s' not found within this Investment account '%s' - so manually creating/adding..." %(secCurr.getName(), acct)
                                text += "%s\n" %(_txt); myPrint("B",_txt)

                                # need to create the Security sub-account in this Investment Account....
                                newSecurityAcct = Account.makeAccount(MD_REF.getCurrentAccountBook(), Account.AccountType.SECURITY, acct)   # noqa
                                newSecurityAcct.setEditingMode()
                                newSecurityAcct.getUUID()
                                newSecurityAcct.setAccountName(fields.security.getAccountName())
                                newSecurityAcct.setCurrencyType(fields.security.getCurrencyType())
                                newSecurityAcct.setStartBalance(0)

                                newSecurityAcct.setUsesAverageCost(fields.security.getUsesAverageCost())
                                newSecurityAcct.setBroker(fields.security.getBroker())
                                newSecurityAcct.setBrokerPhone(fields.security.getBrokerPhone())
                                newSecurityAcct.setAPR(fields.security.getAPR())
                                newSecurityAcct.setBondType(fields.security.getBondType())
                                newSecurityAcct.setComment(fields.security.getComment())
                                newSecurityAcct.setCompounding(fields.security.getCompounding())
                                newSecurityAcct.setFaceValue(fields.security.getFaceValue())
                                newSecurityAcct.setMaturity(fields.security.getMaturity())
                                newSecurityAcct.setMonth(fields.security.getMonth())
                                newSecurityAcct.setNumYears(fields.security.getNumYears())
                                newSecurityAcct.setPut(fields.security.getPut())
                                newSecurityAcct.setOptionPrice(fields.security.getOptionPrice())
                                newSecurityAcct.setDividend(fields.security.getDividend())
                                newSecurityAcct.setExchange(fields.security.getExchange())
                                newSecurityAcct.setSecurityType(fields.security.getSecurityType())
                                newSecurityAcct.setSecuritySubType(fields.security.getSecuritySubType())
                                newSecurityAcct.setStrikePrice(fields.security.getStrikePrice())

                                for param in ["hide","hide_on_hp","ol.haspendingtxns", "ol.new_txn_count"]:
                                    newSecurityAcct.setParameter(param, fields.security.getParameter(param))

                                newSecurityAcct.setParameter(PARAMETER_KEY,True)
                                newSecurityAcct.syncItem()

                                correctSecAcct = newSecurityAcct
                            else:
                                text+=(" -> will need to auto-create/add Security and then assign txn to %s\n" %(acct))

                        if correctSecAcct:
                            if FIX_MODE:
                                errors_fixed += 1
                                text+=(" -> ASSIGNING txn to %s\n" %(correctSecAcct.getFullAccountName()))
                                fields.security = correctSecAcct
                                fields.storeFields(txn)
                                txn.syncItem()
                            else:
                                text+=(" -> need to assign txn to %s\n" %(correctSecAcct.getFullAccountName()))

                del _txns
                return text, count_the_errors, count_unfixable_yet, errors_fixed


            output += "\nScanning txns for non-hierarchical accounts:\n" \
                        " -------------------------------------------\n\n"

            x, iCountErrors, iCountUnfixable, iErrorsFixed = review_security_accounts(txns, FIX_MODE=False)
            output += x

            output += "\n\nYou have %s non-hierarchical txn errors...\n\n" %(iCountErrors)

            if iCountErrors < 1:
                if lFixedOrphans:
                    txt = "%s: I found no additional non-hierarchical / invalid txns....... UPDATES COMPLETED" %(_THIS_METHOD_NAME)
                    output += "\n%s\n" %(txt); myPrint("B",txt)
                    if not autofix:
                        MD_REF.saveCurrentAccount()
                        setDisplayStatus(txt, "B")
                        play_the_money_sound()
                        jif = QuickJFrame(_THIS_METHOD_NAME,output,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB,lWrapText=False).show_the_frame()
                        myPopupInformationBox(jif, txt)
                    return
                txt = "%s: CONGRATULATIONS - I found no non-hierarchical / invalid txns......." %(_THIS_METHOD_NAME)
                output += "\n%s\n" %(txt); myPrint("B",txt)
                if not autofix:
                    setDisplayStatus(txt, "B")
                    myPopupInformationBox(toolbox_frame_,txt)
                return

            myPrint("B","%s: found %s non-hierarchical txn errors..." %(_THIS_METHOD_NAME, iCountErrors))

            jif = None
            if not autofix:
                jif = QuickJFrame("VIEW Investment Security Txns with Invalid Parent Accounts".upper(), output, lAlertLevel=1, lWrapText=False, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

            # if iCountUnfixable>0:
            #     txt = "%s: You have %s errors to manually first first!" %(_THIS_METHOD_NAME, iCountUnfixable)
            #     myPrint("B", txt)
            #     if not autofix:
            #         setDisplayStatus(txt, "R")
            #         myPopupInformationBox(jif,"You have %s errors to manually first first!" %(iCountUnfixable), _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)
            #     return

            if not autofix:
                if not lFixedOrphans \
                        and not confirm_backup_confirm_disclaimer(jif, _THIS_METHOD_NAME,"FIX %s Security Txns with Invalid Parent Accts?" %(iCountErrors)):
                    return

                jif.dispose()
                myPrint("B", "User accepted disclaimer to FIX Investment Security Txns with Invalid Parent Accounts. Proceeding.....")

            output += "\n\nRUNNING FIX ON SECURITY TXNS TO RE-LINK PARENT ACCOUNTS\n" \
                      "------------------------------------------------------------\n\n"

            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the move/changes..
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
            MD_REF.getUI().setSuspendRefresh(True)

            x, iCountErrors, iCountUnfixable, iErrorsFixed = review_security_accounts(txns, FIX_MODE=True)
            del txns, txnSet

            MD_REF.saveCurrentAccount()
            MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
            MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

            output += x
            output += "\n\nYou had %s non-hierarchical txn errors... FIXED %s\n\n" %(iCountErrors, iErrorsFixed)
            output += "\n<END>"

            txt = "FIXED %s Investment Security Txns with Invalid Parent Accounts (non-hierarchical txn errors)" %(iErrorsFixed)
            myPrint("B", txt)

            if not autofix:
                play_the_money_sound()
                setDisplayStatus(txt, "B")
                jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, lWrapText=False, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                myPopupInformationBox(jif,txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            else:
                myPrint("B", "AUTOFIX ENDING....")

        except:
            output += dump_sys_error_to_md_console_and_errorlog(True)
            txt = "%s: ERROR - Script has crashed. Review screen and console!" %(_THIS_METHOD_NAME)
            output += txt + "\n"
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=2, lWrapText=False, copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
            myPopupInformationBox(jif, txt, _THIS_METHOD_NAME, JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def detect_non_hier_sec_acct_or_orphan_txns():

        txnSet = MD_REF.getCurrentAccount().getBook().getTransactionSet()
        txns = txnSet.iterableTxns()
        fields = InvestFields()

        count_the_errors = 0

        for txn in txns:

            if not isinstance(txn, ParentTxn): continue   # only work with parent transactions

            acct = txn.getAccount()

            # noinspection PyUnresolvedReferences
            if acct.getAccountType() != Account.AccountType.INVESTMENT: continue

            # at this point we are only dealing with investment parent txns
            fields.setFieldStatus(txn)

            if fields.hasSecurity and not acct.isAncestorOf(fields.security):
                count_the_errors += 1
                myPrint("B", "ERROR: Txn for Security %s found within Investment Account %s that is cross linked to another account (or Security is orphaned)!\n"
                             "txn:\n%s\n" %(fields.security, acct, txn.getSyncInfo().toMultilineHumanReadableString()))
        del txnSet, txns

        if count_the_errors:
            myPrint("B", "ERROR: %s investment txn(s) with cross-linked securities detected" %(count_the_errors))
        else:
            myPrint("DB", "NOTE: No investment txn(s) with cross-linked securities were detected - phew!")

        return count_the_errors


    def fix_delete_one_sided_txns():

        # delete_invalid_txns.py
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        myPrint("B", "Script running to analyse whether you have any one sided transactions - usually from Quicken Imports....")
        myPrint("P", "--------------------------------------------------------------------------------------------------------")

        book = MD_REF.getCurrentAccountBook()
        txnSet = book.getTransactionSet()
        txns = txnSet.iterableTxns()

        output = ""
        toDelete = []

        output +="\nLIST OF ONE SIDED TRANSACTIONS (usually from Quicken Imports)\n"
        output +="-------------------------------------------------------------\n"

        for txn in txns:
            if txn.getOtherTxnCount() == 0:
                output += pad(str(txn.getUUID()),50)+" "
                output += "Date: "+pad(convertStrippedIntDateFormattedText(txn.getDateInt()),15)+" "
                output += pad(str(txn.getAccount()),25)+" "
                output += pad(str(txn.getAccount().getAccountType()),25)+" "
                output += pad(str(txn.getTransferType()),15)+" "
                output += rpad(str(txn.getValue()),12)+" "
                output += "\n"

                toDelete.append(txn)

        if not len(toDelete)>0:

            txt = "You have no one-sided transactions to delete!!"
            setDisplayStatus(txt, "B")
            myPrint("B",txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE ONE-SIDE TXNS", JOptionPane.INFORMATION_MESSAGE)
            return

        output += "\n<END>"

        jif=QuickJFrame("LIST OF ONE SIDED TRANSACTIONS (usually from Quicken Imports)", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        myPrint("J","You have %s one-sided transactions that can be deleted!!"%len(toDelete))
        myPopupInformationBox(jif, "You have %s one-sided transactions that can de deleted!!"%len(toDelete), "DELETE ONE-SIDE TXNS", JOptionPane.WARNING_MESSAGE)

        if not confirm_backup_confirm_disclaimer(jif, "DELETE ONE-SIDED TRANSACTIONS", "delete %s one-sided transactions?" %(len(toDelete))):
            return

        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record for the changes..
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(False)
        MD_REF.getUI().setSuspendRefresh(True)

        for t in toDelete:
            myPrint("J", "Item %s deleted" %t.getUUID())
            t.deleteItem()

        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccount().getBook().setRecalcBalances(True)
        MD_REF.getUI().setSuspendRefresh(False)		# This does this too: book.notifyAccountModified(root)

        play_the_money_sound()
        txt = "%s Invalid One-Sided Transactions DELETED!" %(len(toDelete))
        setDisplayStatus(txt, "DG")
        myPrint("B", txt)
        myPopupInformationBox(jif,txt, "DELETE ONE-SIDE TXNS", JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def convert_stock_avg_cst_control():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,"CONVERT ACCT/STOCK TO Avg Cst Ctrl","Do you want to convert a stock to Average Cost Control and reset/wipe any LOT data?",theMessageType=JOptionPane.WARNING_MESSAGE):
            myPopupInformationBox(toolbox_frame_,"NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        accountsList = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(14))
        accountsList = sorted(accountsList, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        accountSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                 "Select a LOT Controlled Acct/Stock to convert to Avg Cost Control",
                                                 "CONVERT ACCT/STOCK TO Avg Cst Ctrl",
                                                 JOptionPane.INFORMATION_MESSAGE,
                                                 getMDIcon(lAlwaysGetIcon=True),
                                                 accountsList,
                                                 None)

        if not accountSec:
            txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl - No Account/Security was selected - no changes made.."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        class SecurityObj:
            def __init__(self,Obj,Book):                                                                                # noqa
                self.Obj = Obj
                self.Acct = Obj.getParentAccount()
                self.TxnSet = Book.getTransactionSet().getTransactionsForAccount(Obj)
                self.Name = Obj.getAccountName()
                self.Num = Obj.getAccountNum()
                self.Type = "SECURITY"
                self.AvgCost = Obj.getUsesAverageCost()
                self.Txns = []
                for _Txn in self.TxnSet: self.Txns.append(TxnObj(_Txn))

        class TxnObj:
            def __init__(self,Txn):                                                                                     # noqa
                self.Obj = Txn
                self.Parent = Txn.getParentTxn()
                self.ID = Txn.getUUID()
                self.DateInt = Txn.getDateInt()
                self.Type = self.Parent.getInvestTxnType().getIDString()
                self.saveCostBasisState = self.Obj.getParameter("cost_basis",None)

        Book = MD_REF.getCurrentAccountBook()

        # We are forcing just the one selected Security into the List (the original script allowed user to hard code several)
        Securities = [SecurityObj(accountSec,Book)]

        iErrors=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    iErrors+=1

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "CONVERT ACCT/STOCK TO Avg Cst Ctrl","Convert %s to Avg Cst Control and wipe %s LOT records?" %(accountSec,iErrors)):
            return

        listWiped=""
        for Security in Securities:
            myPrint("B","@@ User requested to convert Acct/Security %s to Average Lot Control and wipe %s LOT records... EXECUTING NOW" %(Security.Obj, iErrors))
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    listWiped+=" %s Wiped LOT tag on record (was: %s)\n" %(Security.Obj, Txn.Obj.getParameter("cost_basis", None))
                    myPrint("B","@@ Security %s Wiping LOT record on %s" %(Security.Obj, Txn.Obj))
                    Txn.Obj.setParameter("cost_basis", None)
                    Txn.Obj.syncItem()

            Security.Obj.setUsesAverageCost(True)
            Security.AvgCost = True
            Security.Obj.syncItem()

        txt = "CONVERT ACCT/STOCK TO Avg Cst Ctrl - Security %s Changed to Average Cost Control (and %s LOT records wiped)"%(accountSec,iErrors)
        setDisplayStatus(txt, "R")
        myPrint("B", txt)
        play_the_money_sound()
        MyPopUpDialogBox(toolbox_frame_,
                         theStatus="Security %s converted to Average Cost Control (I wiped %s LOT records - shown below)" %(accountSec,iErrors),
                         theMessage="%s" %(listWiped),
                         theTitle="CONVERT ACCT/STOCK TO Avg Cst Ctrl",
                         lAlertLevel=1).go()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def convert_stock_lot_FIFO():
        # MakeFifoCost.py (author unknown)

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        selectHomeScreen()      # Stops the LOT Control box popping up.....

        if detect_non_hier_sec_acct_or_orphan_txns() > 0:
            txt = "CONVERT ACCT/STOCK TO LOT/FIFO: ERROR - Cross-linked (or Orphaned) security txns detected.. Review Console. Run 'FIX: Non-Hierarchical Security Acct Txns (& detect Orphans)' >> no changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,"CONVERT ACCT/STOCK TO LOT/FIFO","Do you want to attempt to convert a stock to LOT Controlled and match Sells to Buys using FiFo?",theMessageType=JOptionPane.WARNING_MESSAGE):
            myPopupInformationBox(toolbox_frame_,"NO CHANGES MADE!",theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        accountsList = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(13))
        accountsList = sorted(accountsList, key=lambda sort_x: (sort_x.getFullAccountName().upper()))

        accountSec = JOptionPane.showInputDialog(toolbox_frame_,
                                                 "Select an Avg Cost Controlled Acct/Stock to convert to LOT/FiFo",
                                                 "CONVERT STOCK FIFO",
                                                 JOptionPane.INFORMATION_MESSAGE,
                                                 getMDIcon(lAlwaysGetIcon=True),
                                                 accountsList,
                                                 None)

        if not accountSec:
            txt = "CONVERT STOCK FIFO - No Account/Security was selected - no changes made.."
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # noinspection PyUnresolvedReferences
        if len(accountSec.getCurrencyType().getSplits()) >0:
            # noinspection PyUnresolvedReferences
            txt = "CONVERT STOCK FIFO - SORRY - You have %s split(s) on this security %s. I have not been programmed to deal with these - contact author...." %(len(accountSec.getCurrencyType().getSplits()),accountSec)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, "CONVERT STOCK FIFO", theMessageType=JOptionPane.ERROR_MESSAGE)
            return


        MyPopUpDialogBox(toolbox_frame_,
                         theStatus="Information before you proceed: %s" %(accountSec),
                         theMessage="This function updates the Acct/Security records as it progresses to generate the report\n"
                                    "There is no pre-report for you to validate/confirm\n"
                                    "1. It will ask you to confirm I can wipe any existing LOT tags incorrectly set first (I will save these)\n"
                                    "2. The report will run, Convert to LOT Control, update the LOT records, and show you the results\n"
                                    "3. If you are not happy, I can reset the Security back to Avg Cost Control (removing/resetting LOT tags)\n"
                                    "4. I will restore wiped (incorrect) LOT tags back to the saved data from step 1.\n"
                                    "** You will be asked to confirm and perform a backup then proceed in the next step....",
                         theTitle="CONVERT STOCK FIFO",
                         OKButtonText="I HAVE READ THIS",
                         lAlertLevel=1).go()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, "CONVERT STOCK FIFO","Convert %s to LOT control and assign FiFio?" %(accountSec)):
            return

        class SecurityObj:
            def __init__(self,Obj,Book):                                                                                # noqa
                self.Obj = Obj
                self.Acct = Obj.getParentAccount()
                self.TxnSet = Book.getTransactionSet().getTransactionsForAccount(Obj)
                self.Name = Obj.getAccountName()
                self.Num = Obj.getAccountNum()
                self.Type = "SECURITY"
                self.Balance = Obj.getBalance()
                self.CurTyp = Obj.getCurrencyType()
                self.AvgCost = Obj.getUsesAverageCost()
                self.Txns = []
                for _Txn in self.TxnSet:
                    self.Txns.append(TxnObj(_Txn))
                self.Txns.sort(key=lambda l: l.Date)

        class TxnObj:
            def __init__(self,Txn):                                                                                     # noqa
                self.Obj = Txn
                self.Parent = Txn.getParentTxn()
                self.ID = Txn.getUUID()
                self.DateInt = Txn.getDateInt()
                self.Type = self.Parent.getInvestTxnType().getIDString()
                # noinspection PyUnresolvedReferences
                self.Date = datetime.datetime.fromtimestamp(DateUtil.convertIntDateToLong(Txn.getDateInt()).time/1e3)
                self.LngShrs = Txn.getValue()
                securityAcct = Txn.getAccount()
                securityCurr = securityAcct.getCurrencyType()
                self.Shares = securityCurr.getDoubleValue(Txn.getValue())
                self.saveCostBasisState = self.Obj.getParameter("cost_basis",None)

        def MakeCostsFifo(Security,Book, INCLUDE_THE_ZEROS):                                                            # noqa
            WrngCnt = 0                                                                                                 # noqa

            textLog = ""

            if not Security.AvgCost:
                _txt = "CONVERT STOCK FIFO - ERROR - Security is already using LOT control - LOGIC ERROR - ABORTING!"
                setDisplayStatus(_txt, "R")
                return
            else:
                textLog+=("Setting the Security '{}:{}' to FIFO lot matching.\n\n".format(Security.Acct.getAccountName(),Security.Name))

                # If you don't do this here, then InvestUtil.getRemainingLots() returns None
                Security.Obj.setUsesAverageCost(False)
                Security.AvgCost = False
                Security.Obj.syncItem()

                for Txn in Security.Txns:                                                                               # noqa
                    if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                            and (Txn.LngShrs != 0 or INCLUDE_THE_ZEROS)):
                        RLots = InvestUtil.getRemainingLots(Book,Security.Obj,Txn.Obj.getDateInt())
                        ShrsLeft = -(Txn.LngShrs)
                        Buys = ""
                        prettyBuys = ""
                        for Txn2 in Security.Txns:
                            if Txn2.LngShrs > 0 and Txn2.ID in RLots:
                                RInfo = RLots.get(Txn2.ID)
                                # noinspection PyUnresolvedReferences
                                RShrs = RInfo.getAvailableShares()
                                if RShrs >= ShrsLeft:
                                    Buys += "{}:{};".format(Txn2.ID,ShrsLeft)
                                    prettyBuys += "BUY-{}:{};".format(convertStrippedIntDateFormattedText(Txn2.DateInt),Txn.Obj.getAccount().getCurrencyType().getDoubleValue(ShrsLeft))
                                    ShrsLeft = 0
                                    break
                                elif RShrs > 0:
                                    Buys += "{}:{};".format(Txn2.ID,RShrs)
                                    prettyBuys += "BUY-{}:{};".format(convertStrippedIntDateFormattedText(Txn2.DateInt),Txn.Obj.getAccount().getCurrencyType().getDoubleValue(RShrs))
                                    ShrsLeft -= RShrs
                        if ShrsLeft > 0:
                            textLog+=("@@ WARNING! Came up short %s shares for ID='%s' on date=%s!\n" %(rpad(Txn.Obj.getAccount().getCurrencyType().getDoubleValue(ShrsLeft),12),Txn.ID,Txn.Date.strftime(convertMDShortDateFormat_strftimeFormat())))
                            WrngCnt += 1
                        if len(Buys) > 0:
                            Txn.Obj.setParameter("cost_basis",Buys)
                            Txn.Obj.syncItem()
                            Txn.Obj.getParentTxn().syncItem()
                            textLog+=("cost_basis for the sale dated: %s of %s shares on %s set to '%s'\n" %(convertStrippedIntDateFormattedText(Txn.DateInt),rpad(Txn.Shares,12),Txn.Date.strftime(convertMDShortDateFormat_strftimeFormat()),prettyBuys))
                    else:
                        if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())):
                            textLog+=("skipped ZERO sale dated: %s of %s shares...'\n" %(convertStrippedIntDateFormattedText(Txn.DateInt),rpad(Txn.Shares,12)))

            return WrngCnt, textLog

        output = "CONVERT STOCK FIFO (Convert Accounts/Security using Avg Cost Control to LOT control & assign FiFo)\n" \
                 " =================================================================================================\n\n"

        WrngCnt = 0
        Book = MD_REF.getCurrentAccountBook()

        # We are forcing just the one selected Security into the List (the original script allowed user to hard code several)
        Securities = [SecurityObj(accountSec,Book)]

        iErrors=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                        and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                    iErrors+=1
        if iErrors>0:
            if not myPopupAskQuestion(toolbox_frame_,"CONVERT STOCK FIFO",
                                      "WARNING: I found %s LOTS already set on account/security. Do you want to proceed (and overwrite) these?" %(iErrors),
                                      theMessageType=JOptionPane.ERROR_MESSAGE):
                txt = "CONVERT STOCK FIFO - ABORTED - as Acct/Security %s already had %s LOT records!!??" %(accountSec, iErrors)
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            myPrint("B", "CONVERT STOCK FIFO - RESETTING %s LOT TAGS on Acct/Security %s!!"%(iErrors, accountSec))
            output+=("\nRESETTING %s LOT TAGS on Acct/Security %s!!\n"%(iErrors, accountSec))

            for Security in Securities:
                for Txn in Security.Txns:
                    if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType())
                            and (Txn.Obj.getParameter("cost_basis", None) is not None)):
                        output+=" > Found LOT tag on Sale record, when it should be None... Resetting to None (was SELL %s Shrs Dated:%s: %s)\n" %(rpad(Txn.Shares,12),convertStrippedIntDateFormattedText(Txn.DateInt),Txn.Obj.getParameter("cost_basis", None))
                        Txn.Obj.setParameter("cost_basis", None)
                        Txn.Obj.syncItem()

        iSellZeros=0
        for Security in Securities:
            for Txn in Security.Txns:
                if (InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType()) and Txn.LngShrs == 0):
                    iSellZeros+=1

        lIncludeSellZeros=False
        if iSellZeros>0:
            if myPopupAskQuestion(toolbox_frame_,"CONVERT STOCK FIFO",
                                  "WARNING: I found %s Sale Txns for ZERO shares. YES = INCLUDE and match these to Zero Buys; NO = SKIP/IGNORE them?" %(iSellZeros),
                                  theMessageType=JOptionPane.WARNING_MESSAGE):
                myPrint("B", "CONVERT STOCK FIFO: Acct/Security %s - Will match %s ZERO sales too..."%(accountSec, iSellZeros))
                lIncludeSellZeros = True

        for Security in Securities:
            count, text = MakeCostsFifo(Security,Book, lIncludeSellZeros)
            WrngCnt += count
            output += text

        if iSellZeros>0:
            if lIncludeSellZeros:
                output+="\n\n @@ ALERT - I have matched Sales for ZERO shares to BUYS... @@\n\n"
            else:
                output+="\n\n @@ ALERT - The MD LOT Window will pop up wanting you to match the Zero Sells, which you can't.. You can just press Cancel on this (or re-run and Include them) @@\n\n"

        output+=("\nFinished. Processed {} securities producing {} warnings.\n".format(len(Securities),WrngCnt))

        _secAcctRelCurr = accountSec.getCurrencyType()                                                                  # noqa
        _secAcctCostBasis = InvestUtil.getCostBasis(accountSec)
        _secAcctCostBasisDbl = _secAcctRelCurr.getDoubleValue(_secAcctCostBasis)

        output += "\nMD Reports the cost basis for '%s' is now %s\n" %(accountSec, _secAcctCostBasisDbl)

        if not InvestUtil.isCostBasisValid(accountSec):
            cbMessageValidIndicator = "** INVALID ** (you can edit these manually later in MD)"
            txt = "CONVERT STOCK FIFO: WARNING - MD reports the cost basis for '%s' is **INVALID** after the update.." %(accountSec)
        else:
            cbMessageValidIndicator = "VALID"
            txt = "CONVERT STOCK FIFO: NOTE: MD is reporting that the cost basis for '%s' is VALID after the update.." %(accountSec)
        myPrint("B", txt); output += "\n%s\n" %(txt)

        jif=QuickJFrame("CONVERT STOCK FIFO - REVIEW RESULTS", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        ask=MyPopUpDialogBox(jif,
                             theStatus="Please review results on security: %s" %(accountSec),
                             theMessage="These changes have already been made to your dataset\n"
                                        "FYI - MD is reporting that the updated Cost Basis / Lot control status is %s\n"
                                        "To reset the security back to Avg Cost Control and reset/remove these altered LOT records select CANCEL\n"
                                        "(NOTE: I will put the LOT records back to the same state before this script ran)"
                                        "[OK KEEP RESULTS] will accept these changes" %(cbMessageValidIndicator),
                             theTitle="CONVERT STOCK FIFO",
                             OKButtonText="OK KEEP RESULTS",
                             lCancelButton=True,
                             lAlertLevel=1)
        if not ask.go():
            jif.dispose()       # already within the EDT
            myPrint("B", "\nREVERTING CHANGES - RESETTING ACCOUNT/SECURITY %s BACK TO AVERAGE COST CONTROL!!\n"%(accountSec))
            myPrint("B", "CONVERT STOCK FIFO - RESETTING LOT TAGS on Acct/Security %s!!"%(accountSec))

            output+=("\nREVERTING CHANGES - RESETTING ACCOUNT/SECURITY %s BACK TO AVERAGE COST CONTROL!!\n"%(accountSec))
            output+=("\nRESETTING LOT TAGS on Acct/Security %s!!\n"%(accountSec))

            for Security in Securities:

                myPrint("B","CONVERT STOCK FIFO - Reverting Security %s back to Average Cost Control" %(accountSec))
                output+=("@@ CONVERT STOCK FIFO - Reverting Security %s back to Average Cost Control@@\n" %(accountSec))

                for Txn in Security.Txns:
                    if InvestUtil.isSaleTransaction(Txn.Parent.getInvestTxnType()):
                        if Txn.Obj.getParameter("cost_basis", None) != Txn.saveCostBasisState:
                            output+="  >> Reverting LOT record to: %s\n" %(Txn.saveCostBasisState)
                            Txn.Obj.setParameter("cost_basis", Txn.saveCostBasisState)
                            Txn.Obj.syncItem()
                output+=" > Reverting to Average Cost Control...\n"
                Security.Obj.setUsesAverageCost(True)
                Security.AvgCost = True
                Security.Obj.syncItem()
                output+="\n<END>"
                txt = "CONVERT STOCK FIFO - Changes to Security %s REJECTED and REVERSED - review report" %(accountSec)
                setDisplayStatus(txt, "R")
        else:
            jif.dispose()       # already within the EDT
            output+="\nCHANGES ACCEPTED and RETAINED...\n" \
                    "\n<END>"
            txt = "CONVERT STOCK FIFO - Changes to Security %s Accepted and retained - review report" %(accountSec)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)


        jif=QuickJFrame("CONVERT STOCK FIFO - REVIEW RESULTS", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        play_the_money_sound()
        myPopupInformationBox(jif, "REVIEW REPORT", "CONVERT STOCK FIFO", JOptionPane.WARNING_MESSAGE)


        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def show_open_share_lots():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        class LotInfo:
            def __init__(self, _date, _buyPrice, _availableShares, _costBasis, _currentPrice, _currentValue):
                self.date = _date
                self.buyPrice = _buyPrice
                self.availableShares = _availableShares
                self.costBasis = _costBasis
                self.currentPrice = _currentPrice
                self.currentValue = _currentValue

        book = MD_REF.getCurrentAccountBook()
        date = datetime.datetime.today()

        output="\n\nANALYSING SHARES/SECURITIES WITH OPEN (Unconsumed LOTS)\n" \
               " ======================================================\n\n"

        output+='Outstanding Tax Lots as of %s\n\n'%(date.strftime(convertMDShortDateFormat_strftimeFormat()))

        iFound=0
        for secAcct in AccountUtil.getAccountIterator(book):
            if secAcct.getAccountType() !=  secAcct.AccountType.SECURITY: continue
            if secAcct.getUsesAverageCost():                           continue

            curr = secAcct.getCurrencyType()
            rcurr = secAcct.getCurrencyType().getRelativeCurrency()

            dpc = curr.getDecimalPlaces()
            rdpc = rcurr.getDecimalPlaces()

            dpc_divvy = Math.pow(10, dpc)
            rdpc_divvy = Math.pow(10, dpc - rdpc)

            if InvestUtil.getCostBasis(secAcct) > 0 or not InvestUtil.isCostBasisValid(secAcct):
                output+="\nInvestment Account: %s Security: %s\n\n" %(secAcct.getParentAccount(), secAcct.getAccountName())
                if not InvestUtil.isCostBasisValid(secAcct):
                    output+="\n** COST BASIS IS INVALID** (you have sales not fully matched to buys)\n\n"

                totalCostBasis = 0.0
                totalAvailableShares = 0.0
                currentPrice = 1.0 / secAcct.getCurrencyType().getRelativeRate()
                lotList = []
                lots = InvestUtil.getRemainingLots(book, secAcct, DateUtil.getStrippedDateInt())

                # noinspection PyUnresolvedReferences
                for transaction, availSharesTracker in lots.items():
                    availableShares = availSharesTracker.getAvailableShares() / dpc_divvy
                    if availableShares > 0:
                        # t = book.getTransactionSet().getTxnByID(transaction)
                        t = TxnUtil.getTxnByID(book.getTransactionSet(), transaction)
                        # noinspection PyUnresolvedReferences
                        date = datetime.datetime.fromtimestamp(DateUtil.convertIntDateToLong(t.getDateInt()).time / 1000)
                        adjustedBuyPrice = 1.0 / secAcct.getCurrencyType().adjustRateForSplitsInt(t.getDateInt(), t.getRate()) * (rdpc_divvy)  # noqa
                        costBasis = availableShares*adjustedBuyPrice
                        currentValue = currentPrice*availableShares
                        totalCostBasis += costBasis
                        totalAvailableShares += availableShares
                        lotList.append(LotInfo(date, adjustedBuyPrice, availableShares, costBasis, currentPrice, currentValue))
                lotList.sort(key=lambda sort_l: sort_l.date)
                lotCount = 0

                output+=("%s %s %s %s %s %s\n"
                         %(pad("Buy.Date",10),
                           rpad("Buy.Price",12),
                           rpad("Avail.Shares",14),
                           rpad("Cost.Basis",14),
                           rpad("Current.Price",14),
                           rpad("Current.Value",14)))

                for _lot in lotList:
                    lotCount += 1
                    output+=("%s %s %s %s %s %s\n"
                             %(pad(_lot.date.strftime(convertMDShortDateFormat_strftimeFormat()),10),
                               rpad(_lot.buyPrice,12),
                               rpad(_lot.availableShares,14),
                               rpad(_lot.costBasis,14),
                               rpad(_lot.currentPrice,14),
                               rpad(_lot.currentValue,14)))
                    iFound+=1
                output+=("%s %s %s %s %s %s\n"
                         %(pad("",10),
                           rpad("",12),
                           rpad("----------",14),
                           rpad("----------",14),
                           rpad("",14),
                           rpad("----------",14)))
                if lotCount > 1:
                    output+=("%s %s %s %s %s %s\n"
                             %(pad("",10),
                               rpad("",12),
                               rpad(totalAvailableShares,14),
                               rpad(totalCostBasis,14),
                               rpad("",14),
                               rpad(totalAvailableShares*currentPrice,14)))

                output+=("%s %s\n\n" %(rpad("Current share balance:",(10+1+12)), rpad(secAcct.getBalance()/dpc_divvy,14)))

                output+="\n"
        output+="\n<END>"

        # diag.kill()
        #
        if iFound<1:
            txt = "VIEW OPEN LOTS - You have no open / unconsumed LOTs to display!"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,"VIEW OPEN LOTS")
        else:
            toolbox_frame_.toFront()
            txt = "VIEW OPEN LOTS - Displaying %s open LOTS!" %(iFound)
            setDisplayStatus(txt, "B")
            jif = QuickJFrame("VIEW OPEN LOTS",output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def diagnose_matched_lot_data():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "DIAGNOSE MATCHED LOT DATA"

        if MD_REF.getCurrentAccount().getBook() is None: return

        book = MD_REF.getCurrentAccountBook()
        date = datetime.datetime.today()

        output = "\n\nDIAGNOSING SHARES/SECURITIES LOT MATCHING DATA\n" \
                 " =================================================\n\n"

        output += 'as of %s\n\n' %(date.strftime(convertMDShortDateFormat_strftimeFormat()))

        allAccounts = AccountUtil.allMatchesForSearch(book, AcctFilter.ALL_ACCOUNTS_FILTER)
        secAccounts = [acct for acct in allAccounts if acct.getAccountType() == Account.AccountType.SECURITY]           # noqa

        securitiesToValidate = []

        for secAcct in secAccounts:
            if InvestUtil.isCostBasisValid(secAcct): continue

            output += "%s: reports invalid cost basis... Checking for sells\n" %(secAcct)

            sellCheck = False
            tSet = secAcct.getBook().getTransactionSet().getTransactionsForAccount(secAcct)
            if tSet is not None:
                for i in range(0, tSet.getSize()):
                    absTxn = tSet.getTxn(i)
                    txnType = absTxn.getParentTxn().getInvestTxnType()
                    if txnType.isBuy() or txnType.isSell():
                        split = TxnUtil.getSecurityPart(absTxn.getParentTxn())
                        if split.getValue() < 0:
                            sellCheck = True
                            break

            if not sellCheck: continue

            output += "... this security account does hold Sell txns - will proceed to validate LOTS\n"
            securitiesToValidate.append(secAcct)

        if len(securitiesToValidate) < 1:
            txt = "SUCCESS - FOUND NO 'INVALID' LOT MATCHING DATA"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME)
            return

        output += "\n\nWARNING: Found %s 'INVALID' LOT MATCHING(s) TO VALIDATE\n\n" %(len(securitiesToValidate))

        def validateLots(sec):
            # duplicates - isCostBasisValid(Account sec)
            curr = sec.getCurrencyType()
            buySet = TxnSet()
            sellSet = TxnSet()
            buyList = {}
            txnSet = sec.getBook().getTransactionSet().getTransactionsForAccount(sec)
            _errorTxt = ""

            for _i in range(0, txnSet.getSize()):
                _absTxn = txnSet.getTxn(_i)
                _txnType = _absTxn.getParentTxn().getInvestTxnType()
                if (_txnType == InvestTxnType.BUY or _txnType == InvestTxnType.SELL
                        or _txnType == InvestTxnType.BUY_XFER or _txnType == InvestTxnType.SELL_XFER):
                    _split = TxnUtil.getSecurityPart(_absTxn.getParentTxn())
                    if (_split.getParentAmount() < 0):
                        buySet.addTxn(_split)
                    elif (_split.getParentAmount() > 0):
                        sellSet.addTxn(_split)
                elif (_txnType == InvestTxnType.DIVIDEND or _txnType == InvestTxnType.DIVIDEND_REINVEST):
                    _split = TxnUtil.getSecurityPart(_absTxn.getParentTxn())
                    if (_split.getParentAmount() < 0):
                        buySet.addTxn(_split)

            for j in range(0, sellSet.getSize()):
                stxn = sellSet.getTxn(j)
                shares = Math.abs(stxn.getValue())
                if (shares != TxnUtil.getNumShares(stxn)):
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed on 'shares != TxnUtil.getNumShares(stxn)'\n"
                    _errorTxt += "shares: %s, getNumShares: %s\n" %(shares, TxnUtil.getNumShares(stxn))
                    _errorTxt += "This means that the total qty of shares for this Sell is not exactly matched to the same qty of Buy(s)\n"
                    _errorTxt += "stxn: %s\n" %(stxn)
                    _errorTxt += stxn.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                    _errorTxt += "Transaction date: %s\n" %(convertStrippedIntDateFormattedText(stxn.getParentTxn().getDateInt()))
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

                buyTable = TxnUtil.parseCostBasisTag(stxn)
                if (buyTable is not None):
                    for txnID in buyTable:
                        if (txnID in buyList):
                            oldValue = buyList.get(txnID)
                            plusValue = buyTable.get(txnID)
                            adjustedShares = curr.adjustValueForSplitsInt(stxn.getDateInt(), plusValue)
                            newValue = oldValue + adjustedShares
                            buyList[txnID] = newValue
                            continue
                        buyList[txnID] = curr.adjustValueForSplitsInt(stxn.getDateInt(), buyTable.get(txnID))
                else:
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed as buyTable (cost basis lot tags) is None\n"
                    _errorTxt += "This probably means that no Buy(s) have been matched to this Sell\n"
                    _errorTxt += "stxn: %s\n" %(stxn)
                    _errorTxt += stxn.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                    _errorTxt += "Transaction date: %s\n" %(convertStrippedIntDateFormattedText(stxn.getParentTxn().getDateInt()))
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

            for txnID in buyList:
                txn = TxnUtil.getTxnByID(buySet, txnID)
                if (txn is None):
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed as could not find txnID: '%s' in buySet\n" %(txnID)
                    _errorTxt += "This means that a matched Buy txn doesn't seem to exist any more?\n"
                    _errorTxt += "buySet  contains: %s\n" %(buySet)
                    _errorTxt += "buyList contains: %s\n" %(buyList)
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

                numShares = buyList.get(txnID)
                if (curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()) < numShares):
                    _errorTxt += "*****************\n"
                    _errorTxt += "... Failed as 'curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()) < numShares'\n"
                    _errorTxt += "This means that a Buy is over matched on Sell(s) - i.e. the Buy qty is less than the total matched Sell qty\n"
                    _errorTxt += "On TxnID: %s\n" %(txnID)
                    _errorTxt += "On Txn:   %s\n" %(txn)
                    _errorTxt += txn.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                    _errorTxt += "Transaction date: %s\n" %(convertStrippedIntDateFormattedText(txn.getParentTxn().getDateInt()))
                    _errorTxt += "curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()): %s\n" %(curr.adjustValueForSplitsInt(txn.getDateInt(), txn.getValue()))
                    _errorTxt += "numShares: %s\n" %(numShares)
                    _errorTxt += "*****************\n"
                    return False, _errorTxt

            return True, _errorTxt

        for secAcct in securitiesToValidate:
            output += "\nVALIDATING: %s\n" %(secAcct)
            result, _output = validateLots(secAcct)
            output += _output
            if result:
                output += "STRANGE RESULT - Now seems to validates as OK? %s\n" %(secAcct)
                continue

            output += "... FAILED VALIDATION!!! %s\n\n" %(secAcct)

        toolbox_frame_.toFront()
        txt = "%s: Displaying invalid LOT matching data" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "B")
        jif = QuickJFrame(_THIS_METHOD_NAME, output, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        myPopupInformationBox(jif,txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    class OpenFolderButtonAction(AbstractAction):

        def __init__(self): pass

        def actionPerformed(self, event):
            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

            helper = MD_REF.getPlatformHelper()

            grabProgramDir = find_the_program_install_dir()
            if not os.path.exists((grabProgramDir)): grabProgramDir = None

            grabSyncFolder = get_sync_folder()

            locations = [
                "Show Preferences (config.dict) Folder",
                "Show Custom themes Folder",
                "Show Console (error) log Folder",
                "Show Contents of your current Dataset Folder",
                "Show Extensions Folder",
                "Show Auto Backup Folder",
                "Show Last used (Manual) Backup Folder"]

            # noinspection PyUnresolvedReferences
            locationsDirs = [
                Common.getPreferencesFile(),
                ThemeInfo.customThemeFile,
                MD_REF.getLogFile(),
                MD_REF.getCurrentAccount().getBook().getRootFolder(),
                Common.getFeatureModulesDirectory(),
                FileUtils.getBackupDir(MD_REF.getPreferences()),
                File(MD_REF.getUI().getPreferences().getSetting("backup.last_saved", ""))]

            if grabSyncFolder:
                locations.append("Open Sync Folder")
                locationsDirs.append(File(grabSyncFolder))

            if grabProgramDir:
                locations.append("Open Program's Install Directory")
                locationsDirs.append(File(grabProgramDir))

            selectedFolder = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "Select the Folder you would like to open",
                                                         "Select Folder",
                                                         JOptionPane.INFORMATION_MESSAGE,
                                                         getMDIcon(lAlwaysGetIcon=True),
                                                         locations,
                                                         None)
            if not selectedFolder:
                txt = "No folder was selected to open.."
                setDisplayStatus(txt, "R")
                return

            try:
                Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(str(locationsDirs[locations.index(selectedFolder)])),None)
            except:
                pass

            if not os.path.exists(str(locationsDirs[locations.index(selectedFolder)])):
                txt = "Sorry - File/Folder does not exist! (path copied to clipboard)"
                setDisplayStatus(txt, "R")
                return

            thePathString = locationsDirs[locations.index(selectedFolder)].getCanonicalPath()   # type: str

            if (Platform.isOSX() and grabSyncFolder and
                    ("iCloud~com~infinitekind~moneydancesync" in thePathString or "dropbox" in thePathString.lower())):
                # Bypass system security preventing access to certain folders....
                openResponse = subprocess.check_output('open "%s"' %(thePathString), shell=True)                        # noqa
                txt = "Sync Folder location: %s (copied to clipboard) & opened" %(thePathString)
                setDisplayStatus(txt, "B")
            else:
                helper.openDirectory(locationsDirs[locations.index(selectedFolder)])
                txt = "Folder %s opened..: %s  (path copied to clipboard)" %(selectedFolder, locationsDirs[locations.index(selectedFolder)])
                setDisplayStatus(txt, "B")

            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
            return

    def display_passwords():
        myPrint(u"D", u"In ", inspect.currentframe().f_code.co_name, u"()")

        MD_enc = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
        MD_hnt = MD_REF.getUI().getCurrentAccounts().getEncryptionHint()
        MD_sync_pwd = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()

        theMsg = u"'Master' Encryption Passphrase ('password'): "
        displayMsg = u"'Master' Encryption Passphrase ('password'): "

        if MD_enc is not None and MD_enc != u"":
            theMsg += u"%s" %(MD_enc)
            displayMsg += u"%s" %(MD_enc)
            if MD_hnt is not None and MD_hnt != u"":
                theMsg += u"  >> Encryption Passphrase Hint: %s" %(MD_hnt)
                displayMsg += u"  >> Encryption Passphrase Hint: %s" %(MD_hnt)
            else:
                theMsg += u"  >> Encryption Passphrase Hint: (NOT SET)"
                displayMsg += u"  >> Encryption Passphrase Hint: (NOT SET)"

            theMsg += u"\n"
            displayMsg += u"  -  "
        else:
            theMsg += u"(NOT SET - this means a default 'internal' encryption passphrase is being used)\n"
            displayMsg += u"(NOT SET - this means a default 'internal' encryption passphrase is being used)  -  "

        theMsg += u"Sync Passphrase: "
        displayMsg += u"Sync Passphrase: "

        if MD_sync_pwd is not None and MD_sync_pwd != u"":
            theMsg += u"%s" %(MD_sync_pwd)
            displayMsg += u"%s" %(MD_sync_pwd)
        else:
            theMsg += u"(NOT SET)"
            displayMsg += u"(NOT SET)"

        myPrint(u"B",u"Displaying Moneydance Encryption & Sync Passphrase(s) ....!")

        txt = u"Moneydance Encryption Passphrases: %s" %(displayMsg)
        setDisplayStatus(txt, "B")

        MyPopUpDialogBox(toolbox_frame_,u"Moneydance Encryption Passphrases:",theMsg,theTitle=u"PASSWORDS",lAlertLevel=1).go()

        myPrint(u"D", u"Exiting ", inspect.currentframe().f_code.co_name, u"()")
        return theMsg, displayMsg

    def close_dataset():
        # type: () -> bool

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not GlobalVars.UPDATE_MODE or not isToolboxUnlocked(): return False

        _THIS_METHOD_NAME = "CLOSE DATASET"

        currentBook = MD_REF.getCurrentAccountBook()     # type: AccountBook
        if currentBook is None:
            myPopupInformationBox(toolbox_frame_, "CRITICAL ERROR: AccountBook is missing? (Suggest you restart!)",theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        # Already on the EDT....
        if not ManuallyCloseAndReloadDataset.isSafeToCloseDataset():
            txt = "ERROR: MD reports that it's not OK to close open windows - no changes made"
            myPopupInformationBox(toolbox_frame_,txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return False

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return False
        if not backup_config_dict():  return False

        try:
            myPrint("B", "%s: Opening the Console Window (as it might be useful)" %(_THIS_METHOD_NAME))
            ConsoleWindow.showConsoleWindow(MD_REF.getUI())
        except: myPrint("B", "%s: FAILED to open the Console Window... ignoring the error...." %(_THIS_METHOD_NAME))

        if float(MD_REF.getBuild()) >= 4057:    # MoneyBot can be a bit quirky on ealrier builds....
            try:
                myPrint("B", "%s: Opening a Moneybot Window (as it might be useful)" %(_THIS_METHOD_NAME))
                MoneyBotWindow.showBotView(MD_REF.getUI())
            except: myPrint("B", "%s: FAILED to open a Moneybot Window... ignoring the error...." %(_THIS_METHOD_NAME))
        else:
            myPrint("B", "%s: Not bothering to open a Moneybot Window... (it's quirky on earlier builds)..." %(_THIS_METHOD_NAME))

        toolbox_frame_.toFront()

        _msg = pad("Please wait:", 50, padChar=".")
        pleaseWait = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False,OKButtonText="WAIT")
        pleaseWait.go()

        try:
            MD_REF.getUI().setStatus("Toolbox will now close your dataset", -1.0)

            myPrint("B", "%s: Executing CLOSE CURRENT DATASET" %(_THIS_METHOD_NAME))

            if not ManuallyCloseAndReloadDataset.manuallyCloseDataset(currentBook, lKillAllSyncers=True, lCloseWindows=True, lKillAllFramesWithBookReferences=True):
                txt = "ERROR: MD reports that it could not close all open windows.... - no changes made (you might need to restart MD)"
                myPopupInformationBox(toolbox_frame_, txt, theTitle="ERROR", theMessageType=JOptionPane.ERROR_MESSAGE)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                return False

            txt = "DATASET CLOSED (review console if appropriate)"
            myPopupInformationBox(toolbox_frame_, theMessage=txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            setDisplayStatus(txt, "B"); myPrint("B", txt)

            try: WelcomeWindow.showWelcomeWindow(MD_REF.getUI())
            except: myPrint("B", "%s: FAILED to launch the WelcomeWindow... ignoring the error...." %(_THIS_METHOD_NAME))

            return True

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "%s function has failed. Review log and console - You should probably RESTART MD" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,theMessage=txt, theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)

        finally:

            ManuallyCloseAndReloadDataset.startBackgroundSyncing()

            pleaseWait.kill()

        return False


    def rename_relocate_dataset(lRelocateDataset=False, lRelocateToInternal=True):
        # type: (bool, bool) -> bool

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if lRelocateDataset:
            actionString = "relocate"
        else:
            actionString = "rename"
        _THIS_METHOD_NAME = ("%s DATASET" %(actionString)).upper()

        currentBook = MD_REF.getCurrentAccountBook()     # type: AccountBook
        if currentBook is None:
            myPopupInformationBox(toolbox_frame_, "CRITICAL ERROR: AccountBook is missing? (Suggest you restart!)",theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)
            return False

        # Already on the EDT....
        if not ManuallyCloseAndReloadDataset.isSafeToCloseDataset():
            txt = "ERROR: MD reports that it's not OK to close open windows - no changes made"
            myPopupInformationBox(toolbox_frame_,txt)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            return True

        currentRoot = currentBook.getRootAccount()
        currentName = currentBook.getName()

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return True
        if not backup_config_dict():  return True

        fCurrentFilePath = MD_REF.getCurrentAccount().getBook().getRootFolder()
        currentFilePath = fCurrentFilePath.getCanonicalPath()

        newName = currentName

        if lRelocateDataset:

            if lRelocateToInternal:
                newLocation = AccountBookUtil.DEFAULT_FOLDER_CONTAINER

            else:
                selectedFolder = getFileFromFileChooser(toolbox_frame_,                     # Parent frame or None
                                                        get_home_dir(),                     # Starting path
                                                        None,                               # Default Filename
                                                        "Select new location for dataset",  # Title
                                                        False,                              # Multi-file selection mode
                                                        True,                               # True for Open/Load, False for Save
                                                        False,                              # True = Files, else Dirs
                                                        "SELECT FOLDER",                    # Load/Save button text, None for defaults
                                                        None,                               # File filter (non Mac only). Example: "txt" or "qif"
                                                        lAllowTraversePackages=False,
                                                        lAllowTraverseApplications=False,
                                                        lForceJFC=False,
                                                        lForceFD=False,
                                                        lAllowNewFolderButton=True,
                                                        lAllowOptionsButton=True)

                if selectedFolder is None or selectedFolder == "" or not File(selectedFolder).exists():
                    txt = "%s: User chose to cancel or no folder selected." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return None
                newLocation = File(selectedFolder)

            fNewNamePath = AccountBook.getUnusedFileNameWithBase(newLocation, StringUtils.stripExtension(fCurrentFilePath.getName()))
            newName = fNewNamePath.getName()
            oldPathURI = Paths.get(fCurrentFilePath.toURI())
            newPathURI = Paths.get(fNewNamePath.toURI())

        else:

            while True:
                userRequestedNewName = myPopupAskForInput(toolbox_frame_,
                                                          theTitle=_THIS_METHOD_NAME,
                                                          theFieldLabel="NEW NAME:",
                                                          theFieldDescription="Enter a new name for this dataset",
                                                          defaultValue=newName)

                if userRequestedNewName is None or userRequestedNewName == "":
                    txt = "No new name entered - no changes made"
                    myPopupInformationBox(toolbox_frame_,txt)
                    setDisplayStatus(txt, "R")
                    return True

                newName = AccountBook.stripNonFilenameSafeCharacters(userRequestedNewName)
                newNamePath = os.path.join(os.path.dirname(currentFilePath), newName + Common.ACCOUNT_BOOK_EXTENSION)
                fNewNamePath = File(newNamePath)

                oldPathURI = Paths.get(fCurrentFilePath.toURI())
                newPathURI = Paths.get(fNewNamePath.toURI())

                if newName is None or newName == "" or fNewNamePath.exists():
                    myPopupInformationBox(toolbox_frame_, "ERROR: new name: '%s' invalid or already exists?" %(newName),theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                    continue

                break

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "%s this dataset?" %(actionString.capitalize())):
            return True

        _msg = pad("Please wait:", 50, padChar=".")
        pleaseWait = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False,OKButtonText="WAIT")
        pleaseWait.go()

        try:
            MD_REF.getUI().setStatus("Toolbox will now %s your dataset" %(actionString), -1.0)

            myPrint("B", "Updating Root's internal name to match new name")
            currentRoot.setAccountName(newName)
            currentRoot.syncItem()

            myPrint("B", "Executing '%s' on current dataset: %s - will %s to: %s" %(_THIS_METHOD_NAME, fCurrentFilePath.getCanonicalPath(), actionString, fNewNamePath.getCanonicalPath()))

            if not ManuallyCloseAndReloadDataset.manuallyCloseDataset(currentBook, lKillAllSyncers=True, lCloseWindows=True, lKillAllFramesWithBookReferences=True):
                txt = "ERROR: MD reports that it could not close all open windows.... - no changes made (you might need to restart MD)"
                myPopupInformationBox(toolbox_frame_, txt, theTitle="ERROR", theMessageType=JOptionPane.ERROR_MESSAGE)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                return False
            del currentBook, currentRoot

            success = False
            try:
                myPrint("B", "attempting to move (rename/copy) file from " + fCurrentFilePath.getAbsolutePath() + " to " + fNewNamePath.getAbsolutePath())
                Files.move(oldPathURI, newPathURI, [StandardCopyOption.ATOMIC_MOVE])
                myPrint("B", "... nio atomic (rename/copy) successful!")
                success = True
            except IOException as e:
                myPrint("B", "nio atomic move failed.  Reverting to old-fashioned copy-and-move. Error was:", e)
                try:
                    IOUtils.copyDirectoryContents(fCurrentFilePath, fNewNamePath)
                    IOUtils.deleteFolder(fCurrentFilePath)
                    myPrint("B", "... copyDirectoryContents successful!")
                    success = True
                except IOException as e2:
                    myPrint("B", "copy copyDirectoryContents FAILED!  Deleting destination and sticking with the original. Error was:", e2)
                    dump_sys_error_to_md_console_and_errorlog()
                    IOUtils.deleteFolder(fNewNamePath)

            if not success:
                txt = "%s: File operation(s) failed (review console) - no changes made...." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,"%s - Will close Toolbox & reopen original" %(txt),theMessageType=JOptionPane.ERROR_MESSAGE)

                absPath = fCurrentFilePath.getAbsolutePath()

                newWrapper = AccountBookWrapper.wrapperForFolder(fCurrentFilePath)   # type: AccountBookWrapper

            else:

                myPrint("B", "** %sd dataset to: %s\n" %(actionString, fNewNamePath.getCanonicalPath()))

                absPath = fNewNamePath.getAbsolutePath()

                if fCurrentFilePath.exists():
                    raise Exception("ERROR: The old file/path still exists: %s" %(fCurrentFilePath.getAbsolutePath()))

                txt = "Dataset: %sd to: '%s" %(actionString, newName)
                setDisplayStatus(txt, "B"); myPrint("B", txt)
                play_the_money_sound()
                myPopupInformationBox(toolbox_frame_, "%s - Will close Toolbox and open %sd dataset" %(txt, actionString))

                newWrapper = AccountBookWrapper.wrapperForFolder(fNewNamePath)   # type: AccountBookWrapper

            prefs = MD_REF.getUI().getPreferences()

            if not AccountBookUtil.isWithinInternalStorage(newWrapper.getBook()):
                externalFiles = prefs.getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, StreamVector())
                if not externalFiles.contains(absPath):
                    myPrint("DB", "adding file '%s' to external account list (config.dict)" %(absPath))
                    externalFiles.add(absPath)
                    prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFiles)

            prefs.setSetting(GlobalVars.Strings.MD_CONFIGDICT_CURRENT_ACCOUNT_BOOK, absPath)

            if newWrapper is None: raise Exception("ERROR: 'AccountBookWrapper.wrapperForFolder' returned None")
            myPrint("B", "Successfully obtained 'wrapper' for: %s\n" %(fNewNamePath))

            cleanup_external_files_setting(lAutoPurge=True)

            myPrint("B", "Opening %s dataset...." %("renamed/relocated" if success else "original"))

            if success and fCurrentFilePath.exists():
                raise Exception("ERROR: The old file/path still exists: %s" %(fCurrentFilePath.getAbsolutePath()))

            ManuallyCloseAndReloadDataset.startBackgroundSyncing()

            # .setCurrentBook() always pushes mdGUI().dataFileOpened() on the EDT (if not already on the EDT)....
            myPrint("DB", "... calling .setCurrentBook() to open the dataset...")
            openResult = MD_REF.setCurrentBook(newWrapper)

            myPrint("DB", "... after-open getSyncer():", MD_REF.getCurrentAccountBook().getSyncer(), MD_REF.getCurrentAccountBook().getSyncer().isRunningInBackground(), MD_REF.getCurrentAccountBook().getSyncer().isSyncing())
            for t in [t for t in Thread.getAllStackTraces().keySet() if "sync" in t.getName()]: myPrint("DB", "...... Current Syncer Threads...:", getJVMThreadInformation(t, True))

            if not openResult or newWrapper.getBook() is None:
                txt = "%s: Failed to open Dataset (wrong password?)...." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,"%s - Will show Welcome Window" %(txt),theMessageType=JOptionPane.WARNING_MESSAGE)
                WelcomeWindow.showWelcomeWindow(MD_REF.getUI())

                # Do this after .setCurrentBook() so-as not to co-modify listeners.....
                SwingUtilities.invokeLater(GenericWindowClosingRunnable(toolbox_frame_))

                return False

            if success and fCurrentFilePath.exists():
                raise Exception("ERROR: The old file/path still exists: %s" %(fCurrentFilePath.getAbsolutePath()))

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "%s function has failed. Review log and console - You should probably RESTART MD" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R"); myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_,theMessage=txt, theTitle=_THIS_METHOD_NAME,theMessageType=JOptionPane.ERROR_MESSAGE)

        finally:

            pleaseWait.kill()

        return False


    def change_fonts():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if float(MD_REF.getBuild()) < 3030:
            txt = "Error - must be on Moneydance build 3030+ to change fonts! NO CHANGES MADE!"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User requested to change Moneydance Default Fonts!")

        if not backup_config_dict():
            txt = "Error backing up config.dict preferences file before deletion - NO CHANGES MADE!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        prefs=MD_REF.getUI().getPreferences()

        systemFonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames()
        for installedFont in systemFonts: myPrint("DB","System OS Font %s is installed in your system..:" %installedFont)

        # These are taken from MD Code - build 3034 - watch out they may change...!
        Mac_fonts_main =     ["SF Pro Display", "SF Display", "Helvetica Neue", "Helvetica", "Lucida Grande", "Dialog"]
        Mac_fonts_mono =     ["Gill Sans", "Menlo", "Monaco", "Monospaced"]

        Windows_fonts_main = ["Dialog"]
        Windows_fonts_mono = ["Calibri","Monospaced"]

        Linux_fonts_main =   ["Dialog"]
        Linux_fonts_mono =   ["Monospaced"]

        all_fonts_code =   ["Hack", "Monospaced"]
        all_fonts_print =   ["Helvetica", "Dialog"]

        lExit=False
        lAnyFontChanges=False

        for checkFont in ["main_font","mono_font","code_font","print.font_name"]:
            x = prefs.getSetting(checkFont, None)
            if x is not None and x == "null":
                lAnyFontChanges=True
                prefs.setSetting(checkFont,None)
                myPrint("B","@@ Font setting %s in config.dict was set to 'null'. I have corrected this and deleted the setting.." %checkFont)

        if lAnyFontChanges: MD_REF.savePreferences()

        while True:
            if lExit: break

            mainF = prefs.getSetting("main_font", None)
            monoF = prefs.getSetting("mono_font", None)
            codeF = prefs.getSetting("code_font", None)
            printF = prefs.getSetting("print.font_name", None)

            myPrint("DB",'@@ MONEYDANCE: Config.dict: "main_font" currently set to %s' %mainF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "mono_font" currently set to %s' %monoF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "code_font" currently set to %s' %codeF)
            myPrint("DB",'@@ MONEYDANCE: Config.dict: "print.font_name" currently set to %s' %printF)

            display_main="None(Moneydance defaults)"
            display_mono="None(Moneydance defaults)"
            display_code="None(Moneydance defaults)"
            display_print="None(Moneydance defaults)"
            if mainF and mainF != "null": display_main = mainF
            if monoF and monoF != "null": display_mono = monoF
            if codeF and codeF != "null": display_code = codeF
            if printF and printF != "null": display_print = printF

            MyPopUpDialogBox(toolbox_frame_,"Config.dict - CURRENT FONTS:",
                             '"main_font" currently set to %s\n'
                             '"mono_font" currently set to %s  (Used for mainly numbers)\n'
                             '"code_font" currently set to %s  (the Moneybot / Python Font >> IMPACTS OUTPUT COLUMN ALIGNMENT <<)\n'
                             '"print.font_name" currently set to %s' %(display_main,display_mono,display_code,display_print),
                             theTitle="FONTS",OKButtonText="CONTINUE").go()

            _options=["MAIN: CHANGE SETTING",
                      "MAIN: DELETE SETTING",
                      "MONO: CHANGE SETTING",
                      "MONO: DELETE SETTING",
                      "CODE: CHANGE SETTING",
                      "CODE: DELETE SETTING",
                      "PRINT: CHANGE SETTING",
                      "PRINT: DELETE SETTING"]

            selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                         "What type of change do you want to make?",
                                                         "ALTER FONTS",
                                                         JOptionPane.WARNING_MESSAGE,
                                                         getMDIcon(None),
                                                         _options,
                                                         None)

            if not selectedOption: break

            lMain = (_options.index(selectedOption) == 0 or _options.index(selectedOption) == 1)
            lMono = (_options.index(selectedOption) == 2 or _options.index(selectedOption) == 3)
            lCode = (_options.index(selectedOption) == 4 or _options.index(selectedOption) == 5)
            lPrint = (_options.index(selectedOption) == 6 or _options.index(selectedOption) == 7)

            lDelete = (_options.index(selectedOption) == 1 or _options.index(selectedOption) == 3 or _options.index(selectedOption) == 5 or _options.index(selectedOption) == 7)
            lChange = (_options.index(selectedOption) == 0 or _options.index(selectedOption) == 2 or _options.index(selectedOption) == 4 or _options.index(selectedOption) == 6)

            if lMain:
                theKey = "main_font"
            elif lMono:
                theKey = "mono_font"
            elif lCode:
                theKey = "code_font"
            elif lPrint:
                theKey = "print.font_name"
            else:
                raise(Exception("error"))

            if lDelete:
                if myPopupAskQuestion(toolbox_frame_,"DELETE FONT KEY","Are you sure you want to delete key: %s?" %theKey,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE):
                    prefs.setSetting(theKey,None)
                    MD_REF.savePreferences()
                    lAnyFontChanges=True
                    myPrint("B", "Config.dict: key: %s DELETED - RESTART MD" %theKey)
                    myPopupInformationBox(toolbox_frame_, "Config.dict: key: %s DELETED - RESTART MD" %theKey, "FONTS", JOptionPane.WARNING_MESSAGE)
                    continue
                else:
                    continue

            elif lChange:

                theFonts = None                                                                                         # noqa
                if Platform.isOSX():
                    if lMain:
                        theFonts = Mac_fonts_main
                    elif lMono:
                        theFonts = Mac_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))
                elif Platform.isWindows():
                    if lMain:
                        theFonts = Windows_fonts_main
                    elif lMono:
                        theFonts = Windows_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))
                else:
                    if lMain:
                        theFonts = Linux_fonts_main
                    elif lMono:
                        theFonts = Linux_fonts_mono
                    elif lCode:
                        theFonts = all_fonts_code
                    elif lPrint:
                        theFonts = all_fonts_print
                    else: raise(Exception("error"))

                for x in theFonts: myPrint("DB","Possible internal default fonts for your Platform...: %s" %x)

                _options=["CHOOSE FROM MD INTERNAL LIST", "CHOOSE FROM YOUR OS' SYSTEM INSTALLED"]
                selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                             "New Font Selection options for: %s?" %theKey,
                                                             "ALTER FONTS",
                                                             JOptionPane.WARNING_MESSAGE,
                                                             getMDIcon(None),
                                                             _options,
                                                             None)

                if not selectedOption:
                    continue

                if _options.index(selectedOption) == 0 or _options.index(selectedOption) == 1:

                    if _options.index(selectedOption) == 1: theFonts = systemFonts
                    selectedFont = JOptionPane.showInputDialog(toolbox_frame_,
                                                               "Select new Font to set for %s" %theKey,
                                                               "ALTER FONTS",
                                                               JOptionPane.WARNING_MESSAGE,
                                                               getMDIcon(None),
                                                               theFonts,
                                                               None)
                    if not selectedFont:
                        continue
                    else:
                        prefs.setSetting(theKey,selectedFont)
                        MD_REF.savePreferences()
                        lAnyFontChanges=True
                        myPrint("B", 'Config.dict: key: %s CHANGED to "%s" - RESTART MD' %(theKey,selectedFont))
                        myPopupInformationBox(toolbox_frame_, 'Config.dict: key: %s CHANGED to "%s"\nRESTART MD' %(theKey,selectedFont), "FONTS", JOptionPane.WARNING_MESSAGE)
                        continue

                else: raise(Exception("error"))

            continue

        if lAnyFontChanges:

            try:
                MD_REF.getUI().getFonts().updateFonts()
                txt = "MD Font Changes made (MD Fonts were also reinitialised) - YOU MIGHT NEED TO RESTART MONEYDANCE ANYWAY (config.dict was also backed up)...."
            except:
                txt = "MD Font Changes made (failed to reinitialise MD Fonts) - PLEASE RESTART MONEYDANCE (config.dict was also backed up)...."

            myPrint("DB", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
        else:
            txt = "NO FONT ACTIONS TAKEN! - NO CHANGES MADE...."
            myPrint("D", txt)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def delete_theme_file():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("DB", "User requested to delete custom theme file!")

        # noinspection PyUnresolvedReferences
        customThemeFile = str(ThemeInfo.customThemeFile)
        if not os.path.exists(customThemeFile):
            txt = "Custom Theme file does not exist to delete!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not myPopupAskQuestion(toolbox_frame_,
                                  "DELETE MD custom Theme file?",
                                  "Are you sure you want to delete custom Theme file?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.ERROR_MESSAGE):

            txt = "User declined to delete custom Theme file!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not doesUserAcceptDisclaimer(toolbox_frame_, "DELETE MD custom Theme file", "DELETE custom theme file?"):
            txt = "User declined to agree to disclaimer >> custom Theme file!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User confirmed to delete custom Theme file...")

        try:
            if not backup_custom_theme_file():
                txt = "Error backing up custom theme file prior to deletion - no changes made!"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            os.remove(customThemeFile)
            txt = "DELETED CUSTOM THEME FILE: %s" %(customThemeFile)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE CUSTOM THEME FILE", JOptionPane.WARNING_MESSAGE)

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "ERROR DELETING CUSTOM THEME FILE: %s" %(customThemeFile)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPopupInformationBox(toolbox_frame_, txt, "DELETE CUSTOM THEME FILE", JOptionPane.ERROR_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def find_IOS_sync_data():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if not(Platform.isOSX() or Platform.isWindows()):
            txt = "FindIOSSyncDataButtonAction() called, but not OSx or Windows!?"
            setDisplayStatus(txt, "R")
            myPrint("B",txt)
            return

        instructions = """
INSTRUCTIONS TO ATTEMPT TO RETRIEVE YOUR MONEYDANCE SYNC ENCRYPTION KEY FROM iPHONE/iPAD

NOTE: As of 15th January 2021, there is a new iOS app in Beta Test, this allows you to view your encryption passphrase
... I understand an Android version is also coming... Ideally use these first if you have access to your mobile

OTHERWISE:
STEP 1. Ensure you have the Moneydance iOS App working & Syncing on an iphone/iPad.
STEP 2. Perform an iPhone/iPad backup to your computer Using iTunes (or Finder on Mac Big Sur). Instructions below....
STEP 3. RETURN HERE and let Toolbox attempt search; or search manually yourself (instructions below)

-----------------------------------------------------------------------------------------------------------------------------        
NOTE: If on a Mac, and you want Toolbox to search in step 3, then you must change these Mac Settings first...        
>>The system prevents programmatic access to the backups.. 
>> Go to Mac / Settings / Security & Privacy. Privacy Tab
- Click the padlock to unlock the settings
- Scroll down left side to Full Disk Access
- On the right, find Moneydance and tick it (or click the + to add and tick it) to Grant Access
- Exit and restart Moneydance, then run this Toolbox option again (if you don't do this, it will not find your backups!)..
>> Change this setting back afterwards.....
-----------------------------------------------------------------------------------------------------------------------------        

NOTE: DO NOT EDIT THE FILE MENTIONED BELOW. ALWAYS QUIT WITHOUT SAVING.
IF YOU COPY THE FILE TO YOUR DESKTOP, MAKE SURE YOU COPY (and not move)...
(Normally you hold down the CTRL, or OPTION/ALT key whilst dragging so the icon changes to a plus and copy)


================================
Mac (easiest option if possible) 
================================
Please review these instructions:
https://support.apple.com/en-gb/guide/iphone/iph3ecf67d29/ios
- Essentially install iTunes (not needed on Mac Big Sur - which uses finder)
- Go to the iPhone/iPad tab, General options
- Perform a local backup (NOT ENCRYPTED)

>> Come back here after backup completed and then run this Toolbox option to search backups........ <<

OR MANUAL INSTRUCTIONS BELOW

This link has details on the backup location: https://support.apple.com/en-gb/HT204215

>> Locate your backup(s) in Finder: 
- Open Finder. Menu GO 
- Go To Folder 
- Copy and paste this:

~/Library/Application Support/MobileSync/Backup/ 
Press Return.

You will see a list of backups. (e.g. 00008030-000E31343A02802E) 
Right click this folder (the most recent) 
Select "New terminal at folder". Then terminal will open at this folder. 

Copy / paste this command below and press enter...

grep -rl tik_dropbox_md *

...wait...

It will find something like this: 
c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c 
This is the file you need, stay in Terminal

plutil -p c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c 
(and you will see the information on the screen next to "tik_dropbox_md_sync_key" =>

or do this: 
open -a TextEdit c8/c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

And you will see text and gibberish..... but also your key... Your key should be visible... See example. My was after the text 'last_account_used2V'

(of course, now you know the file, you can find it, copy it to desktop, open with other text viewers....)


================================
WINDOWS 
================================
Download and install iTunes, plug in iPhone. Select the iPhone icon and you should see  (General) options
(Help here: https://support.apple.com/en-gb/guide/iphone/iph3ecf67d29/ios)

Perform a local backup, DESELECT Encrypt local backup. Select Backup NOW 

...wait...

>> Come back here after backup completed and then run this Toolbox option to search backups........ <<

OR MANUAL INSTRUCTIONS BELOW

When finished, locate your backup - help here: https://support.apple.com/en-gb/HT204215

In the taskbar search box, type command (no enter) and when there is a popup select run as administrator 
type 
cd %userprofile% (Or a different folder if in a different place) 
cd apple 
cd mobilesync 
cd backup 
dir 
Your backups will be listed. If only one, skip this next step, else find the latest…. Select/copy the name 
cd <the selected name>

So you will now be at something like...: 
C:\\Users\\<username>\\Apple\\MobileSync\\Backup\\00008030-000E31343A02802E> 
or 
C:\\Users\\<username>>\\Apple\\MobileSync\\Backup> (if only one backup)

Now type this and enter:

findstr /S /I /M /C:"tik_dropbox_md" *.* 
... wait ...

It will show you something like this..:

00008030-000E31343A02802E\\c8\\c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

Backup name: 00008030-000E31343A02802E 
SubDir: c8 
Actual file name you want: c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

Now copy/paste the whole string (one line) and type this (paste the long name) and enter

start notepad 00008030-000E31343A02802E\\c8\\c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c

Notepad is rubbish, so use the cursor and move right along the lines until you see your key... 
---

On both the above options, you can find and copy the file to your desktop. Rename the desktop copy to 'key.plist' for ease of use after you have it.

Once you have the file..: 
On windows you can download and use this tool: 
https://www.imactools.com/iphonebackupviewer/download/win 
Run the program, select the 3 line menu button top right, Tools, Property List View, then open the key.plist file you saved to your desktop..

On Mac, in terminal 
cd /Users/<yourname>/Desktop 
type and enter 
plutil -convert xml1 key.plist 
Now you will have a text readable version of the file you can open in a text editor..

<END>            
"""

        jif = QuickJFrame("View Instructions:", instructions,lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        jif.setLocationRelativeTo(toolbox_frame_)

        if not myPopupAskQuestion(jif,
                                  "SEARCH COMPUTER iOS BACKUP(s)",
                                  "This may be time consuming...Do you want to continue with the search for Encryption Sync Passphrases now?",
                                  JOptionPane.YES_NO_OPTION,
                                  JOptionPane.WARNING_MESSAGE):

            txt = "User Aborted iOS backup(s) search..."
            setDisplayStatus(txt, "R")
            return

        jif.dispose()       # already within the EDT

        if Platform.isOSX():
            searchList = ["Library/Application Support/MobileSync/Backup"]
        else:
            searchList = ["Apple\\MobileSync\\Backup",
                          "Apple Computer\\MobileSync\\Backup",
                          "AppData\\Roaming\\Apple\\MobileSync\\Backup",
                          "AppData\\Roaming\\Apple Computer\\MobileSync\\Backup"]


        miniText=""
        pathList = []
        for x in (searchList):
            fullPath = os.path.join(get_home_dir(), x)
            miniText += "%s\n" %fullPath
            if os.path.exists(fullPath) and os.path.isdir(fullPath):
                pathList.append(fullPath)

        if len(pathList)<1:
            txt = "Sorry - could not find your IOS Backup directory(s)..."
            setDisplayStatus(txt, "R")
            myPrint("B", "Sorry - could not find your IOS Backup directory(s) in %s ....:" %get_home_dir())
            myPrint("B", searchList)
            MyPopUpDialogBox(toolbox_frame_,"Search for iOS Backup(s) - could not find your directory(s):",
                             miniText,theTitle="RECOVER IOS SYNC KEY",OKButtonText="ABORT").go()
            return

        theIKReference = "c8c8dcebf5eab9bb14012e7df9ff46aa1d333a7c"  # WARNING, this may change? Might have to switch to finding the key..!
        diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching iOS Backup(s)..",theTitle="SEARCH", lModal=False,OKButtonText="WAIT")
        diag.go()

        def findIOSBackup(pattern, path):
            iFound=0                                                                                                    # noqa
            result = []
            dotCounter = 0

            lContinueToEnd=False

            if not GlobalVars.i_am_an_extension_so_run_headless:
                print "Searching for your iOS Backups (might be time consuming):.....",

            for root, dirs, files in os.walk(path):

                if dotCounter % 1000 <1:
                    if not GlobalVars.i_am_an_extension_so_run_headless: print ".",

                if not dotCounter or (dotCounter % 10000 <1 and not lContinueToEnd):

                    options=["STOP HERE","SEARCH TO END", "KEEP ASKING"]
                    response = JOptionPane.showOptionDialog(toolbox_frame_,
                                                            "Are you OK to continue (%s found so far)?"%iFound,
                                                            "SEARCH COMPUTER FOR iOS BACKUP(s)",
                                                            0,
                                                            JOptionPane.QUESTION_MESSAGE,
                                                            getMDIcon(None),
                                                            options,
                                                            options[2])
                    if response == 0:
                        _txt = "User Aborted iOS Backup(s) search..."
                        setDisplayStatus(_txt, "R")
                        return result, iFound

                    elif response == 1:
                        lContinueToEnd = True

                dotCounter+=1

                if debug: myPrint("DB","Searching: %s" %(root))

                for name in files:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp):
                        myPrint("DB", "found file link! %s - will skip" %fp)
                        continue
                    if fnmatch.fnmatch(name, pattern):
                        iFound+=1
                        result.append(fp)

                for name in dirs:
                    fp = os.path.join(root, name)
                    if os.path.islink(fp):
                        myPrint("DB", "found dir link! %s - will skip" %fp)
                        continue
                    if fnmatch.fnmatch(name, pattern):
                        iFound+=1
                        result.append(fp)

            return result, iFound

        iFound = 0
        fileList=[]

        for theDir in pathList:
            myPrint("P","Searching from Directory: %s" %theDir)

            holdFileList, holdFound = findIOSBackup(theIKReference, theDir)
            fileList += holdFileList
            iFound += holdFound

        diag.kill()

        print
        myPrint("B","Completed search for iOS Backup(s): %s found (called: %s)" %(iFound, theIKReference))

        if iFound < 1:
            txt = "Sorry - could not find the Moneydance Sync file(s) (%s) in iOS backup(s)..." %(theIKReference)
            setDisplayStatus(txt, "R")
            myPrint("B", txt)
            myPrint("B", fileList)
            x=""
            if Platform.isOSX():
                x="PLEASE CHECK YOU GRANTED FULL DISK ACCESS (READ INSTRUCTIONS)\n\n"
            MyPopUpDialogBox(toolbox_frame_,"Search for iOS Backups - SORRY >> COULD NOT FIND the Moneydance App Sync File (%s) in these directories:"%theIKReference,
                             x+miniText,theTitle="RECOVER IOS SYNC KEY",OKButtonText="CLOSE").go()
            return


        # ###############################################################################################
        # https://github.com/provegard/binaryplist/
        # Copyright (c) 2011, Per Rovegard <per@rovegard.se>
        # Licensed under the 3-clause BSD license.
        from struct import unpack
        from datetime import tzinfo, timedelta

        # noinspection PyDeprecation
        def dump_plist(obj, _format):
            if 'plist' == (_format or 'plist'):
                from plistlib import writePlist
                writePlist(obj, sys.stdout)
            elif 'json' == _format:
                import json
                s = json.dumps(obj, indent=2)
                print(s)

        def decode_plist(_filename, _format="plist", _search="ALL"):   # Can be "plist" or "json"
            with open(_filename, 'rb') as fd:
                try:
                    plist_root = read_binary_plist(fd)

                    if _search == "ALL":
                        dump_plist(plist_root, _format)
                    else:
                        if _search in plist_root:
                            return plist_root[_search]
                        else:
                            return "NOT FOUND"

                except PListFormatError as e:
                    myPrint("B","Format error: %s" % (e.message))
                    return "ERROR"
                except PListUnhandledError as e:
                    myPrint("B","Unhandled: %s" % (e.message))
                    return "ERROR"

        # HEADER
        #         magic number ("bplist")
        #         file format version
        #
        # OBJECT TABLE
        #         variable-sized objects
        #
        #         Object Formats (marker byte followed by additional info in some cases)
        #         null    0000 0000
        #         bool    0000 1000                       // false
        #         bool    0000 1001                       // true
        #         fill    0000 1111                       // fill byte
        #         int     0001 nnnn       ...             // # of bytes is 2^nnnn, big-endian bytes
        #         real    0010 nnnn       ...             // # of bytes is 2^nnnn, big-endian bytes
        #         date    0011 0011       ...             // 8 byte float follows, big-endian bytes
        #         data    0100 nnnn       [int]   ...     // nnnn is number of bytes unless 1111 then int count follows, followed by bytes
        #         string  0101 nnnn       [int]   ...     // ASCII string, nnnn is # of chars, else 1111 then int count, then bytes
        #         string  0110 nnnn       [int]   ...     // Unicode string, nnnn is # of chars, else 1111 then int count, then big-endian 2-byte uint16_t
        #                 0111 xxxx                       // unused
        #         uid     1000 nnnn       ...             // nnnn+1 is # of bytes
        #                 1001 xxxx                       // unused
        #         array   1010 nnnn       [int]   objref* // nnnn is count, unless '1111', then int count follows
        #                 1011 xxxx                       // unused
        #         set     1100 nnnn       [int]   objref* // nnnn is count, unless '1111', then int count follows
        #         dict    1101 nnnn       [int]   keyref* objref* // nnnn is count, unless '1111', then int count follows
        #                 1110 xxxx                       // unused
        #                 1111 xxxx                       // unused
        #
        # OFFSET TABLE
        #         list of ints, byte size of which is given in trailer
        #         -- these are the byte offsets into the file
        #         -- number of these is in the trailer
        #
        # TRAILER
        #         byte size of offset ints in offset table
        #         byte size of object refs in arrays and dicts
        #         number of offsets in offset table (also is number of objects)
        #         element # in offset table which is top level object
        #         offset table offset


        try:
            unichr(8364)                                                                                                # noqa
        except NameError:
            # Python 3
            def unichr(x):                                                                                              # noqa
                return chr(x)

        # From CFDate Reference: "Absolute time is measured in seconds relative to the
        # absolute reference date of Jan 1 2001 00:00:00 GMT".
        SECS_EPOCH_TO_2001 = 978307200

        MARKER_NULL = 0X00
        MARKER_FALSE = 0X08
        MARKER_TRUE = 0X09
        MARKER_FILL = 0X0F                                                                                              # noqa
        MARKER_INT = 0X10
        MARKER_REAL = 0X20
        MARKER_DATE = 0X33
        MARKER_DATA = 0X40
        MARKER_ASCIISTRING = 0X50
        MARKER_UNICODE16STRING = 0X60
        MARKER_UID = 0X80
        MARKER_ARRAY = 0XA0
        MARKER_SET = 0XC0
        MARKER_DICT = 0XD0


        def read_binary_plist(fd):
            """Read an object from a binary plist.
            The binary plist format is described in CFBinaryPList.c at
            http://opensource.apple.com/source/CF/CF-550/CFBinaryPList.c. Only the top
            level object is returned.
            Raise a PListFormatError or a PListUnhandledError if the input data cannot
            be fully understood.
            Arguments:
            fd -- a file-like object that is seekable
            """
            r = BinaryPListReader(fd)
            return r.read()


        class PListFormatError(Exception):
            """Represent a binary plist format error."""
            pass


        class PListUnhandledError(Exception):
            """Represent a binary plist error due to an unhandled feature."""
            pass


        class ObjectRef(object):
            def __init__(self, index):                                                                                  # noqa
                self.index = index

            def resolve(self, lst):
                return lst[self.index]


        class BinaryPListReader(object):

            def __init__(self, fd):                                                                                     # noqa
                self._fd = fd
                self._offsets = None
                self.objectRefSize = None

            def read(self):
                fd = self._fd

                # start from the beginning to check the signature
                fd.seek(0, 0)
                buf = fd.read(7)

                # verify the signature; the first version digit is always 0
                if buf != b"bplist0":
                    raise PListFormatError("Invalid signature: %s" % (buf, ))

                # seek to and read the trailer (validation omitted for now)
                fd.seek(-32, 2)
                buf = fd.read(32)

                _, offsetIntSize, self.objectRefSize, numObjects, topObject, offsetTableOffset = unpack(">5x3B3Q", buf)

                # read the object offsets
                fd.seek(offsetTableOffset, 0)
                self._offsets = [self._read_sized_int(offsetIntSize) for _ in range(0, numObjects)]

                # read the actual objects
                objects = [self._read_object(offs) for offs in self._offsets]

                # resolve lazy values (references to the object list)
                self._resolve_objects(objects)

                return objects[topObject]

            def _resolve_objects(self, objects):
                # all resolutions are in-place, to avoid breaking references to
                # the outer objects!
                for obj in objects:
                    if isinstance(obj, list):
                        for i in range(0, len(obj)):
                            obj[i] = obj[i].resolve(objects)
                    if isinstance(obj, set):
                        temp = [item.resolve(objects) for item in obj]
                        obj.clear()
                        obj.update(temp)
                    if isinstance(obj, dict):
                        temp = {k.resolve(objects): v.resolve(objects) for k, v in list(obj.items())}
                        obj.clear()
                        obj.update(temp)

            def _read_object(self, offset=-1):
                if offset >= 0:
                    self._fd.seek(offset)
                else:
                    offset = self._fd.tell()  # for the error message
                marker = ord(self._fd.read(1))
                nb1 = marker & 0xf0
                nb2 = marker & 0x0f

                obj = None
                if nb1 == MARKER_NULL:
                    if marker == MARKER_NULL:
                        obj = None
                    elif marker == MARKER_FALSE:
                        obj = False
                    elif marker == MARKER_TRUE:
                        obj = True
                    # TO DO: Fill byte, skip over
                elif nb1 == MARKER_INT:
                    count = 1 << nb2
                    obj = self._read_sized_int(count)
                elif nb1 == MARKER_REAL:
                    obj = self._read_sized_float(nb2)
                elif marker == MARKER_DATE:  # marker!
                    secs = self._read_sized_float(3)
                    secs += SECS_EPOCH_TO_2001
                    obj = datetime.datetime.fromtimestamp(secs, UTC())
                elif nb1 == MARKER_DATA:
                    # Binary data
                    count = self._read_count(nb2)
                    obj = self._fd.read(count)
                elif nb1 == MARKER_ASCIISTRING:
                    # ASCII string
                    count = self._read_count(nb2)
                    obj = self._fd.read(count).decode("ascii")
                elif nb1 == MARKER_UNICODE16STRING:
                    # UTF-16 string
                    count = self._read_count(nb2)
                    data = self._fd.read(count * 2)
                    chars = unpack(">%dH" % (count, ), data)
                    s = u''
                    for ch in chars:
                        s += unichr(ch)
                    obj = s
                elif nb1 == MARKER_UID:
                    count = 1 + nb2
                    obj = self._read_sized_int(count)
                elif nb1 == MARKER_ARRAY:
                    count = self._read_count(nb2)
                    # we store lazy references to the object list
                    obj = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
                elif nb1 == MARKER_SET:
                    count = self._read_count(nb2)
                    # we store lazy references to the object list
                    obj = set([ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)])
                elif nb1 == MARKER_DICT:
                    count = self._read_count(nb2)
                    # first N keys, then N values
                    # we store lazy references to the object list
                    keys = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
                    values = [ObjectRef(self._read_sized_int(self.objectRefSize)) for _ in range(0, count)]
                    obj = dict(list(zip(keys, values)))

                try:
                    return obj
                except NameError:
                    raise PListFormatError("Unknown marker at position %d: %d" %
                                           (offset, marker))

            def _read_count(self, nb2):
                count = nb2
                if count == 0xf:
                    count = self._read_object()
                return count

            def _read_sized_float(self, log2count):
                if log2count == 2:
                    # 32 bits
                    ret, = unpack(">f", self._fd.read(4))
                elif log2count == 3:
                    # 64 bits
                    ret, = unpack(">d", self._fd.read(8))
                else:
                    raise PListUnhandledError("Unhandled real size: %d" %
                                              (1 << log2count, ))
                return ret

            def _read_sized_int(self, count):
                # in format version '00', 1, 2, and 4-byte integers have to be
                # interpreted as unsigned, whereas 8-byte integers are signed
                # (and 16-byte when available). negative 1, 2, 4-byte integers
                # are always emitted as 8 bytes in format '00'
                buf = self._fd.read(count)
                if count == 1:
                    ret = ord(buf)
                elif count == 2:
                    ret, = unpack(">H", buf)
                elif count == 4:
                    ret, = unpack(">I", buf)
                elif count == 8:
                    ret, = unpack(">q", buf)
                else:
                    raise PListUnhandledError("Unhandled int size: %d" %
                                              (count, ))
                return ret


        class UTC(tzinfo):

            def utcoffset(self, dt):
                return timedelta(0)

            def tzname(self, dt):
                return "UTC"

            def dst(self, dt):
                return timedelta(0)

        # typedef struct {
        #    uint8_t  _unused[5];
        #    uint8_t  _sortVersion;
        #    uint8_t  _offsetIntSize;
        #    uint8_t  _objectRefSize;
        #    uint64_t _numObjects;
        #    uint64_t _topObject;
        #    uint64_t _offsetTableOffset;
        # } CFBinaryPlistTrailer;

        syncPassphrases=[]
        for foundFile in fileList:
            try:
                theSyncKey = decode_plist(foundFile,_format="plist",_search="tik_dropbox_md_sync_key")
                syncPassphrases.append(theSyncKey)
            except:
                syncPassphrases.append("Sorry - caught an error decoding the file")

        niceFileList="\n SEARCH FOR MONEYDANCE (%s) iOS Backup(s)\n"%theIKReference
        niceFileList+="Search for these Directories:\n"
        niceFileList+=miniText
        niceFileList+="\nFound these Directories:\n"

        for x in pathList:
            niceFileList+="%s\n" %x
        niceFileList+="\n"

        if not iFound:
            niceFileList+="\n<NONE FOUND>\n"

        for x in fileList:
            myPrint("B","Found: %s" %x)
            niceFileList+=x+"\n"

        niceFileList+="\nPOSSIBLE SYNC ENCRYPTION PASSPHRASES:\n"
        if len(syncPassphrases) < 1:
            niceFileList+="\n<NONE FOUND>\n"

        for encryptionKey in syncPassphrases:
            niceFileList+="%s\n" %encryptionKey

        niceFileList+="\n\n<END>"
        txt = "Find my iOS Backup(s) found %s files, with %s possible Sync Encryption keys" %(iFound,len(syncPassphrases))
        setDisplayStatus(txt, "DG")

        jif=QuickJFrame("LIST OF MONEYDANCE iOS Backups and Sync Encryption keys FOUND".upper(), niceFileList, lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        myPopupInformationBox(jif, "%s Sync Encryption keys found...." %(len(syncPassphrases)), "iOS BACKUP SEARCH", JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def import_QIF():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "IMPORT QIF"

        theTitle = "Select QIF file for import"
        QIFfilename = getFileFromFileChooser(toolbox_frame_,         # Parent frame or None
                                            get_home_dir(),          # Starting path
                                            "select_your_file.qif",  # Default Filename
                                            theTitle,                # Title
                                            False,                   # Multi-file selection mode
                                            True,                    # True for Open/Load, False for Save
                                            True,                    # True = Files, else Dirs
                                            None,                    # Load/Save button text, None for defaults
                                            "qif",                   # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=True,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if QIFfilename is None or QIFfilename == "":
            txt = "%s: User chose to cancel or no file selected >>  So no Import will be performed... " %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not os.path.exists(QIFfilename) or not os.path.isfile(QIFfilename):
            txt = "%s: Sorry, file selected to import either does not exist or is not a file" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        dropdownAccts=AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(5))
        dropdownAccts=sorted(dropdownAccts, key=lambda sort_x: (sort_x.getAccountType(), sort_x.getFullAccountName().upper()))  # type: [Account]
        dropdownAccts.insert(0,"<NONE: USE QIF SPECIFIED>")

        label_QIF = JLabel("%s" %(os.path.basename(QIFfilename)))

        label_accounts = JLabel("Select Default Account if none specified in QIF:")
        user_accounts = JComboBox(dropdownAccts)

        # QIF_FORMATS = ["QIF_FORMAT_AUTO", "QIF_FORMAT_MMDDYY", "QIF_FORMAT_DDMMYY", "QIF_FORMAT_YYMMDD"]
        QIF_FORMATS = ["QIF_FORMAT_AUTO", "QIF_FORMAT_MMDDYY", "QIF_FORMAT_DDMMYY", "QIF_FORMAT_YYMMDD"]
        label_qif_format = JLabel("Select QIF Format")
        user_QIF_format = JComboBox(QIF_FORMATS)

        decimalStrings = [".",","]
        label_decimal = JLabel("Select your decimal point character")
        user_selectDecimal = JComboBox(decimalStrings)
        user_selectDecimal.setSelectedIndex(0)

        dropdownCurrs=[]
        currencies = MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies()
        for curr in currencies:
            if curr.getCurrencyType() != CurrencyType.Type.CURRENCY: continue                                           # noqa
            dropdownCurrs.append(curr)
        dropdownCurrs=sorted(dropdownCurrs, key=lambda sort_x: (sort_x.getName().upper()))
        label_currency = JLabel("Select Default Currency for any Accounts created:")
        user_currency = JComboBox(dropdownCurrs)
        user_currency.setSelectedItem(MD_REF.getCurrentAccount().getBook().getCurrencies().getBaseType())

        IMPORT_TYPE = ["QIF_MODE_TRANSFER", "QIF_MODE_DOWNLOAD"]
        # label_import_type = JLabel("Select Import Type")
        # user_import_type = JComboBox(IMPORT_TYPE)
        #

        label_import_type_transfer = JLabel("TRANSFER MODE?")
        user_import_type_transfer = JRadioButton("(transfer)", True)
        label_import_type_download = JLabel("DOWNLOAD (from bank) MODE?")
        user_import_type_download = JRadioButton("(disabled - use newer function)",False)
        user_import_type_download.setEnabled(False)
        bg2 = ButtonGroup()
        bg2.add(user_import_type_transfer)
        bg2.add(user_import_type_download)

        label_importStructure = JLabel("Import Structure only (no data)?")
        user_importStructureOnly = JRadioButton("(structure only)", False)
        label_importAllData = JLabel("Import all data?")
        user_importAllData = JRadioButton("(all data)", False)
        bg = ButtonGroup()
        bg.add(user_importStructureOnly)
        bg.add(user_importAllData)

        userFilters = JPanel(GridLayout(0, 2))
        userFilters.add(JLabel("IMPORT FILE:"))
        userFilters.add(label_QIF)
        userFilters.add(label_qif_format)
        userFilters.add(user_QIF_format)
        userFilters.add(label_decimal)
        userFilters.add(user_selectDecimal)
        userFilters.add(label_currency)
        userFilters.add(user_currency)
        userFilters.add(label_accounts)
        userFilters.add(user_accounts)
        userFilters.add(JLabel(""))
        userFilters.add(JLabel("---"))
        # userFilters.add(label_import_type)
        # userFilters.add(user_import_type)
        userFilters.add(label_import_type_transfer)
        userFilters.add(user_import_type_transfer)
        userFilters.add(label_import_type_download)
        userFilters.add(user_import_type_download)
        userFilters.add(JLabel(""))
        userFilters.add(JLabel("---"))
        userFilters.add(label_importStructure)
        userFilters.add(user_importStructureOnly)
        userFilters.add(label_importAllData)
        userFilters.add(user_importAllData)


        while True:
            options = ["EXIT", "IMPORT"]
            userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                       userFilters,
                                                       "IMPORT QIF (Older MD Function)",
                                                       JOptionPane.OK_CANCEL_OPTION,
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       getMDIcon(lAlwaysGetIcon=True),
                                                       options, options[0]))
            if userAction != 1:
                txt = "%s: - User aborted - No changes made....." %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            if not user_importStructureOnly.isSelected() and not user_importAllData.isSelected():
                user_importStructureOnly.setForeground(getColorRed())
                user_importAllData.setForeground(getColorRed())
                continue

            if not user_import_type_transfer.isSelected() and not user_import_type_download.isSelected():
                user_import_type_transfer.setForeground(getColorRed())
                user_import_type_download.setForeground(getColorRed())
                continue

            break

        if user_QIF_format.getSelectedItem() == "QIF_FORMAT_AUTO":
            theQIFFormat = Common.QIF_FORMAT_AUTO
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_MMDDYY":
            theQIFFormat = Common.QIF_FORMAT_MMDDYY
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_DDMMYY":
            theQIFFormat = Common.QIF_FORMAT_DDMMYY
        elif user_QIF_format.getSelectedItem() == "QIF_FORMAT_YYMMDD":
            theQIFFormat = Common.QIF_FORMAT_YYMMDD
        else:
            txt = "%s: Error - QIF Format %s unknown / unsupported by Moneydance now....?!" %(_THIS_METHOD_NAME, user_QIF_format.getSelectedItem())
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if user_import_type_transfer.isSelected():
            theImportType = Common.QIF_MODE_TRANSFER
        elif user_import_type_download.isSelected():
            theImportType = Common.QIF_MODE_DOWNLOAD
        else:
            txt = "%s: Error - QIF MODE unknown / unsupported by Moneydance now....?!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # if user_import_type.getSelectedItem() == "QIF_MODE_TRANSFER":
        #     theImportType = Common.QIF_MODE_TRANSFER
        # elif user_import_type.getSelectedItem() == "QIF_MODE_DOWNLOAD":
        #     theImportType = Common.QIF_MODE_DOWNLOAD
        # else:
        #     txt = "QIF IMPORT: Error - QIF MODE %s unknown / unsupported by Moneydance now....?!" %(user_import_type.getSelectedItem())
        #     setDisplayStatus(txt, "R")
        #     myPopupInformationBox(toolbox_frame_,txt,"QIF IMPORT" %(user_import_type.getSelectedItem()), theMessageType=JOptionPane.WARNING_MESSAGE)
        #     return

        theAcct = None
        if isinstance(user_accounts.getSelectedItem(), Account):
            theAcct = user_accounts.getSelectedItem()

        theMsg =  "File name:        %s\n"         %(QIFfilename)
        theMsg += "QIF Format:       %s (%s)\n"    %(user_QIF_format.getSelectedItem(),theQIFFormat)
        theMsg += "Decimal Char:     %s\n"         %(user_selectDecimal.getSelectedItem())
        theMsg += "Default Currency: %s\n"         %(user_currency.getSelectedItem())
        theMsg += "Default Account:  %s\n"         %(user_accounts.getSelectedItem())
        theMsg += "Import Type:      %s (%s)\n"    %(IMPORT_TYPE[theImportType],theImportType)
        theMsg += "Structure Only:   %s\n"         %(user_importStructureOnly.isSelected())

        ask=MyPopUpDialogBox(toolbox_frame_,
                             theStatus="Please confirm parameters:",
                             theMessage=theMsg,
                             theTitle="QIF IMPORT",
                             OKButtonText="PROCEED",
                             lCancelButton=True)
        if (not ask.go() or not myPopupAskBackup(toolbox_frame_,"Do you want to make a Backup before your QIF Import?")):
            txt = "%s: User aborted - NO CHANGES MADE" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B","User has requested a QIF import with these following parameters:\n")
        myPrint("B",theMsg)
        myPrint("J",">>EXECUTING IMPORT................\n")

        MD_REF.importQIFIntoAccount(    MD_REF.getCurrentAccount().getBook(),
                                            File(QIFfilename),
                                            theQIFFormat,                           # one of Common.QIF_FORMAT_MMDDYY, QIF_FORMAT_YYMMDD, QIF_FORMAT_DDMMYY, QIF_FORMAT_AUTO
                                            user_selectDecimal.getSelectedItem(),   # your decimal place character.
                                            user_currency.getSelectedItem(),        # the default currency to use for any new accounts that are created
                                            theAcct,                                # the default account to import into (though the QIF file may also specify multiple accounts with names)
                                            theImportType,                          # Common.QIF_MODE_DOWNLOAD or Common.QIF_MODE_TRANSFER
                                            user_importStructureOnly.isSelected())  # if true, only import the account and category structure

        myPrint("J",">>FINISHED IMPORT................\n")

        txt = "%s: File %s imported (review console log for any messages)" %(_THIS_METHOD_NAME, os.path.basename(QIFfilename))
        setDisplayStatus(txt, "B")
        play_the_money_sound()
        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

        ConsoleWindow.showConsoleWindow(MD_REF.getUI())

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def convert_timestamp_readable_date():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        getTimeStamp = myPopupAskForInput(toolbox_frame_,"CONVERT TIMESTAMP","TimeStamp:","Enter the TimeStamp (Milliseconds) to see the readable date")

        setDisplayStatus(" ", "DG")

        if getTimeStamp is None or getTimeStamp == "" or not StringUtils.isInteger(getTimeStamp) or int(getTimeStamp) < 1: return
        readableStamp = get_time_stamp_as_nice_text(int(getTimeStamp))

        txt = "Convert Timestamp (%s): %s" %(getTimeStamp,readableStamp)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"CONVERT TIMESTAMP")

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def force_remove_extension():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        myPrint("DB", "User requested to delete all references to orphaned/outdated Extensions from config.dict and *.mxt files...")

        orphan_prefs, orphan_files, orphan_confirmed_extn_keys = get_orphaned_extension()

        if len(orphan_prefs)<1 and len(orphan_files)<1 and len(orphan_confirmed_extn_keys)<1:
            txt = "No orphaned Extension preferences or files detected - nothing to do!"
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        displayData="\nLISTING EXTENSIONS ORPHANED IN CONFIG.DICT OR FILES (*.MXT)\n\n"

        for x in orphan_prefs.keys():
            displayData+="%s Extension: %s is %s\n" %(pad("config.dict:",40),pad(x,40),pad(orphan_prefs[x],40))

        displayData+="\n"

        for x in orphan_confirmed_extn_keys.keys():
            _theVersion = MD_REF.getUI().getPreferences().getSetting(orphan_confirmed_extn_keys[x][1],None)
            displayData+="%s Extension: %s Key: %s (build: %s) is %s\n" %(pad("config.dict: ",40),pad(x,40),pad(orphan_confirmed_extn_keys[x][1],40),_theVersion,pad(orphan_confirmed_extn_keys[x][0],40))

        displayData+="\n"

        for x in orphan_files.keys():
            displayData+="%s Extension: %s is %s\n" %(pad("File: "+orphan_files[x][1],40),pad(x,40),pad(orphan_files[x][0],40))

        displayData+="\n<END>"
        jif = QuickJFrame("ORPHANED EXTENSIONS", displayData,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

        if not confirm_backup_confirm_disclaimer(jif, "DELETE ORPHANED EXTENSIONS", "delete the Extension Orphans?"):
            return

        extensionDir = Common.getFeatureModulesDirectory()
        if not extensionDir:
            txt = "DELETE ORPHANED EXTENSIONS - Error getting Extensions directory - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not backup_config_dict():
            txt = "DELETE ORPHANED EXTENSIONS - Error backing up config.dict preferences file - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # reload latest preferences
        extension_prefs = MD_REF.getUI().getPreferences().getTableSetting("gen.fmodules",None)
        if not extension_prefs:
            txt = "DELETE ORPHANED EXTENSIONS - Error getting gen.fmodules setting - no changes made...."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(jif,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # OK - let's go....!! Delete away!!!
        for x in orphan_prefs.keys():
            extension_prefs.put(x,None)
            myPrint("B","Orphaned extension %s removed from config.dict!" %x)

        MD_REF.getUI().getPreferences().setSetting("gen.fmodules",extension_prefs)
        myPrint("B","config.dict gen.fmodules setting re-saved....")

        for x in orphan_confirmed_extn_keys:
            MD_REF.getUI().getPreferences().setSetting(orphan_confirmed_extn_keys[x][1],None)
            myPrint("B","Orphaned extension key %s removed from config.dict!" %orphan_confirmed_extn_keys[x][1])

        MD_REF.savePreferences()

        lError=False
        # extensionDir = Common.getFeatureModulesDirectory()
        for x in orphan_files.keys():
            # noinspection PyTypeChecker
            fileToDelete = os.path.join(extensionDir.getAbsolutePath(),orphan_files[x][1])
            if not os.path.exists(fileToDelete):
                lError=True
                myPrint("B","ERROR orphaned extension file %s MISSING" %fileToDelete)
            else:
                try:
                    os.remove(fileToDelete)
                    myPrint("B","Orphaned extension file %s deleted" %fileToDelete)
                except:
                    lError=True
                    myPrint("B","ERROR deleting orphaned extension file %s deleted" %fileToDelete)
                    dump_sys_error_to_md_console_and_errorlog()

        play_the_money_sound()

        if lError:
            myPrint("B", "Orphaned Extensions have been deleted - WITH ERRORS - from config.dict and the .MXT files from the Extensions folder....")
            txt = "ORPHANED EXTENSIONS HAVE BEEN DELETED - WITH ERRORS - REVIEW CONSOLE ERROR LOG!"
        else:
            myPrint("B", "SUCCESS - Your Orphaned Extensions have been deleted from config.dict and the .MXT files from the Extensions folder....")
            txt = "SUCCESS - YOUR ORPHANED EXTENSIONS HAVE BEEN DELETED - MANUALLY RESTART MONEYDANCE!"

        setDisplayStatus(txt, "R")
        myPopupInformationBox(jif, txt, "DELETE ORPHANED EXTENSIONS", JOptionPane.ERROR_MESSAGE)
        return

    def reset_window_positions():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _RESETWINLOC    = 0
        _RESETREGFILT   = 1
        _RESETREGVIEW   = 2
        _RESETALL       = 3

        what = [
            "RESET - Only Window Locations on their own (Excludes Filters & Views)",
            "RESET - Only Transaction Register Filters",
            "RESET - Only Transaction Register Initial / Current View screen",
            "RESET - Window display settings (Sizes, Locations, Sorts, Widths etc) - Everything EXCEPT Filters & Views"
        ]

        resetWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                "Select the Window display setting(s) to RESET",
                                                "RESET WINDOW DISPLAY SETTINGS",
                                                JOptionPane.WARNING_MESSAGE,
                                                getMDIcon(None),
                                                what,
                                                None)
        if not resetWhat:
            txt = "No RESET WINDOW DISPLAY SETTINGS TYPE option was chosen - no changes made!"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("DB", "User requested to %s settings from config.dict, LocalStorage() ./safe/settings , and by account!" %resetWhat)

        lAll = lWinLocations = lRegFilters = lRegViews = False

        if resetWhat == what[_RESETALL]:        lAll            = True
        if resetWhat == what[_RESETWINLOC]:     lWinLocations   = True
        if resetWhat == what[_RESETREGFILT]:    lRegFilters     = True
        if resetWhat == what[_RESETREGVIEW]:    lRegViews       = True

        def get_set_config(st, tk, lReset, lResetAll, lResetWinLoc, lResetRegFilters, lResetRegViews):                  # noqa
            # As of 2021.2010   Window locations are only in config.dict.
            #                   Register Filters and Initial Register Views are only in LocalStorage()
            #                   column width, sort orders, etc are everywhere......

            configData = []

            invalidKeysToZap = StreamVector()
            if isinstance(invalidKeysToZap, Vector): pass

            if not lReset:
                configData.append("\nDATA STORED WITHIN CONFIG.DICT (effectively defaults where not specifically set by Account):")
                configData.append("--------------------------------------------------------------------------------------------")

            lastKey = None
            for theKey in tk:
                # Skip config settings we don't want to reset

                # Main safety filter here
                value = st.get(theKey)
                if not check_for_window_display_data(theKey, value): continue

                if lResetAll:
                    pass
                elif lResetWinLoc:
                    if not check_for_just_locations_window_display_data(theKey, value): continue
                elif lResetRegFilters:
                    if not check_for_just_register_filters_window_display_data(theKey, None): continue
                elif lResetRegViews:
                    if not check_for_just_initial_view_filters_window_display_data(theKey, None): continue
                else:
                    myPrint("B", "@@@ ERROR in get_set_config(): unexpected parameter!?")
                    raise(Exception("@@@ ERROR in get_set_config(): unexpected parameter!?"))

                if lReset:
                    invalidKeysToZap.add(theKey)

                test = "col_widths."
                if theKey.startswith(test):
                    if lReset:
                        pass
                        # MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("COLUMN WIDTHS:")

                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                test = "ext_mgmt_win"
                if theKey.startswith(test):
                    if lReset:
                        pass
                        # MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nEXTENSIONS WINDOW:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                lFoundKeyTest = False
                for test in ["moneybot_py_divider", "mbot."]:
                    if theKey.startswith(test):
                        lFoundKeyTest = True
                        if lReset:
                            pass
                            # MD_REF.getPreferences().setSetting(theKey, None)
                        else:
                            if theKey[:len(test)] != lastKey:
                                lastKey = theKey[:len(test)]
                                configData.append("\nMONEYBOT:")
                            configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                if lFoundKeyTest: continue

                test = "gui."
                if theKey.startswith(test):
                    if lReset:
                        pass
                        # MD_REF.getPreferences().setSetting(theKey, None)
                    else:
                        if theKey[:len(test)] != lastKey:
                            lastKey = theKey[:len(test)]
                            configData.append("\nGUI.:")
                        configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                    continue

                lFoundKeyTest = False
                for test in ["security_list", "curr_list", "ratioSettings.", "ol_acct_map_win"]:
                    if theKey.startswith(test):
                        lFoundKeyTest = True
                        if lReset:
                            pass
                            # MD_REF.getPreferences().setSetting(theKey, None)
                        else:
                            if theKey[:len(test)] != lastKey:
                                lastKey = theKey[:len(test)]
                                configData.append("\nMISC:")
                            configData.append(pad(theKey+":",30) + MD_REF.getPreferences().getSetting(theKey, None).strip())
                if lFoundKeyTest: continue

                myPrint("B","@@ RESET WINDOW DATA - ERROR >> What is this key: %s ? @@" %theKey)
                raise(Exception("ERROR - caught an un-coded key: " + str(theKey)))

            # END OF config.dict search
            ########################################################################################################

            if lResetAll or lResetRegFilters or lResetRegViews:
                # Now get the same data for each account
                accounts = AccountUtil.allMatchesForSearch(MD_REF.getCurrentAccount().getBook(), MyAcctFilter(6))

                if not lReset:
                    configData.append("\nDATA STORED INTERNALLY BY ACCOUNT (not config.dict):")
                    configData.append("-----------------------------------------------------")

                dataPrefKey = "col_widths."
                dataPrefKeys_legacy = [  "gui.col_widths",
                                         "rec_reg.credit",
                                         "rec_reg.debit" ]

                keyIterator=[]
                if lResetRegFilters:    keyIterator.append("sel_reg_filter")
                if lResetRegFilters:    keyIterator.append("sel_invreg_filter")
                if lResetRegViews:      keyIterator.append("sel_inv_view")

                for acct in accounts:

                    last = None

                    if lResetAll:
                        for x in _COLWIDTHS:
                            xx = acct.getPreference(dataPrefKey+x, None)

                            if xx:
                                if lReset:
                                    # NOTE: This really sets the preference in LocalStorage() with the acct's UUII+"." prepended as the key!!!! (Sneaky eh!!??)
                                    acct.setPreference(dataPrefKey+x, None)
                                    # acct.syncItem() # Not entirely sure about this.... If Preference goes to LocalStorage() then Acct shouldn't be affected..
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Key: %s Value: %s" %(pad(dataPrefKey+x+":",30),str(xx).strip()))

                    if lResetRegFilters or lResetRegViews:
                        for x in keyIterator:
                            xx = acct.getPreference(x, None)

                            if xx:
                                if lReset:
                                    # NOTE: This really sets the preference in LocalStorage() with the acct's UUII+"." prepended as the key!!!! (Sneaky eh!!??)
                                    acct.setPreference(x, None)
                                    # acct.syncItem() # Not entirely sure about this.... If Preference goes to LocalStorage() then Acct shouldn't be affected..
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Key: %s Value: %s" %(pad(x+":",30),str(xx).strip()))

                    lNeedsSync = False

                    if lResetAll:
                        for theLegacyKey in dataPrefKeys_legacy:

                            # Look for legacy keys actually on the account..!
                            yy = acct.getParameter(theLegacyKey, None)

                            if yy:  # Should be a legacy setting
                                if lReset:
                                    acct.setEditingMode()
                                    acct.setParameter(theLegacyKey, None)
                                    lNeedsSync = True
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Legacy Key: %s Value: %s" %(pad(theLegacyKey+":",30-7),str(yy).strip()))

                    if lResetRegFilters or lResetRegViews:
                        for theLegacyKey in keyIterator:

                            # Look for legacy keys actually on the account..!
                            yy = acct.getParameter(theLegacyKey, None)

                            if yy:  # Should be a legacy setting
                                if lReset:
                                    acct.setEditingMode()
                                    acct.setParameter(theLegacyKey, None)
                                    lNeedsSync = True
                                else:
                                    if last != acct:
                                        last = acct
                                        configData.append("\n>>Account: %s" %(acct.getAccountName()))

                                    configData.append("Legacy Key: %s Value: %s" %(pad(theLegacyKey+":",30-7),str(yy).strip()))

                    if lReset and lNeedsSync:
                        acct.syncItem()

                # END OF Accounts search
                ########################################################################################################

                if not lReset:
                    configData.append("\nDATA STORED INTERNALLY WITHIN LOCAL STORAGE (not config.dict):")
                    configData.append("----------------------------------------------------------------")

                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                keys = sorted(LS.keys())

                if lResetAll:

                    last = None

                    for theKey in keys:
                        value = LS.get(theKey)

                        for theTypeToCheck in dataPrefKeys_legacy:

                            if theKey.endswith("."+theTypeToCheck):

                                if lReset:
                                    LS.put(theKey, None)
                                else:
                                    splitKey = theKey.split('.')
                                    if splitKey[0] != last:
                                        last = splitKey[0]
                                        lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])
                                        if lookupAcct:
                                            configData.append("\n>>Account: %s" %(lookupAcct.getAccountName()))
                                        else:
                                            configData.append("\n>>Account: <NOT FOUND> ???")

                                    configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                        # Now look for keys not linked to Accounts... Perhaps deleted ones?
                        for theTypeToCheck in _COLWIDTHS:

                            if theKey.endswith(".col_widths."+theTypeToCheck):

                                splitKey = theKey.split('.')
                                lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])

                                if lookupAcct: continue     # Found one, probably caught above, so skip

                                if lReset:
                                    LS.put(theKey, None)
                                else:
                                    if splitKey[0] != last:
                                        last = splitKey[0]
                                        configData.append("\n>>Account: <NOT FOUND> ??? (probably a deleted account)")

                                    configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                if lResetRegFilters or lResetRegViews:

                    last = None

                    for theKey in keys:
                        value = LS.get(theKey)

                        if lResetRegFilters:
                            if not check_for_just_register_filters_window_display_data(theKey, None):
                                continue
                        elif lResetRegViews:
                            if not check_for_just_initial_view_filters_window_display_data(theKey, None):
                                continue
                        else:
                            myPrint("B", "@@ ERROR: RESET WINDOW DISPLAY SETTINGS - Unexpected filter!?")
                            raise(Exception("@@ ERROR: RESET WINDOW DISPLAY SETTINGS - Unexpected filter!?"))

                        if lReset:
                            LS.put(theKey, None)
                        else:
                            splitKey = theKey.split('.')
                            if splitKey[0] != last:
                                last = splitKey[0]
                                lookupAcct = MD_REF.getCurrentAccount().getBook().getAccountByUUID(splitKey[0])
                                if lookupAcct:
                                    configData.append("\n>>Account: %s" %(lookupAcct.getAccountName()))
                                else:
                                    configData.append("\n>>Account: <NOT FOUND>???")

                            configData.append("LS Key: %s Value: %s" %(pad(theKey+":",55),str(value).strip()))

                # END OF LocalStorage() search
                ########################################################################################################

            if lReset and invalidKeysToZap.size() > 0:
                myPrint("B","Saving keys to zap into Preferences:", invalidKeysToZap)
                MD_REF.getPreferences().setSetting(GlobalVars.Strings.TOOLBOX_PREFERENCES_ZAPPER, invalidKeysToZap)

            configData.append("\n <END>")

            for i in range(0, len(configData)):
                configData[i] = configData[i] + "\n"

            configData = "".join(configData)

            if not lReset:
                jif = QuickJFrame("View the relevant RESET WINDOW DISPLAY SETTINGS that will be reset if you select OK to proceed", configData,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                return jif

            return

        st,tk = read_preferences_file(lSaveFirst=False)

        if not st:
            _txt = "ERROR: RESET WINDOW DISPLAY SETTINGS >> reading and sorting the data file - no changes made!..."
            setDisplayStatus(_txt, "R")
            myPopupInformationBox(None,_txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("D", "\nDisplaying the relevant RESET WINDOW DISPLAY SETTINGS (in various places) that I can reset.....:\n")

        theNewViewFrame = get_set_config(st, tk, False, lAll, lWinLocations, lRegFilters, lRegViews)

        if not confirm_backup_confirm_disclaimer(theNewViewFrame, "RESET WINDOW DISPLAY SETTINGS", "%s data?" %(resetWhat)):
            return

        if not backup_config_dict():
            _txt = "RESET WINDOW DISPLAY SETTINGS: ERROR making backup of config.dict - no changes made!"
            setDisplayStatus(_txt, "R")
            myPopupInformationBox(theNewViewFrame,_txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not backup_local_storage_settings():
            _txt = "RESET WINDOW DISPLAY SETTINGS: ERROR making backup of LocalStorage() ./safe/settings - no changes made!"
            setDisplayStatus(_txt, "R")
            myPopupInformationBox(theNewViewFrame,_txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        ##### FORCE CLOSE ALL WINDOWS SO THEY DO NOT SAVE THEIR SETTINGS AFTER TOOLBOX CHANGES #########################
        # try:
        #     forceCloseMoneydanceWindows()
        # except:
        #     dump_sys_error_to_md_console_and_errorlog()
        #     myPopupInformationBox(theNewViewFrame, "ERROR: forceCloseMoneydanceWindows() crashed (will continue anyway)", "RESET WINDOW DISPLAY SETTINGS", JOptionPane.ERROR_MESSAGE)


        # DO THE RESET HERE
        myPrint("B","Executing the windows settings reset....")
        get_set_config(st, tk, True, lAll, lWinLocations, lRegFilters, lRegViews)

        MD_REF.savePreferences()                                        # save config.dict
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()   # Flush local storage to safe/settings

        play_the_money_sound()
        myPrint("B", "SUCCESS - %s data reset in config.dict config file, internally by Account & Local Storage...." %(resetWhat))
        txt = "OK - %s settings forgotten.... RESTART MD!" %(resetWhat)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(theNewViewFrame, "SUCCESS - %s - MONEYDANCE WILL EXIT - PLEASE MANUALLY RESTART MD" %(resetWhat), "RESET WINDOW DISPLAY SETTINGS", JOptionPane.WARNING_MESSAGE)

        myPrint("B","Requesting Moneydance shuts down now...")
        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=False, lAllowSaveWorkspace=False)

    def advanced_mode_suppress_dropbox_warning():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        ask=MyPopUpDialogBox(toolbox_frame_,theStatus="You can suppress the 'Your file seems to be in a shared folder' Warning..",
                             theMessage="Moneydance support states that you should NEVER store your dataset in Dropbox.\n"
                                        "... and that you should store your dataset locally and use Moneydance's built-in syncing instead to share across computers and devices.\n"
                                        "THEREFORE YOU PROCEED AT ENTIRELY YOUR OWN RISK AND ACCEPT THAT STORING IN DROPBOX MIGHT DAMAGE YOUR DATA!",
                             theTitle="SUPPRESS DROPBOX WARNING",
                             lCancelButton=True,
                             OKButtonText="ACCEPT RISK",
                             lAlertLevel=3)

        if not ask.go():
            txt = "'SUPPRESS DROPBOX WARNING' - User chose to exit  - no changes made"
            setDisplayStatus(txt, "R")
            return

        if confirm_backup_confirm_disclaimer(toolbox_frame_, "SUPPRESS DROPBOX WARNING", "Suppress 'Your data is stored in a shared folder' (Dropbox) message?"):
            suppressFile = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "suppress_file_in_dropbox_restriction.txt")
            if not os.path.exists(suppressFile):
                try:
                    x=open(suppressFile, "w")
                    x.write("DISCLAIMER - YOU SUPPRESS THE 'Your file is stored in a shared folder' (Dropbox) WARNING AT YOUR OWN RISK\n"
                            "STORING YOUR MD DATASET IN DROPBOX CAN DAMAGE YOUR DATASET\n\n"
                            "(Warning courtesy of Toolbox)")

                    x.close()
                    myPrint("B","ADVANCED MODE: 'SUPPRESS DROPBOX WARNING': User requested to suppress the 'Your file is stored in a shared folder' (dropbox) warning....")
                    myPrint("B", "@@User accepted warnings and disclaimer about dataset damage and instructed Toolbox to create %s - EXECUTED" %(suppressFile))
                    play_the_money_sound()
                    txt = "'SUPPRESS DROPBOX WARNING' - Suppressed >> 'Your file is stored in a shared folder' (dropbox) warning. MONEYDANCE WILL NOW RESTART"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,"'SUPPRESS DROPBOX WARNING'",JOptionPane.ERROR_MESSAGE)
                    ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)
                    return
                except:
                    myPrint("B","'SUPPRESS DROPBOX WARNING' - Error creating %s" %(suppressFile))
                    dump_sys_error_to_md_console_and_errorlog()

            txt = "'SUPPRESS DROPBOX WARNING' - ERROR - either the file already exists, or I failed to create the file..(review console log)?"
            setDisplayStatus(txt, "R")

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def advanced_mode_save_trunk_file():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "ADVANCED: SAVE TRUNK FILE"

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME,"Execute Save Trunk File function?"):
            return

        myPrint("B","%s: Calling saveTrunkFile() now at user request...." %(_THIS_METHOD_NAME))
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..
        MD_REF.getCurrentAccount().getBook().saveTrunkFile()
        play_the_money_sound()

        txt = "%s: Save Trunk Executed!" %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME,JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def advanced_clone_dataset():
        """This feature clones the open dataset. It takes a backup, restores the backup, wipes sync, removes transactional data.
        It deletes txns, price history, attachments from the clone (rather than recreating a new structure. The next evolution
        of this function will allow recreation of balances and cutoff dates"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "ADVANCED: Clone Dataset".upper()
        PARAMETER_KEY = "toolbox_clone_dataset"


        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, ("-" * (len(_THIS_METHOD_NAME)+1)))

        # Refer:
        # com.moneydance.apps.md.view.gui.MoneydanceGUI.saveToBackup(SecondaryFrame) : void
        # com.moneydance.apps.md.view.gui.MoneydanceGUI.openBackup(Frame) : boolean

        currentBook = MD_REF.getCurrentAccountBook()     # type: AccountBook
        if currentBook is None:
            myPopupInformationBox(toolbox_frame_, "ERROR: AccountBook is missing?",theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

        MD_decimal = MD_REF.getPreferences().getDecimalChar()

        currentName = currentBook.getName().strip()

        fCurrentFilePath = MD_REF.getCurrentAccount().getBook().getRootFolder()
        currentFilePath = fCurrentFilePath.getCanonicalPath()

        # newName = AccountBook.stripNonFilenameSafeCharacters(currentName+"_CLONE_%s" %(System.currentTimeMillis()))
        newName = AccountBook.stripNonFilenameSafeCharacters(currentName+"_CLONE")

        lbl_cloneName = JLabel("Enter the name for the cloned dataset:")
        user_cloneName = JTextField(newName)

        user_zeroAcctOpeningBalances = JCheckBox("Zero all account opening balances?", True)
        user_zeroAcctOpeningBalances.setToolTipText("When enabled, will reset account initial/opening balances to zero")

        user_purgeAllTransactions = JCheckBox("Purge all transactions?", True)
        user_purgeAllTransactions.setToolTipText("When enabled, purges all transactions from the clone")

        user_purgeSnapHistory = JCheckBox("Purge all security price & currency rate history (keep current and most recent one)?", True)
        user_purgeSnapHistory.setToolTipText("When enabled, purges security price & currency rate history (leaving current price/rate and most recent price/rate)")

        filterPanel = JPanel(GridLayout(0, 1))
        filterPanel.add(lbl_cloneName)
        filterPanel.add(user_cloneName)
        filterPanel.add(JLabel(""))
        filterPanel.add(user_zeroAcctOpeningBalances)
        filterPanel.add(user_purgeAllTransactions)
        filterPanel.add(user_purgeSnapHistory)

        _options = ["Cancel", "CLONE"]

        while True:
            jsp_acd = MyJScrollPaneForJOptionPane(filterPanel,850, 175)

            userAction = JOptionPane.showOptionDialog(toolbox_frame_,
                                                      jsp_acd,
                                                      "%s: Select CLONE Options:" %(_THIS_METHOD_NAME.upper()),
                                                      JOptionPane.OK_CANCEL_OPTION,
                                                      JOptionPane.QUESTION_MESSAGE,
                                                      getMDIcon(None),
                                                      _options,
                                                      _options[0])

            if userAction < 1:
                txt = "%s: User did not select clone options - no changes made" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt)
                return

            # userRequestedNewName = myPopupAskForInput(toolbox_frame_,
            #                                           theTitle=_THIS_METHOD_NAME,
            #                                           theFieldLabel="CLONED DATASET NAME:",
            #                                           theFieldDescription="Enter a new name for the cloned dataset",
            #                                           defaultValue=newName)
            #
            # if userRequestedNewName is None or userRequestedNewName == "":
            #     txt = "No name entered for cloned dataset - no changes made"
            #     myPopupInformationBox(toolbox_frame_,txt)
            #     setDisplayStatus(txt, "R")
            #     return

            newName = AccountBook.stripNonFilenameSafeCharacters(user_cloneName.getText())
            newNamePath = os.path.join(os.path.dirname(currentFilePath),newName + Common.ACCOUNT_BOOK_EXTENSION)
            fNewNamePath = File(newNamePath)

            if newName is None or newName == "" or fNewNamePath.exists():
                myPopupInformationBox(toolbox_frame_, "ERROR: new cloned file name: '%s' invalid or already exists?" %(newName),theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                continue

            if not user_zeroAcctOpeningBalances.isSelected() and not user_purgeAllTransactions.isSelected() and not user_purgeSnapHistory.isSelected():
                myPopupInformationBox(toolbox_frame_, "ERROR: Nothing selected to remove whilst cloning (pointless!)?",theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                continue

            break

        if not doesUserAcceptDisclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Are you really sure you want to create a clone of current dataset?"):
            txt = "%s: User declined the disclaimer - no changes made...." %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        # lKeepBalances = True
        # keepTxnsAfterDate = None
        lZeroOpeningBalances = user_zeroAcctOpeningBalances.isSelected()
        lRemoveAllTxns = user_purgeAllTransactions.isSelected()
        lRemoveAllSnapHistory = user_purgeSnapHistory.isSelected()

        output += "CLONE PROCESSING OPTIONS:\n" \
                  "-------------------------\n"
        output += "Purge all transactions:                           %s\n" %(lRemoveAllTxns)
        output += "Zero all accounts' opening balances:              %s\n" %(lZeroOpeningBalances)
        output += "Purge all security price & currency rate history: %s\n" %(lRemoveAllSnapHistory)
        output += "\n"

        _msgPad = 100
        _msg = pad("Please wait:",_msgPad,padChar=".")
        diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False,OKButtonText="WAIT")
        diag.go()

        try:
            output += "Current dataset file path:    %s\n" %(fCurrentFilePath.getCanonicalPath())
            output += "New cloned dataset file path: %s\n" %(fNewNamePath.getCanonicalPath())

            tmpFile = File.createTempFile("toolbox_%s" %(System.currentTimeMillis()), ".moneydancearchive")
            tmpFile.deleteOnExit()

            MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..

            output += "Saving current dataset back to disk (trunk)\n"
            currentBook.saveTrunkFile()    # Save dataset too before backup


            class MyFilenameFilter(FilenameFilter):
                def accept(self, thedirname, thefilename):

                    keepDirs = ["attach"]
                    ignoreFiles = ["processed.dct"]
                    ignoreExtns = [".txn",".txn-tmp",".mdtxn", ".mdtxnarchive"]

                    for keepDir in keepDirs:
                        if thedirname.getPath().endswith(keepDir):
                            return True

                    for ignoreExt in ignoreExtns:
                        if thefilename.endswith(ignoreExt): return False

                    for ignoreFile in ignoreFiles:
                        if thefilename == ignoreFile: return False
                    return True

            _msg = pad("Please wait: Creating a temporary backup",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)
            try:
                zipOut = ZipOutputStream(BufferedOutputStream(FileOutputStream(tmpFile), 65536))   # type: ZipOutputStream
                IOUtils.zipRecursively(zipOut, currentBook.getRootFolder(), MyFilenameFilter())
                zipOut.close()
                output += "Current dataset backed up to: %s (stripping out txn and archive files)\n" %(tmpFile)
            except:
                myPopupInformationBox(toolbox_frame_, "ERROR: could not create temporary backup (review console)",theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
                output += dump_sys_error_to_md_console_and_errorlog(True)
                raise

            passphrase = MD_REF.getUI().getCurrentAccounts().getEncryptionKey()
            if passphrase and passphrase != "":
                output += "Your encryption passphrase: '%s' will be reused in the cloned dataset\n" %(passphrase)
            else:
                output += "No user encryption passphrase will be set in the clone\n"

            class MySecretKeyCallback(SecretKeyCallback):
                def __init__(self, passPhrase):
                    self.passPhrase = passPhrase

                def setVerifier(self, paramSecretKeyVerifier): pass

                def getPassphrase(self, hint):                                                                              # noqa
                    return self.passPhrase

                def getPassphrase(self, dataName, hint):                                                                    # noqa
                    return self.passPhrase

            passwordCallback = MySecretKeyCallback(passphrase)

            # try:
            class MyFilenameFilter(FilenameFilter):
                def accept(self, dirname, filename):                                                                    # noqa
                    if filename.endswith(Common.ACCOUNT_BOOK_EXTENSION):
                        return True
                    return False

            _msg = pad("Please wait: Restoring temporary backup to clone new dataset",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            tmpFolder = IOUtils.createTempFolder()
            output += "Created temporary folder (for restore): %s\n" %(tmpFolder)
            IOUtils.openZip(tmpFile, tmpFolder.getAbsolutePath())
            output += "Unzipped temporary backup into: %s\n" %(tmpFolder)
            zipContents = tmpFolder.list(MyFilenameFilter())
            if zipContents is None or len(zipContents) < 1: raise Exception("ERROR: Zip file seems incorrect")
            tmpMDFile = File(tmpFolder, zipContents[0])

            newBookFile = fNewNamePath
            if not tmpMDFile.renameTo(newBookFile):
                IOUtils.copyFolder(tmpMDFile, newBookFile)
                output += "Renamed restored dataset to: %s\n" %(newBookFile)

            newWrapper = AccountBookWrapper.wrapperForFolder(newBookFile)   # type: AccountBookWrapper
            if newWrapper is None: raise Exception("ERROR: 'AccountBookWrapper.wrapperForFolder' returned None")
            output += "Successfully obtained 'wrapper' for: %s\n" %(newBookFile)

            newWrapper.setUUIDResetFlag(True)

            _msg = pad("Please wait: Opening cloned dataset",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            try:
                if not newWrapper.loadLocalStorage(passwordCallback): raise Exception("ERROR: calling 'newWrapper.loadLocalStorage()'")
                output += "Successfully loaded Clone's local storage \n"

                if not newWrapper.loadDataModel(passwordCallback): raise Exception("ERROR: calling 'newWrapper.loadDataModel()'")
                output += "Successfully loaded Clone's data model \n"

                newBook = newWrapper.getBook()
                if newBook is None: raise Exception("ERROR: 'AccountBook' is None")
                output += "Successfully obtained Clone's AccountBook reference\n"

                newBookSyncer = newBook.getSyncer()
                if newBookSyncer is None: raise Exception("ERROR: cloned dataset's 'Syncer' is None")
                output += "Clone's 'Syncer' is running (%s)\n" %(newBookSyncer)

            except MDException as mde:
                if mde.getCode() == 1004:
                    MD_REF.getUI().showErrorMessage("ERROR: The dataset's password is incorrect!?  Failed to open clone?")
                    raise
                else:
                    dump_sys_error_to_md_console_and_errorlog()
                    raise

            cloneTime = System.currentTimeMillis()
            newRoot = newBook.getRootAccount()

            newRoot.setParameter(PARAMETER_KEY, safeStr(cloneTime))
            newRoot.setComment("This dataset was cloned by the Toolbox extension on: %s (%s)"
                               %(convertStrippedIntDateFormattedText(DateUtil.getStrippedDateInt()), cloneTime))
            if newRoot.getAccountName().strip() != newBook.getName():
                output += "Updating new root's account name to: '%s'\n" %(newBook.getName())
                newRoot.setAccountName(newBook.getName())
            newBook.logModifiedItem(newRoot)

            if not AccountBookUtil.isWithinInternalStorage(newBook):
                AccountBookUtil.registerExternalAccountBook(newBook)
                output += "Registered cloned dataset with the File/Open menu list\n"

            _msg = pad("Please wait: Resetting Sync in cloned dataset..",_msgPad,padChar=".")
            diag.updateMessages(newTitle=_msg, newStatus=_msg)

            SYNC_KEYS = getNetSyncKeys()

            newStorage = newBook.getLocalStorage()
            for skey in SYNC_KEYS: newStorage.remove(skey)                                                              # noqa
            newStorage.put("netsync.dropbox.fileid", UUID.randomUUID())
            newStorage.put("_is_master_node", True)
            newStorage.put(PARAMETER_KEY, safeStr(cloneTime))
            newStorage.save()
            if newRoot is not None:
                newRoot.setEditingMode()
                for skey in SYNC_KEYS: newRoot.removeParameter(skey)
                newBook.logModifiedItem(newRoot)

            output += "Clone's Sync settings have been reset and the internal UUID set to: '%s'\n" %(newStorage.getStr("netsync.dropbox.fileid","<ERROR>"))

            # MD_REF.setCurrentBook(newWrapper)

            output += "Imported and created clone book: %s\n" %(newBookFile.getCanonicalPath())
            # newBook.notifyAccountModified(newBook.getRootAccount())
            MD_REF.getUI().updateOpenFilesMenus()
            output += "Updated 'open files' menu...\n"

            if lZeroOpeningBalances:
                _msg = pad("Please wait: Zeroing account opening/initial balances..",_msgPad,padChar=".")
                diag.updateMessages(newTitle=_msg, newStatus=_msg)

                allAccounts = AccountUtil.allMatchesForSearch(newBook, AcctFilter.ALL_ACCOUNTS_FILTER)
                for acct in allAccounts:
                    currentInitialBal = acct.getStartBalance()
                    if currentInitialBal != 0:
                        rCurr = acct.getCurrencyType()
                        output += "Setting account's initial / opening balance to zero (was: %s): %s\n"\
                                  %(rCurr.formatFancy(currentInitialBal, MD_decimal), acct)
                        acct.setStartBalance(0)
                        newBook.logModifiedItem(acct)
                        # acct.syncItem()

            # noinspection PyArgumentList
            class MyCloneTxnSearchFilter(TxnSearch):

                # def __init__(self,dateStart,dateEnd):
                #     self.dateStart = dateStart
                #     self.dateEnd = dateEnd

                def matchesAll(self):                                                                                           # noqa
                    return False

                def matches(self, _txn):
                    if not isinstance(_txn, ParentTxn): return False
                    return True
                    #
                    # if txn.getDateInt() >= self.dateStart and txn.getDateInt() <= self.dateEnd:                                 # noqa
                    #     return True
                    # return False


            if lRemoveAllTxns:
                newBook.setRecalcBalances(False)

                _msg = pad("Please wait: Deleting txns/attachments (as necessary)..",_msgPad,padChar=".")
                diag.updateMessages(newTitle=_msg, newStatus=_msg)

                startTimeMs = System.currentTimeMillis()
                attachmentsToDelete = []
                ts = newBook.getTransactionSet().getTransactions(MyCloneTxnSearchFilter())
                output += "Removing all (%s) transactions from clone...\n" %(ts.getSize())
                for txn in ts:
                    if not isinstance(txn, ParentTxn):
                        myPrint("B",txn.getSyncInfo().toMultilineHumanReadableString())
                        raise Exception("ERROR: Should not delete splits!")
                    if txn.hasAttachments():
                        for attachKey in txn.getAttachmentKeys():
                            attachTag = txn.getAttachmentTag(attachKey)
                            attachmentsToDelete.append(attachTag)
                tsList = ArrayList()
                ts.copyInto(tsList)
                if not newBook.logRemovedItems(tsList): raise Exception("ERROR: newBook.logRemovedItems(tsList) returned false?")

                if len(attachmentsToDelete):
                    output += "Deleting %s attachments from clone...\n" %(len(attachmentsToDelete))
                    for attachment in attachmentsToDelete:
                        fAttachFile = File(attachment)
                        if fAttachFile.exists():
                            fAttachFile.delete()

                    if removeEmptyDirs(os.path.join(newBook.getRootFolder().getCanonicalPath(), "safe")):
                        output += "Successfully removed empty attachment folders...\n"
                    else:
                        output += "Error whilst removing empty attachment folders... (ignoring and continuing)\n"

                output += "Mass delete of %s txns and %s attachments took: %s seconds\n" %(ts.getSize(), len(attachmentsToDelete), (System.currentTimeMillis() - startTimeMs) / 1000.0)

            if lRemoveAllSnapHistory:
                startTimeMs = System.currentTimeMillis()

                _msg = pad("Please wait: Purging security price / currency rate history..",_msgPad,padChar=".")
                diag.updateMessages(newTitle=_msg, newStatus=_msg)

                keepSnaps = []

                allCurrencies = newBook.getCurrencies().getAllCurrencies()
                allSnaps = newBook.getItemsWithType(CurrencySnapshot.SYNCABLE_TYPE_VALUE)

                iCountSecurities = iCountCurrencies = 0

                for curSec in allCurrencies:
                    if curSec.getCurrencyType() == CurrencyType.Type.SECURITY: iCountSecurities += 1                    # noqa
                    if curSec.getCurrencyType() == CurrencyType.Type.CURRENCY: iCountCurrencies += 1                    # noqa
                    secSnapshots = curSec.getSnapshots()
                    if len(secSnapshots) > 0: keepSnaps.append(secSnapshots[-1])

                output += "Currency rate / Security price history ('csnaps') before purge: %s (%s currencies, %s securities)\n"\
                          %(allSnaps.size(), iCountCurrencies, iCountSecurities)

                for snap in keepSnaps: allSnaps.remove(snap)

                output += "Price history - keeping: %s 'csnaps', deleting: %s 'csnaps'\n" %(len(keepSnaps), allSnaps.size())

                if not newBook.logRemovedItems(allSnaps): raise Exception("ERROR: newBook.logRemovedItems(allSnaps) returned false?")

                output += "Mass delete of %s currency rate / security price history 'csnaps' took: %s seconds\n"\
                          %(allSnaps.size(), (System.currentTimeMillis() - startTimeMs) / 1000.0)

            newBook.setRecalcBalances(True)

            if not newBook.save(): raise Exception("ERROR: cloned AccountBook .save() returned false")

            # myPrint("B", "Syncer: %s, isSyncing: %s, isRunningInBackground: %s" %(newBookSyncer, newBookSyncer.isSyncing(), newBookSyncer.isRunningInBackground()))
            newBookSyncer.stopSyncing()
            output += "Cloned dataset's 'Syncer' has been shut down (flushing remaining in-memory changes)\n"

            # register attachment for deletion etc
            # delete all txn files afterwards

            # newBook.saveTrunkFile()
            newBookSyncer.saveNewTrunkFile(True)
            output += "Cloned dataset has been re-saved to disk (as a new trunk file)\n"

            # Copied from com.infinitekind.tiksync.Syncer
            OUTGOING_PATH = "tiksync/out"
            INCOMING_PATH = "tiksync/in"
            TXN_FILE_EXTENSION = ".txn"
            TXN_FILE_EXTENSION_TMP = ".txn-tmp"
            OUTGOING_TXN_FILE_EXTENSION = ".mdtxn"
            PROCESSED_FILES = "tiksync/processed.dct"
            newStorage.delete(PROCESSED_FILES)
            for mdDir in [OUTGOING_PATH, INCOMING_PATH]:
                for filename in newStorage.listFiles(mdDir):
                    if (filename.endswith(TXN_FILE_EXTENSION_TMP)
                            or filename.endswith(OUTGOING_TXN_FILE_EXTENSION)
                            or filename.endswith(TXN_FILE_EXTENSION)):
                        newStorage.delete(mdDir+"/"+filename)
            output += "Deleted clone's 'processed.dct' and all .txn type files.....\n"

            output += "\n\n" \
                      "-------------------------------------------------------------------------------------------------\n"
            output += "Original dataset's object analysis:\n"
            output += count_database_objects()
            fileSize, fileCount = calculateMoneydanceDatasetSize(True)
            output += "...dataset size: %sMB (%s files)\n" %(rpad(fileSize,12),fileCount)
            output += "\n"

            output += "Analysis of objects in cloned dataset:\n"
            output += count_database_objects(newBook)
            fileSize, fileCount = calculateMoneydanceDatasetSize(True, whichBook=newBook)
            output += "...dataset size: %sMB (%s files)\n" %(rpad(fileSize,12),fileCount)
            output += "-------------------------------------------------------------------------------------------------\n"
            output += "\n"

        except:
            txt = "Clone function has failed. Review log and console (CLONE INCOMPLETE)"
            output += "%s\n" %(txt)
            output += dump_sys_error_to_md_console_and_errorlog(True)
            jif = QuickJFrame(title=_THIS_METHOD_NAME, output=output, lAlertLevel=2, copyToClipboard=True, lWrapText=False).show_the_frame()
            myPopupInformationBox(jif,theMessage=txt, theTitle="ERROR",theMessageType=JOptionPane.ERROR_MESSAGE)
            return
        finally:
            diag.kill()

        output += "\n\nCLONE %s SUCCESSFULLY CREATED - USE MENU>FILE>OPEN\n\n" %(newBook.getName())
        output += "<END>"
        jif = QuickJFrame(title=_THIS_METHOD_NAME,output=output,copyToClipboard=True,lWrapText=False).show_the_frame()
        myPopupInformationBox(jif,"Clone dataset: %s created (review output)" %(newBook.getName()))

    def advanced_mode_sync_push_pull(_push_pull):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()" )

        _THIS_METHOD_NAME = "ADVANCED: FORCE SYNC PUSH/PULL"

        PUSH_RESYNC = "tiksync/force_push_resync"                                                                       # noqa
        PULL_RESYNC = "tiksync/force_pull_resync"                                                                       # noqa

        lSyncPush = lSyncPull = False
        if _push_pull.upper() == "PUSH": lSyncPush = True
        if _push_pull.upper() == "PULL": lSyncPull = True
        if not lSyncPush and not lSyncPull: raise Exception("%s: Invalid parameter supplied" %(_THIS_METHOD_NAME))

        if lSyncPull: raise Exception("%s: Sorry - PULL function is disabled" %(_THIS_METHOD_NAME))

        if lSyncPull: _THIS_METHOD_NAME = "ADVANCED: FORCE SYNC PULL"
        if lSyncPush: _THIS_METHOD_NAME = "ADVANCED: FORCE SYNC PUSH"

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()                                                      # noqa

        if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = "%s: Sorry - can only push from a Primary Sync Dataset...(Toolbox can promote to Primary if required)" %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)

        syncFolder = None                                                                                               # noqa
        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
        except:
            syncFolder = False                                                                                          # noqa
            dump_sys_error_to_md_console_and_errorlog()
            txt = "Sorry - cannot proceed as error getting Sync status (review console for details)"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        if syncFolder is None:
            txt = "%s: Cannot proceed as you don't appear to be using Sync" %(_THIS_METHOD_NAME)
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        txt = None
        if lSyncPull:
            txt = "THIS WILL FORCE SYNC TO PULL REMOTE DATASET, OVERWRITING YOUR LOCAL COPY"
            myPopupInformationBox(toolbox_frame_, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            txt = "%s: Execute Sync Force Pull (of remote Sync Data, overwrite local data)?" %(_THIS_METHOD_NAME)
        if lSyncPush:
            txt = "THIS WILL FORCE SYNC TO PUSH LOCAL DATASET, OVERWRITING REMOTE COPIES"
            myPopupInformationBox(toolbox_frame_, txt, theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            txt = "%s: Execute Sync Force Push (of local Sync Data to remotes)?" %(_THIS_METHOD_NAME)

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME,txt): return

        myPrint("B", "User accepted disclaimer - now executing: %s" %(txt))
        MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record..

        if lSyncPush:
            MD_REF.getCurrentAccount().getBook().getSyncer().forceResyncFromLocal()
            myPrint("B", "@@ Called .getSyncer().forceResyncFromLocal() to Force Push (Re)Sync to remotes...")
            # storage.writeToFileAtomically(PyByteArray(), PUSH_RESYNC)
            # myPrint("B", "@@ Created: %s" %(PUSH_RESYNC))

        if lSyncPull:
            MD_REF.getUI().getCurrentAccounts().setNeedsResetFromSyncFolder()
            myPrint("B", "@@ Called .getCurrentAccounts().setNeedsResetFromSyncFolder() to Force Pull (Re)Sync from remotes...")

            # MD_REF.getCurrentAccount().getBook().getSyncer().resetSyncingAndWaitForRemoteData()
            # myPrint("B", "@@ Called .getSyncer().resetSyncingAndWaitForRemoteData() to Force Pull (Re)Sync from remotes...")

            # storage.writeToFileAtomically(PyByteArray(), PULL_RESYNC)
            # myPrint("B", "@@ Created: %s" %(PULL_RESYNC))

        MD_REF.saveCurrentAccount()
        play_the_money_sound()

        txt = "%s: Force Sync Push/Pull requested." %(_THIS_METHOD_NAME)
        setDisplayStatus(txt, "R")

        ConsoleWindow.showConsoleWindow(MD_REF.getUI())
        MyPopUpDialogBox(toolbox_frame_,
                         "%s" %(txt),
                         "Check the Help>Console Window...\n"
                         "Wait (up to) a few minutes and look for the following entries in the console log....:\n"
                         "...'Toolbox.... @@ Called .getSyncer().forceResyncFromLocal() to Force Push (Re)Sync to remotes...'\n"
                         "...'uploading new trunk file v3/trunk-nnnnnnnnnnnn.mdtxn to syncFolder'\n"
                         "...'deleting stale sync log file: v3/nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.mdtxn'\n"
                         "(the above line may repeat several times)...\n"
                         "... and then 'checking for txn logs...'....\n"
                         "When it's finished, hopefully with no errors, then RESTART MD. <GOOD LUCK!>",
                         theTitle=_THIS_METHOD_NAME,
                         lModal=True,OKButtonText="ACKNOWLEDGE").go()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def advanced_mode_set_check_days():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        key = "moneydance.checknum_series_threshold"
        props_lookback_days = System.getProperty(key, "180")

        ask = MyPopUpDialogBox(toolbox_frame_,"Next Check Number Algorithm look-back Threshold:",
                               'System.getProperty("%s") currently set to: %s\n'%(key,props_lookback_days),
                               theTitle="NEXT CHEQUE NUMBER ALGORITHM",
                               lCancelButton=True,OKButtonText="CHANGE")
        if not ask.go():
            txt = "ADVANCED MODE: NO CHANGES MADE TO NEXT CHECK NUMBER LOOK-BACK THRESHOLD"
            setDisplayStatus(txt, "B")
            return

        lDidIChangeDays=False

        while True:
            days_response = myPopupAskForInput(toolbox_frame_,"CHANGE NEXT CHECK NUMBER LOOK-BACK THRESHOLD","Days:",
                                               "Enter new number of days (1 to 365):",props_lookback_days)

            if days_response is None:
                days_response = 0
                break
            elif days_response == props_lookback_days:
                break
            elif not StringUtils.isInteger(days_response):
                continue
            elif int(days_response)>0 and int(days_response)<365:                                                       # noqa
                lDidIChangeDays = True
                break

        if lDidIChangeDays:
            System.setProperty(key,str(days_response))
            myPrint("B","ADVANCED MODE: System Property '%s' set to %s" %(key,days_response))
        else:
            txt = "ADVANCED MODE: NO CHANGES MADE TO NEXT CHECK NUMBER LOOK-BACK THRESHOLD"
            setDisplayStatus(txt, "B")
            return

        txt = "ADVANCED MODE: Next Check Number Algorithm look-back Threshold set to %s (days)" %(days_response)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt,"NEXT CHEQUE NUMBER ALGORITHM",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def advanced_mode_edit_parameter_keys():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        if not myPopupAskQuestion(toolbox_frame_,"ADVANCED: EDIT OBJ'S MODE","DANGER - ARE YOU SURE YOU WANT TO VISIT THIS FUNCTION?",
                                  theMessageType=JOptionPane.ERROR_MESSAGE):
            txt = "ADVANCED Edit Obj Mode - User declined to proceed - aborting.."
            setDisplayStatus(txt, "R")
            return

        objSelecter = CuriousViewInternalSettingsButtonAction(lOFX=False, EDIT_MODE=True)
        theObject = objSelecter.actionPerformed("")  # type: list
        del objSelecter

        if theObject is None or len(theObject)!=1:
            # txt = "ADVANCED Edit Obj Mode - No Object selected/found - aborting.."
            # setDisplayStatus(txt, "R")
            return

        theObject = theObject[0]            # type: MoneydanceSyncableItem

        _ADVANCED_KEYADD          = 0
        _ADVANCED_KEYCHG          = 1
        _ADVANCED_KEYDEL          = 2
        _ADVANCED_RECORDDELETE    = 3

        what = [
            "Object ADD    Parameter Key (and data)",
            "Object CHANGE Parameter Key's Data",
            "Object DELETE Parameter Key (and it's data)",
            "DELETE OBJECT - NOT RECOMMENDED!"
        ]

        while True:

            lAdd = lChg = lDel = lDeleteRecord = False

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the option for the modification (on %s)?" %(theObject),
                                                       "ADVANCED",
                                                       JOptionPane.WARNING_MESSAGE,
                                                       getMDIcon(None),
                                                       what,
                                                       None)

            if not selectedWhat:
                txt = "Thank you for using ADVANCED MODE!.. Exiting"
                setDisplayStatus(txt, "B")
                return

            if selectedWhat == what[_ADVANCED_KEYADD]:          lAdd = True
            if selectedWhat == what[_ADVANCED_KEYCHG]:          lChg = True
            if selectedWhat == what[_ADVANCED_KEYDEL]:          lDel = True
            if selectedWhat == what[_ADVANCED_RECORDDELETE]:    lDeleteRecord = True

            text = ""
            if lChg:            text = "ADD"
            if lChg:            text = "CHANGE"
            if lDel:            text = "DELETE"
            if lDeleteRecord:   text = "DELETE OBJECT"

            if lAdd:
                addKey = myPopupAskForInput(toolbox_frame_,
                                            "ADVANCED: ADD PARAMETER TO %s" % (theObject),
                                            "PARAMETER:",
                                            "Carefully enter the name of the Parameter you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                            "",
                                            False,
                                            JOptionPane.WARNING_MESSAGE)

                if not addKey or len(addKey.strip()) < 1: continue
                addKey = addKey.strip()

                if not check_if_key_string_valid(addKey):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter %s is NOT valid!" % addKey, "ADVANCED: ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED menu

                testKeyExists = theObject.getParameter(addKey,None)                                                     # noqa

                if testKeyExists:
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter %s already exists - cannot add - aborting..!" %(addKey), "ADVANCED: ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED menu

                addValue = myPopupAskForInput(toolbox_frame_,
                                              "ADVANCED: ADD PARAMETER VALUE TO %s" %(theObject),
                                              "VALUE:",
                                              "Carefully enter the value you want to add (STRINGS ONLY! CaSE MattERS):",
                                              "",
                                              False,
                                              JOptionPane.WARNING_MESSAGE)

                if not addValue or len(addValue.strip()) <1: continue
                addValue = addValue.strip()

                if not check_if_key_data_string_valid(addValue):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Parameter value %s is NOT valid!" %(addValue), "ADVANCED: ADD TO %s" %(theObject), JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED menu

                if confirm_backup_confirm_disclaimer(toolbox_frame_, "ADVANCED MODE","ADD PARAMETER VALUE TO %s" %(theObject)):

                    theObject.setParameter(addKey,addValue)                                                             # noqa
                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.syncItem()                                                                            # noqa
                    play_the_money_sound()
                    txt = "@@ ADVANCEDMODE: Parameter: %s Value: %s added to %s @@" %(addKey,addValue,theObject)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)
                    myPopupInformationBox(toolbox_frame_,
                                          "SUCCESS: Key %s added to %s!" % (addKey,theObject),
                                          "ADVANCED: ADD TO %s" %(theObject),
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                continue

            # DELETE OBJECT  :-<
            if lDeleteRecord:

                output =  "%s PLEASE REVIEW PARAMETER & VALUE BEFORE DELETING OBJECT\n" %(theObject)
                output += "---------------------------------------------------------\n\n"

                if isinstance(theObject, SplitTxn):
                    txt = theObject.getParentTxn().getSyncInfo().toMultilineHumanReadableString()
                else:
                    txt = theObject.getSyncInfo().toMultilineHumanReadableString()

                output += "\n%s\n" %(txt)

                output += "\n<END>"
                if isinstance(theObject, SplitTxn):
                    jif = QuickJFrame("REVIEW THE SPLIT TXN's DATA BEFORE DELETION (OF THE SPLIT)", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                elif isinstance(theObject, ParentTxn):
                    jif = QuickJFrame("REVIEW THE PARENT'S TXN DATA BEFORE DELETION (OF THE WHOLE PARENT TXN)", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()
                else:
                    jif = QuickJFrame("REVIEW THE OBJECT's DATA BEFORE DELETION", output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

                if confirm_backup_confirm_disclaimer(jif, "ADVANCED: DELETE OBJECT","DELETE OBJECT %s" %(theObject)):

                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        # This will delete the split only; thus we also must sync the parent
                        theObject.deleteItem()                                                                          # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.deleteItem()                                                                          # noqa

                    play_the_money_sound()
                    txt = "@@ ADVANCEDMODE: OBJECT %s DELETED @@" %(theObject)
                    setDisplayStatus(txt, "R")
                    myPrint("B",txt)

                    myPopupInformationBox(jif,
                                          "SUCCESS: OBJECT %s DELETED" %(theObject),
                                          "ADVANCED: DELETE OBJECT",
                                          JOptionPane.ERROR_MESSAGE)
                    return

                continue

            # OK, so we are changing or deleting
            if lChg or lDel:

                paramKeys = sorted(theObject.getParameterKeys())                                                        # noqa
                selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                          "Select the %s Parameter you want to %s" % (theObject,text),
                                                          "ADVANCED",
                                                          JOptionPane.WARNING_MESSAGE,
                                                          getMDIcon(None),
                                                          paramKeys,
                                                          None)
                if not selectedKey: continue

                value = theObject.getParameter(selectedKey, None)                                                       # noqa

                output =  "%s PLEASE REVIEW PARAMETER & VALUE BEFORE MAKING CHANGES\n" %(theObject)
                output += "------------------------------------------------\n\n"

                output += "\n@@ This '%s' key can be changed/deleted by this script @@\n" % selectedKey

                output += "\n%s %s\n" %(pad("%s PARAMETER:"%(theObject),25),selectedKey)
                output += "\n%s %s\n" %(pad("Type:",25), type(value))
                output += "\n%s %s\n" %(pad("Value:",25), value)

                output += "\n<END>"
                jif = QuickJFrame("REVIEW THE KEY BEFORE CHANGES to %s" %(theObject), output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

                chgValue = None

                if lChg:
                    chgValue = myPopupAskForInput(jif,
                                                  "ADVANCED: CHANGE PARAMETER VALUE IN %s" %(theObject),
                                                  "VALUE:",
                                                  "Carefully enter the new value (STRINGS ONLY! CaSE MattERS):",
                                                  value,
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                    chgValue = chgValue.strip()

                    if not check_if_key_data_string_valid(chgValue):
                        myPopupInformationBox(jif,"ERROR: value %s is NOT valid!" %chgValue,"ADVANCED: CHANGE IN %s" %(theObject),JOptionPane.ERROR_MESSAGE)
                        continue    # back to ADVANCED menu

                confAction = ""
                if lDel:
                    confAction = "%s key: %s (with old value: %s)" %(text,selectedKey,value)
                if lChg:
                    confAction = "%s key: %s to new value: %s" %(text,selectedKey,chgValue)

                if confirm_backup_confirm_disclaimer(jif, "ADVANCED: %s VALUE IN %s" %(text,theObject),confAction):

                    if lDel:
                        theObject.setParameter(selectedKey,None)                                                        # noqa

                    if lChg:
                        theObject.setParameter(selectedKey,chgValue)                                                    # noqa

                    if isinstance(theObject, SplitTxn):                                                                 # noqa
                        theObject.getParentTxn().syncItem()                                                             # noqa
                    else:
                        theObject.syncItem()                                                                            # noqa

                    MD_REF.savePreferences()            # Flush all in memory settings to config.dict file on disk
                    play_the_money_sound()

                    if lDel:
                        myPrint("B","@@ ADVANCEDMODE: Parameter: %s DELETED from %s (old value: %s) @@" %(selectedKey,theObject,value))
                        myPopupInformationBox(jif,
                                              "SUCCESS: Parameter: %s DELETED from %s (old value: %s)" %(selectedKey,theObject,value),
                                              "ADVANCED: DELETE IN %s" %theObject,
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        myPrint("B","@@ ADVANCEDMODE: Parameter: %s CHANGED to %s in %s @@" %(selectedKey,chgValue, theObject))
                        myPopupInformationBox(jif,
                                              "SUCCESS: Parameter: %s CHANGED to %s in %s" %(selectedKey,chgValue, theObject),
                                              "ADVANCED: CHANGE IN %s" %theObject,
                                              JOptionPane.WARNING_MESSAGE)
                    jif.dispose()       # already within the EDT
                    continue

                jif.dispose()       # already within the EDT
                continue

        # ENDWHILE

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def advanced_remove_int_external_files_settings():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        options = ["Remove 'External' entries from File>Open menu [and optionally DELETE dataset from disk too]",
                   "DELETE 'Internal' / Default location dataset(s) from Disk (which will also remove entry from File>Open)"]

        selectedOption = JOptionPane.showInputDialog(toolbox_frame_,
                                                     "Select the option you require",
                                                     "ADVANCED: DELETE INT/EXT DATASET",
                                                     JOptionPane.WARNING_MESSAGE,
                                                     getMDIcon(lAlwaysGetIcon=True),
                                                     options,
                                                     None)

        if not selectedOption or options.index(selectedOption) > 1:
            txt = "No option selected.. No changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        theText = ""
        lInternal = lExternal = False
        if options.index(selectedOption) == 0:
            lExternal = True
            theText = ( "This allows you to REMOVE references to Datasets stored in the non-default 'External' locations\n"
                        "This removes the entries from the MD File>Open Menu.\n"
                        "Missing dataset references will be auto-purged from the list before you start selection\n"
                        "You will be offered each Dataset name one-by-one\n"
                        "You will NOT be offered, or allowed, to delete the current open dataset\n"
                        "OPTIONALLY - You can choose to also DELETE these dataset(s) FROM DISK (after your confirmation)\n"
                        "There will not be any backup prompt - please do this yourself first!\n\n"
                        "THIS IS THE DISCLAIMER UP FRONT - CLICK I AGREE TO PROCEED" )

        elif options.index(selectedOption) == 1:
            lInternal = True
            theText = ( "This allows you to DELETE Datasets from the MD default 'Internal' location\n"
                        "You will be offered each Dataset name one-by-one\n"
                        "You will NOT be offered, or allowed, to delete the current open dataset\n"
                        "Each dataset you select will be DELETED FROM DISK (after your confirmation)\n"
                        "(This will therefore remove the entry from the MD File>Open Menu)\n"
                        "There will not be any backup prompt - please do this yourself first!\n\n"
                        "THIS IS THE DISCLAIMER UP FRONT - CLICK I AGREE TO PROCEED" )

        ask=MyPopUpDialogBox(toolbox_frame_,
                             "For Your Information",
                             theText,
                             theTitle="ADVANCED: REMOVE ENTRIES/DATASETS",
                             OKButtonText="I AGREE - PROCEED", lCancelButton=True,
                             lAlertLevel=2)
        if not ask.go():
            txt = "No agreement to proceed.. No changes made"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if lInternal:
            advancedRemoveInternalFilesSettings()

        elif lExternal:
            advancedRemoveExternalFilesSettings()

        MD_REF.getUI().updateOpenFilesMenus()

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def advanced_mode_edit_prefs():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        if MD_REF.getCurrentAccount().getBook() is None: return

        _ADVANCED_CONFIGADD          = 0
        _ADVANCED_CONFIGCHG          = 1
        _ADVANCED_CONFIGDEL          = 2
        _ADVANCED_LOCALSTORAGEADD    = 3
        _ADVANCED_LOCALSTORAGECHG    = 4
        _ADVANCED_LOCALSTORAGEDEL    = 5

        what = [
            "config.dict ADD setting",
            "config.dict CHANGE setting",
            "config.dict DELETE setting",
            "Local Storage Setting ADD setting",
            "Local Storage Setting CHANGE setting",
            "Local Storage Setting DELETE setting"
        ]

        while True:

            lAdd = lChg = lDel = False
            lConfigDict = lLocalStorage = False

            # noinspection PyUnusedLocal
            LS = st = tk = prefs = fileType = None

            selectedWhat = JOptionPane.showInputDialog(toolbox_frame_,
                                                       "Select the Key data / option to modify",
                                                       "ADVANCED",
                                                       JOptionPane.WARNING_MESSAGE,
                                                       getMDIcon(None),
                                                       what,
                                                       None)

            if not selectedWhat:
                txt = "Thank you for using ADVANCED MODE!.."
                setDisplayStatus(txt, "B")
                return

            if selectedWhat == what[_ADVANCED_CONFIGADD]: lAdd = True
            if selectedWhat == what[_ADVANCED_CONFIGCHG]: lChg = True
            if selectedWhat == what[_ADVANCED_CONFIGDEL]: lDel = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEADD]: lAdd = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGECHG]: lChg = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEDEL]: lDel = True

            if selectedWhat == what[_ADVANCED_CONFIGADD]: lConfigDict = True
            if selectedWhat == what[_ADVANCED_CONFIGCHG]: lConfigDict = True
            if selectedWhat == what[_ADVANCED_CONFIGDEL]: lConfigDict = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEADD]: lLocalStorage = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGECHG]: lLocalStorage = True
            if selectedWhat == what[_ADVANCED_LOCALSTORAGEDEL]: lLocalStorage = True

            LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()

            if lConfigDict:
                fileType = "config.dict"
                st,tk = read_preferences_file(lSaveFirst=True)  # Must flush memory to disk first before we read the file....
                prefs=sorted(tk)
            elif lLocalStorage:
                fileType = "LocalStorage() ./safe/settings"
                ls_keys = LS.keys()
                prefs=sorted(ls_keys)
            else:
                raise(Exception("ERROR - Unknown type!"))

            text = ""
            if lChg: text = "CHANGE"
            if lDel: text = "DELETE"

            if lAdd:
                addKey = myPopupAskForInput(toolbox_frame_,
                                            "ADVANCED: ADD KEY TO %s" % fileType,
                                            "KEY NAME:",
                                            "Carefully enter the name of the key you want to add (cAseMaTTers!) - STRINGS ONLY:",
                                            "",
                                            False,
                                            JOptionPane.WARNING_MESSAGE)

                if not addKey or len(addKey.strip()) < 1: continue
                addKey = addKey.strip()

                if not check_if_key_string_valid(addKey):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key %s is NOT valid!" % addKey, "ADVANCED: ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED menu

                testKeyExists = True
                if lConfigDict:     testKeyExists = MD_REF.getUI().getPreferences().getSetting(addKey,None)
                if lLocalStorage:   testKeyExists = LS.get(addKey)

                if testKeyExists:
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key %s already exists - cannot add - aborting..!" % addKey, "ADVANCED: ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to 'Advanced' menu

                addValue = myPopupAskForInput(toolbox_frame_,
                                              "ADVANCED: ADD KEY VALUE TO %s" % fileType,
                                              "KEY VALUE:",
                                              "Carefully enter the key value you want to add (STRINGS ONLY!):",
                                              "",
                                              False,
                                              JOptionPane.WARNING_MESSAGE)

                if not addValue or len(addValue.strip()) <1: continue
                addValue = addValue.strip()

                if not check_if_key_data_string_valid(addValue):
                    myPopupInformationBox(toolbox_frame_, "ERROR: Key value %s is NOT valid!" % addValue, "ADVANCED: ADD TO %s" % fileType, JOptionPane.ERROR_MESSAGE)
                    continue    # back to ADVANCED menu

                if doesUserAcceptDisclaimer(toolbox_frame_, "ADVANCED: ADD KEY VALUE TO %s" %(fileType), "Add key: '%s' with value: '%s'?" %(addKey,addValue)):
                    if lConfigDict:
                        MD_REF.getUI().getPreferences().setSetting(addKey,addValue)
                        MD_REF.savePreferences()                # Flush all in memory settings to config.dict file on disk
                    if lLocalStorage:
                        LS.put(addKey,addValue)
                        LS.save()    # Flush local storage to safe/settings

                    play_the_money_sound()
                    myPrint("B","@@ ADVANCEDMODE: key: %s value: %s added to %s @@" %(addKey,addValue,fileType))
                    myPopupInformationBox(toolbox_frame_,
                                          "SUCCESS: Key %s added to %s!" % (addKey,fileType),
                                          "ADVANCED: ADD TO %s" % fileType,
                                          JOptionPane.WARNING_MESSAGE)
                    continue

                myPopupInformationBox(toolbox_frame_, "NO CHANGES MADE!", "ADVANCED", JOptionPane.INFORMATION_MESSAGE)
                continue

            # OK, so we are changing or deleting
            if lChg or lDel:
                selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                          "Select the %s key/setting you want to %s" % (fileType,text),
                                                          "ADVANCED",
                                                          JOptionPane.WARNING_MESSAGE,
                                                          getMDIcon(None),
                                                          prefs,
                                                          None)
                if not selectedKey: continue

                lOK_to_Change = False
                value = None
                if lConfigDict:
                    # value = MD_REF.getUI().getPreferences().getSetting(selectedKey)
                    value = st.get(selectedKey)   # Have to use the backdoor to maintain the real instance type

                if lLocalStorage:
                    value = LS.get(selectedKey)
                    valueTest = LS.getString(selectedKey, "")

                    try:
                        # Is it a StreamTable?
                        valueTest_st = StreamTable()
                        valueTest_st.readFrom(valueTest)
                        value = valueTest_st
                    except:
                        # Is it a StreamVector?
                        valueTest_sv = StreamVector()
                        try:
                            valueTest_sv.readFrom(valueTest)
                            value = valueTest_sv
                        except:
                            pass

                output =  "%s PLEASE REVIEW KEY & VALUE BEFORE MAKING CHANGES\n" %fileType
                output += "%s------------------------------------------------\n\n" %("-"*len(fileType))

                if isinstance(value,(StreamTable,StreamVector)) and lChg:
                    output += "\n@@ Sorry: StreamTable & StreamVector keys cannot be changed by this script (only deleted) @@\n"
                elif not isinstance(value, (str, unicode)) and lChg:
                    output += "\n@@ Sorry: %s keys cannot be changed by this script (only deleted) @@\n" % type(value)
                else:
                    lOK_to_Change = True
                    output += "\n@@ This '%s' key can be changed/deleted by this script @@\n" % selectedKey

                output += "\n%s %s\n" %(pad("%s KEY:"%fileType,25),selectedKey)
                output += "\n%s %s\n" %(pad("Type:",25), type(value))

                if isinstance(value,(StreamTable,StreamVector)):
                    try:
                        output += "\n%s\n%s\n" %("Value:", value)
                    except IllegalArgumentException:
                        value = "<ERROR: Failed to show contents>"
                        output += "\n%s... (you can proceed anyway)\n" %(value)
                else:
                    output += "\n%s %s\n" %(pad("Value:",25), value)

                output += "\n<END>"
                jif = QuickJFrame("REVIEW THE KEY BEFORE CHANGES to %s" %fileType, output,copyToClipboard=lCopyAllToClipBoard_TB).show_the_frame()

                if lChg and not lOK_to_Change:
                    myPopupInformationBox(jif,
                                          "SORRY: I cannot change the key %s in %s" %(selectedKey,fileType),
                                          "ADVANCED: CHANGE KEY IN %s" %fileType,
                                          JOptionPane.ERROR_MESSAGE)
                    continue

                chgValue = None

                if lChg:
                    chgValue = myPopupAskForInput(jif,
                                                  "ADVANCED: CHANGE KEY VALUE IN %s" %(fileType),
                                                  "KEY VALUE:",
                                                  "Carefully enter the new key value (STRINGS ONLY!):",
                                                  value,
                                                  False,
                                                  JOptionPane.WARNING_MESSAGE)

                    if not chgValue or len(chgValue.strip()) <1 or chgValue == value: continue
                    chgValue = chgValue.strip()

                    if not check_if_key_data_string_valid(chgValue):
                        myPopupInformationBox(jif,"ERROR: Key value %s is NOT valid!" %chgValue,"ADVANCED: CHANGE IN %s" %fileType,JOptionPane.ERROR_MESSAGE)
                        continue    # back to ADVANCED menu

                agreed = False
                if lDel: agreed = doesUserAcceptDisclaimer(jif, "ADVANCED: %s KEY VALUE IN %s" %(text,fileType), "%s key: %s (with old value: %s)?" %(text,selectedKey,value))
                if lChg: agreed = doesUserAcceptDisclaimer(jif, "ADVANCED: %s KEY VALUE IN %s" %(text,fileType), "%s key: %s to new value: %s?" %(text,selectedKey,chgValue))
                if agreed:
                    if lConfigDict:
                        if lDel:
                            MD_REF.getUI().getPreferences().setSetting(selectedKey,None)
                        if lChg:
                            MD_REF.getUI().getPreferences().setSetting(selectedKey,chgValue)
                        MD_REF.savePreferences()            # Flush all in memory settings to config.dict file on disk
                    if lLocalStorage:
                        if lDel:
                            LS.put(selectedKey,None)
                        if lChg:
                            LS.put(selectedKey,chgValue)
                        LS.save()                               # Flush local storage to safe/settings

                    play_the_money_sound()

                    if lDel:
                        myPrint("B","@@ ADVANCEDMODE: key: %s DELETED from %s (old value: %s) @@" %(selectedKey,fileType,value))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s DELETED from %s (old value: %s)" %(selectedKey,fileType,value),
                                              "ADVANCED: DELETE IN %s" %fileType,
                                              JOptionPane.WARNING_MESSAGE)
                    if lChg:
                        myPrint("B","@@ ADVANCEDMODE: key: %s CHANGED to %s in %s @@" %(selectedKey,chgValue, fileType))
                        myPopupInformationBox(jif,
                                              "SUCCESS: key: %s CHANGED to %s in %s" %(selectedKey,chgValue, fileType),
                                              "ADVANCED: CHANGE IN %s" %fileType,
                                              JOptionPane.WARNING_MESSAGE)
                    continue

                myPopupInformationBox(jif,"NO CHANGES MADE!", "ADVANCED", JOptionPane.INFORMATION_MESSAGE)
                continue

        # ENDWHILE

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def getModifiedDatesFomZip(_storage, _archiveFile):
        """Interrogates a zip archive, then processes all entries, and determines the oldest and newest modified dates"""

        zip_in = ZipInputStream(_storage.openFileForReading(_archiveFile))  # type: ZipInputStream
        oldestMInt = newestMInt = 0
        try:
            while True:
                entry = zip_in.getNextEntry()       # type: ZipEntry
                if entry is None: break
                if not entry.isDirectory():
                    name = entry.getName()                                                                              # noqa
                    modifiedDate = entry.getTime()
                    if modifiedDate > 0:
                        modifiedDateInt = DateUtil.convertLongDateToInt(modifiedDate)
                        oldestMInt = (modifiedDateInt if oldestMInt < 1 else min(oldestMInt, modifiedDateInt))
                        newestMInt = (modifiedDateInt if newestMInt < 1 else max(newestMInt, modifiedDateInt))
                zip_in.closeEntry()
        except: pass

        finally:
            try: zip_in.closeEntry()
            except: pass

            try: zip_in.close()
            except: pass

        return (oldestMInt, newestMInt)

    def advanced_mode_shrink_dataset():
        """Attempts to reduce dataset size by 'purging' txn log files - relies on processed.dct as failsafe for dates"""

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        SIMULATE = False

        _THIS_METHOD_NAME = "ADVANCED: SHRINK DATASET SIZE"

        output = "%s:\n" \
                 "%s\n\n" %(_THIS_METHOD_NAME, " "*len(_THIS_METHOD_NAME))

        if SIMULATE: output += "*** SIMULATION MODE *** No changes really being made!!\n"*3; output += "\n"

        DAYS_TO_KEEP = 30

        SAVE_TRUNK = False

        # Copied from com.infinitekind.tiksync.Syncer
        OUTGOING_PATH = "tiksync/out"
        INCOMING_PATH = "tiksync/in"
        TXN_FILE_EXTENSION = ".txn"
        TXN_FILE_EXTENSION_TMP = ".txn-tmp"
        OUTGOING_TXN_FILE_EXTENSION = ".mdtxn"
        ARCHIVE_PATH = "archive"
        ARCHIVE_EXTENSION = ".mdtxnarchive"
        PROCESSED_FILES = "tiksync/processed.dct"
        UPLOADBUFFER = "tiksync/uploadbuf"

        if not perform_qer_quote_loader_check(toolbox_frame_, _THIS_METHOD_NAME): return

        MD_REF.saveCurrentAccount()

        safeFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe")

        fp = os.path.join(safeFullPath, PROCESSED_FILES)
        if not os.path.exists(fp):
            myPrint("B", "ERROR - cannot proceed as file does not exist: %s" %(os.path.join(safeFullPath, PROCESSED_FILES)))
            txt = "Sorry - cannot proceed as %s does not exist?! (review console for details)" %(PROCESSED_FILES)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        output += "Base 'safe' folder is: %s\n\n" %(safeFullPath)

        output += "Verified and found: %s\n" %(PROCESSED_FILES)

        storage = MD_REF.getCurrentAccountBook().getLocalStorage()

        # Grab processed files here - freeze at this point....
        lError = False
        processedIn = None
        processedTxnFiles = StreamTable()  # type: StreamTable
        try:
            if storage.exists(PROCESSED_FILES):
                processedIn = storage.openFileForReading(PROCESSED_FILES)
                output += "Read %s data into memory\n" %(PROCESSED_FILES)
            else:
                lError = True                                                                                           # noqa
                raise Exception("Error: %s does not appear to exist?" %(PROCESSED_FILES))
            if processedIn is not None: processedTxnFiles.readFrom(processedIn)
        except:
            lError = True
            dump_sys_error_to_md_console_and_errorlog()
        finally:
            if processedIn is not None:
                try:
                    processedIn.close()
                except IOException:
                    lError = True
                    dump_sys_error_to_md_console_and_errorlog()

        oldestP = newestP = 0
        for pFileName in processedTxnFiles:
            pDate = processedTxnFiles.getLong(pFileName, 0)
            if pDate > 0:
                oldestP = (pDate if oldestP < 1 else min(oldestP, pDate))
                newestP = (pDate if newestP < 1 else max(newestP, pDate))

        output += ("Loaded %s (contains: %s entries, size: %sMBs). Oldest: %s, Newest: %s\n"
                  %(PROCESSED_FILES, len(processedTxnFiles), convertBytesMBs(os.path.getsize(fp)),
                    convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(oldestP)),
                    convertStrippedIntDateFormattedText(DateUtil.convertLongDateToInt(newestP))))

        if lError or len(processedTxnFiles) < 1:
            if lError:
                txt = "Sorry - cannot proceed as error processing %s (review console for details)" %(PROCESSED_FILES)
            elif len(processedTxnFiles) < 1:
                txt = "Sorry - cannot proceed as %s contains no records?" %(PROCESSED_FILES)
            myPrint("B", txt)                                                                                           # noqa
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        syncFolder = None                                                                                               # noqa
        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
        except:
            syncFolder = False                                                                                          # noqa
            dump_sys_error_to_md_console_and_errorlog()
            txt = "Sorry - cannot proceed as error getting Sync status (review console for details)"
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        fileSize, fileCount = calculateMoneydanceDatasetSize(True)

        output += "\nDataset is currently %sMBs containing %s files\n" %(fileSize, fileCount)

        MyPopUpDialogBox(toolbox_frame_,
                         "%sThis function attempts to shrink your dataset size (currently %sMBs, %s files)." %(("SIMULATION MODE: " if SIMULATE else ""),fileSize, fileCount),
                         "It does NOT change your actual database of records (known as 'trunk')\n"
                         "MD keeps log files for every change you (have ever) made. Typically these are .txn and .mdtxn files\n"
                         "Whilst in theory they could be used to rebuild your database from an older start point, this has rarely been done [to my knowledge].\n"
                         "These files accumulate over time, and can be safely deleted. Toolbox can purge log files older than [%s] days (you set this value)\n"
                         "It validates against the log of known processed dates, and also peeks inside archived zip files that MD creates\n"
                         "NOTE: You will need to repeat this process on other Sync copies too...\n"
                         "PRIOR TO RUNNING THIS, IDEALLY RESTART MD, & ENSURE THAT QUOTE LOADER/Q&ER EXTNS, IMPORTS & BANK DOWNLOADS ARE **NOT** RUNNING\n"
                         "<GOOD LUCK>" %(DAYS_TO_KEEP),
                         theTitle=_THIS_METHOD_NAME,
                         lModal=True,OKButtonText="ACKNOWLEDGE").go()

        lPurgeOutDir = False
        if syncFolder is None:
            output += "\nSyncing appears disabled....\n"
            theMsg = MyPopUpDialogBox(toolbox_frame_,
                                        "It appears that you have Syncing disabled (is this correct?).",
                                        "If you really are NOT using Sync, I can purge the 'out' directory too?\n"
                                        "Only Click 'PURGE-OUT' if you are NOT using Sync on this dataset.\n"
                                        "(i.e. if you have temporarily disabled Sync, click Cancel)\n"
                                        "If you 'PURGE-OUT', you can (re)create a NEW Sync relationship later (if needed)....\n"
                                        "(clicking 'Cancel' means Do NOT purge 'out' directory...)",
                                        theTitle=_THIS_METHOD_NAME, lCancelButton=True, OKButtonText="PURGE-OUT")
            if theMsg.go():
                output += "User confirmed that Sync is not being used and to proceed with purge of '%s'..\n" %(OUTGOING_PATH)
                lPurgeOutDir = True
            else:
                output += "User requested NOT to purge '%s'..\n" %(OUTGOING_PATH)
        else:
            output += "\nSync is ENABLED and as such, '%s' will NOT be purged. (SyncDir: %s)\n" %(OUTGOING_PATH, syncFolder)

        while True:

            newDaysToKeep = myPopupAskForInput(toolbox_frame_,
                                            _THIS_METHOD_NAME,
                                            "Days to Keep:",
                                            "Enter the new Days to Keep setting (currently %s) - min 0" %(DAYS_TO_KEEP),
                                            defaultValue=str(DAYS_TO_KEEP))

            if newDaysToKeep is not None and not StringUtils.isInteger(newDaysToKeep):
                continue

            if newDaysToKeep is None or int(newDaysToKeep) < 0 or int(newDaysToKeep) > (365*5):
                txt = "%s: No valid days to keep entered.. - NO CHANGES MADE!" %(_THIS_METHOD_NAME)
                setDisplayStatus(txt, "B")
                myPopupInformationBox(toolbox_frame_, txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                return

            DAYS_TO_KEEP = int(newDaysToKeep)
            myPrint("DB", "Days to Keep set to %s" %(DAYS_TO_KEEP))
            break

        todayDateInt = DateUtil.getStrippedDateInt()
        lookBackDateInt = DateUtil.incrementDate(todayDateInt, 0, 0, -(DAYS_TO_KEEP))

        output += "\nDays to keep setting set as: %s. Today: %s. Purge up to Date: %s\n" %(DAYS_TO_KEEP,
                                                                                           convertStrippedIntDateFormattedText(todayDateInt),
                                                                                           convertStrippedIntDateFormattedText(lookBackDateInt))

        output += "\n\n" \
                  "LISTING POTENTIAL PURGE TARGET FILES\n" \
                  " ===================================\n"

        class StoreFileReference:

            def __init__(self, _safePath, _filename, _fullPath, _theDateInt=0, _oldestProcessedInt=0, _newestProcessedInt=0):
                self.safePath = _safePath
                self.filename = _filename
                self.fullPath = _fullPath
                self.theDateInt = _theDateInt
                self.oldestProcessedInt = _oldestProcessedInt
                self.newestProcessedInt = _newestProcessedInt
                self.fileSize = os.path.getsize(_fullPath)

        output += "\n%s targets...:\n" %(OUTGOING_PATH)
        # Scan 'out' files... (awaiting Sync)
        targetOutFilesForDeletion = []
        for filename in storage.listFiles(OUTGOING_PATH):
            fp = os.path.join(safeFullPath, OUTGOING_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if (filename.endswith(TXN_FILE_EXTENSION_TMP)) and is_file_older_than_x_days(fp, max(1, DAYS_TO_KEEP)):
                # These are normally 'broken' sync txn files..... get rid of them (but always keep today's just in case)....
                targetOutFilesForDeletion.append(StoreFileReference(OUTGOING_PATH, filename, fp))
                output += "%s\n" %(filename)
                continue

            if not lPurgeOutDir: continue

            if not filename.endswith(TXN_FILE_EXTENSION):   continue
            if not processedTxnFiles.containsKey(filename): continue                                                    # noqa

            txnFileTimestamp = processedTxnFiles.getLong(filename, 0)
            txnFileDate = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
            if txnFileDate != 0 and txnFileDate <= lookBackDateInt:
                # Confirmed that the processed file database has logged this file as processed into trunk!
                targetOutFilesForDeletion.append(StoreFileReference(OUTGOING_PATH, filename, fp, txnFileDate))

        if len(targetOutFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetOutFilesForDeletion = sorted(targetOutFilesForDeletion, key=lambda sort_x: (sort_x.theDateInt))
            for target in targetOutFilesForDeletion:
                output += "%s (processed: %s, modified: %s)\n" %(target.filename,
                                                                 convertStrippedIntDateFormattedText(target.theDateInt),
                                                                 getHumanReadableModifiedDateTimeFromFile(target.fullPath))

        output += "\n%s targets...:\n" %(UPLOADBUFFER)
        targetUploadBufferForDeletion = []
        fp = os.path.join(safeFullPath, UPLOADBUFFER)
        if (os.path.exists(fp) and is_file_older_than_x_days(fp, max(1, DAYS_TO_KEEP))):
            # Should be an 'old' file... delete it.....
            targetUploadBufferForDeletion.append(StoreFileReference(UPLOADBUFFER, UPLOADBUFFER, fp))
            output += "%s (modified: %s)\n" %(UPLOADBUFFER, getHumanReadableModifiedDateTimeFromFile(fp))
        del fp
        if len(targetUploadBufferForDeletion) < 1: output += "<NONE>\n"

        # Scan 'in' files (in theory all processed into Sync locally)
        output += "\n%s targets...:\n" %(INCOMING_PATH)
        targetInFilesForDeletion = []
        for filename in storage.listFiles(INCOMING_PATH):
            fp = os.path.join(safeFullPath, INCOMING_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if not filename.endswith(OUTGOING_TXN_FILE_EXTENSION):  continue
            if not processedTxnFiles.containsKey(filename):         continue                                            # noqa

            txnFileTimestamp = processedTxnFiles.getLong(filename, 0)
            txnFileDate = (0 if txnFileTimestamp == 0 else DateUtil.convertLongDateToInt(txnFileTimestamp))
            if txnFileDate != 0 and txnFileDate <= lookBackDateInt:
                # Confirmed that the processed file database has logged this file as processed into trunk!
                targetInFilesForDeletion.append(StoreFileReference(INCOMING_PATH, filename, fp, txnFileDate))
            del fp
        if len(targetInFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetInFilesForDeletion = sorted(targetInFilesForDeletion, key=lambda sort_x: (sort_x.theDateInt))
            for target in targetInFilesForDeletion:
                output += "%s (processed: %s, modified: %s)\n" %(target.filename,
                                                                 convertStrippedIntDateFormattedText(target.theDateInt),
                                                                 getHumanReadableModifiedDateTimeFromFile(target.fullPath))

        # Scan 'archive' files (these are zip files containing .mdtxn files)
        output += "\n%s targets...:\n" %(ARCHIVE_PATH)
        targetArchiveFilesForDeletion = []

        for filename in storage.listFiles(ARCHIVE_PATH):
            fp = os.path.join(safeFullPath, ARCHIVE_PATH, filename)
            if not os.path.exists(fp): raise Exception("Error: file does not exist: %s" %(fp))

            if not filename.endswith(ARCHIVE_EXTENSION): continue

            oldestModInt, newestModInt = getModifiedDatesFomZip(storage, ARCHIVE_PATH+"/"+filename)
            if oldestModInt < 1 or newestModInt < 1: continue

            if newestModInt <= lookBackDateInt:
                targetArchiveFilesForDeletion.append(StoreFileReference(ARCHIVE_PATH, filename, fp, _oldestProcessedInt=oldestModInt, _newestProcessedInt=newestModInt))
            del fp
        if len(targetArchiveFilesForDeletion) < 1:
            output += "<NONE>\n"
        else:
            targetArchiveFilesForDeletion = sorted(targetArchiveFilesForDeletion, key=lambda sort_x: (sort_x.newestProcessedInt))
            for target in targetArchiveFilesForDeletion:
                output += "%s ZIPFile (contains oldest: %s, newest: %s; ZIPfile modified: %s)\n"\
                          %(target.filename,
                            convertStrippedIntDateFormattedText(target.oldestProcessedInt),
                            convertStrippedIntDateFormattedText(target.newestProcessedInt),
                            getHumanReadableModifiedDateTimeFromFile(target.fullPath))


        sizeOutDelete = sizeInDelete = sizeUploadBufferDelete = sizeArchiveFilesDelete = 0.0
        for fn in targetOutFilesForDeletion:        sizeOutDelete           += fn.fileSize
        for fn in targetInFilesForDeletion:         sizeInDelete            += fn.fileSize
        for fn in targetUploadBufferForDeletion:    sizeUploadBufferDelete  += fn.fileSize
        for fn in targetArchiveFilesForDeletion:    sizeArchiveFilesDelete  += fn.fileSize

        totalSize = sizeOutDelete + sizeInDelete + sizeUploadBufferDelete + sizeArchiveFilesDelete
        totalFiles = len(targetOutFilesForDeletion) + len(targetInFilesForDeletion) + len(targetUploadBufferForDeletion) + len(targetArchiveFilesForDeletion)

        if totalFiles < 1:
            txt = "Sorry. No files to purge found!"
            myPrint("B", "%s: %s" %(_THIS_METHOD_NAME, txt))
            setDisplayStatus("%s: %s" %(_THIS_METHOD_NAME, txt), "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        txt1 = "OK, I can purge %s files and reduce dataset size by %sMBs" %(totalFiles, convertBytesMBs(totalSize))
        txt2 = ("Syncing is currently: %s\n"
                "Purge of 'out' directory is: %s\n"
                "Days to keep is set at: %s\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs\n"
                "%s: can purge %s files, %sMBs" % (
                    ("ENABLED" if syncFolder is not None else "DISABLED"), ("ENABLED" if lPurgeOutDir else "DISABLED"),
                    DAYS_TO_KEEP,
                    OUTGOING_PATH,  len(targetOutFilesForDeletion),         convertBytesMBs(sizeOutDelete),
                    INCOMING_PATH,  len(targetInFilesForDeletion),          convertBytesMBs(sizeInDelete),
                    ARCHIVE_PATH,   len(targetArchiveFilesForDeletion),     convertBytesMBs(sizeArchiveFilesDelete),
                    UPLOADBUFFER,   len(targetUploadBufferForDeletion),     convertBytesMBs(sizeUploadBufferDelete)))

        output += "\n" \
                  "%s\n" \
                  "%s\n\n" %(txt1, txt2)

        jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

        MyPopUpDialogBox(jif,
                         txt1,
                         txt2,
                         theTitle=_THIS_METHOD_NAME,
                         lModal=True,OKButtonText="ACKNOWLEDGE").go()


        if not confirm_backup_confirm_disclaimer(jif,
                                                 _THIS_METHOD_NAME,
                                                 "%sShrink Dataset by removing %s old change log files (older than %s days)?"
                                                 %(("SIMULATION MODE: " if SIMULATE else ""),totalFiles, DAYS_TO_KEEP)):
            return

        jif.dispose()
        output += "\nUSER CONFIRMED DISCLAIMER AND AGREED TO PROCEED WITH %s\n\n" %(_THIS_METHOD_NAME)

        # Should probably do something with com.moneydance.apps.md.controller.BackgroundOpsThread - but haven't worked that out yet

        output += "Flushing memory and saving Preferences to disk....\n"
        MD_REF.savePreferences()

        output += "Flushing memory and saving local storage settings to disk....\n"
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()

        output += "Flushing memory and saving in memory dataset changes to disk (log files)....\n"
        MD_REF.saveCurrentAccount()

        output += "Pausing the MD Syncing engine....\n"
        MD_REF.getCurrentAccountBook().pauseSyncing()

        if not SIMULATE and SAVE_TRUNK:  # Now that we check processed.dct, not strictly necessary....
            output += "Flushing dataset back to trunk file....\n"
            MD_REF.getCurrentAccount().getBook().saveTrunkFile()

        output += "\n" \
                  "DELETING LOG FILES...\n" \
                  " --------------------\n"

        for fn in targetOutFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))


        for fn in targetInFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        for fn in targetUploadBufferForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        for fn in targetArchiveFilesForDeletion:
            output += "Deleting...: %s/%s\n" %(fn.safePath,fn.filename)
            if os.path.exists(fn.fullPath):
                if not SIMULATE: os.remove(fn.fullPath)
                # if not SIMULATE: storage.delete(fn.safePath+"/"+fn.filename)
            else: raise Exception("Error: %s does not exist to delete?" %(fn.fullPath))

        output += ">> Finished removing files.....\n\n"

        output += "Resuming the MD Syncing engine....\n\n"
        MD_REF.getCurrentAccountBook().resumeSyncing()

        newFileSize, newFileCount = calculateMoneydanceDatasetSize(True)
        output += "Dataset was %sMBs containing %s files\n" %(fileSize, fileCount)
        output += "Dataset now %sMBs containing %s files\n" %(newFileSize, newFileCount)
        output += "...reduced (%sMBs)          (%s files)\n" %(fileSize-newFileSize, fileCount-newFileCount)

        if SIMULATE:
            output += "\n\n" \
                      "SIMULATION OVER - NO CHANGES MADE...\n".upper()
        else:
            output += "\n\n" \
                      "I recommend you perform another backup and restart MD...\n".upper()

        output += "\n<END>"

        jif = QuickJFrame(_THIS_METHOD_NAME, output, lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB, lJumpToEnd=True, lWrapText=False).show_the_frame()

        if SIMULATE:
            txt = "SIMULATION - Dataset (not really) reduced by %sMBs (%s files) - review log for details" %(fileSize-newFileSize, fileCount-newFileCount)
        else:
            txt = "SUCCESS - Dataset reduced by %sMBs (%s files) - review log for details" %(fileSize-newFileSize, fileCount-newFileCount)

        setDisplayStatus("%s: %s" %(_THIS_METHOD_NAME, txt), "R")
        myPrint("B","%s: %s" %(_THIS_METHOD_NAME, txt))
        myPopupInformationBox(jif,txt,theTitle=_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def advanced_mode_encrypt_file():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: IMPORT/ENCRYPT INTO LOCAL STORAGE"

        myPopupInformationBox(toolbox_frame_, "Select a non-encrypted file. It will be encrypted and saved to TMP directory of current dataset (details in console log)")

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()
        # startingFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath())

        theTitle = "Select file to import (encrypt) and save in the LocalStorage TMP directory"
        selectedFile = getFileFromFileChooser(toolbox_frame_,     # Parent frame or None
                                              get_home_dir(),     # Starting path
                                              None,               # Default Filename
                                              theTitle,           # Title
                                              False,              # Multi-file selection mode
                                              True,               # True for Open/Load, False for Save
                                              True,               # True = Files, else Dirs
                                              None,               # Load/Save button text, None for defaults
                                              "txt",              # File filter (non Mac only). Example: "txt" or "qif"
                                              lAllowTraversePackages=True,
                                              lForceJFC=False,
                                              lForceFD=True,
                                              lAllowNewFolderButton=True,
                                              lAllowOptionsButton=True)

        if selectedFile is None or selectedFile == "":
            txt = "%s: No file selected to import/encrypt/save..!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not os.path.exists(selectedFile) or not os.path.isfile(selectedFile):
            txt = "%s: Sorry, file selected to import / encrypt either does not exist or is not a file" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        try:
            copyFileName = File(selectedFile).getName()
            tmpFile = "tmp" + os.path.sep + str(System.currentTimeMillis() % 10000L) +  "-" + copyFileName
            fis = FileInputStream(File(selectedFile))
            LS.writeFile(tmpFile, fis)
            fis.close()
            helper = MD_REF.getPlatformHelper()
            helper.openDirectory(File(os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe","tmp")))
        except:
            txt = "%s: SORRY - Failed to import (encrypt) file %s (view console error log)" %(_THIS_METHOD_NAME, selectedFile)
            myPrint("B", txt)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B","%s: User requested to import (encrypt) file: %s into LocalStorage() TMP dir... SUCCESS!" %(_THIS_METHOD_NAME, selectedFile))

        txt = "%s: File %s encrypted and saved in TMP dir" %(_THIS_METHOD_NAME, selectedFile)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,txt, theMessageType=JOptionPane.INFORMATION_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def file_chooser_wrapper(_methodTitle, _startingFolder, _dialogTitle, _proceedButtonText):
        # With the latest MacOSx, FileDialog causes some problems when as accessing 'system' locations.
        # ...it presents the last used non-system location - useless for this - we want this specific directory....!
        # JFileChooser has a non native LaF on Mac, but worked... But then VAQua broke it....
        # MacOS: ~/Library/Containers/com.infinitekind.MoneydanceOSX/Data/Documents is a system-location
        # User will have to manually navigate... Oh well!
        # Update.... as of 2022/07/04 - Now using AppleScript to open this location! ;->

        selectedFile = getFileFromAppleScriptFileChooser(toolbox_frame_,                    # Parent frame or None
                                                         _startingFolder,                   # Starting path
                                                         None,                              # Default Filename
                                                         _dialogTitle,                      # Title
                                                         False,                             # Multi-file selection mode
                                                         True,                              # True for Open/Load, False for Save
                                                         True,                              # True = Files, else Dirs
                                                         _proceedButtonText,                # Load/Save button text, None for defaults
                                                         None,                              # File filter (non Mac only). Example: "txt" or "qif"
                                                         lAllowTraversePackages=True,
                                                         lAllowTraverseApplications=True,
                                                         lForceJFC=False,
                                                         lForceFD=False,
                                                         lAllowNewFolderButton=False,
                                                         lAllowOptionsButton=False)

        if selectedFile is None or selectedFile == "":
            txt = "%s: User chose to cancel or no file selected." %(_methodTitle)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _methodTitle, theMessageType=JOptionPane.WARNING_MESSAGE)
            return None

        if not os.path.exists(selectedFile) or not os.path.isfile(selectedFile):
            txt = "%s: Sorry, file selected to extract either does not exist or is not a file?" %(_methodTitle)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _methodTitle, theMessageType=JOptionPane.WARNING_MESSAGE)
            return None

        return selectedFile

    def advanced_mode_decrypt_file():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: EXTRACT/DECRYPT FROM LOCAL STORAGE"

        myPopupInformationBox(toolbox_frame_,"Select an internal MD encrypted file from within the 'safe'. "
                                             "I will decrypt and save it to TMP directory in this current dataset (details in console log)")

        LS = MD_REF.getCurrentAccountBook().getLocalStorage()
        internalSafeFullPath = os.path.join(MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath(), "safe")

        selectedFile = file_chooser_wrapper(_THIS_METHOD_NAME, internalSafeFullPath, "Select Moneydance internal file to extract and copy to TMP directory", "EXTRACT")
        if selectedFile is None: return

        searchForSafe = selectedFile.lower().find(".moneydance"+os.path.sep+"safe"+os.path.sep)
        if searchForSafe <= 0:
            txt = "%s: file selected to extract must be within the MD Dataset 'safe'" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        truncatedPath = selectedFile[searchForSafe+len(".moneydance"+os.path.sep+"safe"+os.path.sep):]

        tmpDir = File(MD_REF.getCurrentAccount().getBook().getRootFolder(), "tmp")
        tmpDir.mkdirs()
        copyFileName = File(selectedFile).getName()
        tmpFile = File.createTempFile(str(System.currentTimeMillis() % 10000L), "-"+copyFileName, tmpDir)
        tmpFile.deleteOnExit()
        fout = FileOutputStream(tmpFile)

        lCaughtError = False

        try:
            LS.readFile(truncatedPath, fout)

        except IOException as ioe:
            cause = ioe.getCause()
            if cause is not None and cause.getClass().getName().endswith("BadPaddingException"):                        # noqa
                myPrint("B","Caught: BadPaddingException. Class: %s, %s" %(cause.getClass(), cause.getClass().getName()))
                lCaughtError = True
            else:
                raise

        except:
            dump_sys_error_to_md_console_and_errorlog()
            txt = "SORRY - Failed to extract file %s (view console error log)" %(selectedFile)
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        finally:
            if fout is not None:
                fout.close()

        if lCaughtError:
            txt = "@@ WARNING: txn file '%s' may have been corrupted. Skipping the remainder, it may be best to delete it >> ERROR(BadPaddingException)!" %(selectedFile)
            myPrint("B",txt)
            txt = "ERROR: BadPaddingException - Most of file decrypted & copied to TMP dir (CONSIDER DELETING FILE!):'%s'" %(selectedFile)
            txtColor = "R"
            msgType = JOptionPane.ERROR_MESSAGE
        else:
            myPrint("B","User requested to extract file: %s from LocalStorage()/safe and copy to TMP dir... SUCCESS!" %(selectedFile))
            txt = "ADVANCED MODE: File decrypted and copied to TMP dir: '%s'" %(selectedFile)
            txtColor = "B"
            msgType = JOptionPane.INFORMATION_MESSAGE

        setDisplayStatus(txt,txtColor)
        myPopupInformationBox(toolbox_frame_, txt, theMessageType=msgType)

        MD_REF.getPlatformHelper().openDirectory(tmpDir)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def advanced_mode_decrypt_dataset():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: EXTRACT/DECRYPT ENTIRE DATASET"

        if not doesUserAcceptDisclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Extract/decrypt entire dataset?"):
            txt = "%s: User declined to continue - aborted" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt,"B")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        _theTitle = "Select location to store Extracted/Decrypted dataset... (CANCEL=ABORT)"
        theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                            get_home_dir(),         # Starting path
                                            None,                   # Default Filename
                                            _theTitle,              # Title
                                            False,                  # Multi-file selection mode
                                            True,                   # True for Open/Load, False for Save
                                            False,                  # True = Files, else Dirs
                                            "DECRYPT DATASET",      # Load/Save button text, None for defaults
                                            None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                            lAllowTraversePackages=False,
                                            lForceJFC=False,
                                            lForceFD=False,
                                            lAllowNewFolderButton=True,
                                            lAllowOptionsButton=True)

        if theDir is None or theDir == "":
            txt = "%s: User did not select extraction/decryption folder... Aborting" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "B")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        if not os.path.exists(theDir):
            txt = "ERROR - the extraction/decryption folder does not exist?"
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        decryptionFolder = File(theDir, "decrypted")
        if decryptionFolder.exists():
            txt = "%s: Sorry, decrypted sub folder must NOT pre-exist - select another location..... Aborting" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, JOptionPane.WARNING_MESSAGE)
            return

        myPrint("B", "Calling save routines before decryption...")
        MD_REF.saveCurrentAccount()
        MD_REF.getCurrentAccountBook().getLocalStorage().save()

        if myPopupAskQuestion(toolbox_frame_, theQuestion="Flush memory to disk(trunk) before starting extraction/decryption?", theTitle=_THIS_METHOD_NAME):
            myPrint("B", "Saving Trunk before extraction/decryption...")
            MD_REF.getCurrentAccountBook().saveTrunkFile()

        decryptionFolder.mkdirs()

        _msgPad = 100
        _msg = pad("Please wait: DECRYPTING", _msgPad, padChar=".")
        diag = MyPopUpDialogBox(toolbox_frame_, theStatus=_msg, theTitle=_msg, lModal=False,OKButtonText="WAIT")
        diag.go()

        myPrint("B","DECRYPTING ENTIRE DATASET to: '%s'" %(decryptionFolder.getCanonicalPath()))

        wrapper = MD_REF.getUI().getCurrentAccounts()

        invokeMethodByReflection(wrapper, "copyFolderToDecryptedStore", [String, File], ["", decryptionFolder])

        myPrint("B","FINISHED DECRYPTING ENTIRE DATASET to: '%s'" %(decryptionFolder.getCanonicalPath()))
        diag.kill()

        txt = "ENTIRE DATASET EXTRACTED/DECRYPTED TO %s" %(decryptionFolder.getCanonicalPath())
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_, txt)

        MD_REF.getPlatformHelper().openDirectory(decryptionFolder)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

    def advanced_mode_decrypt_file_from_sync():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: EXTRACT/PEEK AT SYNC FILE"

        lFailTest = False
        KEY_TEST_FILE = "key_test"
        FOLDER_VER = "v3"

        passphrase = encryptedTestBytes = syncFolder = None
        try:
            passphrase = MD_REF.getUI().getCurrentAccounts().getSyncEncryptionPassword()
            syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()

            encryptedTestBytes = IOUtils.readFully(syncFolder.readUnencrypted(KEY_TEST_FILE))
            if encryptedTestBytes is None or len(encryptedTestBytes) <= 0:
                myPrint("DB", "ERROR - The read of unencrypted data from Sync's 'key_test' returned None or zero bytes...")
                lFailTest = True
        except:
            dump_sys_error_to_md_console_and_errorlog()
            myPrint("DB", "ERROR - Failed to get your Sync Folder and read unencrypted data from 'key_test'...")
            lFailTest = True

        def canPasswordDecryptSyncData(_passphrase, the_encryptedTestBytes):
            if (the_encryptedTestBytes is None or len(the_encryptedTestBytes) <= 0): return False
            try:
                decryptedBytes = MDSyncCipher.decryptBytes(the_encryptedTestBytes, _passphrase)
                keyTestInfo = SyncRecord()
                if (not keyTestInfo.readSet(ByteArrayInputStream(decryptedBytes))): return False
                # Record starts with 12-digit random truncated UUID...
                if keyTestInfo.getString("test", "monkeys") == "Hello, how are you?":
                    myPrint("DB", "Success - I managed to decrypt your 'key_test' file from Sync Folders using your stored encryption passphrase..")
                    return True

            except BadPaddingException:
                myPrint("DB", "ERROR - BadPaddingException: I could NOT decrypt your 'key_test' file from Sync Folders using your stored encryption passphrase..!")
                return False

            myPrint("DB", "ERROR - I could NOT decrypt your 'key_test' file from Sync Folders using your stored encryption passphrase..!")
            return False

        if lFailTest or not canPasswordDecryptSyncData(passphrase, encryptedTestBytes):
            txt = "Sorry, I cannot find/test/decrypt your Sync 'key_file' (No Sync Folder, Bad Passphrase)? - Aborting!"
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return
        del passphrase

        syncFolderOnDisk = get_sync_folder()
        if not syncFolderOnDisk:
            txt = "Sorry, I cannot find your Sync folder? - Aborting!"
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        syncFolderOnDisk = os.path.join(syncFolderOnDisk, syncFolder.getSubpath())
        myPrint("DB", "Sync folder is:", syncFolderOnDisk)

        subs = syncFolder.listSubfolders(None)
        if FOLDER_VER not in subs:
            txt = "Sorry, I cannot find your '%s' Sync sub-folder? - Aborting!" %(FOLDER_VER)
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.ERROR_MESSAGE)
            return

        myPopupInformationBox(toolbox_frame_, "Select a file from your Sync folder. I will decrypt it and show you the lines on screen... ")

        selectedFile = file_chooser_wrapper(_THIS_METHOD_NAME, syncFolderOnDisk, "Select Moneydance Sync encrypted file to extract / peek..", "EXTRACT/PEEK")
        if selectedFile is None: return

        if not selectedFile.startswith(syncFolderOnDisk):
            txt = "Sorry, Sync file selected to extract must be within your Sync folders'"
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        truncatedPath = selectedFile[len(syncFolderOnDisk):]
        myPrint("DB", truncatedPath)

        if "/attach/" in truncatedPath:
            txt = "Sorry, I cannot show you attachments at this time..."
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        fail = False
        readLines = None
        try:
            readLines = IOUtils.readlines(syncFolder.readFile(truncatedPath))
        except:
            fail = True
            myPrint("DB","Failed to read/decrypt.. Will try unencrypted")

        try:
            if fail:
                readLines = IOUtils.readlines(syncFolder.readUnencrypted(truncatedPath))
                fail = False
        except:
            fail = True
            myPrint("DB","Failed to read/unencrypted..")

        if fail:
            txt = "Sorry, I failed to read your file... Exiting..."
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if readLines is None or len(readLines) < 1:
            txt = "Sorry, your Sync file appears to be empty..? Exiting..."
            setDisplayStatus(txt,"R")
            myPopupInformationBox(toolbox_frame_,txt,_THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        len_lines = sum(len(line) for line in readLines)
        buildString = "\n".join(readLines)

        jif = QuickJFrame(_THIS_METHOD_NAME+"(%s lines, %s chars)" %(len(readLines),len_lines), buildString,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()
        del buildString

        txt = "ADVANCED MODE: File %s decrypted and shown to user" %(selectedFile)
        setDisplayStatus(txt,"B")
        myPopupInformationBox(jif, txt)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def advanced_mode_DEBUG(lForceON=False):
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        key = "moneydance.debug"
        md_debug = MD_REF.DEBUG
        props_debug = System.getProperty(key, None)

        toggleText = "ON"

        if not lForceON:
            if md_debug or (props_debug is not None and props_debug!="false"):
                toggleText = "OFF"

            ask = MyPopUpDialogBox(toolbox_frame_,"DEBUG STATUS:",
                                   "main.DEBUG                             currently set to: %s\n"
                                   'System.getProperty("%s") currently set to: %s\n'
                                   'OFXConnection.DEBUG_MESSAGES           currently set to: %s\n'
                                   'MoneybotURLStreamHandlerFactory.DEBUG  currently set to: %s\n'
                                   'OnlineTxnMerger.DEBUG                  currently set to: %s\n'
                                   'Syncer.DEBUG                           currently set to: %s\n'
                                   %(md_debug,key,props_debug,OFXConnection.DEBUG_MESSAGES,MoneybotURLStreamHandlerFactory.DEBUG,OnlineTxnMerger.DEBUG,Syncer.DEBUG),
                                   theTitle="TOGGLE MONEYDANCE INTERNAL DEBUG",
                                   lCancelButton=True,OKButtonText="SET ALL to %s" %toggleText)
            if not ask.go():
                txt = "ADVANCED MODE: NO CHANGES MADE TO DEBUG!"
                setDisplayStatus(txt,"B")
                return

            myPrint("B","ADVANCED MODE: User requested to change all internal DEBUG modes to %s - setting these now...!" %(toggleText))

        if toggleText == "OFF":
            MD_REF.DEBUG = False
            System.clearProperty(key)
            OFXConnection.DEBUG_MESSAGES = False
            MoneybotURLStreamHandlerFactory.DEBUG = False
            OnlineTxnMerger.DEBUG = False
            Syncer.DEBUG = False
        else:
            MD_REF.DEBUG = True
            System.setProperty(key, "true")
            OFXConnection.DEBUG_MESSAGES = True
            MoneybotURLStreamHandlerFactory.DEBUG = True
            OnlineTxnMerger.DEBUG = True
            Syncer.DEBUG = True

        if lForceON:
            myPrint("DB","Moneydance Debug turned ON (same as launching Console window)......")
            return

        txt = "All Moneydance internal debug settings turned %s" %(toggleText)
        setDisplayStatus(txt,"B")
        myPopupInformationBox(toolbox_frame_,"All Moneydance internal debug settings turned %s" %toggleText,"TOGGLE MONEYDANCE INTERNAL DEBUG",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        return

    def advanced_mode_other_DEBUG():
        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        debugKeys = ["com.moneydance.apps.md.view.gui.txnreg.DownloadedTxnsView.DEBUG",
                     "com.moneydance.apps.md.view.gui.OnlineUpdateTxnsWindow.DEBUG"]

        selectedKey = JOptionPane.showInputDialog(toolbox_frame_,
                                                  "Select the DEBUG Setting you want to view/toggle",
                                                  "ADVANCED: OTHER DEBUG",
                                                  JOptionPane.INFORMATION_MESSAGE,
                                                  getMDIcon(lAlwaysGetIcon=True),
                                                  debugKeys,
                                                  None)

        if not selectedKey or debugKeys.index(selectedKey) > 1:
            txt = "No Debug key was selected to view/toggle.."
            setDisplayStatus(txt, "R")
            return

        currentSetting = False
        if debugKeys.index(selectedKey) == 0:
            currentSetting = DownloadedTxnsView.DEBUG
        elif debugKeys.index(selectedKey) == 1:
            currentSetting = OnlineUpdateTxnsWindow.DEBUG

        ask = MyPopUpDialogBox(toolbox_frame_,"OTHER DEBUG STATUS:",
                               "%s currently set to: %s" %(selectedKey, currentSetting),
                               theTitle="TOGGLE THIS MONEYDANCE INTERNAL OTHER DEBUG",
                               lCancelButton=True,OKButtonText="SET to %s" %(not currentSetting))
        if not ask.go():
            txt = "ADVANCED MODE: NO CHANGES MADE TO OTHER DEBUG!"
            setDisplayStatus(txt, "B")
            return

        myPrint("B","ADVANCED MODE: User requested to change DEBUG %s to %s - setting now...!" %(selectedKey,not currentSetting))

        if debugKeys.index(selectedKey) == 0:
            DownloadedTxnsView.DEBUG = not currentSetting
        elif debugKeys.index(selectedKey) == 1:
            OnlineUpdateTxnsWindow.DEBUG = not currentSetting

        txt = "Moneydance internal debug settings %s turned %s" %(selectedKey, not currentSetting)
        setDisplayStatus(txt, "B")
        myPopupInformationBox(toolbox_frame_,"Moneydance internal debug settings %s turned %s" %(selectedKey, not currentSetting),"TOGGLE MONEYDANCE INTERNAL OTHER DEBUG",JOptionPane.WARNING_MESSAGE)

        myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
        return

    def advanced_mode_demote_primary_to_secondary():
        # the reverse of convert_secondary_to_primary_data_set

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: MAKE this PRIMARY a SECONDARY NODE"

        if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
            txt = "Your dataset is already Secondary - no changes made.."
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "DEMOTE this Primary into a Secondary Dataset?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(False)
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()        # Flush local storage to safe/settings

        play_the_money_sound()
        txt = "%s: Dataset DEMOTED to Secondary (non-Primary/Master) Node - MONEYDANCE WILL NOW RESTART" %(_THIS_METHOD_NAME)
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def advanced_mode_force_sync_off():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: FORCE DISABLE/TURN SYNC OFF"

        _PARAM_KEY = "netsync.sync_type"
        _NONE = "none"

        storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

        if storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE:
            txt = "Your Sync is already disabled/turned off! NO ACTION TAKEN"
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Force Disable/Turn OFF Sync?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        storage.put(_PARAM_KEY, _NONE)
        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()        # Flush local storage to safe/settings

        play_the_money_sound()
        txt = "Sync ('%s')has been force disabled/turned OFF - MONEYDANCE WILL NOW RESTART" %(_PARAM_KEY)
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def getNetSyncKeys():
        _SYNC_KEYS = ["netsync.dropbox.fileid",
                      "netsync.sync_type",
                      "netsync.subpath",
                      "netsync.dropbox_enabled",
                      "netsync.synckey",
                      "ext.netsync.settings",
                      "netsync.guid",
                      "netsync.fs.sync_path",
                      "netsync.db.access_token_key",
                      "netsync.db.access_token_secret",
                      "netsync.db.v2token",
                      "netsync.download_attachments",
                      "migrated.netsync.dropbox.fileid",
                      "migrated.ext.netsync.settings",
                      "migrated.netsync.dropbox_enabled",
                      "migrated.netsync.guid",
                      "migrated.netsync.synckey"
                      ]
        return _SYNC_KEYS

    def advanced_mode_force_reset_sync_settings():
        # Resets all Sync settings, generates a new Sync ID, Turns Sync Off. You can turn it back on later....

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: FORCE RESET SYNC SETTINGS"

        storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Force reset all Sync settings, generate new SyncID & disable Sync?"):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        SYNC_KEYS = getNetSyncKeys()

        for skey in SYNC_KEYS: storage.remove(skey)

        # Copied from: com.moneydance.apps.md.controller.AccountBookWrapper.resetSyncInfoIfNecessary()
        storage.put("netsync.dropbox.fileid", UUID.randomUUID())

        # NOTE: as of 2022.3(4063) - this is also performed: .setIsMasterSyncNode(True)
        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(True)
        storage.save()

        root = MD_REF.getCurrentAccountBook().getRootAccount()
        if root is not None:
            root.setEditingMode()
            for skey in SYNC_KEYS: root.removeParameter(skey)
            root.syncItem()

        play_the_money_sound()
        txt = "ALL SYNC SETTINGS HAVE BEEN RESET - MONEYDANCE WILL NOW RESTART"
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def toggle_sync_download_attachments():

        myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

        _THIS_METHOD_NAME = "ADVANCED: TOGGLE SYNC DOWNLOAD ATTACHMENTS"

        shouldDownloadAllAttachments = getShouldDownloadAllAttachments()

        storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

        if not confirm_backup_confirm_disclaimer(toolbox_frame_, _THIS_METHOD_NAME, "Toggle Sync Download Attachments setting to: %s"
                                                                                    %("OFF" if shouldDownloadAllAttachments else "ON")):
            return

        if not backup_local_storage_settings():
            txt = "%s: ERROR making backup of LocalStorage() ./safe/settings - no changes made!" %(_THIS_METHOD_NAME)
            setDisplayStatus(txt, "R")
            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
            return

        storage.put("netsync.download_attachments", not shouldDownloadAllAttachments)
        storage.save()

        play_the_money_sound()
        txt = "Sync download attachments setting now: %s - MONEYDANCE WILL NOW RESTART" %("ON" if getShouldDownloadAllAttachments() else "OFF")
        myPrint("B", txt); setDisplayStatus(txt, "R")
        myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

    def checkForREADONLY():

        checkDropbox = tell_me_if_dropbox_folder_exists()
        datasetPath = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()

        if not os.access(datasetPath, os.W_OK) or (checkDropbox and not os.access(checkDropbox, os.W_OK)):
            myPrint("B", "@@@ ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! @@@")
            myPrint("B", "\n>> %s - Writable: %s\n"
                         ">> %s - Writable: %s\n"
                    %(checkDropbox, os.access(checkDropbox, os.W_OK), datasetPath, os.access(datasetPath, os.W_OK)))

            play_the_money_sound()
            MyPopUpDialogBox(toolbox_frame_,
                                   "ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! - YOU NEED TO EXIT MD AND FIX MANUALLY",
                                   "%s - Writable: %s\n"
                                   "%s - Writable: %s"
                                   %(checkDropbox, os.access(checkDropbox, os.W_OK), datasetPath, os.access(datasetPath, os.W_OK)),
                                   theTitle="FOLDER PROBLEM",
                                   OKButtonText="OK - I WILL EXIT",
                                   lAlertLevel=2).go()

            txt = "ERROR: YOUR KEY FOLDERS ARE NOT WRITABLE! - YOU NEED TO EXIT MD AND FIX MANUALLY"
            setDisplayStatus(txt, "R")

        return

# END OF GLOBAL CLASSES and DEFs

    # ##################################################################################################################
    # ##################################################################################################################
    # ##### MAIN DISPLAY CLASS                                                                      ####################
    # ##################################################################################################################
    # ##################################################################################################################

    def findEnvironmentPassphrases():
        theList = []
        if int(MD_REF.getBuild()) < 3088:     # MD2021.2(3088) added this capability
            return theList
        for k, v in os.environ.items():
            if k.startswith("md_passphrase"):
                theList.append([k,v])
        return theList

    def setSyncingLabel():
        try:
            syncMethods = SyncFolderUtil.getAvailableFolderConfigurers(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts())
            noSyncOption = SyncFolderUtil.configurerForIDFromList(u"none", syncMethods)
            syncMethod = SyncFolderUtil.getConfigurerForFile(MD_REF.getUI(), MD_REF.getUI().getCurrentAccounts(), syncMethods)
            if syncMethod is None or syncMethod == noSyncOption:
                GlobalVars.mainPnl_syncing_lbl.setText("<Syncing not configured>")
                GlobalVars.mainPnl_syncing_lbl.setForeground(MD_REF.getUI().colors.defaultTextForeground)
            else:
                GlobalVars.mainPnl_syncing_lbl.setText("<Syncing configured: %s>" %(syncMethod))
                GlobalVars.mainPnl_syncing_lbl.setForeground(getColorDarkGreen())
        except:
            GlobalVars.mainPnl_syncing_lbl.setText("<ERROR GETTING SYNC STATUS>")
            GlobalVars.mainPnl_syncing_lbl.setForeground(getColorRed())

    def setMemoryLabel():
        try:
            # https://stackoverflow.com/questions/3571203/what-are-runtime-getruntime-totalmemory-and-freememory
            runTime = Runtime.getRuntime()

            maxMemory = runTime.maxMemory()
            freeMemory = runTime.freeMemory()
            totalMemory = runTime.totalMemory()
            usedMemory = totalMemory - freeMemory
            memoryUsedPecentage = (usedMemory / float(maxMemory))

            maxMemoryTxt = "no limit" if (Long(maxMemory) == Long.MAX_VALUE) else "{:,} GB".format(convertBytesGBs(maxMemory))
            memoryAllocatedTxt = "{:,} GB".format(convertBytesGBs(totalMemory))
            memoryUsedTxt = "{:,} GB".format(convertBytesGBs(usedMemory))
            memoryFreeTxt = "{:,} GB".format(convertBytesGBs(freeMemory))
            memoryUsedPercentage = "{:.0%}".format(memoryUsedPecentage)
            vmoptionsTxt = "('-Xmx' .vmoption) " if (not Platform.isOSX()) else ""

            memoryText = ("<JVM Memory: Maximum %spossible: %s; Allocated to JVM: %s; Used: %s(%s of max); Free: %s>"
                          %(vmoptionsTxt, maxMemoryTxt, memoryAllocatedTxt, memoryUsedTxt, memoryUsedPercentage, memoryFreeTxt))

            color = MD_REF.getUI().colors.defaultTextForeground
            if  memoryUsedPecentage > 0.75: color = getColorRed()
            GlobalVars.mainPnl_memory_lbl.setText(memoryText)
            GlobalVars.mainPnl_memory_lbl.setForeground(color)
        except:
            GlobalVars.mainPnl_memory_lbl.setText("<MEMORY STATS ERROR>")
            GlobalVars.mainPnl_memory_lbl.setForeground(getColorRed())

    class DiagnosticDisplay(PreferencesListener):

        def __init__(self):
            self.myScrollPane = None
            self.theFrame = None
            self.moduleID = myModuleID

        def preferencesUpdated(self):
            myPrint("DB", "In %s.%s()" %(self, inspect.currentframe().f_code.co_name))

            myPrint("B","Your MD Preferences have been updated... I am closing Toolbox... Please relaunch if you want to use it...")
            SwingUtilities.invokeLater(GenericWindowClosingRunnable(self.theFrame))
            myPrint("DB","Back from calling GenericWindowClosingRunnable to push a WINDOW_CLOSING Event (via the Swing EDT) to %s...." %(self.moduleID))

        class WindowListener(WindowAdapter):

            def __init__(self, theFrame, callingClass):
                self.theFrame = theFrame        # type: MyJFrame
                self.callingClass = callingClass

            def windowActivated(self, windowEvent):
                myPrint("D","In ", inspect.currentframe().f_code.co_name, "()", windowEvent)
                setSyncingLabel()
                setSyncingLabel()
                setMemoryLabel()

            # def windowDeactivated(self, windowEvent): pass                                                              # noqa
            # def windowDeiconified(self, windowEvent): pass                                                              # noqa
            # def windowGainedFocus(self, windowEvent): pass                                                              # noqa
            # def windowLostFocus(self, windowEvent): pass                                                                # noqa
            # def windowIconified(self, windowEvent): pass                                                                # noqa
            # def windowOpened(self, windowEvent): pass                                                                   # noqa
            # def windowStateChanged(self, windowEvent): pass                                                             # noqa

            def windowClosing(self, windowEvent):
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()", windowEvent)
                myPrint("DB", "DiagnosticDisplay() Frame shutting down....")
                terminate_script()

            def windowClosed(self, windowEvent):
                myPrint("DB","In ", inspect.currentframe().f_code.co_name, "()", windowEvent)
                myPrint("DB", "... SwingUtilities.isEventDispatchThread() returns: %s" %(SwingUtilities.isEventDispatchThread()))

                self.theFrame.isActiveInMoneydance = False

                myPrint("DB","applistener is %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))

                if self.theFrame.MoneydanceAppListener is not None:
                    try:
                        MD_REF.removeAppEventListener(self.theFrame.MoneydanceAppListener)
                        myPrint("DB","\n@@@ Removed my MD App Listener... %s\n" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
                        self.theFrame.MoneydanceAppListener = None
                    except:
                        myPrint("B","FAILED to remove my MD App Listener... %s" %(classPrinter("MoneydanceAppListener", self.theFrame.MoneydanceAppListener)))
                        dump_sys_error_to_md_console_and_errorlog()

                if self.theFrame.HomePageViewObj is not None:
                    self.theFrame.HomePageViewObj.unload()
                    myPrint("DB","@@ Called HomePageView.unload() and Removed reference to HomePageView %s from MyJFrame()...@@\n" %(classPrinter("HomePageView", self.theFrame.HomePageViewObj)))
                    self.theFrame.HomePageViewObj = None

                myPrint("DB", "Removing Preferences listener:", self.callingClass)
                MD_REF.getPreferences().removeListener(self.callingClass)

                cleanup_actions(self.theFrame)

        class CloseAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In CloseAction().", inspect.currentframe().f_code.co_name, "()")
                myPrint("DB", "DiagnosticDisplay() Frame shutting down....")

                myPrint("DB",".. calling terminate_script()")
                terminate_script()

        class UnlockAction(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame
                self.saveTitle = theFrame.getTitle()

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In UnlockAction().", inspect.currentframe().f_code.co_name, "()")

                if GlobalVars.TOOLBOX_UNLOCK:
                    txt = "@@@ Toolbox is already Unlocked... RELOCKING Toolbox! @@@"
                    sColor = "B"
                    GlobalVars.TOOLBOX_UNLOCK = False
                    self.theFrame.setTitle(self.saveTitle)
                else:
                    v = int(float(MD_REF.getVersion())); b = int(float(MD_REF.getBuild())); c = v+b
                    response = myPopupAskForInput(self.theFrame,"@@ UNLOCK TOOLBOX @@", "PASSWORD:", "Enter the password to unlock powerful features",
                                          defaultValue=None,isPassword=True,theMessageType=JOptionPane.ERROR_MESSAGE)
                    lCorrect = False

                    if response is not None:
                        if StringUtils.isInteger(response) and int(response) == c:
                            lCorrect = True
                        if StringUtils.looksLikeFormula(response):
                            if int(StringUtils.parseFormula(response, MD_REF.getPreferences().getDecimalChar())) == c:
                                lCorrect = True

                    if lCorrect:
                        txt = "@@@ Toolbox UNLOCKED @@@"
                        sColor = "R"
                        GlobalVars.TOOLBOX_UNLOCK = True
                        self.theFrame.setTitle(u"Toolbox UNLOCKED (%s+I for Help) - DATASET: %s" % (MD_REF.getUI().ACCELERATOR_MASK_STR, MD_REF.getCurrentAccountBook().getName().strip()))
                    else:
                        txt = "@@@ Toolbox NOT Unlocked @@@"
                        sColor = "B"

                GlobalVars.mainPnl_toolboxUnlocked_lbl.setText("<TOOLBOX UNLOCKED>" if isToolboxUnlocked() else "")
                setDisplayStatus(txt, sColor); myPrint("B",txt)

        class QuickJVMDiags(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):                                                                           # noqa

                diagTxt = "Quick JVM Diagnostics:\n" \
                          " ---------------------\n\n"

                diagTxt += getJVMUsageStatistics(True, True, True) + "\n\n"
                
                diagTxt += "Threads:\n" \
                           " -------\n"
                lastGroup = None
                for t in sorted(Thread.getAllStackTraces().keySet(), key=lambda sort_t: (sort_t.getThreadGroup().getName(), sort_t.getName().lower())):
                    tg = t.getThreadGroup().getName()
                    if lastGroup is not None and tg != lastGroup: diagTxt += "  --\n"
                    lastGroup = tg
                    diagTxt += getJVMThreadInformation(t, True)
                diagTxt += "\n"

                ct = Thread.currentThread()
                diagTxt += "** This (Toolbox) thread:        %s (id: %s) %s\n" %(pad(ct.getName(),40), rpad(ct.getId(),4), ct.getThreadGroup())

                try:
                    backgroundOpsThread = MD_REF.getBackgroundThread()
                    if backgroundOpsThread is not None:
                        backgroundOpsThreadId = backgroundOpsThread.getId()
                        diagTxt += "** Main's Background Ops Thread: %s (id: %s)\n" %(pad(backgroundOpsThread,40), rpad(backgroundOpsThreadId,4))
                except: pass

                try:
                    book = MD_REF.getCurrentAccountBook()
                    syncer = book.getSyncer()
                    if syncer is not None:
                        syncerThread = getFieldByReflection(syncer, "syncThread")
                        syncerThreadId = syncerThread.getId() if (syncerThread) else None
                        diagTxt += "** Current Book's Sync Thread:   %s (id: %s) %s\n" %(pad(syncerThread,40), rpad(syncerThreadId,4), syncer)
                except: pass

                diagTxt += "\n\nWindows:\n" \
                           " -------\n"

                def sortWindowTypes(_win):
                    if isinstance(_win, JFrame): return 3
                    if isinstance(_win, Frame):  return 2
                    return 0

                for win in sorted(Window.getWindows(), key=lambda sort_w: (sortWindowTypes(sort_w), type(sort_w), sort_w.getName())):
                    diagTxt += "%s %s isFocused: %s isVisible: %s isActive: %s isDisplayable: %s isShowing: %s (Owner: %s:%s)\n"\
                               %(pad(type(win),70), pad(win.getName(),25),
                                 getYN(win.isFocused()), getYN(win.isVisible()), getYN(win.isActive()), getYN(win.isDisplayable()), getYN(win.isShowing()),
                                 type(win.getOwner()), (None if (win.getOwner()) is None else win.getOwner().getName()))

                diagTxt += "\nOld Frames holding on to 'book' references....:\n" \
                           " ----------------------------------------------\n"
                for win in sorted(Window.getWindows(), key=lambda sort_w: (sortWindowTypes(sort_w), type(sort_w), sort_w.getName())):
                    try:
                        ref_book = getFieldByReflection(win, "book")
                        if ref_book is not None:
                            diagTxt += "%s %s %s '%s' @{:x} (Owner: %s:%s)\n".format(System.identityHashCode(ref_book)) \
                                                                            %(pad("<<THIS BOOK>>" if (ref_book is MD_REF.getCurrentAccountBook()) else "!!OLD BOOK", 13, "!"),
                                                                              pad(win.getName(),25), pad(type(win),70), pad(ref_book.getName(),70),
                                                                              type(win.getOwner()), (None if (win.getOwner()) is None else win.getOwner().getName()))
                        del ref_book
                    except: pass

                diagTxt += "\n<END>"

                QuickJFrame("QUICK JVM DIAGNOSTICS", diagTxt, lAlertLevel=1, copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False, lAutoSize=True).show_the_frame()
                setDisplayStatus("Quick JVM Diagnostics displayed...", "B")

        class DisplayUUID(AbstractAction):

            def __init__(self, theFrame):
                self.theFrame = theFrame

            def actionPerformed(self, event):                                                                           # noqa
                myPrint("DB","In DisplayUUID().", inspect.currentframe().f_code.co_name, "()")

                uuid = myPopupAskForInput(self.theFrame,"DISPLAY OBJECT BY UUID", "UUID:", "Enter the UUID to display",
                                          defaultValue=None,isPassword=False,theMessageType=JOptionPane.INFORMATION_MESSAGE)
                if StringUtils.isEmpty(uuid): return

                uuid = uuid.strip()

                obj = MD_REF.getCurrentAccount().getBook().getItemForID(uuid)
                if obj is None: obj = MD_REF.getCurrentAccount().getBook().getItemForID(uuid.lower())                   # noqa

                # We search Txns too as Splits by their UUID (for example) can only be found this way...
                if obj is None: obj = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTxnByID(uuid)
                if obj is None: obj = MD_REF.getCurrentAccount().getBook().getTransactionSet().getTxnByID(uuid.lower()) # noqa
                if obj is None: obj = TxnUtil.getTxnByID(MD_REF.getCurrentAccount().getBook().getTransactionSet(), uuid)

                if obj is None: return

                if isinstance(obj, AbstractTxn):
                    MD_REF.getUI().showTxnXML(obj, self.theFrame)
                else:
                    MD_REF.getUI().showRawItemDetails(obj, self.theFrame)

        class OnlineBankingToolsButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):

                # OFX BANKING MENU

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                try:

                    user_UNLOCKMDPlusDiagnostic = JRadioButton("UNLOCKED - Moneydance+ Diagnostics (READONLY)", False)
                    user_UNLOCKMDPlusDiagnostic.setToolTipText("When Toolbox is unlocked, will display extra MD+ Diagnostics - DO NOT SHARE WITH OTHERS!")
                    user_UNLOCKMDPlusDiagnostic.setEnabled(isToolboxUnlocked() and isMDPlusEnabledBuild())
                    # user_UNLOCKMDPlusDiagnostic.setForeground(MD_REF.getUI().getColors().futureTxnIndicator)
                    user_UNLOCKMDPlusDiagnostic.setForeground(MD_REF.getUI().getColors().accountIconTint)

                    user_searchOFXData = JRadioButton("Search for stored OFX related data", False)
                    user_searchOFXData.setToolTipText("This searches for Online Banking (OFX) related setup information in most places...")

                    user_viewInstalledBankProfiles = JRadioButton("View your installed Bank / Service Profiles", False)
                    user_viewInstalledBankProfiles.setToolTipText("This will display all the setup data stored on your service/banking logon profile(s)")

                    user_viewListALLMDServices = JRadioButton("View list of MD's Bank dynamic setup profiles (then select one)", False)
                    user_viewListALLMDServices.setToolTipText("This will display Moneydance's dynamic setup profiles for all banks - pulled from Infinite Kind's website..")

                    user_view_CUSIP_settings = JRadioButton("View your Security's hidden CUSIP settings (The link between your Bank's Securities & MD Securities)", False)
                    user_view_CUSIP_settings.setToolTipText("This will show your Security's hidden CUSIP settings. These link your downloads on Investment Securities to MD Securities")

                    user_viewOnlineTxnsPayeesPayments = JRadioButton("View your Online Txns/Payees/Payments", False)
                    user_viewOnlineTxnsPayeesPayments.setToolTipText("This will show you your cached Online Txns (there should be none) and also your saved online payees and payments")

                    user_viewAllLastTxnDownloadDates = JRadioButton("View all your OFX last download txn dates (for all accounts)", False)
                    user_viewAllLastTxnDownloadDates.setToolTipText("View all your OFX last download txn dates (across all accounts)")

                    user_viewReconcileAsOfDates = JRadioButton("View your active accounts' calculated reconcile window auto 'as of' dates (Bank/Credit Cards/Investment)", False)
                    user_viewReconcileAsOfDates.setToolTipText("Displays how the reconcile as_of date is calculated for your active accounts")

                    user_toggleMDDebug = JRadioButton("Toggle Moneydance Debug (ONLY use for debugging)", False)
                    user_toggleMDDebug.setToolTipText("This toggles Moneydance's internal DEBUG(s) on/off. When ON you get more messages in the Console Log (the same as opening console)")

                    user_forgetOFXBankingLink = JRadioButton("Forget OFX Banking File Import Link (remove_ofx_account_bindings.py) (MD versions < MD2022)", False)
                    user_forgetOFXBankingLink.setToolTipText("Force MD to forget OFX Banking Import link attributed to an Account. Moneydance will ask you to recreate the link on next import.. THIS CHANGES DATA! (remove_ofx_account_bindings.py)")
                    user_forgetOFXBankingLink.setEnabled(GlobalVars.UPDATE_MODE and (not isMDPlusEnabledBuild() or isToolboxUnlocked()))
                    user_forgetOFXBankingLink.setForeground(getColorRed())

                    user_manageCUSIPLink = JRadioButton("Reset/Fix/Edit/Add CUSIP Banking Link (remove_ofx_security_bindings.py)", False)
                    user_manageCUSIPLink.setToolTipText("Allows you to reset/add/edit/move your CUSIP banking link between security records. THIS CHANGES DATA! (remove_ofx_security_bindings.py)")
                    user_manageCUSIPLink.setEnabled(GlobalVars.UPDATE_MODE)
                    user_manageCUSIPLink.setForeground(getColorRed())

                    user_updateOFXLastTxnUpdate = JRadioButton("Update OFX Last Txn Update Date (Downloaded) field for an account (MD versions >= 2022 use Online menu)", False)
                    user_updateOFXLastTxnUpdate.setToolTipText("Allows you to edit the last download txn date which is used to set the start date for txn downloads - THIS CHANGES DATA!")
                    # user_updateOFXLastTxnUpdate.setEnabled(GlobalVars.UPDATE_MODE and (not isMDPlusEnabledBuild() or isToolboxUnlocked()))
                    user_updateOFXLastTxnUpdate.setEnabled(GlobalVars.UPDATE_MODE)
                    user_updateOFXLastTxnUpdate.setForeground(getColorRed())

                    user_reset_OFXLastTxnUpdate_dates = JRadioButton("Reset ALL OFX Last Txn Update Dates (default, OFX and MD+) (MD build 4074 onwards)", False)
                    user_reset_OFXLastTxnUpdate_dates.setToolTipText("Allows you to reset ALL the last download txn dates used to set the start date for txn downloads (4074 onwards) - THIS CHANGES DATA!")
                    user_reset_OFXLastTxnUpdate_dates.setEnabled(GlobalVars.UPDATE_MODE and isMulti_OFXLastTxnUpdate_build())
                    user_reset_OFXLastTxnUpdate_dates.setForeground(getColorRed())

                    user_deleteOFXBankingLogonProfile = JRadioButton("Delete OFX Banking Service / Logon Profile (remove_one_service.py)", False)
                    user_deleteOFXBankingLogonProfile.setToolTipText("This will allow you to delete an Online Banking logon / service profile (service) from Moneydance. E.g. you will have to set this up again. THIS CHANGES DATA! (remove_one_service.py)")
                    user_deleteOFXBankingLogonProfile.setEnabled(GlobalVars.UPDATE_MODE)
                    user_deleteOFXBankingLogonProfile.setForeground(getColorRed())

                    user_cleanupMissingOnlineBankingLinks = JRadioButton("Cleanup missing Online Banking Links", False)
                    user_cleanupMissingOnlineBankingLinks.setToolTipText("This Cleans up missing Online Banking Links - NOTE: Always called when 'Delete OFX Banking Service / Logon Profile' is run. THIS CHANGES DATA!")
                    user_cleanupMissingOnlineBankingLinks.setEnabled(GlobalVars.UPDATE_MODE)
                    user_cleanupMissingOnlineBankingLinks.setForeground(getColorRed())

                    user_authenticationManagement = JRadioButton("OFX Authentication Management (various functions to manage authentication, UserIDs, ClientUIDs)", False)
                    user_authenticationManagement.setToolTipText("Brings up the sub menu. Allows you to clear your authentication cache (single or all) and edit user IDs/ClientUIDs. THIS CAN CHANGE DATA!")
                    user_authenticationManagement.setEnabled(GlobalVars.UPDATE_MODE)
                    user_authenticationManagement.setForeground(getColorRed())

                    user_deleteOnlineTxns = JRadioButton("Delete Single cached OnlineTxnList Record/Txns", False)
                    user_deleteOnlineTxns.setToolTipText("Allows you to surgically remove your cached Online Txn List txns - THESE SHOULD NOT BE HERE! THIS CHANGES DATA!")
                    user_deleteOnlineTxns.setEnabled(GlobalVars.UPDATE_MODE)
                    user_deleteOnlineTxns.setForeground(getColorRed())

                    user_deleteALLOnlineTxns = JRadioButton("Delete ALL cached OnlineTxnList Record/Txns (delete_intermediate_downloaded_transaction_caches.py)", False)
                    user_deleteALLOnlineTxns.setToolTipText("Purges/cleans any/all your cached Online Txn List records / txns - THERE SHOULD BE NONE! VERY SAFE TO RUN! THIS CHANGES DATA! (delete_intermediate_downloaded_transaction_caches.py)")
                    user_deleteALLOnlineTxns.setEnabled(GlobalVars.UPDATE_MODE)
                    user_deleteALLOnlineTxns.setForeground(getColorRed())

                    user_cookieManagement = JRadioButton("OFX Cookie Management", False)
                    user_cookieManagement.setToolTipText("Brings up the sub menu. Allows you to manage your OFX cookies - THIS CAN CHANGE DATA!")
                    user_cookieManagement.setEnabled(GlobalVars.ADVANCED_MODE)
                    user_cookieManagement.setForeground(getColorRed())

                    user_forceMDPlusNameCacheAccessTokensRebuild = JRadioButton("Force MD+ name cache & access tokens rebuild", False)
                    user_forceMDPlusNameCacheAccessTokensRebuild.setToolTipText("Wipes your internal MD+ cached bank names and access tokens. These should rebuild themselves. THIS CHANGES DATA!")
                    user_forceMDPlusNameCacheAccessTokensRebuild.setEnabled(GlobalVars.ADVANCED_MODE)
                    user_forceMDPlusNameCacheAccessTokensRebuild.setForeground(getColorRed())

                    user_forceDisconnectMDPlusConnection = JRadioButton("Force Disconnect an MD+ Connection (USE WITH CARE)", False)
                    user_forceDisconnectMDPlusConnection.setToolTipText("Attempts to force disconnect and MD+ connection. THIS CHANGES DATA!")
                    user_forceDisconnectMDPlusConnection.setEnabled(GlobalVars.ADVANCED_MODE and isMDPlusGetPlaidClientEnabledBuild())
                    user_forceDisconnectMDPlusConnection.setForeground(getColorRed())

                    user_export_MDPlus_LicenseObject = JRadioButton("Export your Moneydance+ (Plaid) license (keys) to a file (for 'transplant')", False)
                    user_export_MDPlus_LicenseObject.setToolTipText("This will Export your stored Moneydance+ (Plaid) license (keys) etc to a file (for 'transplant'). READONLY")
                    user_export_MDPlus_LicenseObject.setEnabled(GlobalVars.ADVANCED_MODE)
                    user_export_MDPlus_LicenseObject.setForeground(getColorRed())

                    user_import_MDPlus_LicenseObject = JRadioButton("Import ('transplant') your Moneydance+ (Plaid) license (keys) from a file (exported by Toolbox)", False)
                    user_import_MDPlus_LicenseObject.setToolTipText("This will Import ('transplant') your Moneydance+ (Plaid) license (keys) from a file exported by Toolbox. THIS CHANGES DATA!")
                    user_import_MDPlus_LicenseObject.setEnabled(GlobalVars.ADVANCED_MODE)
                    user_import_MDPlus_LicenseObject.setForeground(getColorRed())

                    user_zapMDPlusProfile = JRadioButton("ZAP your Moneydance+ (Plaid) settings (only when status is NOT 'activated')", False)
                    user_zapMDPlusProfile.setToolTipText("This will delete your stored Moneydance+ (Plaid) data/keys (including banking links) etc - E.g. you will have to set this up again. THIS CHANGES DATA!")
                    user_zapMDPlusProfile.setEnabled((GlobalVars.ADVANCED_MODE) and (not isMDPlusLicenseActivated() or isToolboxUnlocked()))
                    user_zapMDPlusProfile.setForeground(getColorRed())

                    user_manuallyPrimeUSAARootUserIDClientIDs = JRadioButton("USAA ONLY: (NEW METHOD) Manually 'prime' / overwrite stored Root UserIDs/ClientUIDs", False)
                    user_manuallyPrimeUSAARootUserIDClientIDs.setToolTipText("USAA Only: Allows you to 'prime' / overwrite stored UserIDs/ClientUIDs for USSA")
                    user_manuallyPrimeUSAARootUserIDClientIDs.setEnabled(GlobalVars.UPDATE_MODE)
                    user_manuallyPrimeUSAARootUserIDClientIDs.setForeground(getColorRed())

                    user_createUSAAProfile = JRadioButton("USAA Only: (DEPRECATED METHOD) Executes the special script to create a working USAA OFX Profile", False)
                    user_createUSAAProfile.setToolTipText("Executes: ofx_create_new_usaa_bank_custom_profile.py - THIS CHANGES DATA!")
                    user_createUSAAProfile.setEnabled(GlobalVars.UPDATE_MODE)
                    user_createUSAAProfile.setForeground(getColorRed())

                    labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Update mode **")
                    labelFYI2.setForeground(getColorRed())

                    labelFYI3 = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced Mode **")
                    labelFYI3.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    bg = ButtonGroup()
                    bg.add(user_forgetOFXBankingLink)
                    bg.add(user_deleteOFXBankingLogonProfile)
                    bg.add(user_cleanupMissingOnlineBankingLinks)
                    bg.add(user_manageCUSIPLink)
                    bg.add(user_searchOFXData)
                    bg.add(user_UNLOCKMDPlusDiagnostic)
                    bg.add(user_viewInstalledBankProfiles)
                    bg.add(user_view_CUSIP_settings)
                    bg.add(user_viewOnlineTxnsPayeesPayments)
                    bg.add(user_viewAllLastTxnDownloadDates)
                    bg.add(user_viewReconcileAsOfDates)
                    bg.add(user_cookieManagement)
                    bg.add(user_forceMDPlusNameCacheAccessTokensRebuild)
                    bg.add(user_forceDisconnectMDPlusConnection)
                    bg.add(user_export_MDPlus_LicenseObject)
                    bg.add(user_import_MDPlus_LicenseObject)
                    bg.add(user_zapMDPlusProfile)
                    bg.add(user_authenticationManagement)
                    bg.add(user_deleteOnlineTxns)
                    bg.add(user_deleteALLOnlineTxns)
                    bg.add(user_manuallyPrimeUSAARootUserIDClientIDs)
                    bg.add(user_createUSAAProfile)
                    bg.add(user_updateOFXLastTxnUpdate)
                    bg.add(user_reset_OFXLastTxnUpdate_dates)
                    bg.add(user_viewListALLMDServices)
                    # bg.add(user_toggleOFXDebug)
                    bg.add(user_toggleMDDebug)
                    bg.clearSelection()

                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))

                    if isToolboxUnlocked():
                        userFilters.add(user_UNLOCKMDPlusDiagnostic)

                    userFilters.add(user_searchOFXData)
                    userFilters.add(user_viewInstalledBankProfiles)
                    userFilters.add(user_viewListALLMDServices)
                    userFilters.add(user_view_CUSIP_settings)
                    userFilters.add(user_viewOnlineTxnsPayeesPayments)
                    userFilters.add(user_viewAllLastTxnDownloadDates)
                    userFilters.add(user_viewReconcileAsOfDates)
                    userFilters.add(user_toggleMDDebug)
                    # userFilters.add(user_toggleOFXDebug)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))
                    if not GlobalVars.UPDATE_MODE:
                        userFilters.add(labelFYI2)

                    userFilters.add(user_forgetOFXBankingLink)
                    userFilters.add(user_manageCUSIPLink)
                    userFilters.add(user_updateOFXLastTxnUpdate)
                    userFilters.add(user_reset_OFXLastTxnUpdate_dates)
                    userFilters.add(user_deleteOFXBankingLogonProfile)
                    userFilters.add(user_cleanupMissingOnlineBankingLinks)
                    userFilters.add(user_authenticationManagement)
                    userFilters.add(user_deleteOnlineTxns)
                    userFilters.add(user_deleteALLOnlineTxns)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---- ADVANCED MODE ONLY -----"))
                    if not GlobalVars.ADVANCED_MODE:
                        userFilters.add(labelFYI3)
                    userFilters.add(user_cookieManagement)

                    if isMDPlusEnabledBuild():
                        userFilters.add(user_forceMDPlusNameCacheAccessTokensRebuild)
                        userFilters.add(user_forceDisconnectMDPlusConnection)
                        userFilters.add(user_export_MDPlus_LicenseObject)
                        userFilters.add(user_import_MDPlus_LicenseObject)
                        userFilters.add(user_zapMDPlusProfile)

                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---- USAA ONLY (Update Mode)-----"))
                    userFilters.add(user_manuallyPrimeUSAARootUserIDClientIDs)
                    userFilters.add(user_createUSAAProfile)

                    while True:
                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters,775,725)
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Online Banking (OFX) Tools",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Online Banking (OFX) Tools - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_forgetOFXBankingLink.isSelected():                      forgetOFXImportLink()
                        if user_deleteOFXBankingLogonProfile.isSelected():              deleteOFXService()
                        if user_cleanupMissingOnlineBankingLinks.isSelected():          cleanupMissingOnlineBankingLinks(lAutoPurge=False)
                        if user_manageCUSIPLink.isSelected():                           CUSIPFix()
                        if user_toggleMDDebug.isSelected():                             advanced_mode_DEBUG()
                        if user_UNLOCKMDPlusDiagnostic.isSelected():                    UNLOCKMDPlusDiagnostic()
                        if user_authenticationManagement.isSelected():                  OFX_authentication_management()
                        if user_forceMDPlusNameCacheAccessTokensRebuild.isSelected():   forceMDPlusNameCacheAccessTokensRebuild()
                        if user_forceDisconnectMDPlusConnection.isSelected():           forceDisconnectMDPlusConnection()
                        if user_export_MDPlus_LicenseObject.isSelected():               export_MDPlus_LicenseObject()
                        if user_import_MDPlus_LicenseObject.isSelected():               import_MDPlus_LicenseObject()
                        if user_zapMDPlusProfile.isSelected():                          zap_MDPlus_Profile()
                        if user_cookieManagement.isSelected():                          OFX_cookie_management()
                        if user_deleteOnlineTxns.isSelected():                          OFX_delete_saved_online_txns()
                        if user_deleteALLOnlineTxns.isSelected():                       OFX_delete_ALL_saved_online_txns()
                        if user_manuallyPrimeUSAARootUserIDClientIDs.isSelected():      manuallyPrimeUSAARootUserIDClientIDs()
                        if user_createUSAAProfile.isSelected():                         createUSAAProfile()
                        if user_updateOFXLastTxnUpdate.isSelected():                    OFX_update_OFXLastTxnUpdate()
                        if user_reset_OFXLastTxnUpdate_dates.isSelected():              OFX_reset_OFXLastTxnUpdate_dates()
                        if user_searchOFXData.isSelected():                             CuriousViewInternalSettingsButtonAction(lOFX=True).actionPerformed("")
                        if user_viewListALLMDServices.isSelected():                     download_md_fiscal_setup()
                        if user_view_CUSIP_settings.isSelected():                       OFX_view_CUSIP_settings()
                        if user_viewOnlineTxnsPayeesPayments.isSelected():              OFX_view_online_txns_payees_payments()
                        if user_viewAllLastTxnDownloadDates.isSelected():               OFX_view_all_last_txn_download_dates()
                        if user_viewReconcileAsOfDates.isSelected():                    OFX_view_reconcile_AsOf_Dates()
                        if user_viewInstalledBankProfiles.isSelected():                 ofx_view_service_profile_data()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class FixDropboxOneWaySyncButtonAction(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                # fix_dropbox_one_way_syncing.py
                # reset_sync_and_dropbox_settings.py
                theKey = "migrated.netsync.dropbox.fileid"

                titleText = "Remove legacy Dropbox Migrated Sync Key".upper()
                question  = "Remove '%s' key to fix Dropbox one-way & iCloud Sync issues?" %(theKey)

                if not confirm_backup_confirm_disclaimer(toolbox_frame_, titleText, question):
                    return

                myPrint("B","%s: Removing key '%s' from LocalStorage() at user request...." %(titleText, theKey))

                LS = MD_REF.getUI().getCurrentAccounts().getBook().getLocalStorage()
                LS.remove(theKey)
                LS.save()

                MD_REF.saveCurrentAccount()           # Flush any current txns in memory and start a new sync record...
                play_the_money_sound()

                self.myButton.setVisible(False)
                self.myButton.setEnabled(False)

                txt = "%s: Completed. MONEYDANCE WILL NOW RESTART" %(titleText)
                setDisplayStatus(txt, "R"); myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_,txt,titleText,JOptionPane.WARNING_MESSAGE)
                ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)

        class RegisterMoneydance(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                # if MD_REF.isRegistered(): return
                LicenseKeyWindow(MD_REF.getUI(), toolbox_frame_).setVisible(True)


        class MakeDropBoxSyncFolder(AbstractAction):

            def __init__(self, myButton):
                self.myButton = myButton

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if check_for_dropbox_folder():
                    txt = "Sorry - Fix: Create .moneydancesync folder button not available!? NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPrint("B","MakeDropBoxSyncFolder() called, but check_for_dropbox_folder() returned True - so we should not be here? FIX NOT AVAILABLE")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if not myPopupAskQuestion(toolbox_frame_,
                                          "DROPBOX",
                                          "Create missing Dropbox .moneydancesync folder?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.ERROR_MESSAGE):

                    txt = "User declined to create missing Dropbox .moneydancesync folder - NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                self.myButton.setVisible(False)
                self.myButton.setEnabled(False)

                userHomeProperty = System.getProperty("UserHome", System.getProperty("user.home", "."))
                baseFolder = File(userHomeProperty, "Dropbox")

                try:
                    if File(baseFolder, ".moneydancesync").mkdir():
                        txt = "Created Dropbox .moneydancesync folder in Dropbox"
                        setDisplayStatus(txt, "B")
                        myPrint("B", txt)
                        myPopupInformationBox(toolbox_frame_, txt, "DROPBOX", JOptionPane.WARNING_MESSAGE)
                        return

                except: dump_sys_error_to_md_console_and_errorlog()

                txt = "Error creating Dropbox .moneydancesync folder!?"
                setDisplayStatus(txt, "R")
                myPrint("B", txt)
                myPopupInformationBox(toolbox_frame_, txt, "DROPBOX", JOptionPane.ERROR_MESSAGE)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class FindDatasetButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                _THIS_METHOD_NAME = "FIND DATASET"

                if not myPopupAskQuestion(toolbox_frame_,
                                          "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)/BACKUP(s)",
                                          "This may be time consuming...Do you want to continue with search?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.WARNING_MESSAGE):

                    txt = "%s: User Aborted Dataset search..." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                whatType = ["Datasets",
                             "Backups"]


                selectedWhat = JOptionPane.showInputDialog(     toolbox_frame_,
                                                                "WHAT TYPE OF DATASET?",
                                                                "Choose Datasets or Backups",
                                                                JOptionPane.INFORMATION_MESSAGE,
                                                                getMDIcon(lAlwaysGetIcon=True),
                                                                whatType,
                                                                None)
                if selectedWhat is None:
                    txt = "%s: No Dataset Type was selected - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if whatType.index(selectedWhat) == 0:
                    lBackup=False
                    theExtension = "*.moneydance".lower()
                elif whatType.index(selectedWhat) == 1:
                    lBackup=True
                    theExtension = "*.moneydancearchive".lower()
                else:
                    txt = "%s: Dataset Type Error - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                myPrint("DB", "Dataset type: %s" %(theExtension))

                if Platform.isWindows():
                    theRoot = os.path.join("C:"+os.path.sep)
                else:
                    theRoot = os.path.sep

                lRootExclusions = False

                whereFrom = [ "From UserDir: %s" %get_home_dir(),
                              "From Root: %s (excluding some system locations and other volumes)" %theRoot,
                              "From Root: %s (nothing excluded - might take a long time / never finish)" %theRoot,
                              "Select your own start point"]

                selectedStart = JOptionPane.showInputDialog(toolbox_frame_,
                                                            "Select the Search start folder",
                                                            "WHERE TO SEARCH FROM",
                                                            JOptionPane.INFORMATION_MESSAGE,
                                                            getMDIcon(lAlwaysGetIcon=True),
                                                            whereFrom,
                                                            None)
                if selectedStart is None:
                    txt = "%s: No start point was selected - aborting.." %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if whereFrom.index(selectedStart) == 3:

                    theTitle = "Select location to start %s Dataset Search (CANCEL=ABORT)" %(theExtension)
                    theDir = getFileFromFileChooser(    toolbox_frame_,         # Parent frame or None
                                                        get_home_dir(),         # Starting path
                                                        None,                   # Default Filename
                                                        theTitle,               # Title
                                                        False,                  # Multi-file selection mode
                                                        True,                   # True for Open/Load, False for Save
                                                        False,                  # True = Files, else Dirs
                                                        "START SEARCH",         # Load/Save button text, None for defaults
                                                        None,                   # File filter (non Mac only). Example: "txt" or "qif"
                                                        lAllowTraversePackages=True,
                                                        lAllowTraverseApplications=True,
                                                        lForceJFC=False,
                                                        lForceFD=False,
                                                        lAllowNewFolderButton=False,
                                                        lAllowOptionsButton=False)

                    if theDir is None or theDir == "":
                        txt = "%s: User did not select Search Directory... Aborting" %(_THIS_METHOD_NAME)
                        setDisplayStatus(txt, "R")
                        myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                        return None

                elif whereFrom.index(selectedStart) == 2:  # From ROOT with no exclusions
                    theDir = theRoot
                elif whereFrom.index(selectedStart) == 1:  # From ROOT with exclusions
                    lRootExclusions = True
                    theDir = theRoot
                elif whereFrom.index(selectedStart) == 0:  # From User Home Dir
                    theDir = get_home_dir()
                else:
                    txt = "%s: Error Selecting Search Directory... Aborting" %(_THIS_METHOD_NAME)
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_, txt, _THIS_METHOD_NAME, theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                diag = MyPopUpDialogBox(toolbox_frame_,"Please wait: searching..",theTitle=_THIS_METHOD_NAME, lModal=False,OKButtonText="WAIT")
                diag.go()

                save_list_of_found_files=[]

                myPrint("B","DATASET Search >> Searching from Directory: %s" %theDir)

                def findDataset(pattern, path):
                    iFound=0                                                                                            # noqa
                    result = []
                    dotCounter = 0
                    thingsSearched = 0

                    lContinueToEnd=False

                    if not GlobalVars.i_am_an_extension_so_run_headless:
                        print "Searching for your %s Datasets (might be time consuming):."%theExtension,

                    exclude_these_dirs = []

                    if lRootExclusions:
                        if Platform.isOSX():
                            exclude_these_dirs = ["/System", "/Library"]
                        elif Platform.isUnix():
                            exclude_these_dirs = ["/media", "/boot", "/cdrom", "/sys", "/proc", "/dev", "/mnt"]
                        myPrint("B","Root exclusions requested... These are: %s" %(exclude_these_dirs))

                    start_time = time.time()
                    timeOutCheckBackMinutes = 10.0
                    timeOutSeconds = 10

                    class MyTimerTask(TimerTask):

                        def __init__(self, dlg, theTimer):
                            self.dlg = dlg
                            self.theTimer = theTimer

                        def run(self):
                            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()")

                            myPrint("D","Timer task triggered - closing the JOption Pane....")
                            self.dlg.setVisible(False)
                            self.theTimer.cancel()

                            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                            return

                    class MyJOptionPaneListener(ComponentAdapter):

                        def __init__(self, timeout, dlg):
                            self.timeout = timeout
                            self.dlg = dlg
                            self.t = None

                        def componentShown(self, e):
                            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", e)
                            super(MyJOptionPaneListener, self).componentShown(e)                                        # noqa
                            myPrint("D","Toolbox setting up Timer Task for Search function to kill Search dialog...")
                            self.t = Timer("toolbox_finddataset_timer", True)
                            self.t.schedule(MyTimerTask(self.dlg,self.t), self.timeout)
                            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

                        def componentHidden(self, e):
                            myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", e)
                            super(MyJOptionPaneListener, self).componentHidden(e)                                       # noqa
                            myPrint("D","Killing Timer Task for Search function as dialog closed...")
                            self.t.cancel()
                            myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

                    # showOptionDialog(Component parentComponent, Object message, String title, int optionType, int messageType, Icon icon, Object[] options, Object initialValue)
                    def showConfirmDialogWithTimeout(theFrame, theMessage, _theTitle, theOptionType, theMessageType, theIcon, theChoices, theInitialValue, timeout_ms, timeoutChoice):
                        theMsg = JOptionPane(theMessage, theMessageType, theOptionType, theIcon, theChoices, theInitialValue)
                        dlg = theMsg.createDialog(theFrame, _theTitle)
                        dlg.setAlwaysOnTop(True)
                        dlg.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE)
                        theListener = MyJOptionPaneListener( timeout_ms, dlg )
                        dlg.addComponentListener( theListener )
                        dlg.setVisible(True)
                        selectedValue = theMsg.getValue()
                        dlg.removeComponentListener( theListener )
                        del theListener
                        if selectedValue is None or selectedValue < 0:
                            return -1
                        try:
                            return theChoices.index(selectedValue)
                        except:
                            pass    # Probably "uninitializedValue"

                        return theChoices.index(timeoutChoice)

                    options=["STOP HERE","SEARCH TO END", "KEEP ASKING"]

                    for root, dirs, files in os.walk(path, topdown=True):

                        if debug: myPrint("DB","Searching: %s" %(root))

                        if dotCounter % 1000 <1:
                            if not GlobalVars.i_am_an_extension_so_run_headless: print ".",

                        if (not dotCounter
                                or (dotCounter % 10000 <1 and not lContinueToEnd)
                                or (time.time() - start_time > (timeOutCheckBackMinutes*60))):

                            start_time = time.time()

                            # ####
                            response = showConfirmDialogWithTimeout(toolbox_frame_,
                                                                    "Are you OK to continue (so far..: %s found / %s files/searched)?" %(iFound, thingsSearched),
                                                                    "SEARCH COMPUTER FOR MONEYDANCE DATASET(s)",
                                                                    JOptionPane.YES_NO_OPTION,
                                                                    JOptionPane.QUESTION_MESSAGE,
                                                                    getMDIcon(None),
                                                                    options,
                                                                    options[2],
                                                                    timeOutSeconds * 1000,
                                                                    options[2])

                            if response < 1:
                                _txt = "%s: User Aborted Dataset search..." %(_THIS_METHOD_NAME)
                                myPrint("B", _txt); setDisplayStatus(_txt, "R")
                                return result, iFound
                            elif response == 1:
                                lContinueToEnd = True
                            elif response == 2:
                                pass

                        dotCounter+=1

                        # Remove /System dir etc on Mac/Linux....
                        if lRootExclusions:
                            for d in list(dirs):
                                for ex in exclude_these_dirs:
                                    if (root+d).startswith(ex):
                                        dirs.remove(d)

                        if lBackup:

                            for name in files:
                                fp = os.path.join(root,name)
                                if os.path.islink(fp):
                                    myPrint("DB", "found file link! %s - will skip" %fp)
                                    continue

                                thingsSearched+=1
                                if fnmatch.fnmatch(name, pattern):
                                    iFound+=1
                                    result.append("File >> Sz: %sMB Mod: %s Name: %s "
                                                  %(rpad(convertBytesMBs(os.path.getsize(os.path.join(root, name))),6),
                                                    pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11),
                                                    os.path.join(root, name)))
                        for name in dirs:
                            fp = os.path.join(root,name)
                            if os.path.islink(fp):
                                myPrint("DB", "found dir link! %s - will skip" %fp)
                                continue

                            thingsSearched+=1
                            if fnmatch.fnmatch(name, pattern):
                                if name != ".moneydance":
                                    save_list_of_found_files.append(fp)
                                    iFound+=1
                                result.append("Dir >> Modified: %s %s"
                                              %(pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11),
                                              os.path.join(root, name)))
                    return result, iFound

                fileList, iFound = findDataset(theExtension, theDir)

                diag.kill()

                print
                myPrint("B","Completed search for %s datafiles: %s found" %(theExtension,iFound))

                niceFileList="\n SEARCH FOR MONEYDANCE (%s) DATASETS\n" %(theExtension)
                niceFileList+="Search started from Directory: %s\n\n" %(theDir)

                if lRootExclusions:
                    niceFileList+="(NOTE: Root search exclusions of other volumes and some system locations were requested too)\n\n"

                if not iFound:
                    niceFileList+="\n<NONE FOUND>\n"

                for x in fileList:
                    myPrint("B","Found: %s" %x)
                    niceFileList+=x+"\n"

                txt = "Find my %s datasets(s) found %s possible files/directories" %(theExtension,iFound)
                setDisplayStatus(txt, "DG")

                jif = QuickJFrame("LIST OF MONEYDANCE %s DATASETS FOUND" %(theExtension),
                                  niceFileList,
                                  lAlertLevel=1,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

                myPopupInformationBox(jif, "%s %s Datasets located...." %(iFound,theExtension), _THIS_METHOD_NAME, JOptionPane.INFORMATION_MESSAGE)

                if not lBackup:
                    add_to_ext_list=[]
                    internalDir = Common.getDocumentsDirectory().getCanonicalPath()

                    externalFiles = AccountBookUtil.getExternalAccountBooks()
                    externalFiles_asList = []
                    for ext in externalFiles:
                        externalFiles_asList.append(ext.getBook().getRootFolder().getCanonicalPath())

                    for filename in save_list_of_found_files:
                        if not os.path.exists(filename):
                            continue
                        if internalDir in filename:
                            continue
                        if filename in externalFiles_asList:
                            continue
                        add_to_ext_list.append(filename)

                    myPrint("DB","Found %s external files that can be added to config.dict: %s" %(len(add_to_ext_list),add_to_ext_list))

                    if (len(add_to_ext_list) > 0
                            and myPopupAskQuestion(jif, _THIS_METHOD_NAME, "%s of these datasets are not showing in your File/Open menu list(and config.dict)? WOULD YOU LIKE TO ADD ANY OF THEM?" %(len(add_to_ext_list))) ):

                        backup_config_dict(True)

                        iAdded = 0
                        externalFilesVector = MD_REF.getUI().getPreferences().getVectorSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, StreamVector())
                        for add_this_file in add_to_ext_list:
                            if not myPopupAskQuestion(jif,"ADD FILE TO FILE/OPEN MENU","ADD: %s?" %((add_this_file))):
                                continue
                            iAdded+=1
                            myPrint("B","SEARCH FOR DATASETS - %s added to config.dict and file/open menu" %(add_this_file))
                            externalFilesVector.add(add_this_file)
                            MD_REF.getUI().getPreferences().setSetting(GlobalVars.Strings.MD_CONFIGDICT_EXTERNAL_FILES, externalFilesVector)

                        if iAdded:
                            MD_REF.savePreferences()
                            myPopupInformationBox(jif, "SEARCH FOR DATASETS - %s files added to config.dict and file/open menu (RESTART MD REQUIRED)" %(iAdded), "DATASET SEARCH", JOptionPane.INFORMATION_MESSAGE)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class AccountsCategoriesMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                try:
                    user_view_check_number_settings = JRadioButton("View Check Number Settings", False)
                    user_view_check_number_settings.setToolTipText("View the Check Number settings that will display in the Transaction Register")

                    user_force_change_accounts_currency = JRadioButton("FIX: FORCE Change an Account's / Category's Currency (force_change_account_currency.py)", False)
                    user_force_change_accounts_currency.setToolTipText("This allows you to FORCE change an Account's / Category's currency - USE WITH CARE!.. THIS CHANGES DATA! (force_change_account_currency.py)")
                    user_force_change_accounts_currency.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_accounts_currency.setForeground(getColorRed())

                    user_force_change_all_accounts_cats_currency = JRadioButton("FIX: FORCE Change ALL Accounts' / Categories' Currencies (force_change_all_currencies.py)", False)
                    user_force_change_all_accounts_cats_currency.setToolTipText("This allows you to FORCE change ALL Accounts' / Categories' Currencies - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")
                    user_force_change_all_accounts_cats_currency.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_all_accounts_cats_currency.setForeground(getColorRed())

                    user_force_change_accounts_cats_from_to_currency = JRadioButton("FIX: FORCE Change Accounts / Categories [& Securities] FROM Currency TO Currency", False)
                    user_force_change_accounts_cats_from_to_currency.setToolTipText("This allows you to FORCE change Accounts / Categories [& Securities] from one currency to another - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")
                    user_force_change_accounts_cats_from_to_currency.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_accounts_cats_from_to_currency.setForeground(getColorRed())

                    user_force_change_an_accounts_type = JRadioButton("FIX: FORCE Change an Account's Type (set_account_type.py)", False)
                    user_force_change_an_accounts_type.setToolTipText("This allows you to FORCE change an Account's Type - USE WITH CARE!.. THIS CHANGES DATA! (set_account_type.py)")
                    user_force_change_an_accounts_type.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_an_accounts_type.setForeground(getColorRed())

                    user_view_zero_bal_cats = JRadioButton("DIAG: Categories and Balances Report", False)
                    user_view_zero_bal_cats.setToolTipText("This will list all your Categories and show which have Zero Balances - USE UPDATE MODE TO MAKE THESE INACTIVE")

                    user_inactivate_zero_bal_cats = JRadioButton("FIX: Make Zero Balance Categories Inactive", False)
                    user_inactivate_zero_bal_cats.setToolTipText("This will allow you Inactivate all Categories with Zero Balances (you will see the report first). THIS CHANGES DATA!")
                    user_inactivate_zero_bal_cats.setEnabled(GlobalVars.UPDATE_MODE)
                    user_inactivate_zero_bal_cats.setForeground(getColorRed())

                    user_view_shouldBeIncludedInNetWorth_settings = JRadioButton("DIAG: View Accounts' shouldBeIncludedInNetWorth() settings...", False)
                    user_view_shouldBeIncludedInNetWorth_settings.setToolTipText("This will list all Accounts/Categories and the shouldBeIncludedInNetWorth() setting - USE UPDATE MODE TO EDIT")

                    user_edit_shouldBeIncludedInNetWorth_settings = JRadioButton("FIX: Edit an Account's shouldBeIncludedInNetWorth() setting", False)
                    user_edit_shouldBeIncludedInNetWorth_settings.setToolTipText("This will allow you to edit an Account's shouldBeIncludedInNetWorth() setting. THIS CHANGES DATA!")
                    user_edit_shouldBeIncludedInNetWorth_settings.setEnabled(GlobalVars.UPDATE_MODE)
                    user_edit_shouldBeIncludedInNetWorth_settings.setForeground(getColorRed())

                    user_fix_accounts_parent = JRadioButton("FIX: Account's Invalid Parent Account (fix_account_parent.py)", False)
                    user_fix_accounts_parent.setToolTipText("This will diagnose your Parent Accounts and fix if invalid. THIS CHANGES DATA! (fix_account_parent.py)")
                    user_fix_accounts_parent.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_accounts_parent.setForeground(getColorRed())

                    bookName = MD_REF.getCurrentAccountBook().getName().strip()
                    root = MD_REF.getCurrentAccountBook().getRootAccount()
                    rootName = root.getAccountName().strip()
                    user_fix_root_account_name = JRadioButton("FIX: Correct Root Account Name (Only enabled if the name is incorrect)", False)
                    user_fix_root_account_name.setToolTipText("This allows you to change the (nearly) hidden Master/Parent Account Name in Moneydance (referred to as ROOT) to match the name of your Dataset (referred to as BOOK). THIS CHANGES DATA!")
                    user_fix_root_account_name.setEnabled(GlobalVars.UPDATE_MODE and (rootName != bookName))
                    user_fix_root_account_name.setForeground(getColorRed())

                    labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Update mode **")
                    labelFYI2.setForeground(getColorRed())

                    labelFYI_curr_fix = JLabel("       ** disabled when a serious currency/security issue has been detected **")
                    labelFYI_curr_fix.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    bg = ButtonGroup()
                    bg.add(user_view_check_number_settings)
                    bg.add(user_view_zero_bal_cats)
                    bg.add(user_inactivate_zero_bal_cats)
                    bg.add(user_view_shouldBeIncludedInNetWorth_settings)
                    bg.add(user_edit_shouldBeIncludedInNetWorth_settings)
                    bg.add(user_force_change_an_accounts_type)
                    bg.add(user_force_change_accounts_currency)
                    bg.add(user_force_change_all_accounts_cats_currency)
                    bg.add(user_force_change_accounts_cats_from_to_currency)
                    bg.add(user_fix_accounts_parent)
                    bg.add(user_fix_root_account_name)
                    bg.clearSelection()

                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                    userFilters.add(user_view_check_number_settings)
                    userFilters.add(user_view_zero_bal_cats)
                    userFilters.add(user_view_shouldBeIncludedInNetWorth_settings)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                    if not GlobalVars.UPDATE_MODE:
                        userFilters.add(labelFYI2)

                    userFilters.add(user_inactivate_zero_bal_cats)
                    userFilters.add(user_edit_shouldBeIncludedInNetWorth_settings)
                    userFilters.add(user_force_change_an_accounts_type)
                    userFilters.add(user_force_change_accounts_currency)
                    userFilters.add(user_force_change_all_accounts_cats_currency)
                    userFilters.add(user_force_change_accounts_cats_from_to_currency)
                    userFilters.add(user_fix_accounts_parent)
                    userFilters.add(user_fix_root_account_name)

                    while True:

                        bookName = MD_REF.getCurrentAccountBook().getName().strip()
                        root = MD_REF.getCurrentAccountBook().getRootAccount()
                        rootName = root.getAccountName().strip()

                        user_fix_root_account_name.setEnabled(GlobalVars.UPDATE_MODE and (rootName != bookName))

                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters,700,425)
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Accounts / Categories Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Accounts / Categories Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_view_check_number_settings.isSelected():                        view_check_num_settings()
                        if user_view_zero_bal_cats.isSelected():                                zero_bal_categories(False)
                        if user_inactivate_zero_bal_cats.isSelected():                          zero_bal_categories(True)
                        if user_view_shouldBeIncludedInNetWorth_settings.isSelected():          view_shouldBeIncludedInNetWorth_settings()
                        if user_edit_shouldBeIncludedInNetWorth_settings.isSelected():          edit_shouldBeIncludedInNetWorth_settings()
                        if user_force_change_an_accounts_type.isSelected():                     force_change_account_type()
                        if user_force_change_accounts_currency.isSelected():                    force_change_account_cat_currency()
                        if user_force_change_all_accounts_cats_currency.isSelected():           force_change_all_accounts_categories_currencies()
                        if user_force_change_accounts_cats_from_to_currency.isSelected():       force_change_accounts_cats_from_to_currency()
                        if user_fix_accounts_parent.isSelected():                               fix_account_parent()
                        if user_fix_root_account_name.isSelected():                             fix_root_account_name()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class CurrencySecurityMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                try:
                    lAlertPopupShown = False

                    user_show_open_share_lots = JRadioButton("DIAG: Show Open Share LOTS (unconsumed) (show_open_tax_lots.py)", False)
                    user_show_open_share_lots.setToolTipText("This will list all Stocks/Shares with Open/Unconsumed LOTS (when LOT Control ON) - READONLY (show_open_tax_lots.py)")

                    user_diagnose_matched_lot_data = JRadioButton("DIAG: Show Securities with 'invalid' LOT Matching (cause of LOT matching popup window)", False)
                    user_diagnose_matched_lot_data.setToolTipText("Diagnose LOT matching data and highlights 'invalid' matching (causing LOT matching window to appear) - READONLY")

                    user_convert_stock_lot_FIFO = JRadioButton("FIX: Convert Stock to LOT controlled with FIFO lot matching (MakeFifoCost.py)", False)
                    user_convert_stock_lot_FIFO.setToolTipText("Convert Average Cost Controlled Stock to LOT Controlled and Allocate LOTs using FiFo method - THIS CHANGES DATA! (MakeFifoCost.py)")
                    user_convert_stock_lot_FIFO.setEnabled(GlobalVars.UPDATE_MODE)
                    user_convert_stock_lot_FIFO.setForeground(getColorRed())

                    user_convert_stock_avg_cst_control = JRadioButton("FIX: Convert Stock to Average Cost Control", False)
                    user_convert_stock_avg_cst_control.setToolTipText("Convert LOT Controlled Stock to Average Cost Control (and wipe any LOT records) - THIS CHANGES DATA!")
                    user_convert_stock_avg_cst_control.setEnabled(GlobalVars.UPDATE_MODE)
                    user_convert_stock_avg_cst_control.setForeground(getColorRed())

                    user_thin_price_history = JRadioButton("FIX: Thin/Purge Price History (price_history_thinner.py)", False)
                    user_thin_price_history.setToolTipText("This will allow you to Thin / Prune your Price History based on user parameters. THIS CHANGES DATA! (price_history_thinner.py)")
                    user_thin_price_history.setEnabled(GlobalVars.UPDATE_MODE)
                    user_thin_price_history.setForeground(getColorRed())

                    user_fix_nonlinked_security_records = JRadioButton("FIX: Detect and fix Investment Security records not properly linked to Security Master records", False)
                    user_fix_nonlinked_security_records.setToolTipText("This will scan your Investment Security record and check that it's properly linked to a security master record... Allows you to fix this too")
                    user_fix_nonlinked_security_records.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_nonlinked_security_records.setForeground(getColorRed())

                    user_fix_invalidLotRecords = JRadioButton("FIX: Detect and fix (wipe) LOT records where matched Buy/Sell records are invalid", False)
                    user_fix_invalidLotRecords.setToolTipText("Scans LOT matching data and detects where matched records are invalid (missing)... Allows you to fix by wiping the LOT data")
                    user_fix_invalidLotRecords.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_invalidLotRecords.setForeground(getColorRed())

                    user_can_i_delete_security = JRadioButton("DIAG: Can I Delete a Security? (i.e. this is a show where used)", False)
                    user_can_i_delete_security.setToolTipText("This will tell you whether a Selected Security is in use and whether you can delete it in Moneydance")

                    user_can_i_delete_currency = JRadioButton("DIAG: Can I Delete a Currency?  (i.e. this is a show where used)", False)
                    user_can_i_delete_currency.setToolTipText("This will tell you whether a Selected Currency is in use and whether you can delete it in Moneydance")

                    user_list_curr_sec_dpc = JRadioButton("DIAG: List Security / Currency (hidden) decimal place settings", False)
                    user_list_curr_sec_dpc.setToolTipText("This will list your Security and Currency hidden decimal place settings (and attempt to advise of setup errors)")

                    user_diag_curr_sec = JRadioButton("DIAG: Diagnose currencies / securities (including relative currencies) (if errors see fix below) (based on reset_relative_currencies.py)", False)
                    user_diag_curr_sec.setToolTipText("This will diagnose your Currency & Security setup, also checking relative currencies (and advise if you need to run a fix) (reset_relative_currencies.py)")

                    user_diag_price_date = JRadioButton("DIAG: Diagnose currency and security's current price hidden 'price_date' field", False)
                    user_diag_price_date.setToolTipText("This will diagnose your Currency & Security's current price hidden price_date field....")

                    user_edit_security_decimal_places = JRadioButton("FIX: Edit a Security's (hidden) Decimal Place setting (adjusts related Investment txns & Security balances accordingly)", False)
                    user_edit_security_decimal_places.setToolTipText("This allows you to edit the hidden decimal places setting stored against a security (that you determined when you set the security up)")
                    user_edit_security_decimal_places.setEnabled(GlobalVars.UPDATE_MODE and int(MD_REF.getBuild()) >= 1904)  # Pre-2019.4(1904) different usage of rate/rrate/dpc
                    user_edit_security_decimal_places.setForeground(getColorRed())

                    user_merge_duplicate_securities = JRadioButton("FIX: Merge 'duplicate' securities (and related Investment txns) into one master security record.", False)
                    user_merge_duplicate_securities.setToolTipText("Scans for 'duplicated' Securities and can merge together.. Tools>Securities>TickerSymbol is key, ID must be different... (Dpc, RelCurr, Rate, Splits must also match)")
                    user_merge_duplicate_securities.setEnabled(GlobalVars.UPDATE_MODE)
                    user_merge_duplicate_securities.setForeground(getColorRed())

                    user_fix_duplicate_securities_within_same_investment_account = JRadioButton("FIX: Detect and merge/fix duplicate Securities within same Investment Account(s)", False)
                    user_fix_duplicate_securities_within_same_investment_account.setToolTipText("Scans and merges 'duplicated' Securities within the same Investment account(s).. THIS CHANGES DATA!")
                    user_fix_duplicate_securities_within_same_investment_account.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_duplicate_securities_within_same_investment_account.setForeground(getColorRed())

                    user_autofix_price_date = JRadioButton("FIX: Diagnose then fix your currency / security's current price hidden 'price_date' field (along with the current price/rate)", False)
                    user_autofix_price_date.setToolTipText("This will diagnose then fix your Currency & Security's current price hidden price_date field (and current price/rate)....")
                    user_autofix_price_date.setEnabled(GlobalVars.UPDATE_MODE)
                    user_autofix_price_date.setForeground(getColorRed())

                    user_fix_price_date = JRadioButton("FIX: Manually edit a currency/ security's current price hidden 'price_date' field", False)
                    user_fix_price_date.setToolTipText("Allows you to manually edit a Currency / Security's current price hidden 'price_date' field....")
                    user_fix_price_date.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_price_date.setForeground(getColorRed())

                    user_fix_curr_sec = JRadioButton("FIX: Fix currencies / securities (including relative currencies) (based on reset_relative_currencies.py) - MUST RUN DIAGNOSE ABOVE FIRST", False)
                    user_fix_curr_sec.setToolTipText("This will apply fixes to your Currency (& security) / Relative Currency setup (use after running the diagnose option first). THIS CHANGES DATA!  (reset_relative_currencies.py)")
                    user_fix_curr_sec.setEnabled(GlobalVars.UPDATE_MODE and fixRCurrencyCheck is not None and fixRCurrencyCheck>1)
                    user_fix_curr_sec.setForeground(getColorRed())

                    user_fix_invalid_curr_sec = JRadioButton("FIX: Fix Invalid Relative Currency (& security) Rates where <= (1.0/9999999999) or >= 9999999999 (fix_invalid_currency_rates.py)", False)
                    user_fix_invalid_curr_sec.setToolTipText("This will reset any relative rates back to 1.0 where <= (1.0/9999999999) or >= 9999999999. THIS CHANGES DATA!  (fix_invalid_currency_rates.py)")
                    user_fix_invalid_curr_sec.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_invalid_curr_sec.setForeground(getColorRed())

                    user_fix_invalid_price_history = JRadioButton("FIX: Delete invalid price history records where rate <= (1.0/9999999999) or >= 9999999999.", False)
                    user_fix_invalid_price_history.setToolTipText("This will delete and invalid price history records where rate <= (1.0/9999999999) or >= 9999999999. THIS CHANGES DATA!")
                    user_fix_invalid_price_history.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_invalid_price_history.setForeground(getColorRed())

                    user_force_change_accounts_currency = JRadioButton("FIX: FORCE Change an Account's / Category's Currency (force_change_account_currency.py)", False)
                    user_force_change_accounts_currency.setToolTipText("This allows you to FORCE change an Account's / Category's currency - USE WITH CARE!.. THIS CHANGES DATA! (force_change_account_currency.py)")
                    user_force_change_accounts_currency.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_accounts_currency.setForeground(getColorRed())

                    user_force_change_all_accounts_cats_currency = JRadioButton("FIX: FORCE Change ALL Accounts' / Categories' Currencies (force_change_all_currencies.py)", False)
                    user_force_change_all_accounts_cats_currency.setToolTipText("This allows you to FORCE change ALL Accounts' / Categories' Currencies - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")
                    user_force_change_all_accounts_cats_currency.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_all_accounts_cats_currency.setForeground(getColorRed())

                    user_force_change_accounts_cats_from_to_currency = JRadioButton("FIX: FORCE Change Accounts / Categories [& Securities] FROM Currency TO Currency", False)
                    user_force_change_accounts_cats_from_to_currency.setToolTipText("This allows you to FORCE change Accounts / Categories [& Securities] from one currency to another - USE WITH CARE!.. THIS CHANGES DATA! (force_change_all_currencies.py)")
                    user_force_change_accounts_cats_from_to_currency.setEnabled(GlobalVars.UPDATE_MODE)
                    user_force_change_accounts_cats_from_to_currency.setForeground(getColorRed())


                    labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Update mode **")
                    labelFYI2.setForeground(getColorRed())

                    labelFYI_curr_fix = JLabel("       ** only enabled if no serious currency/security issues detected **")
                    labelFYI_curr_fix.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    bg = ButtonGroup()
                    bg.add(user_fix_invalidLotRecords)
                    bg.add(user_show_open_share_lots)
                    bg.add(user_diagnose_matched_lot_data)
                    bg.add(user_convert_stock_lot_FIFO)
                    bg.add(user_convert_stock_avg_cst_control)
                    bg.add(user_fix_nonlinked_security_records)
                    bg.add(user_thin_price_history)
                    bg.add(user_can_i_delete_security)
                    bg.add(user_can_i_delete_currency)
                    bg.add(user_list_curr_sec_dpc)
                    bg.add(user_diag_curr_sec)
                    bg.add(user_diag_price_date)
                    bg.add(user_edit_security_decimal_places)
                    bg.add(user_merge_duplicate_securities)
                    bg.add(user_fix_duplicate_securities_within_same_investment_account)
                    bg.add(user_autofix_price_date)
                    bg.add(user_fix_price_date)
                    bg.add(user_fix_curr_sec)
                    bg.add(user_fix_invalid_curr_sec)
                    bg.add(user_fix_invalid_price_history)
                    bg.add(user_force_change_accounts_currency)
                    bg.add(user_force_change_all_accounts_cats_currency)
                    bg.add(user_force_change_accounts_cats_from_to_currency)
                    bg.clearSelection()

                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                    userFilters.add(user_diag_curr_sec)
                    userFilters.add(user_can_i_delete_security)
                    userFilters.add(user_can_i_delete_currency)
                    userFilters.add(user_list_curr_sec_dpc)
                    userFilters.add(user_show_open_share_lots)
                    userFilters.add(user_diagnose_matched_lot_data)
                    userFilters.add(user_diag_price_date)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                    if not GlobalVars.UPDATE_MODE:
                        userFilters.add(labelFYI2)
                    else:
                        if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD:
                            userFilters.add(labelFYI_curr_fix)

                    userFilters.add(user_fix_curr_sec)

                    # These are new features - better supported from 2021.2 onwards
                    if int(MD_REF.getBuild()) >= MD_RRATE_ISSUE_FIXED_BUILD:
                        userFilters.add(user_edit_security_decimal_places)
                        userFilters.add(user_merge_duplicate_securities)
                        userFilters.add(user_autofix_price_date)
                        userFilters.add(user_fix_price_date)

                    userFilters.add(user_fix_duplicate_securities_within_same_investment_account)
                    userFilters.add(user_fix_invalidLotRecords)
                    userFilters.add(user_convert_stock_lot_FIFO)
                    userFilters.add(user_convert_stock_avg_cst_control)
                    userFilters.add(user_fix_nonlinked_security_records)
                    userFilters.add(user_thin_price_history)
                    userFilters.add(user_fix_invalid_curr_sec)
                    userFilters.add(user_fix_invalid_price_history)
                    userFilters.add(user_force_change_accounts_currency)
                    userFilters.add(user_force_change_all_accounts_cats_currency)
                    userFilters.add(user_force_change_accounts_cats_from_to_currency)

                    while True:

                        user_fix_curr_sec.setEnabled(GlobalVars.UPDATE_MODE and fixRCurrencyCheck is not None and fixRCurrencyCheck>1)

                        user_edit_security_decimal_places.setEnabled(GlobalVars.UPDATE_MODE and int(MD_REF.getBuild()) >= 1904)  # Pre-2019.4(1904) different usage of rate/rrate/dpc
                        user_merge_duplicate_securities.setEnabled(GlobalVars.UPDATE_MODE)
                        user_autofix_price_date.setEnabled(GlobalVars.UPDATE_MODE)
                        user_thin_price_history.setEnabled(GlobalVars.UPDATE_MODE)
                        user_fix_invalid_curr_sec.setEnabled(GlobalVars.UPDATE_MODE)
                        user_fix_invalid_price_history.setEnabled(GlobalVars.UPDATE_MODE)

                        # Pre 2021.2(3089) there were internal code issues with old CurrencyType records (from pre 2019.4) with missing 'rrate' fields. Fixed in build 3089 onwards
                        if not check_all_currency_raw_rates_ok():

                            user_diag_curr_sec.setForeground(getColorBlue())

                            if GlobalVars.UPDATE_MODE and not lAlertPopupShown:

                                if int(MD_REF.getBuild()) < MD_RRATE_ISSUE_FIXED_BUILD:
                                    MyPopUpDialogBox(toolbox_frame_,
                                                     "ALERT: Currency/Security data issues need resolving - some menu items are disabled...",
                                                     "You have some Currency / Security records which were created in an older version of Moneydance\n"
                                                     "These need to be updated to the latest 'format' before Toolbox can allow some options\n"
                                                     "Please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to address this issue\n"
                                                     "OR BETTER >> Upgrade to Moneydance build %s onwards (as the MD code was fixed to deal with this data issue)\n"
                                                     "Menu items will remain disabled until you do this...." %(MD_RRATE_ISSUE_FIXED_BUILD),
                                                     lModal=True, OKButtonText="Acknowledge", lAlertLevel=1).go()
                                else:
                                    MyPopUpDialogBox(toolbox_frame_,
                                                     "ALERT: Currency/Security data issues need resolving - some menu items are disabled...",
                                                     "You have some Currency / Security records which have a data issue\n"
                                                     "These need to be fixed before Toolbox can allow some options\n"
                                                     "Please run 'MENU: Currency & Security tools>Diag/Fix Currencies/Securities' to address this issue\n"
                                                     "Menu items will remain disabled until you do this....",
                                                     lModal=True, OKButtonText="Acknowledge", lAlertLevel=1).go()

                                lAlertPopupShown = True

                            user_autofix_price_date.setEnabled(False)
                            user_thin_price_history.setEnabled(False)
                            user_fix_invalid_curr_sec.setEnabled(False)
                            user_fix_invalid_price_history.setEnabled(False)

                            # Just disable if errors on Security records....
                            if not check_all_currency_raw_rates_ok(CurrencyType.Type.SECURITY):                         # noqa
                                user_edit_security_decimal_places.setEnabled(False)
                                user_merge_duplicate_securities.setEnabled(False)

                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters,1100,625)
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Currency / Security Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Currency / Security Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_can_i_delete_security.isSelected():                                     can_I_delete_security()
                        if user_can_i_delete_currency.isSelected():                                     can_I_delete_currency()
                        if user_list_curr_sec_dpc.isSelected():                                         list_security_currency_decimal_places()
                        if user_diag_price_date.isSelected():                                           list_security_currency_price_date()
                        if user_autofix_price_date.isSelected():                                        list_security_currency_price_date(autofix=True)
                        if user_diag_curr_sec.isSelected():                                             diagnose_currencies(False)
                        if user_fix_curr_sec.isSelected():                                              diagnose_currencies(True)
                        if user_fix_invalid_curr_sec.isSelected():                                      fix_invalid_relative_currency_rates()
                        if user_edit_security_decimal_places.isSelected():                              edit_security_decimal_places()
                        if user_merge_duplicate_securities.isSelected():                                merge_duplicate_securities()
                        if user_fix_duplicate_securities_within_same_investment_account.isSelected():   fix_duplicate_securities_within_same_investment_account()
                        if user_fix_invalid_price_history.isSelected():                                 fix_invalid_price_history()
                        if user_fix_nonlinked_security_records.isSelected():                            detect_fix_nonlinked_investment_security_records()
                        if user_thin_price_history.isSelected():                                        thin_price_history()
                        if user_show_open_share_lots.isSelected():                                      show_open_share_lots()
                        if user_diagnose_matched_lot_data.isSelected():                                 diagnose_matched_lot_data()
                        if user_fix_invalidLotRecords.isSelected():                                     fix_invalidLotRecords()
                        if user_convert_stock_lot_FIFO.isSelected():                                    convert_stock_lot_FIFO()
                        if user_convert_stock_avg_cst_control.isSelected():                             convert_stock_avg_cst_control()
                        if user_force_change_accounts_currency.isSelected():                            force_change_account_cat_currency()
                        if user_force_change_all_accounts_cats_currency.isSelected():                   force_change_all_accounts_categories_currencies()
                        if user_force_change_accounts_cats_from_to_currency.isSelected():               force_change_accounts_cats_from_to_currency()
                        if user_fix_price_date.isSelected():                                            manually_edit_price_date_field()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class TransactionMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                try:
                    user_view_txn_sort = JRadioButton("View Register Transactional Sort Orders", False)
                    user_view_txn_sort.setToolTipText("Allows you  to view the current transaction register sort orders in operation")

                    user_extract_attachments = JRadioButton("Extract Attachments to Folder", False)
                    user_extract_attachments.setToolTipText("Extract all your attachments to a folder of your choosing...")

                    user_diagnose_attachments = JRadioButton("DIAG: Diagnose Attachments and detect Orphans too", False)
                    user_diagnose_attachments.setToolTipText("This will analise your Attachments, show you the file storage consumed, and detect Orphans/issues")

                    syncFolder = None                                                                                       # noqa
                    try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
                    except: syncFolder = False

                    user_diagnose_fix_attachments = JRadioButton("FIX: Diagnose Attachments - DELETE Orphan attachments (** Syncing must be Disabled **)", False)
                    user_diagnose_fix_attachments.setToolTipText("This will analise your Attachments, detect Orphans/issues - AND ALLOW YOU TO DELETE THE ORPHAN ATTACHMENTS")
                    user_diagnose_fix_attachments.setEnabled(GlobalVars.UPDATE_MODE and syncFolder is None)
                    user_diagnose_fix_attachments.setForeground(getColorRed())

                    # user_move_invest_txns = JRadioButton("Move/Merge Investment Transactions from one account to another (DISABLED >> NOW RUN FROM EXTENSIONS MENU)", False)
                    user_move_invest_txns = JRadioButton("Move/Merge Investment Transactions >> NOW RUN FROM EXTENSIONS MENU <<", False)
                    user_move_invest_txns.setToolTipText("This allows you to move your investment transactions from one account into (merges with) another")
                    user_move_invest_txns.setEnabled(GlobalVars.UPDATE_MODE)
                    user_move_invest_txns.setForeground(getColorRed())
                    user_move_invest_txns.setEnabled(isToolboxUnlocked())

                    user_fix_non_hier_sec_acct_txns = JRadioButton("FIX: Non-Hierarchical Security Acct Txns (& detect Orphans) (fix_non-hierarchical_security_account_txns.py)", False)
                    user_fix_non_hier_sec_acct_txns.setToolTipText("This reviews your Investment Security Txns and fixes where the Account reference is cross-linked and incorrect (fix_non-hierarchical_security_account_txns.py & fix_investment_txns_to_wrong_security.py)")
                    user_fix_non_hier_sec_acct_txns.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_non_hier_sec_acct_txns.setForeground(getColorRed())

                    user_fix_delete_one_sided_txns = JRadioButton("FIX: Delete One-Sided Transactions (delete_invalid_txns.py)", False)
                    user_fix_delete_one_sided_txns.setToolTipText("This allows you to DELETE 'invalid' one-sided transactions - usually from a bad quicken import. THIS CHANGES DATA! (delete_invalid_txns.py)")
                    user_fix_delete_one_sided_txns.setEnabled(GlobalVars.UPDATE_MODE)
                    user_fix_delete_one_sided_txns.setForeground(getColorRed())

                    user_reverse_txn_amounts = JRadioButton("FIX: Reverse Transaction Amounts (reverse_txn_amounts.py)", False)
                    user_reverse_txn_amounts.setToolTipText("This allows you to REVERSE the transaction values/amounts for an account within a date range. THIS CHANGES DATA! (reverse_txn_amounts.py)")
                    user_reverse_txn_amounts.setEnabled(GlobalVars.UPDATE_MODE)
                    user_reverse_txn_amounts.setForeground(getColorRed())

                    user_reverse_txn_exchange_rates_by_account_and_date = JRadioButton("FIX: Reverse Transaction Exchange Rates (reverse_txn_exchange_rates_by_account_and_date)", False)
                    user_reverse_txn_exchange_rates_by_account_and_date.setToolTipText("This allows you to REVERSE the transactional exchange rates for an account within a date range. THIS CHANGES DATA! (reverse_txn_exchange_rates_by_account_and_date)")
                    user_reverse_txn_exchange_rates_by_account_and_date.setEnabled(GlobalVars.UPDATE_MODE)
                    user_reverse_txn_exchange_rates_by_account_and_date.setForeground(getColorRed())

                    user_detect_fix_txns_assigned_root = JRadioButton("FIX: Detect and fix transactions assigned to 'root' account", False)
                    user_detect_fix_txns_assigned_root.setToolTipText("This detects transactions assigned to 'root' and offers options to display/fix. THIS CHANGES DATA!")
                    user_detect_fix_txns_assigned_root.setEnabled(GlobalVars.UPDATE_MODE)
                    user_detect_fix_txns_assigned_root.setForeground(getColorRed())

                    labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Update mode **")
                    labelFYI2.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    bg = ButtonGroup()
                    bg.add(user_view_txn_sort)
                    bg.add(user_extract_attachments)
                    bg.add(user_diagnose_attachments)
                    bg.add(user_diagnose_fix_attachments)
                    bg.add(user_move_invest_txns)
                    bg.add(user_fix_non_hier_sec_acct_txns)
                    bg.add(user_fix_delete_one_sided_txns)
                    bg.add(user_reverse_txn_amounts)
                    bg.add(user_reverse_txn_exchange_rates_by_account_and_date)
                    bg.add(user_detect_fix_txns_assigned_root)
                    bg.clearSelection()

                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                    userFilters.add(user_view_txn_sort)
                    userFilters.add(user_extract_attachments)
                    userFilters.add(user_diagnose_attachments)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                    if not GlobalVars.UPDATE_MODE:
                        userFilters.add(labelFYI2)

                    # These are new features - better supported from 2021.2 onwards
                    if int(MD_REF.getBuild()) >= MD_RRATE_ISSUE_FIXED_BUILD:
                        userFilters.add(user_move_invest_txns)

                    userFilters.add(user_diagnose_fix_attachments)
                    userFilters.add(user_fix_non_hier_sec_acct_txns)
                    userFilters.add(user_fix_delete_one_sided_txns)
                    userFilters.add(user_reverse_txn_amounts)
                    userFilters.add(user_reverse_txn_exchange_rates_by_account_and_date)
                    userFilters.add(user_detect_fix_txns_assigned_root)

                    while True:

                        syncFolder = None                                                                                   # noqa
                        try: syncFolder = MD_REF.getUI().getCurrentAccounts().getSyncFolder()
                        except: syncFolder = False
                        user_diagnose_fix_attachments.setEnabled(GlobalVars.UPDATE_MODE and syncFolder is None)

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters,850,350)
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "Transaction(s) Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "Transaction(s) Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_view_txn_sort.isSelected():                                     get_register_txn_sort_orders()
                        if user_extract_attachments.isSelected():                               extract_attachments()
                        if user_diagnose_attachments.isSelected():                              diagnose_attachments()
                        if user_diagnose_fix_attachments.isSelected():                          diagnose_attachments(lFix=True)
                        if user_move_invest_txns.isSelected():                                  move_merge_investment_txns()
                        if user_fix_non_hier_sec_acct_txns.isSelected():                        fix_non_hier_sec_acct_txns()
                        if user_fix_delete_one_sided_txns.isSelected():                         fix_delete_one_sided_txns()
                        if user_reverse_txn_amounts.isSelected():                               reverse_txn_amounts()
                        if user_reverse_txn_exchange_rates_by_account_and_date.isSelected():    reverse_txn_exchange_rates_by_account_and_date()
                        if user_detect_fix_txns_assigned_root.isSelected():                     detect_fix_txns_assigned_root()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class GeneralToolsMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                try:
                    user_display_passwords = JRadioButton("Display Dataset Password/Hint and Sync Passphrase", False)
                    user_display_passwords.setToolTipText("Display the password/hint used to open your Encrypted Dataset, and also your Sync passphrase (if set)")

                    user_view_MD_config_file = JRadioButton("View MD Config File", False)
                    user_view_MD_config_file.setToolTipText("View the contents of your Moneydance configuration file")

                    user_view_searchable_console_log = JRadioButton("View Searchable Console Log", False)
                    user_view_searchable_console_log.setToolTipText("View the whole Console log file - searchable")

                    user_view_MD_custom_theme_file = JRadioButton("View MD Custom Theme File", False)
                    user_view_MD_custom_theme_file.setToolTipText("View the contents of your Moneydance custom Theme file (if you have set one up)")
                    user_view_MD_custom_theme_file.setEnabled(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))    # noqa

                    user_view_java_vmoptions = JRadioButton("View Java VM Options File", False)
                    user_view_java_vmoptions.setToolTipText("View the contents of the Java VM Options runtime file that Moneydance uses")
                    user_view_java_vmoptions.setEnabled(os.path.exists(get_vmoptions_path()))

                    user_view_extensions_details = JRadioButton("View Extension(s) details", False)
                    user_view_extensions_details.setToolTipText("View details about the Extensions installed in your Moneydance system")

                    user_view_memorised_reports = JRadioButton("View Memorised Reports", False)
                    user_view_memorised_reports.setToolTipText("View a list of your Memorised reports")

                    user_find_sync_password_in_ios_backups = JRadioButton("Find Sync Password in iOS Backups (only on Windows and Mac)", False)
                    user_find_sync_password_in_ios_backups.setToolTipText("This search for iOS backup(s) and look for your Sync Encryption password(s)")
                    user_find_sync_password_in_ios_backups.setEnabled(Platform.isOSX() or Platform.isWindows())

                    user_import_QIF = JRadioButton("'Older' Import QIF file and set parameters", False)
                    user_import_QIF.setToolTipText("Runs the 'older' MD importQIFIntoAccount() function and allows you to set parameters (you can select create Account Structure Only) - WILL IMPORT / CHANGE DATA!")

                    user_convert_timestamp = JRadioButton("Convert a TimeStamp number into a readable date/time", False)
                    user_convert_timestamp.setToolTipText("Allows you to input a TimeStamp (Milliseconds) and it will display a readable date/time")

                    user_close_dataset = JRadioButton("Close this dataset (and related windows)", False)
                    user_close_dataset.setToolTipText("Manually closes the dataset, all related windows, but leaves MD open....")
                    user_close_dataset.setEnabled(GlobalVars.UPDATE_MODE and isToolboxUnlocked())
                    user_close_dataset.setForeground(getColorRed())

                    user_rename_dataset = JRadioButton("Rename this dataset (within the same location)", False)
                    user_rename_dataset.setToolTipText("This will allow you to rename this dataset (within the same location) - THIS CHANGES DATA!")
                    user_rename_dataset.setEnabled(GlobalVars.UPDATE_MODE)
                    user_rename_dataset.setForeground(getColorRed())

                    user_relocate_dataset_internal = JRadioButton("Relocate this dataset back to the default 'internal' location", False)
                    user_relocate_dataset_internal.setToolTipText("This will allow you to relocate this dataset back to the internal default location - THIS CHANGES DATA!")
                    user_relocate_dataset_internal.setEnabled(GlobalVars.UPDATE_MODE and not AccountBookUtil.isWithinInternalStorage(MD_REF.getCurrentAccountBook()))
                    user_relocate_dataset_internal.setForeground(getColorRed())

                    user_relocate_dataset_external = JRadioButton("Relocate this dataset to another location [Note: IK do not recommend this]", False)
                    user_relocate_dataset_external.setToolTipText("This will allow you to relocate this dataset to another (non-default) location - THIS CHANGES DATA!")
                    user_relocate_dataset_external.setEnabled(GlobalVars.UPDATE_MODE and (not Platform.isOSX() or not MD_REF.getPlatformHelper().isConstrainedToSandbox()))
                    user_relocate_dataset_external.setForeground(getColorRed())

                    user_cleanup_external_files = JRadioButton("Cleanup MD's File/Open list of 'external' files (does not touch actual files)", False)
                    user_cleanup_external_files.setToolTipText("Cleans up the list of files shown on the MD File/Open menu - THIS CHANGES CONFIG.DICT!")
                    user_cleanup_external_files.setEnabled(GlobalVars.UPDATE_MODE)
                    user_cleanup_external_files.setForeground(getColorRed())

                    user_advanced_delete_int_ext_files = JRadioButton("DELETE Files from Menu>File>Open list and also from DISK", False)
                    user_advanced_delete_int_ext_files.setToolTipText("This allows you to delete internal/external filenames from the list of File>Open files settings>> AND ASKS IF YOU WANT TO DELETE THE FILES TOO..... UPDATES CONFIG.DICT/CAN DELETE FILES")
                    user_advanced_delete_int_ext_files.setForeground(getColorRed())
                    user_advanced_delete_int_ext_files.setEnabled(GlobalVars.UPDATE_MODE)

                    user_change_moneydance_fonts = JRadioButton("Set/Change Default Moneydance FONTS", False)
                    user_change_moneydance_fonts.setToolTipText("This will allow you to Set/Change the Default Moneydance Fonts. THIS CHANGES DATA!")
                    user_change_moneydance_fonts.setEnabled(GlobalVars.UPDATE_MODE and float(MD_REF.getBuild()) >= 3030)
                    user_change_moneydance_fonts.setForeground(getColorRed())

                    user_delete_custom_theme_file = JRadioButton("Delete Custom Theme file", False)
                    user_delete_custom_theme_file.setToolTipText("Delete your custom Theme file (if it exists). This is pretty safe. MD will create a new one if you select in Preferences. THIS DELETES A FILE!")
                    user_delete_custom_theme_file.setEnabled(GlobalVars.UPDATE_MODE and os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))   # noqa
                    user_delete_custom_theme_file.setForeground(getColorRed())

                    user_delete_orphan_extensions = JRadioButton("FIX: Delete Orphaned Extensions", False)
                    user_delete_orphan_extensions.setToolTipText("This will delete any references to orphaned / outdated Extensions (config.dict & .mxt files). THIS CHANGES DATA!")
                    user_delete_orphan_extensions.setEnabled(GlobalVars.UPDATE_MODE)
                    user_delete_orphan_extensions.setForeground(getColorRed())

                    user_reset_window_display_settings = JRadioButton("RESET Window Display Settings", False)
                    user_reset_window_display_settings.setToolTipText("This tells MD to 'forget' window display settings. CLOSE ALL REGISTER WINDOWS FIRST! The beauty is it keeps all other settings intact! THIS CHANGES DATA!")
                    user_reset_window_display_settings.setEnabled(GlobalVars.UPDATE_MODE and GlobalVars.i_am_an_extension_so_run_headless)
                    user_reset_window_display_settings.setForeground(getColorRed())

                    labelFYI2 = JLabel("       ** to activate Exit, Select Toolbox Options, Update mode **")
                    labelFYI2.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    bg = ButtonGroup()
                    bg.add(user_display_passwords)
                    bg.add(user_view_MD_config_file)
                    bg.add(user_view_searchable_console_log)
                    bg.add(user_view_MD_custom_theme_file)
                    bg.add(user_view_java_vmoptions)
                    bg.add(user_view_extensions_details)
                    bg.add(user_view_memorised_reports)
                    bg.add(user_find_sync_password_in_ios_backups)
                    bg.add(user_import_QIF)
                    bg.add(user_convert_timestamp)
                    bg.add(user_reset_window_display_settings)
                    bg.add(user_close_dataset)
                    bg.add(user_rename_dataset)
                    bg.add(user_relocate_dataset_internal)
                    bg.add(user_relocate_dataset_external)
                    bg.add(user_cleanup_external_files)
                    bg.add(user_advanced_delete_int_ext_files)
                    bg.add(user_change_moneydance_fonts)
                    bg.add(user_delete_custom_theme_file)
                    bg.add(user_delete_orphan_extensions)
                    bg.clearSelection()

                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("---------- READONLY FUNCTIONS ----------"))
                    userFilters.add(user_display_passwords)
                    userFilters.add(user_view_searchable_console_log)
                    userFilters.add(user_view_MD_config_file)
                    userFilters.add(user_view_MD_custom_theme_file)
                    userFilters.add(user_view_java_vmoptions)
                    userFilters.add(user_view_extensions_details)
                    userFilters.add(user_view_memorised_reports)
                    userFilters.add(user_find_sync_password_in_ios_backups)
                    userFilters.add(user_import_QIF)
                    userFilters.add(user_convert_timestamp)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))

                    if not GlobalVars.UPDATE_MODE:
                        userFilters.add(labelFYI2)

                    userFilters.add(user_reset_window_display_settings)
                    userFilters.add(user_close_dataset)
                    userFilters.add(user_rename_dataset)
                    userFilters.add(user_relocate_dataset_internal)
                    userFilters.add(user_relocate_dataset_external)
                    userFilters.add(user_cleanup_external_files)
                    userFilters.add(user_advanced_delete_int_ext_files)
                    userFilters.add(user_change_moneydance_fonts)
                    userFilters.add(user_delete_custom_theme_file)
                    userFilters.add(user_delete_orphan_extensions)

                    while True:

                        user_view_java_vmoptions.setEnabled(os.path.exists(get_vmoptions_path()))
                        user_view_MD_custom_theme_file.setEnabled(os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))                             # noqa
                        user_delete_custom_theme_file.setEnabled(GlobalVars.UPDATE_MODE and os.path.exists(ThemeInfo.customThemeFile.getAbsolutePath()))   # noqa
                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters,550,600)
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "General Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "General Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_display_passwords.isSelected():                     display_passwords()
                        if user_view_searchable_console_log.isSelected():           ViewFileButtonAction(MD_REF.getLogFile(), "MD Console Log").actionPerformed(None)
                        if user_view_MD_config_file.isSelected():                   ViewFileButtonAction(Common.getPreferencesFile(), "MD Config").actionPerformed(None)
                        if user_view_MD_custom_theme_file.isSelected():             ViewFileButtonAction(ThemeInfo.customThemeFile, "MD Custom Theme").actionPerformed(None)
                        if user_view_java_vmoptions.isSelected():                   ViewFileButtonAction(File(get_vmoptions_path()), "Java VM File").actionPerformed(None)
                        if user_view_extensions_details.isSelected():               view_extensions_details()
                        if user_view_memorised_reports.isSelected():                get_list_memorised_reports()
                        if user_find_sync_password_in_ios_backups.isSelected():     find_IOS_sync_data()
                        if user_import_QIF.isSelected():                            import_QIF()
                        if user_convert_timestamp.isSelected():                     convert_timestamp_readable_date()
                        if user_close_dataset.isSelected():                         close_dataset()
                        if user_rename_dataset.isSelected():                        rename_relocate_dataset(lRelocateDataset=False)
                        if user_relocate_dataset_internal.isSelected():             rename_relocate_dataset(lRelocateDataset=True, lRelocateToInternal=True)
                        if user_relocate_dataset_external.isSelected():             rename_relocate_dataset(lRelocateDataset=True, lRelocateToInternal=False)
                        if user_cleanup_external_files.isSelected():                cleanup_external_files_setting()
                        if user_advanced_delete_int_ext_files.isSelected():         advanced_remove_int_external_files_settings()
                        if user_change_moneydance_fonts.isSelected():               change_fonts()
                        if user_delete_custom_theme_file.isSelected():              delete_theme_file()
                        if user_delete_orphan_extensions.isSelected():              force_remove_extension()
                        if user_reset_window_display_settings.isSelected():         reset_window_positions()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class AdvancedMenuButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                # if not GlobalVars.ADVANCED_MODE: return

                try:
                    user_ofx_features = JRadioButton("OFX Advanced Mode Options appear in 'MENU: Online Banking (OFX) Tools'...", False)
                    user_ofx_features.setEnabled(False)

                    user_advanced_mode_edit_prefs = JRadioButton("ADD/CHG/DEL System Settings/Prefs (ie config.dict / LocalStorage() settings", False)
                    user_advanced_mode_edit_prefs.setToolTipText("This allows you to MODIFY (add/change/delete) config.dict and LocalStorage() (./safe/settings) keys..... CAN UPDATE DATA")
                    user_advanced_mode_edit_prefs.setForeground(getColorRed())
                    user_advanced_mode_edit_prefs.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_edit_param_keys = JRadioButton("ADD/CHG/DEL Database Object (ie Account, Currency, any object)", False)
                    user_advanced_edit_param_keys.setToolTipText("This allows you to MODIFY (add/change/delete) an Object's Parameter keys..... CAN UPDATE DATA - ONLY USE IF YOU KNOW WHAT YOU ARE DOING")
                    user_advanced_edit_param_keys.setForeground(getColorRed())
                    user_advanced_edit_param_keys.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_toggle_DEBUG = JRadioButton("Toggle Moneydance DEBUG", False)
                    user_advanced_toggle_DEBUG.setToolTipText("This will toggle Moneydance's internal DEBUG setting(s) ON/OFF.....")
                    user_advanced_toggle_DEBUG.setForeground(getColorRed())
                    user_advanced_toggle_DEBUG.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_toggle_other_DEBUGs = JRadioButton("Toggle Other Moneydance DEBUGs", False)
                    user_advanced_toggle_other_DEBUGs.setToolTipText("This will allow you to toggle other known Moneydance internal DEBUG setting(s) ON/OFF..... (these add extra messages to Console output))")
                    user_advanced_toggle_other_DEBUGs.setForeground(getColorRed())
                    user_advanced_toggle_other_DEBUGs.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_extract_from_storage = JRadioButton("Extract a File from LocalStorage", False)
                    user_advanced_extract_from_storage.setToolTipText("This allows you to select & extract (decrypt) a file from inside LocalStorage (copied to TMP dir)..... FILE SELF DESTRUCTS AFTER RESTART")
                    user_advanced_extract_from_storage.setForeground(getColorRed())
                    user_advanced_extract_from_storage.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_decrypt_dataset = JRadioButton("Decrypt entire dataset...", False)
                    user_advanced_decrypt_dataset.setToolTipText("Decrypts your entire Dataset (to a folder of your choosing)")
                    user_advanced_decrypt_dataset.setForeground(getColorRed())
                    user_advanced_decrypt_dataset.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_extract_from_sync = JRadioButton("Peek at an encrypted file located in your Sync Folder...", False)
                    user_advanced_extract_from_sync.setToolTipText("This allows you to select, extract (decrypt) and then peek at a file inside your Sync folder")
                    user_advanced_extract_from_sync.setForeground(getColorRed())
                    user_advanced_extract_from_sync.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_shrink_dataset = JRadioButton("Shrink Dataset size", False)
                    user_advanced_shrink_dataset.setToolTipText("This function deletes MD's log files of all prior changes (not needed).. Typically these are .txn, .mdtxn files...")
                    user_advanced_shrink_dataset.setForeground(getColorRed())
                    user_advanced_shrink_dataset.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_import_to_storage = JRadioButton("Import a File back into LocalStorage", False)
                    user_advanced_import_to_storage.setToolTipText("This allows you to select & import (encrypt) a file back into LocalStorage/safe/tmp dir.....")
                    user_advanced_import_to_storage.setForeground(getColorRed())
                    user_advanced_import_to_storage.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_save_trunk = JRadioButton("Save Trunk File (Flush all in-memory changes & dataset to disk)", False)
                    user_advanced_save_trunk.setToolTipText("This allows you to call the Save Trunk File function)..... Immediately flushes all in memory changes to disk, including your dataset (rather than wait for restart). UPDATES YOUR DATASET")
                    user_advanced_save_trunk.setForeground(getColorRed())
                    user_advanced_save_trunk.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_sync_push = JRadioButton("Force a refresh/PUSH of your local dataset to Sync.", False)
                    user_advanced_sync_push.setToolTipText("Push new Sync data (and rebuild remote copies). Use with care! UPDATES YOUR DATASET")
                    user_advanced_sync_push.setForeground(getColorRed())
                    user_advanced_sync_push.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_advanced_clone_dataset = JRadioButton("Clone Dataset's structure (purge transactional data)", False)
                    user_advanced_clone_dataset.setToolTipText("Clones you dataset, keeps the structures, purges the transactional data - CREATES NEW DATASET")
                    user_advanced_clone_dataset.setForeground(getColorRed())
                    user_advanced_clone_dataset.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_force_sync_off = JRadioButton("Force DISABLE/turn Sync OFF", False)
                    user_force_sync_off.setToolTipText("This sets your Sync method to None - all other settings are preserved. You can turn it back on again later - UPDATES YOUR DATASET")
                    user_force_sync_off.setForeground(getColorRed())
                    user_force_sync_off.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_force_reset_sync_settings = JRadioButton("Force RESET Sync settings (generates new SyncID and turns Sync off. You can turn it back on after MD restart)", False)
                    user_force_reset_sync_settings.setToolTipText("This resets all Sync settings, changes your Sync ID, and turns Sync off. You can then re-enable it for a fresh Sync - You can turn it back on again later - UPDATES YOUR DATASET")
                    user_force_reset_sync_settings.setForeground(getColorRed())
                    user_force_reset_sync_settings.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_toggle_sync_download_attachments = JRadioButton("Toggle Sync Downloading of Attachments", False)
                    user_toggle_sync_download_attachments.setToolTipText("Normally this defaults to ON; Change to OFF to prevent attachments downloading via Sync - UPDATES YOUR DATASET")
                    user_toggle_sync_download_attachments.setForeground(getColorRed())
                    user_toggle_sync_download_attachments.setEnabled(GlobalVars.ADVANCED_MODE)

                    user_demote_primary_to_secondary = JRadioButton("DEMOTE Primary dataset back to a Secondary Node", False)
                    user_demote_primary_to_secondary.setToolTipText("DEMOTE your Primary Sync Node/Dataset to a Secondary Node)..... UPDATES YOUR DATASET")
                    user_demote_primary_to_secondary.setEnabled(GlobalVars.ADVANCED_MODE and MD_REF.getUI().getCurrentAccounts().isMasterSyncNode())
                    user_demote_primary_to_secondary.setForeground(getColorRed())

                    lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
                    user_advanced_suppress_dropbox_warning = JRadioButton("Suppress File in Dropbox Warning", False)
                    user_advanced_suppress_dropbox_warning.setToolTipText("This allows you to suppress the 'Your file seems to be in a shared folder (Dropbox)' warning")
                    user_advanced_suppress_dropbox_warning.setEnabled(GlobalVars.ADVANCED_MODE and lDropbox and not lSuppressed)
                    user_advanced_suppress_dropbox_warning.setForeground(getColorRed())

                    userFilters = JPanel(GridLayout(0, 1))

                    bg = ButtonGroup()
                    bg.add(user_ofx_features)
                    bg.add(user_advanced_toggle_DEBUG)
                    bg.add(user_advanced_toggle_other_DEBUGs)
                    bg.add(user_advanced_extract_from_storage)
                    bg.add(user_advanced_decrypt_dataset)
                    bg.add(user_advanced_extract_from_sync)
                    bg.add(user_advanced_shrink_dataset)
                    bg.add(user_advanced_import_to_storage)
                    bg.add(user_advanced_mode_edit_prefs)
                    bg.add(user_advanced_edit_param_keys)
                    bg.add(user_advanced_clone_dataset)
                    bg.add(user_advanced_save_trunk)
                    bg.add(user_advanced_sync_push)
                    bg.add(user_force_sync_off)
                    bg.add(user_force_reset_sync_settings)
                    bg.add(user_toggle_sync_download_attachments)
                    bg.add(user_demote_primary_to_secondary)
                    bg.add(user_advanced_suppress_dropbox_warning)
                    bg.clearSelection()

                    if not GlobalVars.ADVANCED_MODE:
                        jlbl = JLabel("       ** to activate Exit, Select Toolbox Options, Advanced Mode **")
                        jlbl.setForeground(getColorRed())
                        userFilters.add(jlbl)
                    else:
                        userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("--- READONLY / NON-UPDATE FUNCTIONS ---"))
                    userFilters.add(user_advanced_toggle_DEBUG)
                    userFilters.add(user_advanced_toggle_other_DEBUGs)
                    userFilters.add(user_advanced_extract_from_storage)
                    userFilters.add(user_advanced_decrypt_dataset)
                    userFilters.add(user_advanced_extract_from_sync)
                    userFilters.add(JLabel(" "))
                    userFilters.add(JLabel("----------- UPDATE FUNCTIONS -----------"))
                    userFilters.add(user_ofx_features)
                    userFilters.add(user_advanced_shrink_dataset)
                    userFilters.add(user_advanced_clone_dataset)
                    userFilters.add(user_advanced_save_trunk)
                    userFilters.add(user_demote_primary_to_secondary)
                    userFilters.add(user_advanced_sync_push)
                    userFilters.add(user_force_sync_off)
                    userFilters.add(user_force_reset_sync_settings)
                    userFilters.add(user_toggle_sync_download_attachments)
                    userFilters.add(user_advanced_import_to_storage)
                    userFilters.add(user_advanced_mode_edit_prefs)
                    userFilters.add(user_advanced_edit_param_keys)
                    userFilters.add(user_advanced_suppress_dropbox_warning)

                    _NONE = "none"
                    _PARAM_KEY = "netsync.sync_type"
                    storage = MD_REF.getCurrentAccount().getBook().getLocalStorage()

                    while True:

                        lDropbox, lSuppressed = check_dropbox_and_suppress_warnings()
                        user_advanced_suppress_dropbox_warning.setEnabled(GlobalVars.ADVANCED_MODE and (lDropbox and not lSuppressed))
                        user_demote_primary_to_secondary.setEnabled(GlobalVars.ADVANCED_MODE and (MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))
                        user_advanced_sync_push.setEnabled(GlobalVars.ADVANCED_MODE and (MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()))
                        user_force_sync_off.setEnabled(GlobalVars.ADVANCED_MODE and (not (storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE)))
                        user_toggle_sync_download_attachments.setEnabled(GlobalVars.ADVANCED_MODE and (not (storage.get(_PARAM_KEY) is None or storage.get(_PARAM_KEY) == _NONE)))
                        user_advanced_extract_from_sync.setEnabled(GlobalVars.ADVANCED_MODE and (MD_REF.getUI().getCurrentAccounts().getSyncFolder() is not None))

                        bg.clearSelection()

                        options = ["EXIT", "PROCEED"]
                        jsp = MyJScrollPaneForJOptionPane(userFilters,850,500)
                        userAction = (JOptionPane.showOptionDialog(toolbox_frame_,
                                                                   jsp,
                                                                   "ADVANCED - Diagnostics, Tools, Fixes",
                                                                   JOptionPane.OK_CANCEL_OPTION,
                                                                   JOptionPane.QUESTION_MESSAGE,
                                                                   getMDIcon(lAlwaysGetIcon=True),
                                                                   options, options[0]))
                        if userAction != 1:
                            txt = "ADVANCED - Diagnostics, Tools, Fixes - No menu item selected..."
                            setDisplayStatus(txt, "B")
                            return

                        selectHomeScreen()      # Stops the LOT Control box popping up..... Get back to home screen....

                        if user_advanced_toggle_DEBUG.isSelected():                 advanced_mode_DEBUG()
                        if user_advanced_toggle_other_DEBUGs.isSelected():          advanced_mode_other_DEBUG()
                        if user_advanced_extract_from_storage.isSelected():         advanced_mode_decrypt_file()
                        if user_advanced_decrypt_dataset.isSelected():              advanced_mode_decrypt_dataset()
                        if user_advanced_extract_from_sync.isSelected():            advanced_mode_decrypt_file_from_sync()
                        if user_advanced_shrink_dataset.isSelected():               advanced_mode_shrink_dataset()
                        if user_advanced_import_to_storage.isSelected():            advanced_mode_encrypt_file()
                        if user_advanced_mode_edit_prefs.isSelected():              advanced_mode_edit_prefs()
                        if user_advanced_edit_param_keys.isSelected():              advanced_mode_edit_parameter_keys()
                        if user_advanced_save_trunk.isSelected():                   advanced_mode_save_trunk_file()
                        if user_advanced_sync_push.isSelected():                    advanced_mode_sync_push_pull("PUSH")
                        if user_advanced_clone_dataset.isSelected():                advanced_clone_dataset()
                        if user_force_sync_off.isSelected():                        advanced_mode_force_sync_off()
                        if user_force_reset_sync_settings.isSelected():             advanced_mode_force_reset_sync_settings()
                        if user_toggle_sync_download_attachments.isSelected():      toggle_sync_download_attachments()
                        if user_demote_primary_to_secondary.isSelected():           advanced_mode_demote_primary_to_secondary()
                        if user_advanced_suppress_dropbox_warning.isSelected():     advanced_mode_suppress_dropbox_warning()

                        for button in bg.getElements():
                            if button.isSelected(): return      # Quit the menu system after running something....

                        continue

                except:
                    myPopupInformationBox(toolbox_frame_,"ALERT: Toolbox function has crashed (review console) - Contact author!", "UNEXPECTED ERROR", JOptionPane.ERROR_MESSAGE)
                    dump_sys_error_to_md_console_and_errorlog()

        class ConvertSecondaryButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                # convert_secondary_to_primary_data_set

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                if MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():
                    txt = "Your dataset is already Master - NO CHANGES MADE!"
                    setDisplayStatus(txt, "R")
                    myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                    return

                if myPopupAskQuestion(toolbox_frame_,
                                      "MAKE this SECONDARY a PRIMARY/MASTER NODE",
                                      "Are you sure you want to make this secondary dataset the Primary?",
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.ERROR_MESSAGE):

                    if doesUserAcceptDisclaimer(toolbox_frame_, "MAKE this SECONDARY a PRIMARY/MASTER NODE", "Are you really sure you want to change this secondary into the Primary?"):
                        if not backup_local_storage_settings():
                            txt = "MAKE ME PRIMARY: ERROR making backup of LocalStorage() ./safe/settings - NO CHANGES MADE!"
                            setDisplayStatus(txt, "R")
                            myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)
                            return

                        MD_REF.getUI().getCurrentAccounts().setIsMasterSyncNode(True)
                        MD_REF.getCurrentAccount().getBook().getLocalStorage().save()        # Flush local storage to safe/settings

                        play_the_money_sound()
                        txt = "Dataset Promoted to Primary/Master Node/Dataset - MONEYDANCE WILL NOW RESTART"
                        setDisplayStatus(txt, "R")
                        myPrint("B", txt)
                        myPopupInformationBox(toolbox_frame_, txt, "PRIMARY DATASET", JOptionPane.WARNING_MESSAGE)
                        ManuallyCloseAndReloadDataset.moneydanceExitOrRestart(lRestart=True)
                        return

                txt = "User did not say yes to Master Node promotion - NO CHANGES MADE"
                setDisplayStatus(txt, "R")
                myPopupInformationBox(toolbox_frame_,txt,theMessageType=JOptionPane.WARNING_MESSAGE)

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")

        class AnalyseDatasetSizeButtonAction(AbstractAction):

            def __init__(self): pass

            def actionPerformed(self, event):
                # show_object_type_quantities.py

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )

                output = "DATASET FILE ANALYSIS\n" \
                         " ====================\n\n"

                startDir=MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()
                output += "Dataset path: %s\n\n" %(startDir)

                attach = MD_REF.getCurrentAccountBook().getAttachmentsFolder()
                keyDir = startDir
                trunkDir = os.path.join(startDir,"safe","tiksync")
                attachDir = os.path.join(startDir,"safe", attach)
                settingsDir = os.path.join(startDir,"safe")
                archiveDir = os.path.join(startDir,"safe","archive")
                sync_outDir = os.path.join(startDir,"safe","tiksync", "out")

                sync_outCount = 0
                sync_outSize = 0

                safe_settingsSize = 0
                safe_attachmentsSize = 0
                countAttachments = 0
                safe_archiveSize = 0
                countArchiveFiles = 0
                safe_trunkSize = 0
                safe_tiksyncSize = 0
                countTIKfiles = 0
                # safe_tmpSize = 0
                keySize = 0
                countValidFiles=0
                countNonValidFiles=0
                validSize=0
                nonValidSize=0
                listNonValidFiles=[]
                listLargeFiles=[]

                total_size = 0
                start_path = startDir  # To get size of current directory
                for path, dirs, files in os.walk(start_path):
                    for f in files:
                        lValidFile = False

                        fp = os.path.join(path, f)
                        thisFileSize = os.path.getsize(fp)

                        total_size += thisFileSize

                        if os.path.basename(f) == "key" and path==keyDir and len:
                            lValidFile = True
                            keySize=thisFileSize
                        if os.path.basename(f) == "settings" and path==settingsDir:
                            lValidFile = True
                            safe_settingsSize=thisFileSize
                        if os.path.basename(f) == "trunk" and path==trunkDir:
                            lValidFile = True
                            safe_trunkSize=thisFileSize
                        if path[:len(sync_outDir)] == sync_outDir and (f.endswith(".txn") ):
                            lValidFile = True
                            sync_outSize+=thisFileSize
                            sync_outCount+=1
                        if path[:len(trunkDir)] == trunkDir and (f.endswith("trunk") or f.endswith(".mdtxn") or f.endswith("processed.dct") or f.endswith("delete_to_push_sync_info") or f.endswith(".txn") or f.endswith("force_push_resync") ):
                            lValidFile = True
                            safe_tiksyncSize+=thisFileSize
                            countTIKfiles+=1
                        if path[:len(attachDir)] == attachDir:
                            lValidFile = True
                            safe_attachmentsSize+=thisFileSize
                            countAttachments+=1
                        if path[:len(archiveDir)] == archiveDir and f.endswith(".mdtxnarchive"):
                            lValidFile = True
                            safe_archiveSize+=thisFileSize
                            countArchiveFiles+=1

                        if lValidFile:
                            countValidFiles+=1
                            validSize+=thisFileSize
                            if thisFileSize>500000:
                                listLargeFiles.append([fp,
                                                       thisFileSize,
                                                       pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11)])
                        else:
                            countNonValidFiles+=1
                            nonValidSize+=thisFileSize
                            listNonValidFiles.append([fp,
                                                      thisFileSize,
                                                      pad(datetime.datetime.fromtimestamp(os.path.getmtime(fp)).strftime(convertMDShortDateFormat_strftimeFormat(lForceYYMMDDHMS=True)),11)])

                output+=("Dataset size:               %sMB\n" %(rpad(convertBytesMBs(total_size),12)))
                output+=("- settings file size:       %sKB\n" %(rpad(convertBytesKBs(safe_settingsSize),12)))
                output+=("- key file size:            %sKB\n" %(rpad(convertBytesKBs(keySize),12)))
                output+=("- tiksync folder size:      %sMB (with %s files)\n" %(rpad(convertBytesMBs(safe_tiksyncSize),12),countTIKfiles))
                output+=("  (note trunk file size:    %sMB)\n" %(rpad(convertBytesMBs(safe_trunkSize),12)))

                if sync_outCount:
                    output+=("  (WAITING Sync 'Out' size: %sMB with %s files)\n" %(rpad(convertBytesMBs(sync_outSize),12),sync_outCount))

                output+=("- attachments size:         %sMB (in %s attachments)\n" %(rpad(convertBytesMBs(safe_attachmentsSize),12),countAttachments))
                output+=("- archive size:             %sMB (in %s files)\n" %(rpad(convertBytesMBs(safe_archiveSize),12),countArchiveFiles))
                output+=("---------------------------------------------\n")
                output+=("Valid files size:           %sMB (in %s files)\n\n" %(rpad(convertBytesMBs(validSize),12),countValidFiles))
                output+=("Non-core file(s) size:      %sMB (in %s files)\n" %(rpad(convertBytesMBs(nonValidSize),12),countNonValidFiles))
                for nonValid in listNonValidFiles:
                    output+=("   - Non-core: %sMB %s\n" %(rpad(convertBytesMBs(nonValid[1]),5),nonValid[0]))
                output+="\n\n"

                if len(listLargeFiles):
                    output+=("\nLARGE (core) file(s) > 0.5MB....:\n")
                    for largefile in listLargeFiles:
                        output+=("   - %sMB Mod: %s %s\n" %(rpad(convertBytesMBs(largefile[1]),5),largefile[2], largefile[0]))
                output+="\n\n"

                output+=(count_database_objects())

                output+=(find_other_datasets())

                output+="<END>"

                QuickJFrame("VIEW DATASET FILE ANALYSIS", output,copyToClipboard=lCopyAllToClipBoard_TB, lWrapText=False).show_the_frame()

                txt = ("Your dataset contains %s files and is %sMB. %s non-core files were found consuming %sMB"
                       %(countValidFiles,convertBytesMBs(validSize),countNonValidFiles,convertBytesMBs(nonValidSize)))
                setDisplayStatus(txt, "B")

                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        class DoTheMenu(AbstractAction):

            def __init__(self, displayPanel, menu, callingClass=None):
                self.displayPanel = displayPanel
                self.menu = menu
                self.callingClass = callingClass

            def actionPerformed(self, event):
                global debug, lCopyAllToClipBoard_TB, lAutoPruneInternalBackups_TB  # Global must be here as we set these variables

                myPrint("D", "In ", inspect.currentframe().f_code.co_name, "()", "Event: ", event )
                myPrint("DB", "DoTheMenu() - Command: '%s'" %(event.getActionCommand()))

                # ##########################################################################################################
                if event.getActionCommand() == "Page Setup":
                    pageSetup()

                # ##########################################################################################################
                if event.getActionCommand() == "Help":
                    DisplayHelp().actionPerformed(None)

                # ##########################################################################################################
                if event.getActionCommand() == "About Toolbox":
                    AboutThisScript(toolbox_frame_).go()

                # ##########################################################################################################
                if event.getActionCommand() == "About Moneydance":
                    # MD_REF.getUI().showAbout()
                    abtWin = AboutWindow(MD_REF.getUI(), toolbox_frame_)

                    try: abtWin.setEscapeKeyCancels(True)
                    except: pass

                    abtWin.setVisible(True)


                # ##########################################################################################################
                if event.getActionCommand() == "Auto Prune Internal Backups":

                    if not lAutoPruneInternalBackups_TB:
                        if not myPopupAskQuestion(toolbox_frame_,
                                                  "AUTO PRUNE INTERNAL BACKUPS",
                                                  "Turn on Auto-Prune of internal backups of config.dict & settings (will always keep 5 days and/or 5 copies)?",
                                                  JOptionPane.YES_NO_OPTION,
                                                  JOptionPane.WARNING_MESSAGE):
                            txt = "AUTO-PRUNE INTERNAL BACKUPS DISABLED AS USER DECLINED TO PROCEED"
                            setDisplayStatus(txt, "R")

                            event.getSource().setSelected(False)

                            return
                        else:
                            myPrint("B", "@@ User asked to turn ON auto-prune of internal backups of config.dict and settings (5 days/5 copies).....")
                    else:
                        myPrint("B", "User asked to turn OFF the auto-prune of internal backups of config.dict and settings.....")

                    lAutoPruneInternalBackups_TB = not lAutoPruneInternalBackups_TB

                    if lAutoPruneInternalBackups_TB:
                        prune_internal_backups()

                # ##########################################################################################################
                if event.getActionCommand() == "Debug" or event.getActionCommand() == "Debug":
                    if debug:
                        txt = "Script Debug mode disabled"
                        setDisplayStatus(txt, "DG")
                    else:
                        txt = "Script Debug mode enabled..."
                        setDisplayStatus(txt, "DG")
                        myPrint("B", txt)

                    debug = not debug
                    GlobalVars.mainPnl_debug_lbl.setText("<DEBUG ON>" if debug else "")

                # ##########################################################################################################
                if event.getActionCommand() == "Copy all Output to Clipboard":
                    if lCopyAllToClipBoard_TB:
                        txt = "Diagnostic outputs will NOT be copied to Clipboard"
                        setDisplayStatus(txt, "DG")
                    else:
                        txt = "Diagnostic outputs WILL now all be copied to the Clipboard"
                        setDisplayStatus(txt, "DG")
                        myPrint("B", txt)

                    lCopyAllToClipBoard_TB = not lCopyAllToClipBoard_TB

                # ##########################################################################################################
                if event.getActionCommand() == "Advanced Mode":

                    if not GlobalVars.ADVANCED_MODE:
                        if not myPopupAskQuestion(toolbox_frame_,
                                              "ADVANCED MODE",
                                              "ADVANCED MODE >> DISCLAIMER: DO YOU ACCEPT THAT YOU USE THIS TOOLBOX AT YOUR OWN RISK?",
                                                  JOptionPane.YES_NO_OPTION,
                                                  JOptionPane.ERROR_MESSAGE):
                            txt = "ADVANCED MODE DISABLED AS USER DECLINED DISCLAIMER"
                            setDisplayStatus(txt, "R")
                            myPrint("B", txt)

                            event.getSource().setSelected(False)

                            return
                        else:
                            myPrint("B", "User accepted Disclaimer and agreed to use Toolbox Advanced Mode at own risk.....")

                            backup = BackupButtonAction("Would you like to create a backup before starting Advanced Mode?")
                            backup.actionPerformed(None)

                            if not backup_local_storage_settings() or not backup_config_dict():
                                txt = "ADVANCED MODE DISABLED: SORRY - ERROR WHEN SAVING LocalStorage() ./safe/settings and config.dict to backup file!!??"
                                setDisplayStatus(txt, "R")

                                event.getSource().setSelected(False)
                                return

                            myPrint("B","@@ ADVANCED MODE ENABLED. config.dict and safe/settings have been backed up...! @@")

                            txt = "ADVANCED MODE SELECTED - ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING - THIS CAN CHANGE DATA!"
                            setDisplayStatus(txt, "R")
                    else:
                        txt = "ADVANCED MODE DISABLED"
                        setDisplayStatus(txt, "B")
                        myPrint("B",txt)

                    GlobalVars.ADVANCED_MODE = not GlobalVars.ADVANCED_MODE
                    for btn in GlobalVars.allButtonsList: btn.setColorsAndVisibility()
                    GlobalVars.mainPnl_advancedMode_lbl.setText("<ADVANCED MODE>" if GlobalVars.ADVANCED_MODE else "")

                # ##########################################################################################################
                if event.getActionCommand() == "Update Mode":
                    if not GlobalVars.UPDATE_MODE and myPopupAskQuestion(toolbox_frame_,
                                          "ENABLE UPDATE MODE",
                                          "UPDATE MODE >> DISCLAIMER: DO YOU ACCEPT THAT YOU USE THIS TOOLBOX AT YOUR OWN RISK?",
                                          JOptionPane.YES_NO_OPTION,
                                          JOptionPane.ERROR_MESSAGE):

                        myPrint("B", "User accepted Disclaimer and agreed to enable Toolbox UPDATE mode (at own risk).....")

                        backup = BackupButtonAction("Would you like to create a backup before enabling UPDATE mode?")
                        backup.actionPerformed(None)

                        txt = "UPDATE MODE ENABLED - RED BUTTONS CAN CHANGE YOUR DATA (%s+I for Help)" %(MD_REF.getUI().ACCELERATOR_MASK_STR)
                        setDisplayStatus(txt, "R")

                        GlobalVars.UPDATE_MODE = True

                    else:

                        txt = "BASIC MODE IN OPERATION (Update mode NOT enabled)"
                        setDisplayStatus(txt, "DG")

                        GlobalVars.UPDATE_MODE = False

                    event.getSource().setSelected(GlobalVars.UPDATE_MODE)

                    for btn in GlobalVars.allButtonsList: btn.setColorsAndVisibility()

                    GlobalVars.mainPnl_updateMode_lbl.setText("<UPDATE MODE>" if GlobalVars.UPDATE_MODE else "")


                # Save parameters now...
                if (event.getActionCommand() == "Copy all Output to Clipboard"
                        or event.getActionCommand() == "Debug"
                        or event.getActionCommand() == "Auto Prune Internal Backups"):

                    try:
                        save_StuWareSoftSystems_parameters_to_file()
                    except:
                        myPrint("B", "Error - failed to save parameters to pickle file...!")
                        dump_sys_error_to_md_console_and_errorlog()


                myPrint("D", "Exiting ", inspect.currentframe().f_code.co_name, "()")
                return

        def openDisplay(self):
            global toolbox_frame_   # global must be here as we define it here

            # ConsoleWindow.showConsoleWindow(MD_REF.getUI())
            advanced_mode_DEBUG(lForceON=True)

            screenSize = Toolkit.getDefaultToolkit().getScreenSize()

            # JFrame.setDefaultLookAndFeelDecorated(True)   # Note: Darcula Theme doesn't like this and seems to be OK without this statement...
            toolbox_frame_ = MyJFrame(u"Toolbox - Infinite Kind (co-authored by StuWareSoftSystems)... (%s+I for Help) - DATASET: %s" % (MD_REF.getUI().ACCELERATOR_MASK_STR, MD_REF.getCurrentAccountBook().getName().strip()))
            toolbox_frame_.setName(u"%s_main" %myModuleID)
            self.theFrame = toolbox_frame_

            ManuallyCloseAndReloadDataset.THIS_APPS_FRAME_REFERENCE = toolbox_frame_

            if (not Platform.isOSX()):
                MD_REF.getUI().getImages()
                toolbox_frame_.setIconImage(MDImages.getImage(MD_REF.getSourceInformation().getIconResource()))

            toolbox_frame_.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE)  # The CloseAction() and WindowListener() will handle dispose() - else change back to DISPOSE_ON_CLOSE

            displayString = buildDiagText()

            GlobalVars.STATUS_LABEL = JLabel("Infinite Kind (Moneydance) support tool >> DIAG STATUS: BASIC MODE RUNNING...", JLabel.LEFT)
            GlobalVars.STATUS_LABEL.setForeground(GlobalVars.DARK_GREEN)
            GlobalVars.STATUS_LABEL.setBorder(BorderFactory.createLineBorder(MD_REF.getUI().getColors().headerBorder, 2))

            try:
                if lCopyAllToClipBoard_TB:
                    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(StringSelection(displayString), None)
            except:
                myPrint("J","Error copying diagnostic's main screen contents to Clipboard")
                dump_sys_error_to_md_console_and_errorlog()

            shortcut = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, (shortcut | Event.SHIFT_MASK)), "unlock-window")   # So Plus on Mac...
            toolbox_frame_.getRootPane().getActionMap().put("unlock-window", self.UnlockAction(toolbox_frame_))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_SLASH, (shortcut)), "quick-jvm-diags")  # So / on Mac...
            toolbox_frame_.getRootPane().getActionMap().put("quick-jvm-diags", self.QuickJVMDiags(toolbox_frame_))

            # Add standard CMD-W keystrokes etc to close window
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, shortcut), "close-window")
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F4, shortcut), "close-window")
            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_F,  shortcut), "search-window")
            toolbox_frame_.getRootPane().getActionMap().put("close-window", self.CloseAction(toolbox_frame_))
            toolbox_frame_.addWindowListener(self.WindowListener(toolbox_frame_, self))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, shortcut), "display-pickle")
            toolbox_frame_.getRootPane().getActionMap().put("display-pickle", DisplayPickleFile())

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_U, (shortcut | Event.SHIFT_MASK)), "display-UUID")
            toolbox_frame_.getRootPane().getActionMap().put("display-UUID", self.DisplayUUID(toolbox_frame_))

            toolbox_frame_.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_I, shortcut), "display-help")
            toolbox_frame_.getRootPane().getActionMap().put("display-help", DisplayHelp())

            frame_width = min(1024, min(screenSize.width-20, max(1024,int(round(GetFirstMainFrame.getSize().width *.95,0)))))
            frame_height = min(screenSize.height-20, max(768, int(round(GetFirstMainFrame.getSize().height *.95,0))))

            toolbox_frame_.setPreferredSize(Dimension(frame_width, frame_height))

            # if MD_REF.getUI().firstMainFrame.getExtendedState() != JFrame.ICONIFIED:
            #     toolbox_frame_.setExtendedState(MD_REF.getUI().firstMainFrame.getExtendedState())
            # else:
            #     toolbox_frame_.setExtendedState(JFrame.MAXIMIZED_BOTH)

            toolbox_frame_.setExtendedState(JFrame.NORMAL)

            mainPnl = JPanel(GridBagLayout())

            if lAutoPruneInternalBackups_TB:
                prune_internal_backups(lStartup=True)
            else:
                myPrint("J","Auto-prune of internal backups of config.dict, custom_theme.properties, ./safe/settings files is disabled... so no action")

            # --------------------------------------------------------------------------------------------------
            # START OF BUTTONS

            class MyJButton(JButton):
                def __init__(self, *args, **kwargs):
                    self.btnSize = Dimension(170,40)
                    # self.maxBtnSize = Dimension(170,80)
                    self.advancedCapable = kwargs.pop("advancedCapable", False)
                    self.updateCapable = kwargs.pop("updateCapable", False)
                    self.adhocButton = kwargs.pop("adhocButton", False)
                    self.backupButton = kwargs.pop("backupButton", False)
                    self.registerMDButton = kwargs.pop("registerMDButton", False)

                    super(JButton, self).__init__(*args)
                    self.setBorderPainted(False)
                    self.setOpaque(True)
                    self.setMinimumSize(self.btnSize)
                    # self.setMaximumSize(self.maxBtnSize)
                    self.setPreferredSize(self.btnSize)
                    self.setColorsAndVisibility()

                # def getPreferredSize(self):
                #     return self.btnSize

                def setColorsAndVisibility(self):

                    normalFG = MD_REF.getUI().getColors().defaultTextForeground
                    # normalBG = MD_REF.getUI().getColors().secondaryTextFG  # Just works across all themes better than 'defaultTextForeground'
                    normalBG = Color.LIGHT_GRAY

                    backupFG = MD_REF.getUI().getColors().hudFG
                    backupBG = getColorDarkGreen()
                    backupBOLD = True

                    registerMDFG = MD_REF.getUI().getColors().hudFG
                    registerMDBG = getColorRed()
                    registerMDBOLD = True

                    adhocFG = getColorRed()
                    adhocBG = normalBG
                    adhocBOLD = False

                    advancedEnabledFG = MD_REF.getUI().getColors().hudFG
                    advancedEnabledBG = getColorRed()
                    advancedEnabledBOLD = True

                    updateEnabledFG = getColorRed()
                    updateEnabledBOLD = False

                    if isMDThemeDark() or isMacDarkModeDetected(): pass
                    elif isMDThemeVAQua(): pass
                    elif isMDThemeDefault(): pass
                    elif isMDThemeClassic(): pass
                    elif isMDThemeHighContrast(): pass
                    elif isMDThemeSolarizedLight(): pass
                    elif isMDThemeSolarizedDark(): pass
                    elif isMDThemeCustomizable(): pass


                    if self.isBackupButton():
                        self.setForeground(backupFG)
                        self.setBackground(backupBG)
                        if backupBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        return

                    if self.isRegisterMDButton():
                        self.setForeground(registerMDFG)
                        self.setBackground(registerMDBG)
                        if registerMDBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        return

                    if self.isAdhocButton():
                        self.setForeground(adhocFG)
                        self.setBackground(adhocBG)
                        if adhocBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        self.setVisible(GlobalVars.UPDATE_MODE)
                        return

                    if self.isAdvancedCapable() and GlobalVars.ADVANCED_MODE and not self.isUpdateCapable():
                        self.setForeground(advancedEnabledFG)
                        self.setBackground(advancedEnabledBG)
                        if advancedEnabledBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                        return

                    if ((self.isUpdateCapable() and GlobalVars.UPDATE_MODE)
                            or (self.isAdvancedCapable() and GlobalVars.ADVANCED_MODE)):
                        self.setForeground(updateEnabledFG)
                        if updateEnabledBOLD: self.setFont(self.getFont().deriveFont(Font.BOLD))
                    else:
                        self.setForeground(normalFG)

                    self.setFont(self.getFont().deriveFont(Font.PLAIN))
                    self.setBackground(normalBG)

                def isBackupButton(self): return self.backupButton
                def isRegisterMDButton(self): return self.registerMDButton
                def isAdhocButton(self): return self.adhocButton
                def isAdvancedCapable(self): return self.advancedCapable
                def isUpdateCapable(self): return self.updateCapable

                def updateUI(self):
                    super(MyJButton, self).updateUI()
                    self.setColorsAndVisibility()


            backup_button = MyJButton("<html><center>CREATE BACKUP</center></html>", backupButton=True)
            backup_button.setToolTipText("This will allow you to take a backup of your Moneydance Dataset")
            backup_button.addActionListener(BackupButtonAction("Confirm you want to create a backup (same as MD Menu>File>Export Backup)?"))
            GlobalVars.allButtonsList.append(backup_button)

            analiseDatasetSize_button = MyJButton("<html><center>Analyse Dataset<BR>Objs, Size & Files</center></html>")
            analiseDatasetSize_button.setToolTipText("This quickly analyse the contents of your dataset and show you your Object counts, file sizes, what's taking space, and non-valid files...(show_object_type_quantities.py)")
            analiseDatasetSize_button.addActionListener(self.AnalyseDatasetSizeButtonAction())
            GlobalVars.allButtonsList.append(analiseDatasetSize_button)

            findDataset_button = MyJButton("<html><center>Find My Dataset(s)<BR>and Backups</center></html>")
            findDataset_button.setToolTipText("This will search your hard disk for copies of your Moneydance Dataset(s) - incl Backups.... NOTE: Can be CPU & time intensive..!")
            findDataset_button.addActionListener(self.FindDatasetButtonAction())
            GlobalVars.allButtonsList.append(findDataset_button)

            generalToolsMenu_button = MyJButton("<html><center>MENU: General<BR>tools</center></html>", updateCapable=True)
            generalToolsMenu_button.setToolTipText("Menu containing a variety of general Diagnostics, Fixes and Tools...")
            generalToolsMenu_button.addActionListener(self.GeneralToolsMenuButtonAction())
            GlobalVars.allButtonsList.append(generalToolsMenu_button)

            onlineBankingTools_button = MyJButton("<html><center>MENU: Online Banking<BR>(OFX) Tools</center></html>", updateCapable=True, advancedCapable=True)
            onlineBankingTools_button.setToolTipText("A selection of tools for Online Banking - SOME OPTIONS CAN CHANGE DATA!")
            onlineBankingTools_button.addActionListener(self.OnlineBankingToolsButtonAction())
            GlobalVars.allButtonsList.append(onlineBankingTools_button)

            # ----------------------------------------------------------------------------------------------------------

            currencySecurityMenu_button = MyJButton("<html><center>MENU: Currency<BR>& Security tools</center></html>", updateCapable=True)
            currencySecurityMenu_button.setToolTipText("Menu containing Currency/Security Diagnostics, Fixes and Tools...")
            currencySecurityMenu_button.addActionListener(self.CurrencySecurityMenuButtonAction())
            GlobalVars.allButtonsList.append(currencySecurityMenu_button)

            accountsCategoryMenu_button = MyJButton("<html><center>MENU: Accounts<BR>& Categories tools</center></html>", updateCapable=True)
            accountsCategoryMenu_button.setToolTipText("Menu containing Account and Category Diagnostics, Fixes and Tools...")
            accountsCategoryMenu_button.addActionListener(self.AccountsCategoriesMenuButtonAction())
            GlobalVars.allButtonsList.append(accountsCategoryMenu_button)

            transactionMenu_button = MyJButton("<html><center>MENU: Transactions<BR>tools</center></html>", updateCapable=True)
            transactionMenu_button.setToolTipText("Menu containing Transactional Diagnostics, Fixes and Tools...")
            transactionMenu_button.addActionListener(self.TransactionMenuButtonAction())
            GlobalVars.allButtonsList.append(transactionMenu_button)

            CuriousViewInternalSettings_button = MyJButton("<html><center>CURIOUS?<BR>View Internal Settings</center></html>")
            CuriousViewInternalSettings_button.setToolTipText("This allows you to display very Technical Information on the Moneydance System and many key objects..... READONLY")
            CuriousViewInternalSettings_button.addActionListener(CuriousViewInternalSettingsButtonAction())
            GlobalVars.allButtonsList.append(CuriousViewInternalSettings_button)

            advancedMenu_button = MyJButton("<html><center>ADVANCED MODE</center></html>", advancedCapable=True)
            advancedMenu_button.setToolTipText("Menu containing 'Advanced' Tools...")
            advancedMenu_button.addActionListener(self.AdvancedMenuButtonAction())
            GlobalVars.allButtonsList.append(advancedMenu_button)

            # ----------------------------------------------------------------------------------------------------------

            # These are instant fix buttons
            if not MD_REF.isRegistered():
                RegisterMD_button = MyJButton("<html><center>REGISTER<BR>MONEYDANCE</center></html>", registerMDButton=True)
                RegisterMD_button.setToolTipText("This allows you to enter your registration key")
                RegisterMD_button.addActionListener(self.RegisterMoneydance(RegisterMD_button))
                GlobalVars.allButtonsList.append(RegisterMD_button)

            if (not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode()):
                convertSecondary_button = MyJButton("<html><center>FIX: Make me a<BR>Primary dataset</center></html>", adhocButton=True)
                convertSecondary_button.setToolTipText("Promotes this Dataset a Primary / Master Dataset. Enables Sync options. (typically after restore from a synchronised secondary dataset/backup). THIS CHANGES DATA!")
                convertSecondary_button.addActionListener(self.ConvertSecondaryButtonAction())
                convertSecondary_button.setVisible(False)
                GlobalVars.allButtonsList.append(convertSecondary_button)

            if (not check_for_dropbox_folder()):
                createMoneydanceSyncFolder_button = MyJButton("<html><center>FIX: Create Dropbox<BR>Sync Folder</center></html>", adhocButton=True)
                createMoneydanceSyncFolder_button.setToolTipText("This will allow you to add the missing .moneydancesync folder in Dropbox. THIS CREATES A FOLDER!")
                createMoneydanceSyncFolder_button.addActionListener(self.MakeDropBoxSyncFolder(createMoneydanceSyncFolder_button))
                createMoneydanceSyncFolder_button.setVisible(False)
                GlobalVars.allButtonsList.append(createMoneydanceSyncFolder_button)

            lTabbingModeNeedsChanging = False
            if (isOSXVersionBigSurOrLater()
                    and int(MD_REF.getBuild()) < 3065
                    and not DetectAndChangeMacTabbingMode(True).actionPerformed("quick check")):
                lTabbingModeNeedsChanging = True
                fixTabbingMode_button = MyJButton("<html><center>FIX: MacOS<BR>Tabbing Mode</center></html>", adhocButton=True)
                fixTabbingMode_button.setToolTipText("This allows you to check/fix your MacOS Tabbing Setting")
                fixTabbingMode_button.addActionListener(DetectAndChangeMacTabbingMode(False))
                fixTabbingMode_button.setVisible(False)
                GlobalVars.allButtonsList.append(fixTabbingMode_button)

            lWindowLocationsNeedZapping = False
            if (DetectInvalidWindowLocations(True).actionPerformed("quick_check")):
                lWindowLocationsNeedZapping = True
                fixInvalidWindowLocations_button = MyJButton("<html><center>FIX: Zap Invalid<BR>Window Locations</center></html>", adhocButton=True)
                fixInvalidWindowLocations_button.setToolTipText("This will zap any invalid window locations detected (i.e. they are 'off-screen')")
                fixInvalidWindowLocations_button.addActionListener(DetectInvalidWindowLocations(False))
                fixInvalidWindowLocations_button.setVisible(False)
                GlobalVars.allButtonsList.append(fixInvalidWindowLocations_button)

            if MD_REF.getCurrentAccount().getBook().getLocalStorage().getStr("migrated.netsync.dropbox.fileid", None):
                FixDropboxOneWaySync_button = MyJButton("<html><center>FIX: Remove Legacy<BR>Dropbox Sync Key</center></html>", adhocButton=True)
                FixDropboxOneWaySync_button.setToolTipText("This removes the key 'migrated.netsync.dropbox.fileid' to fix Dropbox One-way & iCloud Syncing issues (reset_sync_and_dropbox_settings.py)")
                FixDropboxOneWaySync_button.addActionListener(self.FixDropboxOneWaySyncButtonAction(FixDropboxOneWaySync_button))
                FixDropboxOneWaySync_button.setVisible(False)
                GlobalVars.allButtonsList.append(FixDropboxOneWaySync_button)

            # end of instant fix buttons
            # ----------------------------------------------------------------------------------------------------------

            ipady = 0                                                                                                   # noqa
            ipadx = 0                                                                                                   # noqa
            topInset = 5                                                                                                # noqa
            colLeftInset = 5                                                                                            # noqa
            colRightInset = 5                                                                                           # noqa
            colInsetFiller = 0                                                                                          # noqa

            onCol = 0
            onRow = 0
            for iButton in range(0,len(GlobalVars.allButtonsList)):
                if onCol >= 5:
                    onCol = 0
                    onRow += 1
                btn = GlobalVars.allButtonsList[iButton]
                colInsetFiller = 5 if onCol >= 4 else 0
                mainPnl.add(btn, GridC.getc(onCol, onRow).wx(0.1).wy(4.0).leftInset(colLeftInset).rightInset(colInsetFiller).topInset(topInset).fillboth())
                onCol += 1

            # ----------------------------------------------------------------------------------------------------------

            onCol = 0
            onRow += 1

            myDiagText = JTextArea(displayString)
            myDiagText.setEditable(False)
            lineWrap = False
            # if isMDThemeVAQua() and float(MD_REF.getBuild()) < 4077: lineWrap = True    # Bug in VAQua9.. Seems OK in VAQua10
            myDiagText.setLineWrap(lineWrap)
            if lineWrap: myDiagText.setWrapStyleWord(True)
            myDiagText.setFont(getMonoFont())

            mySearchAction = SearchAction(toolbox_frame_,myDiagText)
            toolbox_frame_.getRootPane().getActionMap().put("search-window", mySearchAction)

            topInset = 5
            botInset = 5
            ipady = 15
            ipadx = 5
            colSpan = 5
            colInsetFiller = 5
            colLeftInset = 5

            mainPnl.add(GlobalVars.STATUS_LABEL,
                                     GridC.getc(onCol, onRow).pady(ipady).padx(ipadx).leftInset(colLeftInset).rightInset(colInsetFiller).fillx().colspan(colSpan).topInset(topInset).bottomInset(botInset))
            # ----------------------------------------------------------------------------------------------------------

            self.myScrollPane = JScrollPane(myDiagText, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
            # self.myScrollPane.setBorder(BorderFactory.createLineBorder((MD_REF.getUI().getColors()).mainPanelBorderColor, 1))  # This causes VAQua9 bug (OK in VAQua10)
            self.myScrollPane.setViewportBorder(EmptyBorder(1, 5, 5, 5))
            self.myScrollPane.setOpaque(False)
            self.myScrollPane.setWheelScrollingEnabled(True)

            onCol = 0
            onRow += 1
            colSpan = 6
            mainPnl.add(self.myScrollPane, GridC.getc(onCol, onRow).fillboth().colspan(colSpan).wx(99.0).wy(99.0))

            keyToUse = shortcut
            if Platform.isWindows():
                keyToUse = InputEvent.ALT_MASK

            if Platform.isOSX():
                save_useScreenMenuBar= System.getProperty("apple.laf.useScreenMenuBar")
                if save_useScreenMenuBar is None or save_useScreenMenuBar == "":
                    save_useScreenMenuBar= System.getProperty("com.apple.macos.useScreenMenuBar")
                System.setProperty("apple.laf.useScreenMenuBar", "false")
                System.setProperty("com.apple.macos.useScreenMenuBar", "false")
            else:
                save_useScreenMenuBar = "true"

            SetupMDColors.updateUI()

            mb = JMenuBar()
            menu1 = JMenu("<html><b>TOOLBOX Options</b></html>")
            # menu1 = JMenu("TOOLBOX Options")
            menu1.setMnemonic(KeyEvent.VK_T)
            menu1.setForeground(SetupMDColors.FOREGROUND_REVERSED); menu1.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            menuItem0 = JCheckBoxMenuItem("Update Mode")
            menuItem0.setMnemonic(KeyEvent.VK_U)
            menuItem0.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M, keyToUse))
            menuItem0.addActionListener(self.DoTheMenu(mainPnl, menu1, self))
            menuItem0.setToolTipText("Enables UPDATE (Fix Mode) >> can update data/settings...")
            menuItem0.setSelected(False)
            menu1.add(menuItem0)

            menuItemA = JCheckBoxMenuItem("Advanced Mode")      # (Previously Hacker mode)
            menuItemA.setMnemonic(KeyEvent.VK_A)
            menuItemA.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M, (keyToUse | Event.SHIFT_MASK)))
            menuItemA.addActionListener(self.DoTheMenu(mainPnl, menu1, self))
            menuItemA.setToolTipText("Enables 'ADVANCED' Mode - Do not do this unless you know what you are doing... Allows you to update data!")
            menuItemA.setSelected(False)
            menu1.add(menuItemA)

            menuItemC = JCheckBoxMenuItem("Copy all Output to Clipboard")
            menuItemC.setMnemonic(KeyEvent.VK_O)  # Can't think of a spare letter to use!!!!
            menuItemC.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, keyToUse))
            menuItemC.addActionListener(self.DoTheMenu(mainPnl, menu1, self))
            menuItemC.setToolTipText("When selected copies the output of all displays to Clipboard")
            menuItemC.setSelected(lCopyAllToClipBoard_TB)
            menu1.add(menuItemC)

            menuItemD = JCheckBoxMenuItem("Debug")
            menuItemD.setMnemonic(KeyEvent.VK_D)
            menuItemD.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_D, (keyToUse | Event.SHIFT_MASK)))
            menuItemD.addActionListener(self.DoTheMenu(mainPnl, menu1, self))
            menuItemD.setToolTipText("Enables script to output debug information - technical stuff - readonly")
            menuItemD.setSelected(debug)
            menu1.add(menuItemD)

            menuItemP = JCheckBoxMenuItem("Auto Prune Internal Backups")
            menuItemP.setMnemonic(KeyEvent.VK_B)
            menuItemP.addActionListener(self.DoTheMenu(mainPnl, menu1, self))
            menuItemP.setToolTipText("Enables auto pruning of the internal backups that Toolbox makes of config.dict, custom_theme.properties, and ./safe/settings")
            menuItemP.setSelected(lAutoPruneInternalBackups_TB)
            menu1.add(menuItemP)

            menuItemF = JMenuItem("Find/Search")
            menuItemF.setMnemonic(KeyEvent.VK_F)
            menuItemF.setToolTipText("Finds text within the main display window..")
            menuItemF.addActionListener(mySearchAction)
            menu1.add(menuItemF)

            menuItemPS = JMenuItem("Page Setup")
            menuItemPS.setMnemonic(KeyEvent.VK_P)
            menuItemPS.setToolTipText("Printer Page Setup")
            menuItemPS.addActionListener(self.DoTheMenu(mainPnl, menu1, self))
            menu1.add(menuItemPS)

            menuItem2 = JMenuItem("Exit")
            menuItem2.setMnemonic(KeyEvent.VK_E)
            menuItem2.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, keyToUse))
            menuItem2.addActionListener(self.CloseAction(toolbox_frame_))
            menuItem2.setToolTipText("Exit this Toolbox")
            menu1.add(menuItem2)

            mb.add(menu1)

            menuH = JMenu("<html><B>Help/About</b></html>")
            # menuH = JMenu("HELP")
            menuH.setMnemonic(KeyEvent.VK_I)
            menuH.setForeground(SetupMDColors.FOREGROUND_REVERSED); menuH.setBackground(SetupMDColors.BACKGROUND_REVERSED)

            menuItemH = JMenuItem("Help")
            menuItemH.setMnemonic(KeyEvent.VK_I)
            menuItemH.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_I, keyToUse))
            menuItemH.setToolTipText("Display Help")
            menuItemH.addActionListener(self.DoTheMenu(mainPnl, menuH, self))
            menuH.add(menuItemH)

            menuItemA = JMenuItem("About Toolbox")
            menuItemA.setMnemonic(KeyEvent.VK_A)
            menuItemA.setToolTipText("About...")
            menuItemA.addActionListener(self.DoTheMenu(mainPnl, menuH, self))
            menuH.add(menuItemA)

            menuItemAMD = JMenuItem("About Moneydance")
            menuItemAMD.setToolTipText("About...")
            menuItemAMD.addActionListener(self.DoTheMenu(mainPnl, menuH, self))
            menuH.add(menuItemAMD)

            mb.add(menuH)

            # ##############

            mb.add(Box.createHorizontalGlue())

            btnConsole = JButton("Launch Console Window")
            btnConsole.setToolTipText("launches the Moneydance Console Window (and turns DEBUG on).. Useful for extra diagnostics!")

            btnConsole.setOpaque(SetupMDColors.OPAQUE)
            btnConsole.setBackground(SetupMDColors.BACKGROUND)
            btnConsole.setForeground(SetupMDColors.FOREGROUND)

            btnSaveConsole = JButton("Save Console Log")
            btnSaveConsole.setToolTipText("Copy/save the Console Error log file to a directory of your choosing..")
            btnSaveConsole.setOpaque(SetupMDColors.OPAQUE)
            btnSaveConsole.setBackground(SetupMDColors.BACKGROUND)
            btnSaveConsole.setForeground(SetupMDColors.FOREGROUND)

            btnOpenMDFolder = JButton("Open MD Folder")
            btnOpenMDFolder.setToolTipText("Open the selected Moneydance (internal) folder in Explorer/Finder window (etc)")
            btnOpenMDFolder.setOpaque(SetupMDColors.OPAQUE)
            btnOpenMDFolder.setBackground(SetupMDColors.BACKGROUND)
            btnOpenMDFolder.setForeground(SetupMDColors.FOREGROUND)

            btnCopyDiagnostics = JButton("Copy/Save/Print Diagnostics below")
            btnCopyDiagnostics.setToolTipText("Option to Copy the contents of the main diagnostics window (below) to the Clipboard.., or save to file, or print...")
            btnCopyDiagnostics.setOpaque(SetupMDColors.OPAQUE)
            btnCopyDiagnostics.setBackground(SetupMDColors.BACKGROUND)
            btnCopyDiagnostics.setForeground(SetupMDColors.FOREGROUND)

            mb.add(btnConsole)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnSaveConsole)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnOpenMDFolder)
            mb.add(Box.createRigidArea(Dimension(10, 0)))
            mb.add(btnCopyDiagnostics)

            mb.add(Box.createRigidArea(Dimension(30, 0)))

            btnConsole.addActionListener(ShowTheConsole())
            btnSaveConsole.addActionListener(CopyConsoleLogFileButtonAction(MD_REF.getLogFile()))
            btnOpenMDFolder.addActionListener(OpenFolderButtonAction())
            btnCopyDiagnostics.addActionListener(ClipboardButtonAction(displayString))
            # ##############

            toolbox_frame_.setJMenuBar(mb)


            ############################################################################################################
            onCol = 0
            onRow += 1
            colSpan = 6

            bottomPanel = JPanel(GridBagLayout())
            bottomPanel.setBorder(EmptyBorder(10, 10, 10, 10))
            pnl_x = 0
            pnl_y = 0

            setSyncingLabel()
            bottomPanel.add(GlobalVars.mainPnl_syncing_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_debug_lbl.setText("<DEBUG ON>" if debug else "")
            GlobalVars.mainPnl_debug_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_debug_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_preview_lbl.setText("<PREVIEW BUILD>" if isPreviewBuild() else "")
            GlobalVars.mainPnl_preview_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_preview_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_updateMode_lbl.setText("<UPDATE MODE>" if GlobalVars.UPDATE_MODE else "")
            GlobalVars.mainPnl_updateMode_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_updateMode_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_advancedMode_lbl.setText("<ADVANCED MODE>" if GlobalVars.ADVANCED_MODE else "")
            GlobalVars.mainPnl_advancedMode_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_advancedMode_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1
            bottomPanel.add(Box.createHorizontalStrut(20), GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            GlobalVars.mainPnl_toolboxUnlocked_lbl.setText("<TOOLBOX UNLOCKED>" if isToolboxUnlocked() else "")
            GlobalVars.mainPnl_toolboxUnlocked_lbl.setForeground(getColorRed())
            bottomPanel.add(GlobalVars.mainPnl_toolboxUnlocked_lbl, GridC.getc(pnl_x, pnl_y).fillx()); pnl_x += 1

            setMemoryLabel()
            pnl_x = 0; pnl_y += 1
            bottomPanel.add(GlobalVars.mainPnl_memory_lbl, GridC.getc(pnl_x, pnl_y).fillx().colspan(12).center()); pnl_x += 1


            ############################################################################################################

            mainPnl.add(bottomPanel, GridC.getc(onCol, onRow).fillx().colspan(colSpan))

            # toolbox_frame_.add(mainPnl)
            toolbox_frame_.getContentPane().setLayout(BorderLayout())
            toolbox_frame_.getContentPane().add(mainPnl, BorderLayout.CENTER)

            toolbox_frame_.pack()
            toolbox_frame_.setLocationRelativeTo(None)

            try:
                toolbox_frame_.MoneydanceAppListener = MyMoneydanceEventListener(toolbox_frame_)
                MD_REF.addAppEventListener(toolbox_frame_.MoneydanceAppListener)
                myPrint("DB","@@ added AppEventListener() %s @@" %(classPrinter("MoneydanceAppListener", toolbox_frame_.MoneydanceAppListener)))
            except:
                myPrint("B","FAILED to add MD App Listener...")
                dump_sys_error_to_md_console_and_errorlog()

            toolbox_frame_.setVisible(True)     # already on the EDT
            toolbox_frame_.toFront()            # already on the EDT
            toolbox_frame_.isActiveInMoneydance = True

            myPrint("DB","Adding Preferences listener:", self)
            MD_REF.getPreferences().addListener(self)

            if Platform.isOSX():
                System.setProperty("apple.laf.useScreenMenuBar", save_useScreenMenuBar)
                System.setProperty("com.apple.macos.useScreenMenuBar", save_useScreenMenuBar)


            # Check for no currencies.. Popup alert message
            # noinspection PyUnresolvedReferences
            allCurrs = [c for c in MD_REF.getCurrentAccount().getBook().getCurrencies().getAllCurrencies() if c.getCurrencyType() == CurrencyType.Type.CURRENCY]
            if len(allCurrs) < 1:
                MyPopUpDialogBox(toolbox_frame_,"PROBLEM DETECTED",
                                                 "You seem to have no Currencies?!\n" 
                                                 "Please go to Tools/Currencies and add a Currency\n" 
                                                 "This would normally need to be your 'base' currency\n"
                                                 "You should check the currency setup of your accounts too!",
                                                 theTitle="ERROR - NO CURRENCIES EXIST",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=2,
                                                 lModal=True).go()
            del allCurrs

            # Check for problem with java.io.tmpdir - causes missing icons etc.. Popup alert message
            if not detect_broken_critical_javaio_temp_dir_OK():
                MyPopUpDialogBox(toolbox_frame_,"PROBLEM DETECTED",
                                                 "Your 'java.io.tmpdir' setting points to a folder that cannot be accessed\n" 
                                                 "%s\n" 
                                                 "Review console for details and correct problem"
                                                        %(return_critical_javaio_temp_dir_msg()),
                                                 theTitle="ERROR - JAVA TEMP FOLDER",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=2,
                                                 lModal=True).go()

            # Check for problem with 'auto' backup location... Popup alert message
            backupFolder = FileUtils.getBackupDir(MD_REF.getPreferences())
            backupType = MD_REF.getPreferences().getSetting(GlobalVars.Strings.MD_CONFIGDICT_BACKUP_TYPE, "every_x_days")
            autoBackup = (backupType != "no_backup")
            if not autoBackup:
                MyPopUpDialogBox(toolbox_frame_, "AUTO-BACKUP DISABLED",
                                                 "You appear to have disabled auto-backup\n" 
                                                 "If you require automatic backups then...\n" 
                                                 "..you should review menu MD>Preferences>Backups",
                                                 theTitle="WARNING: AUTO BACKUPS DISABLED",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=True).go()
            elif backupFolder is None or not isinstance(backupFolder, File) or not backupFolder.exists():
                MyPopUpDialogBox(toolbox_frame_,"POTENTIAL PROBLEM DETECTED",
                                                 "Your (auto) backup location appears invalid...\n" 
                                                 "..you should review menu MD>Preferences>Backups\n" 
                                                 "Review console for details and correct problem",
                                                 theTitle="ERROR: AUTO-BACKUP FOLDER INVALID",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=True).go()

            # Check for secondary node (potentially restored from backup).. Popup alert message
            if not MD_REF.getUI().getCurrentAccounts().isMasterSyncNode():

                MyPopUpDialogBox(toolbox_frame_,"INFORMATION ONLY - THIS IS NOT A PROBLEM",
                                                 "This Dataset is running as a 'Secondary Node'\n" 
                                                 "- either you are Synchronising to it,\n" 
                                                 "- or you have restored it from a backup/sync copy.\n" 
                                                 "If these statements are true / OK, then ignore this message...\n" 
                                                 ">>Otherwise, to convert to Primary, select Update Mode.",
                                                 theTitle="SECONDARY DATASET/NODE",
                                                 OKButtonText="ACKNOWLEDGE",
                                                 lAlertLevel=1,
                                                 lModal=True).go()

            # Now look for cached downloaded txns that can be purged..
            try:
                countCachedAccount, countCachedTxns = quick_check_cached_online_txns()
                if countCachedTxns > 0:

                    if debug:
                        MyPopUpDialogBox(toolbox_frame_,
                                         theStatus="Cached OFX downloaded bank transactions exist:",
                                         theMessage="You appear to have %s Accounts\n"
                                                    "with %s cached OFX downloaded bank transactions.\n"
                                                    "These should not really be there.\n"
                                                    "Consider using Online Banking (OFX) Tools menu to delete cached OnlineTxnList txns"
                                                    %(countCachedAccount, countCachedTxns),
                                         theTitle="ALERT: Cached OnlineTxnList records exist",
                                         OKButtonText="ACKNOWLEDGE",
                                         lAlertLevel=1,
                                         lModal=True).go()

                    else:
                        myPrint("J","")
                        myPrint("B","#########################################################################################################################################################")
                        myPrint("B","### ALERT: You appear to have %s Accounts with %s cached OFX downloaded bank transactions."%(countCachedAccount, countCachedTxns))
                        myPrint("B","### These should not really be there.")
                        myPrint("B","### Consider using Online Banking (OFX) Tools menu to delete cached OnlineTxnList txns.")
                        myPrint("B","#########################################################################################################################################################\n")
                        myPrint("J","")
                del countCachedAccount, countCachedTxns
            except:
                pass

            # Check to see if Tabbing mode needs changing on a MAc
            if lTabbingModeNeedsChanging:
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="MacOS TABBING MODE WARNING:",
                                 theMessage="Your Mac has 'Tabbing Mode' set to 'always'\n"
                                            "- You can find this in Settings>General>Prefer tabs:,\n"
                                            "- THIS CAUSES STRANGE MONEYDANCE FREEZES.\n"
                                            ">> To change this setting now, use UPDATE Mode...\n"
                                            "........\n",
                                 theTitle="MacOS TABBING MODE WARNING",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=True).go()


            # Check to see if any windows are off-screen
            if lWindowLocationsNeedZapping:
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="INVALID WINDOW LOCATIONS WARNING:",
                                 theMessage="Toolbox has detected that you have at least one saved\n"
                                            "Moneydance window location that is invalid / 'off-screen'.\n"
                                            ">> To zap these invalid settings, use UPDATE Mode...\n"
                                            "........\n",
                                 theTitle="INVALID WINDOW LOCATIONS WARNING",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=True).go()
            # Check whether UserHome is missing - probably on a development platform
            if Platform.isOSX() and System.getProperty(u"UserHome") is None:
                MyPopUpDialogBox(toolbox_frame_,
                                 theStatus="MacOS UserHome Warning:",
                                 theMessage="Your Mac's System Property 'UserHome' is not set\n"
                                            "Some features in Toolbox may not work as expected",
                                 theTitle="MacOS UserHome Warning",
                                 OKButtonText="ACKNOWLEDGE",
                                 lAlertLevel=1,
                                 lModal=True).go()

            # Check for repeated opening of backup files
            try:
                datapath = MD_REF.getCurrentAccount().getBook().getRootFolder().getCanonicalPath()
                datafile = os.path.basename(datapath)
                datafilenew = datafile.replace(".moneydance","")
                if len(datafilenew) > 17:
                    searchDash = datafilenew[-3] + datafilenew[-6] + datafilenew[-14] + datafilenew[-17]
                    if searchDash == "----":
                        MyPopUpDialogBox(toolbox_frame_,
                                         "ALERT: Detected multiple dates in dataset filename.",
                                         "This might mean you're opening backup (*.moneydancearchive) files by double-clicking\n"
                                         "...and this may be creating a new dataset everytime as a result... and so on....\n"
                                         ">> If so, please correct your file opening procedure <<\n"
                                         "(But, if you're happy with your procedure & dataset name, then ignore this alert)",
                                         theTitle="POTENTIAL IMPROPER OPENING OF BACKUP FILES",
                                         OKButtonText="ACKNOWLEDGE",
                                         lAlertLevel=1,
                                         lModal=True).go()
            except:
                pass

            # check_for_old_StuWareSoftSystems_scripts()

            _tb_extn_avail_version = check_for_updatable_extensions_on_startup()

            checkModule = myModuleID
            myExtensions = downloadStuWareSoftSystemsExtensions(checkModule)
            if myExtensions:
                myModule = myExtensions.get("id")
                if myModule == checkModule:
                    availableFromGitHubVersion = int(myExtensions.get("module_build"))

                    if _tb_extn_avail_version > int(version_build):
                        myPrint("B","@@ Extension version %s (signed) is available from Moneydance Menu>>Manage Extensions Menu @@" %_tb_extn_avail_version)
                        theStr = "You are running version %s\n" %version_build
                        theStr += "Extension version %s (signed) is available from Moneydance Menu>>Manage Extensions Menu\n" %_tb_extn_avail_version
                        MyPopUpDialogBox(toolbox_frame_,"Toolbox Version:",theStr,theTitle="UPGRADE AVAILABLE",OKButtonText="Acknowledge").go()

                    elif availableFromGitHubVersion > int(version_build) and availableFromGitHubVersion > _tb_extn_avail_version:
                        myPrint("DB","@@ FYI - Toolbox upgrade to version %s (unsigned) is available from Author's code site.... @@" %(availableFromGitHubVersion))

                    else:
                        myPrint("DB","Toolbox is running latest version available: %s" %max(version_build,availableFromGitHubVersion))

            checkForREADONLY()


    if not GlobalVars.i_am_an_extension_so_run_headless: print("""
Script/extension is analysing your moneydance & system settings....
------------------------------------------------------------------------------
>> DISCLAIMER: This script/extension has the ability to change your data
>> Always perform backup first before making any changes!
>> The Author of this script/extension can take no responsibility for any harm caused
>> If you do not accept this, please exit the script/extension
------------------------------------------------------------------------------
""")

    # This gets the latest build info from the developer... and it overrides the program defaults...
    download_toolbox_version_info()

    lAbort = False
    if TOOLBOX_STOP_NOW:
        lAbort = True
    elif lFailed_get_StuWareSoftSystems_parameters_from_file:
        lAbort = True
    elif float(MD_REF.getVersion()) < TOOLBOX_MINIMUM_TESTED_MD_VERSION or not lImportOK:
        lAbort = True
    elif int(float(MD_REF.getVersion())) > int(TOOLBOX_MAXIMUM_TESTED_MD_VERSION):  # Just stick to major version checks....
        lAbort = True
    else:
        if (float(MD_REF.getBuild()) <= TOOLBOX_MAXIMUM_TESTED_MD_BUILD
                    or myPopupAskQuestion(None,"Toolbox(build: %s) - Moneydance Version/Build" %(version_build),
                                      "MD build (%s)%s is newer than the Toolbox tested build of (%s)%s - Proceed?"
                                      %(MD_REF.getVersion(),MD_REF.getBuild(),TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD),
                                      JOptionPane.WARNING_MESSAGE)):

            # if float(MD_REF.getBuild()) > TOOLBOX_MAXIMUM_TESTED_MD_BUILD:
            #     myPrint("B","@@ WARNING - MD build (%s)%s is newer than the Toolbox tested build of (%s)%s....!"
            #             %(MD_REF.getVersion(),MD_REF.getBuild(),TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD))

            fixRCurrencyCheck = 0

            MD_REF.getUI().setStatus(">> Infinite Kind (co-authored by Stuart Beesley: StuWareSoftSystems) - Toolbox launching.......",0)

            # These checks already run at Dataset Load time:
            # >> com.infinitekind.moneydance.model.AccountBook.performPostLoadVerification()
            # That Currency BaseType is set
            #   >> com.infinitekind.moneydance.model.CurrencyType.performPostLoadVerification()
            #       >> Relative currency loops, zero rate
            #   >> Orphan snapshots with no registered Currency - deletes them
            #   >> Redundant Base currency snapshots - deletes them
            #   >> On each snapshot com.infinitekind.moneydance.model.CurrencySnapshot.performPostLoadVerification
            #       >> resets relative rates < 0 relative to base rate
            #   >> For csplits registered with currency
            #   >> Then sorts the Currency's snapshots and cplits
            # That Account structures are valid
            #   >> Broken acct numbers (old)
            #   >> Validates account structures: com.infinitekind.moneydance.model.Account.ensureAccountStructure()
            #       >> Iterates all accounts. If it finds acct eq type ROOT validates it's the root, fixes duplicate roots, replaces root
            #       >> where not ROOT, validates the parent of this acct has sub accounts
            #   >> Then checks that getRootAccount() is not None - else:
            #       >> it finds it & sets it, or creates it
            #       >> also it also detects and cleans up duplicate roots
            #   >> It also finds orphan accounts, with no parent and links them to root
            # That budget structures are OK.
            # That Txns are valid
            #   >> Txns with getOtherCount() <= 0 get deleted (when a parent)
            #   >> That Txns are not linked to Root (warning only)
            #   >> If Account does not exist:
            #       >> Makes a new account (with ts = 0 = ghost account)
            # Then sorts Accounts
            # Then refreshes balances

            # Check based on fix_restored_accounts.py
            _root = MD_REF.getCurrentAccount().getBook().getRootAccount()   # Should never happen!
            if _root is None or _root.getAccountType()!=Account.AccountType.ROOT:                                       # noqa
                myPrint("B","@@ ERROR: I've Detected that your ROOT Account is Missing or not type ROOT! Contact support or the Author of Toolbox for a fix")
                myPrint("B","@@ FYI - there used to be scripts called fix_restored_accounts.py or fix_root_account_type.py for this (but the last time I looked they were broken.....")
                myPopupInformationBox(None,"ERROR: I've Detected that your ROOT Account is Missing or not type ROOT! Contact support or the Author of Toolbox for a fix",
                                      "ROOT ACCOUNT WARNING",JOptionPane.ERROR_MESSAGE)
                cleanup_references()
            else:

                class MainAppRunnable(Runnable):
                    def __init__(self):
                        pass

                    def run(self):                                                                                      # noqa
                        myPrint("DB", "In MainAppRunnable()", inspect.currentframe().f_code.co_name, "()")
                        myPrint("DB", "SwingUtilities.isEventDispatchThread() = %s" %(SwingUtilities.isEventDispatchThread()))

                        theDisplay = DiagnosticDisplay()
                        theDisplay.openDisplay()

                        # At this point, Toolbox is running. Put bypass methods here for debug testing
                        # GlobalVars.UPDATE_MODE = True
                        # GlobalVars.ADVANCED_MODE = True
                        # Call a function here if needed for debug


                if not SwingUtilities.isEventDispatchThread():
                    myPrint("DB",".. Main App Not running within the EDT so calling via MainAppRunnable()...")
                    SwingUtilities.invokeAndWait(MainAppRunnable())
                else:
                    myPrint("DB",".. Main App Already within the EDT so calling naked...")
                    MainAppRunnable().run()

                # myPrint("DB","Requesting System Garbage Collection....")
                # System.gc()

                myPrint("P","-----------------------------------------------------------------------------------------------------------")
                myPrint("B", "Infinite Kind in conjunction with StuWareSoftSystems - ", GlobalVars.thisScriptName, " script ending (frame is open/running)......")
                myPrint("P","-----------------------------------------------------------------------------------------------------------")

        else:
            lAbort = True

    if lAbort:
        if TOOLBOX_STOP_NOW:
            myPrint("B", "STOP-NOW (DISABLE) COMMAND RECEIVED!")
            myPopupInformationBox(None,
                                  "Toolbox DISABLED (check for version update Extension>Manage Extensions)",
                                  "TOOLBOX DISABLED",
                                  JOptionPane.ERROR_MESSAGE)
        elif lFailed_get_StuWareSoftSystems_parameters_from_file:
            myPrint("B", "lFailed_get_StuWareSoftSystems_parameters_from_file() triggered... Perhaps your dataset is closed?")
            myPopupInformationBox(None,
                                  "Failed to retrieve saved parameters from file, perhaps your dataset is closed?",
                                  "TOOLBOX CANNOT OPEN",
                                  JOptionPane.ERROR_MESSAGE)
            try: WelcomeWindow.showWelcomeWindow(MD_REF.getUI())
            except: pass
        else:
            myPrint("B", "Sorry, this Toolbox (build %s) has only been tested on Moneydance versions %s thru' %s(build %s)... Yours is %s(%s) >> Exiting....."
                    %(version_build, TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD,MD_REF.getVersion(),MD_REF.getBuild()))
            myPopupInformationBox(None,
                                  "Sorry, this Toolbox (build %s) has only been tested on Moneydance versions %s thru' %s(build %s)... Yours is %s(%s) >> Exiting....."
                                  %(version_build, TOOLBOX_MINIMUM_TESTED_MD_VERSION, TOOLBOX_MAXIMUM_TESTED_MD_VERSION,TOOLBOX_MAXIMUM_TESTED_MD_BUILD,MD_REF.getVersion(),MD_REF.getBuild()),
                                  "Toolbox- VERSION TOO NEW",
                                  JOptionPane.ERROR_MESSAGE)
        cleanup_references()
